<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Barry Wittman, Tim Korb, Aditya Mathur">
<title>Start Concurrent: A Gentle Introduction to Concurrent Programming</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="style0.css" type="text/css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style1.css" type="text/css">
<link rel="stylesheet" href="asciidoctor-chunker.css" type="text/css"></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Start Concurrent: A Gentle Introduction to Concurrent Programming</h1>
<div class="details">
<span id="author" class="author">Barry Wittman</span><br>
<span id="email" class="email"><a href="mailto:wittman1@otterbein.edu">wittman1@otterbein.edu</a></span><br>
<span id="author2" class="author">Tim Korb</span><br>
<span id="email2" class="email"><a href="mailto:jtk@purdue.edu">jtk@purdue.edu</a></span><br>
<span id="author3" class="author">Aditya Mathur</span><br>
<span id="email3" class="email"><a href="mailto:apm@purdue.edu">apm@purdue.edu</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="index.html">Attacking Problems with Java</a></li><li><a href="index.html">1. Computer Basics</a>
<ul class="sectlevel2">
<li><a href="index.html#_problem_buying_a_computer">1.1. Problem: Buying a computer</a></li>
<li><a href="index.html#_concepts_hardware_and_software">1.2. Concepts: Hardware and software</a></li>
<li><a href="index.html#_syntax_data_representation">1.3. Syntax: Data representation</a></li>
<li><a href="index.html#_solution_buying_a_computer">1.4. Solution: Buying a computer</a></li>
<li><a href="index.html#_summary">1.5. Summary</a></li>
<li><a href="index.html#_exercises">1.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap2.html">2. Problem Solving and Programming</a>
<ul class="sectlevel2">
<li><a href="chap2.html#_problem_how_to_solve_problems">2.1. Problem: How to solve problems</a></li>
<li><a href="chap2.html#_concepts_developing_software">2.2. Concepts: Developing software</a></li>
<li><a href="chap2.html#_syntax_java_basics">2.3. Syntax: Java basics</a></li>
<li><a href="chap2.html#_solution_how_to_solve_problems">2.4. Solution: How to solve problems</a></li>
<li><a href="chap2.html#_concurrency_solving_problems_in_parallel">2.5. Concurrency: Solving problems in parallel</a></li>
<li><a href="chap2.html#_summary_2">2.6. Summary</a></li>
<li><a href="chap2.html#_exercises_2">2.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap3.html">3. Primitive Types and Strings</a>
<ul class="sectlevel2">
<li><a href="chap3.html#_problem_college_cost_calculator">3.1. Problem: College cost calculator</a></li>
<li><a href="chap3.html#_concepts_types">3.2. Concepts: Types</a></li>
<li><a href="chap3.html#_syntax_types_in_java">3.3. Syntax: Types in Java</a></li>
<li><a href="chap3.html#_syntax_useful_libraries">3.4. Syntax: Useful libraries</a></li>
<li><a href="chap3.html#_solution_college_cost_calculator">3.5. Solution: College cost calculator</a></li>
<li><a href="chap3.html#_concurrency_expressions">3.6. Concurrency: Expressions</a></li>
<li><a href="chap3.html#_summary_3">3.7. Summary</a></li>
<li><a href="chap3.html#_exercises_3">3.8. Exercises</a></li>
</ul>
</li>
<li><a href="chap4.html">4. Selection</a>
<ul class="sectlevel2">
<li><a href="chap4.html#_problem_monty_hall_simulation">4.1. Problem: Monty Hall simulation</a></li>
<li><a href="chap4.html#_concepts_choosing_between_options">4.2. Concepts: Choosing between options</a></li>
<li><a href="chap4.html#_syntax_selection_in_java">4.3. Syntax: Selection in Java</a></li>
<li><a href="chap4.html#_solution_monty_hall">4.4. Solution: Monty Hall</a></li>
<li><a href="chap4.html#_concurrency_selection">4.5. Concurrency: Selection</a></li>
<li><a href="chap4.html#_exercises_4">4.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap5.html">5. Repetition</a>
<ul class="sectlevel2">
<li><a href="chap5.html#_problem_dna_searching">5.1. Problem: DNA searching</a></li>
<li><a href="chap5.html#_concepts_repetition">5.2. Concepts: Repetition</a></li>
<li><a href="chap5.html#_syntax_loops_in_java">5.3. Syntax: Loops in Java</a></li>
<li><a href="chap5.html#_solution_dna_searching">5.4. Solution: DNA searching</a></li>
<li><a href="chap5.html#_concurrency_loops">5.5. Concurrency: Loops</a></li>
<li><a href="chap5.html#_exercises_5">5.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap6.html">6. Arrays</a>
<ul class="sectlevel2">
<li><a href="chap6.html#_introduction">6.1. Introduction</a></li>
<li><a href="chap6.html#_problem_game_of_life">6.2. Problem: Game of Life</a></li>
<li><a href="chap6.html#_concepts_lists_of_data">6.3. Concepts: Lists of data</a></li>
<li><a href="chap6.html#_syntax_arrays_in_java">6.4. Syntax: Arrays in Java</a></li>
<li><a href="chap6.html#_examples_array_usage">6.5. Examples: Array usage</a></li>
<li><a href="chap6.html#_concepts_multidimensional_lists">6.6. Concepts: Multidimensional lists</a></li>
<li><a href="chap6.html#_syntax_advanced_arrays_in_java">6.7. Syntax: Advanced arrays in Java</a></li>
<li><a href="chap6.html#_examples_two_dimensional_arrays">6.8. Examples: Two-dimensional arrays</a></li>
<li><a href="chap6.html#_advanced_special_array_tools_in_java">6.9. Advanced: Special array tools in Java</a></li>
<li><a href="chap6.html#_solution_game_of_life">6.10. Solution: Game of Life</a></li>
<li><a href="chap6.html#_concurrency_arrays">6.11. Concurrency: Arrays</a></li>
<li><a href="chap6.html#_exercises_6">6.12. Exercises</a></li>
</ul>
</li>
<li><a href="chap7.html">7. Simple Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap7.html#_problem_codon_extractor">7.1. Problem: Codon extractor</a></li>
<li><a href="chap7.html#GUIBasicsIntroductionSection">7.2. Concepts: User interaction</a></li>
<li><a href="chap7.html#_syntax_dialogs_and_the_joptionpane_class">7.3. Syntax: Dialogs and the <code>JOptionPane</code> class</a></li>
<li><a href="chap7.html#_solution_codon_extractor">7.4. Solution: Codon extractor</a></li>
<li><a href="chap7.html#_concurrency_simple_guis">7.5. Concurrency: Simple GUIs</a></li>
<li><a href="chap7.html#_summary_4">7.6. Summary</a></li>
<li><a href="chap7.html#_exercises_7">7.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap8.html">8. Methods</a>
<ul class="sectlevel2">
<li><a href="chap8.html#_problem_three_card_poker">8.1. Problem: Three card poker</a></li>
<li><a href="chap8.html#_concepts_dividing_work_into_segments">8.2. Concepts: Dividing work into segments</a></li>
<li><a href="chap8.html#_syntax_methods">8.3. Syntax: Methods</a></li>
<li><a href="chap8.html#_examples_defining_methods">8.4. Examples: Defining methods</a></li>
<li><a href="chap8.html#_solution_three_card_poker">8.5. Solution: Three card poker</a></li>
<li><a href="chap8.html#_concurrency_methods">8.6. Concurrency: Methods</a></li>
<li><a href="chap8.html#_exercises_8">8.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap9.html">9. Classes</a>
<ul class="sectlevel2">
<li><a href="chap9.html#_problem_nested_expressions">9.1. Problem: Nested expressions</a></li>
<li><a href="chap9.html#_concepts_object_oriented_programming">9.2. Concepts: Object-oriented programming</a></li>
<li><a href="chap9.html#_syntax_classes_in_java">9.3. Syntax: Classes in Java</a></li>
<li><a href="chap9.html#_advanced_nested_classes">9.4. Advanced: Nested classes</a></li>
<li><a href="chap9.html#_solution_nested_expressions">9.5. Solution: Nested expressions</a></li>
<li><a href="chap9.html#_concurrency_objects">9.6. Concurrency: Objects</a></li>
<li><a href="chap9.html#_exercises_9">9.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap10.html">10. Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap10.html#_problem_sort_it_out">10.1. Problem: Sort it out</a></li>
<li><a href="chap10.html#_concepts_making_a_promise">10.2. Concepts: Making a promise</a></li>
<li><a href="chap10.html#_syntax_interfaces">10.3. Syntax: Interfaces</a></li>
<li><a href="chap10.html#_advanced_local_and_anonymous_classes">10.4. Advanced: Local and anonymous classes</a></li>
<li><a href="chap10.html#_solution_sort_it_out">10.5. Solution: Sort it out</a></li>
<li><a href="chap10.html#_concurrency_interfaces">10.6. Concurrency: Interfaces</a></li>
<li><a href="chap10.html#_exercises_10">10.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap11.html">11. Inheritance</a>
<ul class="sectlevel2">
<li><a href="chap11.html#_problem_boolean_circuits">11.1. Problem: Boolean circuits</a></li>
<li><a href="chap11.html#_concepts_refining_classes">11.2. Concepts: Refining classes</a></li>
<li><a href="chap11.html#_syntax_inheritance_in_java">11.3. Syntax: Inheritance in Java</a></li>
<li><a href="chap11.html#_examples_problem_solving_with_inheritance">11.4. Examples: Problem solving with inheritance</a></li>
<li><a href="chap11.html#_solution_boolean_circuits">11.5. Solution: Boolean circuits</a></li>
<li><a href="chap11.html#_concurrency_inheritance">11.6. Concurrency: Inheritance</a></li>
<li><a href="chap11.html#_exercises_11">11.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap12.html">12. Exceptions</a>
<ul class="sectlevel2">
<li><a href="chap12.html#_problem_bank_burglary">12.1. Problem: Bank burglary</a></li>
<li><a href="chap12.html#_concepts_error_handling">12.2. Concepts: Error handling</a></li>
<li><a href="chap12.html#_syntax_exceptions_in_java">12.3. Syntax: Exceptions in Java</a></li>
<li><a href="chap12.html#_solution_bank_burglary">12.4. Solution: Bank burglary</a></li>
<li><a href="chap12.html#_concurrency_exceptions">12.5. Concurrency: Exceptions</a></li>
<li><a href="chap12.html#_exercises_12">12.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap13.html">13. Concurrent Programming</a>
<ul class="sectlevel2">
<li><a href="chap13.html#_introduction_2">13.1. Introduction</a></li>
<li><a href="chap13.html#_problem_deadly_virus">13.2. Problem: Deadly virus</a></li>
<li><a href="chap13.html#_concepts_splitting_up_work">13.3. Concepts: Splitting up work</a></li>
<li><a href="chap13.html#_syntax_threads_in_java">13.4. Syntax: Threads in Java</a></li>
<li><a href="chap13.html#_examples_concurrency_and_speedup">13.5. Examples: Concurrency and speedup</a></li>
<li><a href="chap13.html#_concepts_thread_scheduling">13.6. Concepts: Thread scheduling</a></li>
<li><a href="chap13.html#_syntax_thread_states">13.7. Syntax: Thread states</a></li>
<li><a href="chap13.html#_solution_deadly_virus">13.8. Solution: Deadly virus</a></li>
<li><a href="chap13.html#_summary_5">13.9. Summary</a></li>
<li><a href="chap13.html#_exercises_13">13.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap14.html">14. Synchronization</a>
<ul class="sectlevel2">
<li><a href="chap14.html#_introduction_3">14.1. Introduction</a></li>
<li><a href="chap14.html#_problem_dining_philosophers">14.2. Problem: Dining philosophers</a></li>
<li><a href="chap14.html#_concepts_thread_interaction">14.3. Concepts: Thread interaction</a></li>
<li><a href="chap14.html#_syntax_thread_synchronization">14.4. Syntax: Thread synchronization</a></li>
<li><a href="chap14.html#_pitfalls_synchronization_challenges">14.5. Pitfalls: Synchronization challenges</a></li>
<li><a href="chap14.html#_solution_dining_philosophers">14.6. Solution: Dining philosophers</a></li>
<li><a href="chap14.html#_exercises_14">14.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap15.html">15. Constructing Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_problem_math_tutor">15.1. Problem: Math tutor</a></li>
<li><a href="chap15.html#_concepts_graphical_user_interfaces">15.2. Concepts: Graphical user interfaces</a></li>
<li><a href="chap15.html#_syntax_guis_in_java">15.3. Syntax: GUIs in Java</a></li>
<li><a href="chap15.html#_solution_math_tutor">15.4. Solution: Math tutor</a></li>
<li><a href="chap15.html#_concurrency_guis">15.5. Concurrency: GUIs</a></li>
<li><a href="chap15.html#_summary_6">15.6. Summary</a></li>
<li><a href="chap15.html#_exercises_15">15.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap16.html">16. Testing and Debugging</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_fixing_bugs">16.1. Fixing bugs</a></li>
<li><a href="chap16.html#_concepts_approaches_to_debugging">16.2. Concepts: Approaches to debugging</a></li>
<li><a href="chap16.html#_syntax_java_debugging_tools">16.3. Syntax: Java debugging tools</a></li>
<li><a href="chap16.html#_concurrency_parallel_bugs">16.4. Concurrency: Parallel bugs</a></li>
<li><a href="chap16.html#_finding_and_avoiding_bugs">16.5. Finding and avoiding bugs</a></li>
<li><a href="chap16.html#_concepts_design_implementation_and_testing">16.6. Concepts: Design, implementation, and testing</a></li>
<li><a href="chap16.html#_syntax_java_testing_tools">16.7. Syntax: Java testing tools</a></li>
<li><a href="chap16.html#_concurrency_testing_tools">16.8. Concurrency: Testing tools</a></li>
<li><a href="chap16.html#_examples_testing_a_class">16.9. Examples: Testing a class</a></li>
<li><a href="chap16.html#_exercises_16">16.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap17.html">17. Polymorphism</a>
<ul class="sectlevel2">
<li><a href="chap17.html#_problem_banking_account_with_a_vengeance">17.1. Problem: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concepts_polymorphism">17.2. Concepts: Polymorphism</a></li>
<li><a href="chap17.html#_syntax_inheritance_tools_in_java">17.3. Syntax: Inheritance tools in Java</a></li>
<li><a href="chap17.html#_solution_banking_account_with_a_vengeance">17.4. Solution: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concurrency_atomic_libraries">17.5. Concurrency: Atomic libraries</a></li>
<li><a href="chap17.html#_exercises_17">17.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap18.html">18. Dynamic Data Structures</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_problem_infix_conversion">18.1. Problem: Infix conversion</a></li>
<li><a href="chap18.html#_concepts_dynamic_data_structures">18.2. Concepts: Dynamic data structures</a></li>
<li><a href="chap18.html#_syntax_dynamic_arrays_and_linked_lists">18.3. Syntax: Dynamic arrays and linked lists</a></li>
<li><a href="chap18.html#_syntax_abstract_data_types_adt">18.4. Syntax: Abstract data types (ADT)</a></li>
<li><a href="chap18.html#_advanced_generic_data_structures">18.5. Advanced: Generic data structures</a></li>
<li><a href="chap18.html#_solution_infix_conversion">18.6. Solution: Infix conversion</a></li>
<li><a href="chap18.html#_concurrency_linked_lists_and_thread_safety">18.7. Concurrency: Linked lists and thread safety</a></li>
<li><a href="chap18.html#_concurrency_thread_safe_libraries">18.8. Concurrency: Thread-safe libraries</a></li>
<li><a href="chap18.html#_exercises_18">18.9. Exercises</a></li>
</ul>
</li>
<li class="current"><a href="chap19.html">19. Recursion</a>
<ul class="sectlevel2">
<li class="current"><a href="chap19.html#_problem_maze_of_doom">19.1. Problem: Maze of doom</a></li>
<li class="current"><a href="chap19.html#_concepts_recursive_problem_solving">19.2. Concepts: Recursive problem solving</a></li>
<li class="current"><a href="chap19.html#_syntax_recursive_methods">19.3. Syntax: Recursive methods</a></li>
<li class="current"><a href="chap19.html#_syntax_recursive_data_structures">19.4. Syntax: Recursive data structures</a></li>
<li class="current"><a href="chap19.html#_solution_maze_of_doom">19.5. Solution: Maze of doom</a></li>
<li class="current"><a href="chap19.html#_concurrency_futures">19.6. Concurrency: Futures</a></li>
<li class="current"><a href="chap19.html#_exercises_19">19.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap20.html">20. File I/O</a>
<ul class="sectlevel2">
<li><a href="chap20.html#_problem_a_picture_is_worth_1000_bytes">20.1. Problem: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concepts_file_io">20.2. Concepts: File I/O</a></li>
<li><a href="chap20.html#_syntax_file_operations_in_java">20.3. Syntax: File operations in Java</a></li>
<li><a href="chap20.html#_examples_file_examples">20.4. Examples: File examples</a></li>
<li><a href="chap20.html#fileChapterSolution">20.5. Solution: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concurrency_file_io">20.6. Concurrency: File I/O</a></li>
<li><a href="chap20.html#_exercises_20">20.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap21.html">21. Network Communication</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_problem_web_server">21.1. Problem: Web server</a></li>
<li><a href="chap21.html#_concepts_tcpip_communication">21.2. Concepts: TCP/IP communication</a></li>
<li><a href="chap21.html#_syntax_networking_in_java">21.3. Syntax: Networking in Java</a></li>
<li><a href="chap21.html#_solution_web_server">21.4. Solution: Web server</a></li>
<li><a href="chap21.html#_concurrency_networking">21.5. Concurrency: Networking</a></li>
<li><a href="chap21.html#_exercises_21">21.6. Exercises</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">





















<div class="sect1">
<h2 id="ch19-recursion">19. Recursion</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>In order to understand recursion, you must first understand recursion.</p>
</div>
</blockquote>
<div class="attribution">
— Anonymous
</div>
</div>
<div class="sect2">
<h3 id="_problem_maze_of_doom">19.1. Problem: Maze of doom</h3>
<div class="paragraph">
<p>The evil mastermind from <a href="chap13.html">Chapter 13</a> has
returned with a new attempt at world domination. Since he now knows that
you can use concurrency to crack his security code, this time he’s
hidden his deadly virus in a secret location protected by a complex maze
of walls and passageways. Fortunately, you’ve been able to get a copy of
the maze floor plan, but now you must write a program to find a path
through it so you can steal the deadly virus before the evil
mastermind unleashes it on the world.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/maze.svg" alt="maze" width="50%">
</div>
<div class="title">Figure 19.1 Example of a maze to solve.</div>
</div>
<div class="paragraph">
<p>Finding a path through a maze involves systematically exploring twists
and turns, keeping track of where you’ve been, backtracking out of dead
ends, and producing a resulting path once you make it through. You
already have the basic tools necessary to solve this problem. You can,
for example, represent the maze with a two-dimensional array of
characters, where a plus (<code>''+</code>) represents a wall and a space (<code>'&nbsp;'</code>)
represents a passageway. You could mark a path through the maze by
replacing a contiguous (vertical and horizontal but not diagonal)
sequence of <code>'&nbsp;'</code> characters by <code>'*'</code> characters, leading from the
starting square to the final square where the deadly virus is located.</p>
</div>
<div class="paragraph">
<p>The difficulties are dead ends and, worse, loops. How do you keep track of
which paths you’ve tried that didn’t work? While you could use
additional data structures to store this information,
<em>recursion</em> is a solution technique that makes solving problems like
this one surprisingly straightforward.</p>
</div>
</div>
<div class="sect2">
<h3 id="_concepts_recursive_problem_solving">19.2. Concepts: Recursive problem solving</h3>
<div class="paragraph">
<p>The idea that we’ll use to solve this maze problem is called recursion.
Imagine you’re in a maze and have the choice to go right, left, or
straight. No matter which of the three paths you take, you’ll probably
be confronted by more choices of going right, left, or straight as you
progress. You need to explore them all systematically. The process of
systematically exploring the right path is similar to the process of
systematically exploring the left path. The choice at this moment between
left, right, and straight is in fact part of the same systematic process
you want to follow when you’re in the left, right, or straight branches
of the maze.</p>
</div>
<div class="paragraph">
<p>Solutions that can be described in terms of themselves are recursive.
But what is recursion? How can describing something in terms of itself
be useful? Since recursion sounds circular, how can it be applied to
problem solving in Java? How does the computer keep track of these
self-references? The following subsections address these questions.</p>
</div>
<div class="sect3">
<h4 id="_what_is_recursion">19.2.1. What is recursion?</h4>
<div class="paragraph">
<p>In the context of computer science and mathematics, recursion means
describing some repetitive process in terms of itself. Many complex
things can be described elegantly using recursion.</p>
</div>
<div class="paragraph">
<p>Consider the question, “How old are you now?” If you’re 27, you
could answer, “I’m one year older than I was last year.” If then
asked, “Well, how old were you last year?” Again, you could answer,
“I was one year older than I was the year before.” Assuming that the
person who wanted to wanted to know your age was very patient, you could
repeat this answer over and over, explaining that each year you’ve
been one year older than the previous year. However, after being asked 27
times about your age on the previous year, you’d run out of years of
life and be forced to answer, “Zero years old.”</p>
</div>
<div class="paragraph">
<p>This absurd dialog shows an important feature of useful recursive
definitions: They have at least one <em>base case</em> and at least one
<em>recursive case</em>. The base case is the part of the definition that’s
<strong>not</strong> described in terms of itself. It’s a concrete answer. Without the
base case, the process would never end, and the definition would be
meaningless. The recursive case is the part of the definition that <strong>is</strong>
defined in terms of itself. Without the recursive case, the definition
could only describe a finite set of things.</p>
</div>
<div class="paragraph">
<p>In the example above, the base case is being zero years old. You
have no age before that. The recursive case is any age greater than zero
. We can use mathematical notation to describe your age in a
given year. Here <em>age</em>(<em>year</em>) is a function that gives the
age you were during <em>year</em>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/ageRecursion.svg" alt="ageRecursion" width="75%">
</div>
</div>
<div class="paragraph">
<p>To be meaningful, recursive cases should be defined in terms of simpler
or smaller values. In English, it’s equally correct to say that you are
now a year younger than you’ll be next year. Unfortunately, the age that
you’ll be next year is not any closer to a base case, making that
recursion useless.</p>
</div>
<div id="recursiveTreeFigure" class="imageblock">
<div class="content">
<img src="chapters/19-recursion/images/trees.svg" alt="trees" width="100%">
</div>
<div class="title">Figure 19.2 Recursive refinement generating a tree-like image.</div>
</div>
<div class="paragraph">
<p>A recursive definition for your age suggests that recursion is all around
us. Though recursive definitions written in formal notation might seem artificial,
self-similarity is a constant theme in art and nature. The branching of
a trunk of a tree is similar to the branching of its limbs, which is
similar to the branching of its branches, which in turn is similar to
the branching of its twigs. In fact, we borrow the idea of the branching
of a tree to define a recursive data structure in
<a href="chap19.html#_syntax_recursive_data_structures">Section 19.4</a>. <a href="chap19.html#recursiveTreeFigure">Figure 19.2</a>
starts with a simple Y-shaped branching. By successively replacing the
branches with the previous shape, a tree is generated recursively.
<em>Fractals</em> are images generated by similar recursive techniques.
Although many real trees exhibit recursive tendencies, they don’t
follow rules consistently or rigidly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recursive_definitions">19.2.2. Recursive definitions</h4>
<div class="paragraph">
<p>Although recursion crops up throughout the world, certain forms of
recursion are more useful for solving problems. As with many aspects of
programming, the recursion we use has a strong connection to mathematical
principles.</p>
</div>
<div class="paragraph">
<p>In mathematics, a <em>recursive definition</em> is one that is defined in terms
of itself. It’s common to define functions, sequences, and  sets recursively.
Functions, such as <em>f</em>(<em>n</em>), are usually defined in relation to the same
function with a smaller input, such as <em>f</em>(<em>n</em> - 1). Sequences, such as
<em>s</em><sub><em>n</em></sub>, are usually defined in relation to earlier elements in the sequence,
such as <em>s</em><sub><em>n</em>-1</sub>.</p>
</div>
<div id="multiplicationDefinedRecursivelyExample" class="exampleblock">
<div class="title">Example 19.1 Multiplication defined recursively</div>
<div class="content">
<div class="paragraph">
<p>Even very common functions can be defined recursively. Consider the
multiplication <em>x</em> · <em>y</em>. This multiplication means
repeatedly adding <em>x</em> a total of <em>y</em> times.
If <em>y</em> is a positive integer, we can describe this
multiplication with the following recursive definition. Note the base
case and recursive case.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/multiplicationRecursion.svg" alt="multiplicationRecursion" width="50%">
</div>
</div>
<div class="paragraph">
<p>Multiplication seems like such a basic operation that there would be no
need to have such a definition. Yet mathematicians often use multiple
equivalent definitions to prove results. Furthermore, this elementary
definition provides intuition for creating more complex definitions.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#recursiveAdditionExercise">Exercise 19.1</a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 19.2 Factorial defined recursively</div>
<div class="content">
<div class="paragraph">
<p>Another mathematical function with a natural recursive definition is the
factorial function, often written <em>n</em>!. The factorial
function is used heavily in probability and counting. The value of
<em>n</em>! = <em>n</em> · (<em>n</em> - 1) · (<em>n</em> - 2) · …​ · 3 · 2 · 1. Mathematicians
like recursive definitions because they’re able to describe functions
and sequences precisely without using ellipses (…​).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/factorialRecursion.svg" alt="factorialRecursion" width="45%">
</div>
</div>
<div class="paragraph">
<p>Note that the base case gives 1 as the answer when
<em>n</em> = 0. By convention 0! = 1. Thus, this
definition correctly gives 0! = 1,
1! = 1 · 0! = 1, 2! = 2 · 1! = 2,
3! = 3 · 2! = 6, and so on.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 19.3 Fibonacci defined recursively</div>
<div class="content">
<div class="paragraph">
<p>The Fibonacci sequence is an infinite sequence of integers starting with
1, 1, 2, 3, 5, 8, 13, 21, …​. Each term after the two
initial 1s is the sum of the previous two terms in the sequence.
Fibonacci has many interesting properties and crops up in surprisingly
diverse areas of mathematics. It was originally developed to model the growth
of rabbit populations.</p>
</div>
<div class="paragraph">
<p>The Fibonacci sequence also has a natural recursive mathematical
definition. Indeed, you may have noticed that we described each term as
the sum of the two previous terms. We can formally define the
<em>n</em><sup>th</sup> Fibonacci number <em>F</em><sub><em>n</em></sub> as follows,
starting with <em>n</em> = 0.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/fibonacciRecursion.svg" alt="fibonacciRecursion" width="55%">
</div>
</div>
<div class="paragraph">
<p>Since the <em>F</em><sub><em>n</em></sub> depends on the two previous terms, it’s
necessary to have <strong>two</strong> base cases. The Fibonacci sequence is a special
kind of Lucas sequence. Other Lucas sequences specify different values
for the two base cases and sometimes coefficients to multiply the
previous terms by.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_iteration_vs_recursion">19.2.3. Iteration vs. recursion</h4>
<div class="paragraph">
<p>These mathematical definitions are interesting, but what’s their
relationship to Java code? So far, we’ve considered algorithms that
are iterative in nature: processing is performed as a sequence of
operations on elements of a sequential data structure. We sum the
elements of an array by iterating through them from first to last. We
multiply two matrices by using nested <code>for</code> loops to sequence through
the matrix contents in the proper order. Similarly, one method might make
a sequence of one or more calls to other methods. We’re confident that
such computations terminate because we start at the beginning and work
to the end of a finite structure. But what if the structure is not a
simple linear or multidimensional array? The path we’re trying to find
through the maze is of unknown length and complexity.</p>
</div>
<div class="paragraph">
<p>A method might call other methods to complete its operation. For example,
a method that sorts a list of <code>String</code> values calls another method to do
pairwise comparison of the values in the list. A method that calls
<strong>itself</strong>, either directly or indirectly, is called a <em>recursive</em> method.</p>
</div>
<div class="paragraph">
<p>A recursive method might seem like a circular argument that never ends. In
fact, a recursive method only calls itself under certain circumstances.
In other circumstances, it does not. A recursive method has the same two parts
that a mathematical recursive definition has.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Base case</strong> <br>
The operation being computed is done without any recursive calls.</p>
</li>
<li>
<p><strong>Recursive case</strong> <br>
The operation is broken down into smaller pieces, one or
more of which results in a recursive call to the method itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each time a method calls itself recursively it does so on a smaller
problem. Eventually, it reaches a base case, and the recursion
terminates.</p>
</div>
<div class="paragraph">
<p>A recursive method is useful when a problem can be broken down into
smaller subproblems where each subproblem has the same structure as the
original, complete problem. These subproblems can be solved by recursive
calls and the results of those calls assembled to create a larger
solution.</p>
</div>
<div class="paragraph">
<p>Recursive methods are often surprisingly small given their complexity.
Each recursive call only makes a single step forward in the process of
solving the problem. In fact, it can appear that the problem is never
solved. The code has something like a “leap of faith” inside of it.
Assuming you can solve a smaller subproblem, how do you put the
solutions together to solve the full problem? This assumption is the
leap of faith, but it works out as long as the subproblems get broken
down into smaller and smaller pieces that eventually reach a base case.</p>
</div>
<div class="paragraph">
<p>From a theoretical standpoint, any problem that can be solved
iteratively can be solved recursively, and vice versa. Iteration and
recursion are equivalent in computational power. Sometimes it’s more
efficient or more elegant to use one approach or the other, and some
languages are designed to work better with a particular approach.</p>
</div>
</div>
<div class="sect3">
<h4 id="_call_stack">19.2.4. Call stack</h4>
<div class="paragraph">
<p>Many programmers who are new to recursion feel uncomfortable about the
syntax. How can a method call itself? What does that even mean?</p>
</div>
<div class="paragraph">
<p>Recursion in Java is grounded in the idea of a call stack. We discuss
the stack abstract data type in
<a href="chap18.html">Chapter 18</a>. A similar
structure is used to control the flow of control of a program as it calls
methods.</p>
</div>
<div class="paragraph">
<p>Recall that a stack is a first in, last out (FILO) data structure. Each
time a method is called, its local variables are put on the call stack.
As the method executes, a pointer to the current operation it’s
executing is kept on the call stack as well. This collection of local
variables and execution details for a method call is called the <em>stack
frame</em> or <em>activation record</em>. When another method is called, it pushes
its own stack frame onto the call stack as well, and its caller
remembers what it was executing before the call. When a method returns,
it pops its stack frame (the variables and state associated with its
execution) off the call stack.</p>
</div>
<div class="paragraph">
<p>A recursive method is called in exactly the same way. It puts another
copy of its stack frame on the call stack. Each call of the method has
its own stack frame and operates independently. There’s no way to
access the variables from one call to the next, other than by passing in
parameters or returning values.</p>
</div>
<div class="paragraph">
<p><a href="chap19.html#figure-recursive_calls">Figure 19.3</a> shows the stack frames being pushed
onto the call stack as the <code>main()</code> method calls the <code>factorial()</code>
method, starting with the argument <code>4</code>. The <code>factorial()</code> method
recursively calls itself with successively smaller values.</p>
</div>
<div id="figure-recursive_calls" class="imageblock">
<div class="content">
<img src="chapters/19-recursion/images/recursivecalls.svg" alt="recursivecalls" width="100%">
</div>
<div class="title">Figure 19.3 Successive recursive method calls getting added to the call stack.</div>
</div>
<div class="paragraph">
<p><a href="chap19.html#figure-recursive_returns">Figure 19.4</a> shows the stack frames popping off
the call stack as each call to <code>factorial()</code> returns. As the answers are
returned, they’re incorporated into the answer that’s generated and
returned to the next caller in the sequence until the final answer <code>24</code>
(4!) is returned to <code>main()</code>.</p>
</div>
<div id="figure-recursive_returns" class="imageblock">
<div class="content">
<img src="chapters/19-recursion/images/recursivereturns.svg" alt="recursivereturns" width="100%">
</div>
<div class="title">Figure 19.4 Recursive methods returning results to their callers.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_recursive_methods">19.3. Syntax: Recursive methods</h3>
<div class="paragraph">
<p>Unlike many <strong>Syntax</strong> sections in other chapters, there’s no new Java
syntax to introduce here. Any method that calls itself, directly or
indirectly, is a recursive method. Recursive methods are simply methods
like any others, called in the normal way.</p>
</div>
<div class="paragraph">
<p>The real difficulty in learning to program recursively lies in breaking
out of the way you’re used to thinking about program control flow. All
that you’ve learned about solving problems with iteration in previous
chapters might make it harder for you to embrace recursion.</p>
</div>
<div class="paragraph">
<p>Iteration views the whole problem at once and tries to sequence all the
pieces of the solution in some organized way. Recursion is only
concerned with the current step in the solution. If the current step is
one in which the answer is clear, you’re in a base case. Otherwise, the
solution takes one step toward the answer and then makes the leap of
faith, allowing the recursion to take care of the rest. Programmers who
are new to recursion are often tempted to do too much in each recursive
call. Don’t rush it!</p>
</div>
<div class="paragraph">
<p>The use of recursion in languages like Java owes much to the development
of <em>functional programming</em>. In many functional languages (such as
Scheme), there are no loops, and <strong>only</strong> recursion is allowed. In a
number of these languages, there’s no assignment either. Each variable
has one value for its entire lifetime, and that value comes as a
parameter from whatever method called the current method.</p>
</div>
<div class="paragraph">
<p>It may seem odd to you, but this approach is a good one to follow when
writing recursive methods. Try <strong>not</strong> to assign variables inside your
methods. See if the work done in each method can be passed on as an
argument to the next method rather than changing the state inside the
current method. In that way, each recursive method is a frozen snapshot
of some part of the process of solving the problem. Of course, this
guideline is only a suggestion. Many practical recursive methods need to
assign variables internally, but a surprisingly large number do not.</p>
</div>
<div class="paragraph">
<p>Because the data inside these methods is tied so closely to the input
parameters and the return values given back to the caller, these methods
are often made <code>static</code>. Ideally, recursive methods do not change the
state of fields or class variables. Again, sometimes changing external
state is necessary, but recursive methods are meant to take in only
their input parameters and give back only return values. Recursive code
that reads and writes variables inside of objects or classes can be
difficult to understand and debug since it depends on outside data.</p>
</div>
<div class="paragraph">
<p>With this information as background, we focus on examples for the rest
of this section. Because recursion is a new way of thinking, approach
these examples with an open mind. Many students have the experience that
recursion makes no sense until they see the right example. Then, the way
it works suddenly “clicks.” Don’t be discouraged if recursion seems
difficult at first.</p>
</div>
<div class="paragraph">
<p>In this section, we work through examples of factorial computation,
Fibonacci numbers, the classic Tower of Hanoi problem, and exponentiation.
These problems are mathematical in nature because mathematical
recursion is easy to model in code. The next section applies recursion
to processing data structures.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19.4 Factorial implemented recursively</div>
<div class="content">
<div class="paragraph">
<p>In our first example of a recursive implementation, we return to the
factorial function. Recall the recursive definition that describes the
function.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/factorialRecursion.svg" alt="factorialRecursion" width="45%">
</div>
</div>
<div class="paragraph">
<p>By translating this mathematical definition almost directly into Java,
we can generate a method that computes the factorial function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>     <span class="c1">// Base case</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">else</span>            <span class="c1">// Recursive case</span>
		<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the base case and recursive case are exactly the same as in the
recursive definition. The return type of the method is <code>long</code> because
factorial grows so quickly that only the first few values are small
enough to fit inside of an <code>int</code>.</p>
</div>
</div>
</div>
<div id="fibonacciImplementedRecursivelyExample" class="exampleblock">
<div class="title">Example 19.5 Fibonacci implemented recursively</div>
<div class="content">
<div class="paragraph">
<p>Let’s return to the recursive definition of Fibonacci.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/fibonacciRecursion.svg" alt="fibonacciRecursion" width="55%">
</div>
</div>
<div class="paragraph">
<p>Like factorial, this definition translates naturally into a recursive
method in Java.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">// Base cases</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span>                  <span class="c1">// Recursive case</span>
        <span class="k">return</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One significant problem with this implementation is performance. In this case,
the double recursion performs a great deal of redundant computation.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#fibonacciCallsExercise">Exercise 19.3</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>One technique for eliminating redundant computation in recursion is
called <em>memoization</em>. Whenever the value for a subproblem is computed,
we note down the result (like a memo). When we go to compute a value, we
first check to see if we have already found it.</p>
</div>
<div class="paragraph">
<p>To perform memoization for Fibonacci, we can pass an array of <code>int</code>
values of length <code>n + 1</code>. The values in this array all begin with a
value of <code>0</code>. When computing the Fibonacci value for a particular <code>n</code>,
we first check to see if its value is in the array. If not, we perform
the recursion and store the result in the array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">results</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">results</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="n">results</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">results</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">results</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This change makes the computation of the <em>n</em><sup>th</sup> Fibonacci
number much more efficient; however, even more efficient approaches are
described in the exercises.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#constantSpaceFibonacciExercise">Exercise 19.6</a><br>
<a href="chap19.html#fastFibonacciExercise">Exercise 19.8</a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 19.6 Tower of Hanoi</div>
<div class="content">
<div class="paragraph">
<p>The famous Tower of Hanoi puzzle is another example commonly used to
illustrate recursion. In this puzzle, there are three poles containing a
number of different sized disks. The puzzle begins with all disks
arranged in a tower on one pole in decreasing size, with the smallest
diameter disk on top and the largest on the bottom.
<a href="chap19.html#figure-hanoi">Figure 19.5</a> shows an example of the puzzle. The goal is to
move all the disks from the initial pole to the final pole, with two
restrictions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Only one disk can be moved at a time.</p>
</li>
<li>
<p>A larger disk can never be placed on top of a smaller disk.</p>
</li>
</ol>
</div>
<div id="figure-hanoi" class="imageblock">
<div class="content">
<img src="chapters/19-recursion/images/hanoi.svg" alt="hanoi" width="100%">
</div>
<div class="title">Figure 19.5 Tower of Hanoi puzzle with 4 disks on the initial pole.</div>
</div>
<div class="paragraph">
<p>The extra pole is used as a holder for intermediate moves. The idea
behind the recursive solution follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Base Case</strong><br>
Moving one disk is easy. Just move it from the pole it’s on to the
destination pole.</p>
</li>
<li>
<p><strong>Recursive Case</strong><br>
In order to move <em>n</em> &gt; 1 disks from one pole to another,
we can move <em>n</em> - 1 disks to an intermediate pole, move
the <em>n</em><sup>th</sup> disk to the destination pole, and then move the
<em>n</em> - 1 disks from the intermediate pole to the
destination pole.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Tower of Hanoi solution in Java translates this outline into code.</p>
</div>
<div id="TowerOfHanoiProgram" class="listingblock">
<div class="title">Program 19.1 Recursive solution to the Tower of Hanoi with four disks and poles named <code>'A'</code>, <code>'B'</code>, and <code>'C'</code>.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TowerOfHanoi</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="sc">'A'</span><span class="o">,</span> <span class="sc">'C'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">char</span> <span class="n">fromPole</span><span class="o">,</span> <span class="kt">char</span> <span class="n">toPole</span><span class="o">,</span> <span class="kt">char</span> <span class="n">viaPole</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Move disk from pole %c to pole %c.\n"</span><span class="o">,</span>
                <span class="n">fromPole</span><span class="o">,</span> <span class="n">toPole</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">move</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">fromPole</span><span class="o">,</span> <span class="n">viaPole</span><span class="o">,</span> <span class="n">toPole</span><span class="o">);</span>
            <span class="n">move</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">fromPole</span><span class="o">,</span> <span class="n">toPole</span><span class="o">,</span> <span class="n">viaPole</span><span class="o">);</span>
            <span class="n">move</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">viaPole</span><span class="o">,</span> <span class="n">toPole</span><span class="o">,</span> <span class="n">fromPole</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A legend tells of monks that are solving the Tower of Hanoi puzzle with
64 disks. The legend predicts that the world will end when they finish.
Run the implementation above with different numbers of disks to see how
long the sequence of moves is. Try small numbers of disks, since large
numbers of disks take a very long time.</p>
</div>
</div>
</div>
<div id="exponentiationExample" class="exampleblock">
<div class="title">Example 19.7 Exponentiation</div>
<div class="content">
<div class="paragraph">
<p>Both Fibonacci and the Tower of Hanoi have natural recursive structures.
In the case of Fibonacci, one way to implement its natural recursive
definition results in very wasteful computation. In the case of the
Tower of Hanoi, the <strong>only</strong> way to solve the problem takes an
excruciatingly long amount of time.</p>
</div>
<div class="paragraph">
<p>However, we can apply recursion to many practical problems and get
efficient solutions. Consider the problem of exponentiation, which looks
trivial: Given a rational number <em>a</em> and a positive integer
<em>n</em>, find the value of <em>a</em><sup><em>n</em></sup>.</p>
</div>
<div class="paragraph">
<p>It’s tempting to call <code>Math.pow(a, n)</code> or to use a short <code>for</code> loop to
compute this value, but what if neither tool existed in Java? A simple
recursive formulation can describe exponentiation.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/exponentRecursion1.svg" alt="exponentRecursion1" width="45%">
</div>
</div>
<div class="paragraph">
<p>As with factorial and Fibonacci, directly converting the recursive
definition into Java syntax yields a method that computes the correct
value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">power</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="c1">// Base case</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">else</span>          <span class="c1">// Recursive case</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">power</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Admittedly, this method only works for positive integer values of
<em>n</em>. Ignoring that limitation, what can we say about its
efficiency? For any legal value of <em>n</em>, the method is called
<em>n</em> times. If <em>n</em> has a small value, like 2 or
3, the process is quick. But if <em>n</em> is 1,000,000 or so, the
method might take a while to finish. Another problem is that stack size
is limited. On most systems, the JVM crashes with a <code>StackOverflowError</code>
if a method tries to call itself recursively 1,000,000 times.</p>
</div>
<div class="paragraph">
<p>If we limit <em>n</em> to a power of 2, we can do something clever
that makes the method much more efficient with many fewer recursive
calls. Consider this alternative recursive definition of exponentiation.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/exponentRecursion2.svg" alt="exponentRecursion2" width="45%">
</div>
</div>
<div class="paragraph">
<p>Recalling basic rules of exponents, it’s true that <em>a</em><sup><em>n</em></sup> = (<em>a</em><sup><em>n</em>/2</sup>)<sup>2</sup>,
but what does that buy us? If we structure our method correctly, we cut the
size of <em>n</em> in half at each recursive step instead of only reducing <em>n</em> by 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">power</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="c1">// Base case</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>          <span class="c1">// Recursive case</span>
        <span class="kt">double</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">power</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">*</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we only make the recursive call once and save its result in <code>temp</code>.
If we made two recursive calls, we would no longer be more efficient than
the previous method. That version took <em>n</em> recursive calls.
How efficient is this version? The answer is the number of times you
have to cut <em>n</em> in half before you get 1. Let’s call that
value <em>x</em>. Recall that <em>n</em> is a power of 2,
meaning that <em>n</em> = 2<sup><em>k</em></sup> for some integer
<em>k</em> ≥ 0.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/logarithm.svg" alt="logarithm" width="15%">
</div>
</div>
<div class="paragraph">
<p>In other words, the number of times you have to divide <em>n</em>
in half to get 1 is the logarithm base 2 of <em>n</em>, written
log<sub>2</sub> <em>n</em>. The logarithm function is the inverse of
exponentiation. It cuts any number down to size very quickly (just as
exponentiation blows up the value of a number very quickly). For
example, 2<sup>20</sup> = 1,048,576. Thus,
log<sub>2</sub> 1,048,576 = 20. The original version of <code>power()</code>
would have to make 1,048,576 calls to raise a number to that power. This
second version would only have to make 20 calls.</p>
</div>
<div class="paragraph">
<p>It’s critical that <em>n</em> is a power of 2 (1, 2, 4, 8, …​);
otherwise, the process of repeatedly cutting <em>n</em> in half
loses some data due to integer division. The problem is that, at some
point in the recursion, the value of <em>n</em> will become odd unless you
start with a power of 2. There’s a way to extend this clever approach
to all values of <em>n</em>, even and odd, but we leave it as an
exercise.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#fastExponentiationExercise">Exercise 19.7</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Recursion offers elegant ways to compute mathematical functions like
those we’ve explored in this section. Recursion also offers powerful
ways to manipulate data structures. As we show in the next section,
recursive methods are especially well suited to use with recursive data
structures.</p>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_recursive_data_structures">19.4. Syntax: Recursive data structures</h3>
<div class="paragraph">
<p>Because recursion can be used to do anything that iteration can do, it’s
clear that data structures can be processed recursively. For example,
the following recursive method reverses the contents of an array. It
keeps track of the position it’s swapping in the array with the
<code>position</code> parameter. This method is initially called with a value of
<code>0</code> passed as an argument for <code>position</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span><span class="o">(</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">position</span><span class="o">];</span>
		<span class="n">array</span><span class="o">[</span><span class="n">position</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
		<span class="n">array</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="n">reverse</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">position</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that nothing is done in the base case for this recursive method.
The recursion swaps the first element of the array (at index <code>0</code>) with
the last (at index <code>array.length - 1</code>). Recursion continues until
<code>position</code> has reached half the length of <code>array</code>. If execution
continued past the halfway point, it would begin to re-swap elements that
had already been swapped.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#recusivePalindromeExercise">Exercise 19.5</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Although it’s possible to reverse an array recursively, there’s
usually no advantage in doing so. We introduced bubble sort and selection
sort in previous chapters, but neither of these algorithms is very fast.
Many of the best sorting algorithms are recursive, as in the following
example of merge sort.</p>
</div>
<div id="mergeSortExample" class="exampleblock">
<div class="title">Example 19.8 Merge sort</div>
<div class="content">
<div class="paragraph">
<p>Merge sort is an efficient sorting algorithm that’s often implemented
recursively. The idea of the sort is to break a list of items in half
and recursively merge sort each half. Then, these two sorted halves are
merged back together into the final sorted list. The base case of the
recursion is when there’s only a single item in the list, since a list
with only one thing in it is, by definition, sorted.</p>
</div>
<div class="paragraph">
<p>Here’s a method that recursively sorts an <code>int</code> array using the merge
sort algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
			<span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
			<span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">i</span><span class="o">];</span>
		<span class="n">mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="n">mergeSort</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
		<span class="n">merge</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mergeSort()</code> method is quite short and appears to do very little.
It starts by creating arrays <code>a</code> and <code>b</code> and copying roughly half of the
elements in <code>array</code> into each. We make <code>a</code> half the size of <code>array</code>, but
we can’t do the same thing for <code>b</code> because an odd length for <code>array</code>
would leave us without enough space in <code>a</code> and <code>b</code> to hold everything
from <code>array</code>. Instead, we let <code>b</code> hold however much is leftover after
the elements for <code>a</code> have been accounted for.</p>
</div>
<div class="paragraph">
<p>Then, arrays <code>a</code> and <code>b</code> are recursively sorted. Finally, these two
sorted arrays are merged back into <code>array</code> in sorted order using a
helper method called <code>merge()</code>. This method is non-recursive and does
much of the real work in the algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">aIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">bIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">bIndex</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">aIndex</span><span class="o">++];</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">aIndex</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">bIndex</span><span class="o">++];</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">aIndex</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">[</span><span class="n">bIndex</span><span class="o">])</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">aIndex</span><span class="o">++];</span>
        <span class="k">else</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">bIndex</span><span class="o">++];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>merge()</code> method loops through all the elements in <code>array</code>, filling
them in. We keep two indexes, <code>aIndex</code> and <code>bIndex</code>, that keep track of
our current positions in the <code>a</code> and <code>b</code> arrays, respectively. This
method assumes that <code>a</code> and <code>b</code> are sorted and that the sum of their
lengths is the length of <code>array</code>. We want to compare each element in <code>a</code>
and <code>b</code>, always taking the smaller and putting it into the next
available location in <code>array</code>. Since the next smallest item could be in
either <code>a</code> or <code>b</code>, we never know when we’ll run out of elements in
either array. That’s why the first two <code>if</code> statements in the <code>merge()</code>
method check to see if the <code>bIndex</code> or the <code>aIndex</code> is already past the
last element in its respective array. If so, the next element from the
other array is automatically used. By the time the third <code>if</code> statement
is reached, we’re certain that both indexes are valid and can compare
the elements at those locations to see which is smaller.</p>
</div>
<div class="paragraph">
<p>Sorting lists using the merge sort algorithm seems more complicated than
using bubble sort or selection sort, but this additional complication
pays dividends. For large lists, merge sort performs much faster than
either of those sorts. In fact, its speed is comparable to the best
general sorting algorithms that are possible.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#timeSortingExercise">Exercise 19.15</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Although recursive sorting algorithms are useful for arrays, recursion
really shines when manipulating <em>recursive data structures</em>. A recursive
data structure is one that’s defined in terms of itself. For example,
class <code>X</code> is recursive if there’s a field inside <code>X</code> with type <code>X</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">X</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The linked list examples from
<a href="chap18.html">Chapter 18</a> are recursive
data structures, since a linked list node is defined in terms of itself. You
might not have thought of the linked list <code>Node</code> class as being recursive since
it simply has a reference to another <code>Node</code> inside it. However, this
self-reference is the essence of a recursive data structure.</p>
</div>
<div class="paragraph">
<p>Data structures are often defined recursively. We typically need to
represent an unbounded collection of data, but we always write bounded
programs to describe the data. A recursive data structure allows us to
bridge the gap between a compile-time, fixed-length definition and a
run-time, unbounded collection of objects.</p>
</div>
<div class="paragraph">
<p>Recursive data structures have a base case to end the recursion.
Typically, the end of the recursion is indicated by a link with a <code>null</code>
value. For example, in the last node of a linked list, the <code>next</code> field is
<code>null</code>. Unsurprisingly, recursive methods are frequently used to
manipulate recursive data structures.</p>
</div>
<div id="recursiveLinkedListSizeExample" class="exampleblock">
<div class="title">Example 19.9 Recursive linked list size</div>
<div class="content">
<div class="paragraph">
<p>How would you get the size of a linked list? The implementation in
<a href="chap18.html#LinkedListProgram">Program 18.5</a> keeps track of its size as it grows, but
what if it didn’t? A standard way to count the elements in the list
would be to start with a reference to the head of the list and a counter
with value zero. As long as the reference is not <code>null</code>, add one to the
counter and set the reference to the next element on the list.
<a href="chap19.html#IterativeListSizeProgram">Program 19.2</a> counts the elements in this way.</p>
</div>
<div id="IterativeListSizeProgram" class="listingblock">
<div class="title">Program 19.2 Linked list implementation whose <code>size()</code> method counts its elements iteratively.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IterativeListSize</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>   
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">counter</span><span class="o">++;</span>
        <span class="o">}</span>           
        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative way to count the number of elements in a linked list is
to use the natural recursion of the linked list itself. We can say that
the length of a linked list is 0 if the list is empty (the current link
is <code>null</code>); otherwise, it’s one more than the size of the rest of the
list.</p>
</div>
<div class="paragraph">
<p><a href="chap19.html#RecursiveListSizeProgram">Program 19.3</a> counts the elements in a linked
list using this recursive procedure. Note that there’s a non-recursive
<code>size()</code> method that calls the recursive <code>size()</code> method. This
non-recursive method is called a <em>proxy method</em>. The recursive method
requires access to the internals of the data structure. The proxy method
calls the recursive method with the appropriate starting point (<code>head</code>),
while providing a public way to get the list’s size without exposing its
internals.</p>
</div>
<div id="RecursiveListSizeProgram" class="listingblock">
<div class="title">Program 19.3 Linked list implementation with a recursive <code>size()</code> method for counting its elements.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RecursiveListSize</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>   
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>        
    <span class="o">}</span>
    
    <span class="c1">// Proxy method</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Node</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 				<span class="c1">// Base case</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>   
        <span class="k">else</span>
			<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>	<span class="c1">// Recursive case</span>
    <span class="o">}</span>    
<span class="o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#recursivePrintExercise">Exercise 19.9</a><br>
<a href="chap19.html#reversePrintExercise">Exercise 19.10</a></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_trees">19.4.1. Trees</h4>
<div class="paragraph">
<p>A linked list models a linear, one-to-one relationship between its
elements since each item in the list is linked to a maximum of one following
item. Another useful relationship to model is a hierarchical,
one-to-many relationship: parent to children, boss to employees,
directory to files, and so on. These relationships can be modeled using
a <em>tree</em> structure, which begins with a single <em>root</em>, and proceeds
through <em>branches</em> to the <em>leaves</em>. Typically, the elements of a tree
are also called <em>nodes</em>, with the three following special cases.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Root node</strong> <br>
The root of the tree has no parents.</p>
</li>
<li>
<p><strong>Leaf node</strong> <br>
A leaf is at the edge of a tree and has no children.</p>
</li>
<li>
<p><strong>Interior node</strong><br>
An interior node has a parent and at least one child. It’s
neither the root nor a leaf.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="chap19.html#figure-tree_visualization">Figure 19.6</a> shows a visualization of a tree. In
nature, a tree has its root at the bottom and branches upward. Since the
root is the starting point for a tree data structure, it’s almost
always drawn at the top.</p>
</div>
<div id="figure-tree_visualization" class="imageblock">
<div class="content">
<img src="chapters/19-recursion/images/treevisualization.svg" alt="treevisualization" width="100%">
</div>
<div class="title">Figure 19.6 Visualization of a tree. The root is shown in light red. The leaves are shown in blue. The interior nodes are show in light purple.</div>
</div>
<div class="paragraph">
<p>Abstractly, a tree is either empty (the base case) or contains
references to 0 or more other trees (the recursive case). Trees are
useful for storing and retrieving sorted data efficiently. Some
applications include dictionaries, catalogs, ordered lists, and any
other sorted set of objects. For these purposes, we can define an
abstract data type that includes operations such as <code>add()</code> and
<code>find()</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#treeInterfaceExercise">Exercise 19.13</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>A special case of a tree that’s used frequently is a <em>binary tree</em>, in
which each node references at most two other trees.</p>
</div>
<div id="binarySearchTreeExample" class="exampleblock">
<div class="title">Example 19.10 Binary search tree</div>
<div class="content">
<div class="paragraph">
<p>A <em>binary search tree</em> is a further special case of a binary tree with the
following three properties.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The value in the left child of the root is smaller than the value in
the root.</p>
</li>
<li>
<p>The value in the right child of the root is larger than the value in
the root.</p>
</li>
<li>
<p>Both the left and the right subtrees are binary search trees.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This recursive definition describes a tree that makes items with a
natural ordering easy to find. If you’re looking for an item, you first
look at the root of the tree. If the item you want is in the root,
you’ve found it! If the item you want is smaller than the root, go left.
If the item you want is larger than the root, go right. If you ever run
out of tree nodes by hitting a <code>null</code>, the item isn’t in the tree.</p>
</div>
<div class="paragraph">
<p>This example is a simple binary tree that can store a list of <code>String</code>
values and print them out in alphabetical order. <a href="chap19.html#TreeProgram">Program 19.4</a> shows
the <code>Tree</code> class that defines the fields and two public methods, <code>add()</code>
and <code>print()</code>, that operate on the tree. Each is a proxy method that
calls its private recursive version, which takes a reference to a <code>Node</code>
object. The <code>Node</code> static nested class contains three fields.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value</code>: the <code>String</code> value stored at the node</p>
</li>
<li>
<p><code>left</code>: a link to the left subtree</p>
</li>
<li>
<p><code>right</code>: a link to the right subtree</p>
</li>
</ul>
</div>
<div id="TreeProgram" class="listingblock">
<div class="title">Program 19.4 Class that implements a simple binary search tree ADT for creating a sorted list of <code>Strings</code> values.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
    <span class="c1">// Proxy add</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Base case </span><i class="conum" data-value="1"></i><b>(1)</b>
            <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Left recursive case    </span><i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="c1">// Right recursive case   </span><i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">;</span> 			  <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="o">}</span>
    
    <span class="c1">// Proxy print</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
        
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> 				<i class="conum" data-value="5"></i><b>(5)</b>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>	<i class="conum" data-value="6"></i><b>(6)</b>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>				<i class="conum" data-value="7"></i><b>(7)</b>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The recursive <code>add()</code> method first checks to see if the current subtree
is empty (<code>null</code>). If so, it creates a new <code>Node</code> and puts <code>value</code>
inside it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the current subtree is not <code>null</code>, it checks to see if
<code>value</code> is smaller or larger than the <code>value</code> at the root of the subtree.
If it’s smaller, it recurses down the left subtree.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If it’s larger, it
recurses down the right subtree. If <code>value</code> is already in the root node,
it does nothing.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Remember that all parameters are pass by value in Java. Thus, assigning
a new <code>Node</code> to <code>tree</code> doesn’t by itself change anything at higher
levels of the tree. What does change the links in the parent of the
current subtree is returning the <code>tree</code> pointer. If the recursive call
to <code>add()</code> was made with a left or a right subtree, the <code>left</code> or
<code>right</code> link, respectively, of the parent <code>Node</code> is assigned the return
value. If the call was made with <code>root</code>, the parent of the entire tree,
the non-recursive <code>add()</code> method sets its value when the recursive
<code>add()</code> returns.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The recursive <code>print()</code> method starts by walking down the left subtree.
Those values are all alphabetically less than the value of the current
node.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>When it finishes, it prints the current node value.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Finally, it
walks the right subtree to print the values that alphabetically follow
the value in the current node. This path through the nodes of the tree
is called an <em>inorder traversal</em>.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="chap19.html#figure-tree_classes">Figure 19.7</a> shows a visualization of the contents of
this implementation of a binary search tree. As with a linked list, an
“X” is used in place of arrows that point to <code>null</code>.</p>
</div>
<div id="figure-tree_classes" class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/treeclasses.svg" alt="treeclasses" width="75%">
</div>
<div class="title">Figure 19.7 Visualization of a tree implementation with classes.</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#recursiveFindExercise">Exercise 19.11</a><br>
<a href="chap19.html#recursiveHeightExercise">Exercise 19.12</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>With the power of a binary search tree, it takes virtually no code at
all to store a list of <code>String</code> values and then print them out in sorted
order. <a href="chap19.html#ReadAndSortStringsProgram">Program 19.5</a> gives an example of this
process using a <code>Tree</code> object for storage.</p>
</div>
<div id="ReadAndSortStringsProgram" class="listingblock">
<div class="title">Program 19.5 Reads <code>String</code> values, stores them in a binary search tree, and prints the results in sorted order.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadAndSortStrings</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Tree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tree</span><span class="o">();</span>
		<span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		
		<span class="k">while</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span>           
			<span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">());</span>        
		<span class="n">tree</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Binary search trees (and other trees, including heaps, tries, B-trees,
and more) are fundamental data structures that have been studied
heavily. Designing them to have efficient implementations that balance
the size of their left and right subtrees is an important topic that’s
beyond the scope of this book.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_generic_dynamic_data_structures_and_recursion">19.4.2. Generic dynamic data structures and recursion</h4>
<div class="paragraph">
<p>Combining dynamic data structures and generics from the previous chapter
and recursion from this chapter gives us the full power of generic
dynamic data structures and recursive methods to process them.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19.11 Binary search tree to hold integers</div>
<div class="content">
<div class="paragraph">
<p>Consider <a href="chap19.html#IntegerTreeProgram">Program 19.6</a>, which implements a tree that
stores values of type <code>Integer</code>. Although it would be more efficient to
store <code>int</code> values, we use the <code>Integer</code> wrapper class to ease our
eventual transition into a parameterized generic type.</p>
</div>
<div id="IntegerTreeProgram" class="listingblock">
<div class="title">Program 19.6 Variant of <a href="chap19.html#TreeProgram">Program 19.4</a> that stores <code>Integer</code> values instead of <code>String</code> values.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegerTree</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
    <span class="c1">// Proxy add</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Base case</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Left recursive case</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="c1">// Right recursive case</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">;</span>        
    <span class="o">}</span>
    
    <span class="c1">// Proxy print</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
        
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It’s a waste to create class <code>IntegerTree</code>, which is identical to
<code>Tree</code> except that the type <code>String</code> has been replaced by <code>Integer</code>. As
in <a href="chap18.html#_advanced_generic_data_structures">Section 18.5</a>, we want our data
structures, recursive or otherwise, to hold any type. In this way, we
can reuse code across a wide range of applications.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19.12 Defining a generic binary search tree</div>
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#GenericTreeProgram">Program 19.7</a> defines a generic version of the <code>Tree</code>
class. This example is complicated by the fact that we need to be able
to compare the value we want to store with the value in each <code>Node</code>
object. We can’t make a tree with any arbitrary type. Objects of the
type <strong>must</strong> have the ability to be compared to each other and ordered.
Thus, we use a <em>bounded type parameter</em> specifying that the type <code>T</code>
stored in each <code>Tree</code> must implement the <code>Comparable</code> interface. This
requirement complicates the generic syntax significantly but guarantees
that any type that cannot be compared with itself is rejected at
compile-time.</p>
</div>
<div id="GenericTreeProgram" class="listingblock">
<div class="title">Program 19.7 Class that implements a generic tree.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTree</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
    <span class="c1">// Proxy add</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Base case</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Left recursive case</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="c1">// Right recursive case</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">;</span>        
    <span class="o">}</span>
    
    <span class="c1">// Proxy print</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
        
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Node</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tree</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">print</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>First, note that the <code>Node</code> class and the recursive methods are no longer
<code>static</code>. The generic syntax for keeping them <code>static</code> without producing
compiler warnings is unnecessarily complex. The type specifier <code>T extends
Comparable&lt;T&gt;</code> guarantees that type <code>T</code> implements the interface
<code>Comparable&lt;T&gt;</code>. The generic <code>Comparable</code> interface defined in the Java API
is as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax for generics in Java with type bounds is complicated, and we only
scratch the surface here. The good news is that these subtleties are
more important for people designing data structures and libraries and
come up infrequently for programmers who are only using the libraries.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 19.13 Using a generic class</div>
<div class="content">
<div class="paragraph">
<p><a href="chap19.html#ReadAndSortGenericsProgram">Program 19.8</a> uses the generic tree class to
create two kinds of trees, a tree of <code>String</code> objects and a tree of
<code>Integer</code> objects. Java library implementations of binary search trees
are available as the <code>TreeSet</code> and <code>TreeMap</code> classes.</p>
</div>
<div id="ReadAndSortGenericsProgram" class="listingblock">
<div class="title">Program 19.8 Creates two trees with different underlying types.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReadAndSortGenerics</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>

        <span class="nc">GenericTree</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringTree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericTree</span><span class="o">&lt;&gt;();</span>
        <span class="nc">GenericTree</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerTree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericTree</span><span class="o">&lt;&gt;();</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span>
            <span class="n">stringTree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">());</span>      
        <span class="n">stringTree</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">integerTree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>      
        <span class="n">integerTree</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_solution_maze_of_doom">19.5. Solution: Maze of doom</h3>
<div class="paragraph">
<p>Our algorithm for solving the maze follows the conventional
pencil-and-paper method: trial and error! We mark locations in the maze
with <code>'*'</code> as we explore them. If we come to a dead end, we unmark the
location (by replacing <code>'*'</code> with <code>'&nbsp;'</code>) and return to our previous
location to try a different direction.</p>
</div>
<div class="paragraph">
<p>We start at the beginning square of the maze, which must be a passageway.
We mark that location as part of the path by putting <code>'*'</code> in the cell.
Now, what can we do? There are, in general, four possible directions to
head: up, down, left, or right. If that direction doesn’t take us
outside the bounds of the array, then we find either a wall or a
passageway. If we’ve been walking through the maze, we might also find
a part of the current path (often the square we were on before the
current one).</p>
</div>
<div class="paragraph">
<p>Suppose from our current point in the maze we could send a scout ahead
in each of the four directions. If the direction didn’t take the scout
out of bounds, he would find either a wall, a part of the current path
(the path that led into that space), or an open passageway. If the scout
doesn’t find an open passageway, he reports back that that direction
doesn’t work.</p>
</div>
<div class="paragraph">
<p>On the other hand, if the scout finds an open passageway, what does he
do? Brace yourself! He does the exact same thing we just did: send out
scouts of his own in each of the four possible directions.</p>
</div>
<div class="paragraph">
<p>With careful, consistent coding, the scout follows the exact same
process we did. And the scout’s scouts. And so on. There is, in fact, only one
method and instead of calling a scout method to investigate each of the
squares in the four directions, we call our own method recursively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MazeSolver</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">maze</span><span class="o">;</span> 			 			<i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">ROWS</span><span class="o">,</span> <span class="no">COLUMNS</span><span class="o">;</span> 			<i class="conum" data-value="2"></i><b>(2)</b>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MazeSolver</span> <span class="n">solver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MazeSolver</span><span class="o">();</span>	<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">if</span><span class="o">(</span><span class="n">solver</span><span class="o">.</span><span class="na">solve</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nSolved!"</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nNot solvable!"</span><span class="o">);</span>
        <span class="n">solver</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>							<i class="conum" data-value="4"></i><b>(4)</b>
    <span class="o">}</span>   </code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>MazeSolver</code> class needs a two-dimensional array of <code>char</code> values to
store a representation of the maze.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It’s also convenient to store the number of rows and columns as constant fields.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>main()</code> method creates a new <code>MazeSolver</code> object and then calls its
<code>solve()</code> method with a starting location of <code>(0, 0)</code>. It prints an
appropriate message depending on whether or not the maze was solved.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finally, it prints out the maze, which includes a path marked with <code>'*'</code>
symbols if the maze is solvable.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="nf">MazeSolver</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>	<i class="conum" data-value="1"></i><b>(1)</b>
        <span class="no">ROWS</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>					<i class="conum" data-value="2"></i><b>(2)</b>
        <span class="no">COLUMNS</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
        <span class="n">maze</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">ROWS</span><span class="o">][</span><span class="no">COLUMNS</span><span class="o">];</span>			<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="no">ROWS</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>	<i class="conum" data-value="4"></i><b>(4)</b>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="no">COLUMNS</span><span class="o">;</span> <span class="n">column</span><span class="o">++)</span>
                <span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">column</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The constructor for <code>MazeSolver</code> creates a <code>Scanner</code>. It assumes that
the file describing the maze is redirected from standard input, although
it would be easy to modify the constructor to take a file name and read
from there instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next, it reads two integers and sets the <code>ROWS</code> and
<code>COLUMNS</code> to those values, which will be constants moving forward.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>It allocates a two-dimensional array of
<code>char</code> values with <code>ROWS</code> rows and <code>COLUMNS</code> columns.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finally, it reads
through the file, storing each line of <code>char</code> values into this array. As
it reads, it prints out each line to the screen, showing the initial
(unsolved) maze.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="no">ROWS</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="no">COLUMNS</span><span class="o">;</span> <span class="n">column</span><span class="o">++)</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>print()</code> method is a utility method that prints out the maze. It
iterates through each row, printing out the values for the columns in
that row.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">column</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="no">ROWS</span> <span class="o">||</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="no">COLUMNS</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'E'</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'*'</span><span class="o">;</span>
			<span class="k">if</span><span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="o">||</span> <span class="n">solve</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="o">||</span>
				<span class="n">solve</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span> <span class="n">solve</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
				<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="n">maze</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="o">;</span>
				<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The heart of the solution is the recursive method <code>solve()</code>. The
<code>solve()</code> method takes two parameters, <code>row</code> and <code>column</code>, and tries to
find a solution to the maze starting at location <code>maze[row][column]</code>. It
assumes that the maze is filled with <code>'+'</code> for walls, <code>'&nbsp;'</code> for
passageways, and may include <code>'*'</code> characters at locations that are part
of the partially completed solution.</p>
</div>
<div class="paragraph">
<p>If <code>solve()</code> is able to find a solution from the current location, it
returns <code>true</code>, otherwise it returns <code>false</code>. There are three base cases
for the current location in the maze.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The current location is outside the maze. Return <code>false</code>.</p>
</li>
<li>
<p>The current location is the ending location (marked with <code>'E'</code>). We have a winner, return
<code>true</code>!</p>
</li>
<li>
<p>The current location is not a passage (either a wall or a location
in the current path that’s already been marked). This call to <code>solve</code>
is not making progress toward the finish. Return <code>false</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If none of the base cases applies, then the current location, which must
contain a <code>'&nbsp;'</code> character, <strong>might</strong> be on a successful path, so <code>solve()</code>
gives it a try. The method tentatively marks the current position with
<code>'*'</code>. Then, it tries to find a path from the current
location to each of the four neighboring cells by recursively calling <code>solve()</code>.
If any of those four neighbors returns <code>true</code>, then <code>solve()</code> knows it’s found
a completed path and returns <code>true</code> to its caller.</p>
</div>
<div class="paragraph">
<p>If none of the four neighbors was on a path to the destination, then the
current location is not on a path. The method unmarks the current
location (by storing a <code>'&nbsp;'</code>) and returns <code>false</code>. Presumably, its
caller figures out what to do next, perhaps calling a different one of
its neighbors or giving up and returning <code>false</code> to its caller.</p>
</div>
<div class="paragraph">
<p>The very first call to <code>solve()</code> from the <code>main()</code> method either returns
<code>true</code> if a complete path through the maze is found or <code>false</code> if no
path exists. Note that this solver has no guarantee of finding the
<strong>shortest</strong> path through the maze, but if there’s at least one path to
the goal, it’ll find one.</p>
</div>
</div>
<div class="sect2">
<h3 id="_concurrency_futures">19.6. Concurrency: Futures</h3>
<div class="paragraph">
<p>This section doesn’t deal explicitly with recursion, but it does deal
with concurrency and methods in an interesting way. When we call a
method in Java, a stack frame for the method is put on the stack, and
the thread of execution begins executing code inside the method. When it’s
done, it returns a value (or not), and execution resumes in the caller. But
what if calling the method began executing an independent thread, and the
caller continued on without waiting for the method to return?</p>
</div>
<div class="paragraph">
<p>This second situation should seem familiar, since it’s exactly what
happens when the <code>start()</code> method is called on a <code>Thread</code> object: the
<code>start()</code> method returns immediately to its caller, but an independent
thread of execution has begun executing the code in the <code>run()</code> method
of the <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>What if we only care about the value that’s computed by the new thread
of execution? We can think of spawning the thread as an asynchronous
method call, a value that’s computed <strong>at some point</strong> rather than one we
have to wait for. The name for such an asynchronous method call is a
<em>future</em>. In some languages, particularly functional languages, all
concurrency is expressed as a future. In Java, only a little bit of code
is needed to create threads that can behave like futures. However, the
idea of futures is pervasive enough that Java API tools were created to
make the process of creating them simple.</p>
</div>
<div class="paragraph">
<p>We introduce three interfaces and a factory method call that can allow
you to use futures in Java. This section is not a complete introduction
to futures, but the tools presented are enough to get you started.</p>
</div>
<div class="paragraph">
<p>The first interface is the <code>Future</code> interface, which allows you to store
a reference to the asynchronous computation while it’s computing,
before you ask for its value. The second interface is the <code>Callable</code>
interface, which is similar to the <code>Runnable</code> interface in that it
allows you to specify a class whose objects can be started as
independent threads. Both the <code>Future</code> and <code>Callable</code> interfaces are
generic interfaces that require you to specify a type. Remember that futures
are supposed to give back an answer, and that’s the type you supply
as a parameter. For example, when creating a future that returns an
<code>int</code> value, you would create a class that implements the
<code>Callable&lt;Integer&gt;</code> interface, requiring it to contain a method with the
signature <code>Integer call()</code>. Likewise, you would store a reference to the
future you create in a <code>Future&lt;Integer&gt;</code> reference.</p>
</div>
<div class="paragraph">
<p>And how do you create such a future? Usually, many futures are running
at once to leverage the power of multiple cores. What if you want to
create 100 futures but only have 8 cores? The process of creating
threads is expensive, and it might not be worthwhile to create 100
threads when only 8 are able to run concurrently. To deal with this
problem, the Java API provides classes that implement the
<code>ExecutorService</code> interface, which can maintain a fixed-size <em>pool</em> of
threads. When a thread finishes computing one future, it’s
automatically assigned another. To create an object that can manage
threads this way, call the static factory method <code>newFixedThreadPool()</code>
on the <code>Executors</code> class with the size of the thread pool you want
create. For example, we can create an <code>ExecutorService</code> with a pool of 8
threads as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have an <code>ExecutorService</code>, you can give it a <code>Callable</code> object
of a particular type (such as <code>Callable&lt;Integer&gt;</code>) as a parameter to its
<code>submit()</code> method, and it will return a <code>Future</code> object of a matching type
(such as <code>Future&lt;Integer&gt;</code>). Then, the future is running (or at least
scheduled to run). At any later point you can call the <code>get()</code> method on
the <code>Future</code> object, which returns the value of its computation. Like
calling <code>join()</code>, calling <code>get()</code> is a blocking call that might have to
wait for the future to finish executing.</p>
</div>
<div class="paragraph">
<p>All this messy syntax should become clearer in the following example which
uses futures to compute the sum of the square roots of the first
100,000,000 integers concurrently.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19.14 Using futures to sum square roots</div>
<div class="content">
<div class="paragraph">
<p>To use futures to sum the square roots of integers, we first need a
worker class that implements <code>Callable</code>. Since the result of the sum of
square roots is a <code>double</code>, it must implement <code>Callable&lt;Double&gt;</code>. Recall
that primitive types such as <code>double</code> can’t be used as generic type
parameters, requiring us to use wrapper classes in those cases.</p>
</div>
<div id="RootSummerProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>				<i class="conum" data-value="1"></i><b>(1)</b>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RootSummer</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">min</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">max</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">RootSummer</span><span class="o">(</span><span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span> 	<i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">this</span><span class="o">.</span><span class="na">min</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">max</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>   
    
    <span class="kd">public</span> <span class="nc">Double</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span> 					<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, we import <code>java.util.concurrent.*</code> to have access to the <code>Callable</code>
interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>RootSummer</code> is a simple worker class that takes a <code>min</code> and a <code>max</code>
value in its constructor.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Its <code>call()</code> method returns the sum of the square roots of all the <code>int</code>
values greater than or equal to <code>min</code> and less than <code>max</code>.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Of course, we need another class to create the <code>ExecutorService</code>, start
the futures running, and collect the results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RootFutures</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">100000000</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">FUTURES</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">FUTURES</span><span class="o">);</span>     <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="no">THREADS</span><span class="o">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="no">N</span><span class="o">/</span><span class="no">FUTURES</span><span class="o">;</span> <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first part of <code>RootFutures</code> is setup. The imports give us the
concurrency tools we need and a list to store our futures in.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We have three constants. <code>THREADS</code> specifies the number of threads to
create. <code>N</code> gives the number we’re going up to. <code>FUTURES</code> is the total number
of futures we create, considerably larger than the number of threads
they share.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Inside the <code>main()</code> method, we create an <code>ArrayList</code> to hold the
futures. Since we know the number of futures ahead of time, an array
would be ideal. Unfortunately, quirks in the way Java handles generics
make it illegal to create an array with a generic type. Instead, we
create an <code>ArrayList</code> with the size we’ll need pre-allocated.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Next, we create an <code>ExecutorService</code> with a thread pool of size <code>THREADS</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finally, we find the amount of work done by each future by dividing <code>N</code>
by <code>FUTURES</code>.  We can use simple division in this case instead of a more
complicated load-balancing approach because 100,000,000 is divisible by 10.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Creating futures..."</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">FUTURES</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">summer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RootSummer</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">work</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)*</span><span class="n">work</span><span class="o">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">summer</span><span class="o">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">futures</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
        <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To create the futures, we first instantiate a <code>RootSummer</code> object with the
appropriate bounds for the work it’s going to compute.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then, we supply that object to the <code>submit()</code> method on the
<code>ExecutorService</code>, which returns a <code>Future</code> object. We could have saved a
line of code by storing this return value
directly into the list <code>futures</code>.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Getting results from futures..."</span><span class="o">);</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="nl">future:</span> <span class="n">futures</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="o">}</span>
            <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="o">|</span> <span class="nc">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The sum of square roots is: "</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To collect the values from each future, we iterate
through the list of futures with an enhanced <code>for</code> loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We add the return value of each future’s <code>get()</code> method to our running
total <code>sum</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Because <code>get()</code> is a blocking call, we have to catch an <code>InterruptedException</code>
in case we’re interrupted while waiting for the future to respond.
However, we also have to catch an <code>ExecutionException</code> in case an
exception occurs during the execution of the future. This exception
handling mechanism is one of the big advantages of using futures:
Exceptions thrown by the future are propagated back to the thread that
gets the answer from the future. Normal threads simply die if they have
unhandled exceptions. Note that we use the modern exception-catching syntax
to handle two unrelated exceptions with the same <code>catch</code> block.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After all the values have been read and summed, we shut the
<code>ExecutorService</code> down. If we’d wanted, we could have submitted
additional <code>Callable</code> objects to it to run more futures.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finally, we print out the result.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_19">19.7. Exercises</h3>
<div class="paragraph">
<p><strong>Conceptual Problems</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="recursiveAdditionExercise"></a> <a href="chap19.html#multiplicationDefinedRecursivelyExample">Example 19.1</a>
gave a mathematical recursive definition for <em>x</em> · <em>y</em>. Give a similar
recursive definition for <em>x</em> + <em>y</em>, assuming that <em>y</em> is a positive integer.
The structure is similar to the recursion to determine your current age given
in <a href="chap19.html#_what_is_recursion">Section 19.2.1</a>.</p>
</li>
<li>
<p>In principle, every problem that can be solved with an iterative
solution can be solved with a recursive one (and vice versa). However,
the limited size of the call stack can present problems for recursive
solutions with very deep recursion. Why? Conversely, are there any
recursive solutions that are impossible to turn into iterative ones?</p>
</li>
<li>
<p><a id="fibonacciCallsExercise"></a> Consider the first (non-memoized)
recursive version of the Fibonacci method given in
<a href="chap19.html#fibonacciImplementedRecursivelyExample">Example 19.5</a>. How many times is
<code>fibonacci()</code> called with argument 1 to compute
<code>fibonacci(n)</code>? Instrument your program and count the number of calls
for <em>n</em> = 2, 3, 4, …​, 20.</p>
</li>
<li>
<p>In the recursive <code>solve()</code> method in the <code>MazeSolver</code> program given
in <a href="chap19.html#_solution_maze_of_doom">Section 19.5</a>, the current location in the maze
array is set to a space character (<code>'&nbsp;'</code>) if no solution is been
found. What value was in that location? How would the program behave if
the value wasn’t changed back?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Programming Practice</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p><a id="recusivePalindromeExercise"></a> <a href="chap8.html#palindromeExercise">Exercise 8.11</a>
from <a href="chap8.html">Chapter 8</a> challenges you to write a method to
determine whether a <code>String</code> is a palindrome. Recall that a palindrome (if
punctuation and spaces are ignored) can be described as an empty <code>String</code> or
a <code>String</code> in which the first and last characters are equal, with all the
characters in between forming a palindrome. Write a recursive method with the
following signature to test if a <code>String</code> is a palindrome.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this method, the <code>start</code> parameter is the index of the first
character you’re examining, and the <code>end</code> parameter is the index
immediately after the last character you’re examining. Thus, it would
initially be called with a <code>String</code>, <code>0</code>, and the length of the
<code>String</code>, as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="s">"A man, a plan, a canal: Panama"</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span></code></pre>
</div>
</div>
</li>
<li>
<p><a id="constantSpaceFibonacciExercise"></a> The efficient implementation of
Fibonacci from <a href="chap19.html#fibonacciImplementedRecursivelyExample">Example 19.5</a>
eliminates redundant computation through memoization, storing values in
an array as they’re found. However, it’s possible to carry along the
computations of the previous two Fibonacci numbers <strong>without</strong> the
overhead of storing an array. Consider the following method signature.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="kt">int</span> <span class="n">previous</span><span class="o">,</span> <span class="kt">int</span> <span class="n">current</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The next recursive call to the <code>fibonacci()</code> method passes in <code>n - 1</code>
and suitably altered versions of <code>previous</code> and <code>current</code>. When <code>n</code>
reaches <code>0</code>, the <code>current</code> parameter holds the value of the Fibonacci
number you were originally looking for.</p>
</div>
<div class="paragraph">
<p>The method would be called as follows for any value of <code>n</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Complete the implementation of this recursive method.</p>
</div>
</li>
<li>
<p><a id="fastExponentiationExercise"></a> Write an implementation of
fast exponentiation that works for even and odd <em>n</em>. This
implementation is exactly the same as the one given at the end of
<a href="chap19.html#exponentiationExample">Example 19.7</a> except when <em>n</em> is odd.
Use the following recursive definition of exponentiation to guide your
implementation.</p>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/exponentRecursion3.svg" alt="exponentRecursion3" width="55%">
</div>
</div>
</li>
<li>
<p><a id="fastFibonacciExercise"></a> <a href="chap19.html#fibonacciImplementedRecursivelyExample">Example 19.5</a> shows
two implementations that can be used to find the <em>n</em><sup>th</sup> Fibonacci number.
With some knowledge of recurrence relations, it’s possible to show that there’s
a closed-form equation that gives the <em>n</em><sup>th</sup> Fibonacci number <em>F</em><sub><em>n</em></sub> where
<em>F</em><sub>0</sub> = <em>F</em><sub>1</sub> = 1.</p>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/19-recursion/images/fibonacciClosed.svg" alt="fibonacciClosed" width="30%">
</div>
</div>
<div class="paragraph">
<p>Although this equation is a bit ugly, you can plug numbers into it to discover
the value of <em>F</em><sub><em>n</em></sub> quickly, provided that you have an efficient way to raise
values to the <em>n</em><sup>th</sup> power. Use the recursive algorithm for fast exponentiation
from <a href="chap19.html#fastExponentiationExercise">Exercise 19.7</a> to make an implementation that finds the
<em>n</em><sup>th</sup> Fibonacci number <strong>very</strong> quickly.</p>
</div>
<div class="paragraph">
<p>Note that this approach uses real numbers (including
the square root of 5) that need to be represented as <code>double</code> values.
There are exact methods that use fast exponentiation of integer matrices
to do this computation without doing any floating-point arithmetic, but
we won’t go into those details here.</p>
</div>
</li>
<li>
<p><a id="recursivePrintExercise"></a> <a href="chap19.html#recursiveLinkedListSizeExample">Example 19.9</a> shows a way to
calculate the size of a linked list recursively. Add a recursive method called
<code>print()</code> to the <code>RecursiveListSize</code> class that prints out the values in the
linked list recursively, one value per line.</p>
</li>
<li>
<p><a id="reversePrintExercise"></a> Expand the previous exercise to add another method
called <code>reversePrint()</code> that prints out the values in the linked list in the
<strong>opposite</strong> order that they appear. It should take only a slight modification of
the <code>print()</code> method you’ve already written.</p>
</li>
<li>
<p><a id="recursiveFindExercise"></a> Create a recursive <code>find()</code> method (and a
non-recursive proxy method to call it) for the <code>Tree</code> class given in
<a href="chap19.html#TreeProgram">Program 19.4</a>. Its operation is similar to the <code>add()</code>
method. If the subtree it’s examining is empty (<code>null</code>), it should
return <code>false</code>. If the value it’s looking for is at the root of the
current subtree, it should return <code>true</code>. These are the two base cases.
If the value it’s looking for comes earlier in the alphabet than the
value at the root of the current subtree, it should look in the left
subtree. If the value it’s looking for comes later in the alphabet than
the value at the root of the current subtree, it should look in the
right subtree. Those are the two recursive cases.</p>
</li>
<li>
<p><a id="recursiveHeightExercise"></a> The height of a binary tree is defined as
the longest path from the root to any leaf node. Thus, the height of a
tree with only a root node in it is 0. By convention, the height of an
empty tree is -1.</p>
<div class="paragraph">
<p>Create a recursive <code>getHeight()</code> method (and a non-recursive proxy
method to call it) for the <code>Tree</code> class given in
<a href="chap19.html#TreeProgram">Program 19.4</a>. The base case is an empty tree (a <code>null</code>
pointer), which has a height of -1. For the recursive case of a
non-empty tree, its height is one more than the height of the larger of
its two subtrees.</p>
</div>
</li>
<li>
<p><a id="treeInterfaceExercise"></a> Create a Java interface that describes a tree ADT.
Modify the programs in <a href="chap19.html#binarySearchTreeExample">Example 19.10</a> to implement this interface.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Experiments</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic" start="14">
<li>
<p>Write an iterative version of the factorial function and compare its
speed to the recursive version given in the text. Use the
<code>System.nanoTime()</code> method before and after <code>for</code> loops that call the
factorial methods 1,000,000 times each for random values.</p>
</li>
<li>
<p><a id="timeSortingExercise"></a> Write a program that generates four arrays
of random <code>int</code> values with lengths 1,000, 10,000, 100,000, and
1,000,000. Make two additional copies of each array. Then, sort each of
three copies of the array with the selection sort algorithm given in
<a href="chap6.html#selectionSortExample">Example 6.2</a>, the bubble sort algorithm given in
<a href="chap10.html#_problem_sort_it_out">Section 10.1</a>, and the merge sort algorithm given in
<a href="chap19.html#mergeSortExample">Example 19.8</a>, respectively. Use the <code>System.nanoTime()</code> method to time
each of the sorts. Note that both selection sort and bubble sort might take
quite a while to sort an array of 1,000,000 elements.</p>
<div class="paragraph">
<p>Run the program several times and find average values for each algorithm
on each array size. Plot those times on a graph. The times needed to run
selection sort and bubble sort should increase quadratically, but the
time to run merge sort should increase linearithmically. In other words,
an array length of <em>n</em> should take time proportional to
<em>n</em><sup>2</sup> (multiplied by some constant) for selection sort and
bubble sort, but it should take time proportional to
<em>n</em> log<sub>2</sub> <em>n</em> (multiplied by some constant) for merge sort. For
large arrays, the difference in time is significant.</p>
</div>
</li>
<li>
<p>Investigate the performance of using recursion to compute Fibonacci
numbers. Implement the naive recursive solution, the memoization method,
and an iterative solution similar to the memoization method. Use the
<code>System.nanoTime()</code> method to time the computations for large values of <em>n</em>.</p>
<div class="paragraph">
<p><strong>Warning:</strong> It might take a very long time to compute the <em>n</em><sup>th</sup> Fibonacci number
with the naive recursive solution.</p>
</div>
</li>
<li>
<p><a href="chap6.html#wordBinarySearchExercise">Exercise 6.9</a> from <a href="chap6.html">Chapter 6</a> explains how binary search can be used to search for a value in a sorted
array of values. The idea is to play a “high-low” game, first looking
at the middle value. If the value is the one you’re looking for, you’re
done. If it’s too high, look in the lower half of the array. If it’s
too low, look in the upper half of the array. Implement binary search
both iteratively and recursively. Populate an array with 100,000 <code>int</code>
values between 1 and 10,000,000 and sort it. Then, search for 1,000,000
random values generated between 1 and 10,000,000 using iterative binary
search and then recursive binary search. Use the <code>System.nanoTime()</code> method to
time each process. Was the iterative or recursive approach faster? By how much?</p>
</li>
</ol>
</div>
</div>
</div>
</div></div>

<nav>
  <a rel="prev" href="chap18.html" class="nav nav-prev" title="Previous page" aria-label="Previous page" aria-keyshortcuts="Left">
        <i class="fa fa-angle-left"></i>
     </a>
  <a rel="next" href="chap20.html" class="nav nav-next" title="Next page" aria-label="Next page" aria-keyshortcuts="Right">
        <i class="fa fa-angle-right"></i>
     </a>
  <div style="clear: both"></div>
</nav>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-22 11:27:29 -0400
</div>
</div>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VEDGKRPMMK"></script>
          <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-VEDGKRPMMK');
          </script>

</body>
  <script>
  function isInViewport(ele) {
    const rect = ele.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function yPosition (ele) {
    const rect = ele.getBoundingClientRect();
    return (rect.top - 20); // 20px above
  }
  let curr = document.getElementsByClassName('current');
  if (!isInViewport(curr[curr.length - 1])) {
    document.getElementById('toc').scrollTo({
      top: yPosition(curr[0]),
      left: 0,
      behavior: 'smooth'
    });
  }

  /* For page navigation */
  function gotoPage(selector) {
    const button = document.querySelector(selector);
    if (button)
      window.location.href = button.href;
  }
  document.addEventListener('keydown', e => {
    if (e.shiftKey)
      return;
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        gotoPage('.nav-next');
        break;
      case 'ArrowLeft':
        e.preventDefault();
        gotoPage('.nav-prev');
        break;
    }
  });
  </script>
  </html>