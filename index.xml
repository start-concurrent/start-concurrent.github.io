<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="2"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Start Concurrent</title>
<subtitle>A Gentle Introduction to Concurrent Programming</subtitle>
<date>2018-06-05</date>
<authorgroup>
<author>
<personname>
<firstname>Barry</firstname>
<surname>Wittman</surname>
</personname>
<email>bwittman@gmail.com</email>
</author>
<author>
<personname>
<firstname>Aditya</firstname>
<surname>Mathur</surname>
</personname>
<email>apm@purdue.edu</email>
</author>
<author>
<personname>
<firstname>Tim</firstname>
<surname>Korb</surname>
</personname>
<email>jtk@purdue.edu</email>
</author>
</authorgroup>
</info>
<chapter xml:id="_computer_basics">
<title>Computer Basics</title>
<blockquote>
<attribution>
Pablo Picasso
</attribution>
<simpara>Computers are useless. They can only give you answers.</simpara>
</blockquote>
<section xml:id="_problem_buying_a_computer">
<title>Problem: Buying a Computer</title>
<simpara>We begin almost every chapter of this book with a motivating problem.
Why? Sometimes it helps to see how tools can be applied in order to see
why they&#8217;re useful. As we move through each chapter, we cover background
concepts needed to solve the problem in the <emphasis role="strong">Concepts</emphasis> section, the
specific technical details (usually in the form of Java syntax) required
in the <emphasis role="strong">Syntax and Semantics</emphasis> section, and eventually the solution to
the problem in the <emphasis role="strong">Solution</emphasis> sections. If you&#8217;re not interested in the
problem, that&#8217;s fine! Feel free to skip ahead to the <xref linkend="_concepts_hardware_and_software"/> section
or directly to the <xref linkend="_syntax_data_representation"/> section, especially if you
already have some programming experience. Then, if you&#8217;d like to see
another detailed example, the <xref linkend="_solution_buying_a_computer"/> is
available as a reference.</simpara>
<simpara>We&#8217;ll start with a problem that is not about programming and may be
familiar to you. Imagine you are just about to start college and need a
computer. Should you buy a Mac or PC? What kind of computer is going to
run programs faster? Do some kinds of computers crash more than others?
Which features are worth paying more for? Why are there so many
buzzwords and so much impenetrable jargon associated with buying a
computer?</simpara>
<simpara>When many people hear &#8220;computer science,&#8221; these are often the first
questions that come to mind. Most of this book is about programming
computers in a language called Java and not about the computers
themselves. We try to present all the material so that almost any kind
of computer can be used when programming the problems and examples.
Nevertheless, both the hardware that makes up your computer and the
other software running on it affect the way the programs you write work.</simpara>
</section>
<section xml:id="_concepts_hardware_and_software">
<title>Concepts: Hardware and Software</title>
<simpara>Computers are ubiquitous. We see them nearly everywhere. They are found
in most homes, shops, cars, aircraft, phones, and inside many other
devices. Sometimes they are obvious, like a laptop sitting on a desk.
But, most computers are hidden inside other devices such as a watch or a
flat panel television. Computers can be complex or relatively simple
machines. Despite their diversity, we can think of all computers in
terms of their <emphasis>hardware</emphasis> and the <emphasis>software</emphasis> that runs on it.</simpara>
<section xml:id="_hardware">
<title>Hardware</title>
<simpara>Hardware consists of the physical components that make up a computer but
not the programs or data stored on it. Hardware components can be seen
and touched, if you are willing to open the computer case. One way to
organize hardware is to break it down into three categories: the
processor, the memory, and input and output (I/O) devices.</simpara>
<simpara>This view of a computer is a simplified version of what is called the
von Neumann architecture or a stored-program computer. It is a good (but
imperfect) model of most modern computers. In this model, a program (a
list of instructions) is stored in memory. The processor loads the
program and performs the instructions, some of which require the
processor to do a lot of number-crunching. Sometimes the processor reads
data out of memory or writes new data into it. Periodically, the
processor may send output to one of the output devices or receive input
from one of the input devices.</simpara>
<simpara>In other words, the processor thinks, the memory stores, and the I/O
devices interact with the outside world. The processor sits between the
memory and the I/O devices. Let&#8217;s examine these categories further.</simpara>
<figure>
<title>Hardware components in a typical desktop computer categorized into CPU, memory, and I/O devices.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/01-computer-basics/images/vonNeumann.svg" width="100%"/>
</imageobject>
<textobject><phrase>vonNeumann</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_cpu">
<title>CPU</title>
<simpara>The processor, or central processing unit (CPU), is the &#8220;brain&#8221; of a
computer. It fetches instructions, decodes them, and executes them. It
may send data to or from memory or I/O devices. The CPU on virtually all
modern computers is a <emphasis>microprocessor</emphasis>, meaning that all the computation
is done by a single integrated circuit fabricated out of silicon. What
are the important features of CPUs? How do we measure their speed and
power?</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Frequency</simpara>
</entry>
<entry>
<simpara>The speed of a CPU (and indeed a computer as a whole) is often quoted
in gigahertz (GHz). Hertz (Hz) is a measurement of frequency. If
something happens once per second, it has a frequency of exactly 1 Hz.
Perhaps the second hand on your watch moves with a frequency of 1 Hz.
In North America, the current in electrical outlets alternates with a
frequency of approximately 60 Hz. Sound can also be measured by
frequency. The lowest-pitched sound the human ear can hear is around
20 Hz. The highest-pitched sound is around 20,000 Hz. Such a sound
pulses against your eardrum 20,000 times per second. That sounds like
a lot, but many modern computers operate at a frequency of 1 to 4
gigahertz. The prefix &#8220;giga&#8221; means &#8220;billion.&#8221; So, we are talking
about computers doing <emphasis role="strong">something</emphasis> more than a billion (1,000,000,000)
times per second.</simpara>
<simpara>But <emphasis role="strong">what</emphasis> are they doing? This frequency is the <emphasis>clock rate</emphasis>, which
marks how often a regular electrical signal passes through the CPU. On
each tick, the CPU does some computation. How much? It depends. On
some systems, simple instructions (like adding two numbers) can be
computed in a single clock cycle. Other instructions can take ten or
more clock cycles. Different processor designs can take different
numbers of cycles to execute the same instructions. Instructions are
also <emphasis>pipelined</emphasis>, meaning that one instruction is being executed while
another one is being fetched or decoded. Different processors can have
different ways of optimizing this process. Because of these
differences, the frequency of a processor as measured in gigahertz is
not a good way to compare the effective speed of one processor to
another, unless the two processors are very closely related. Even
though it doesn&#8217;t really make sense, clock rate is commonly advertised
as the speed of a computer.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Word size</simpara>
</entry>
<entry>
<simpara>Perhaps you have heard of a 32-bit or 64-bit computer. As we discuss
in the subsection about memory, a bit is a 0 or a 1, the smallest
amount of information you can record. Most new laptop and desktop
computers are 64-bit machines, meaning that they operate on 64 bits at
a time and can use 64-bit values as memory addresses. The instructions
that it executes work on 64-bit quantities, i.e., numbers made up of
64 0s and 1s. The size of data that a computer can operate on with a
single instruction is known as its <emphasis>word size</emphasis>.</simpara>
<simpara>In day to day operations, word size is not important to most users.
Certain programs that interact directly with the hardware, such as the
operating system, may be affected by the word size. For example, most
modern 32-bit operating systems are designed to run on a 64-bit
processor, but most 64-bit operating systems do not run on a 32-bit
processor.</simpara>
<simpara>Programs often run faster on machines with a larger word size, but
they typically take up more memory. A 32-bit processor (or operating
system) cannot use more than 4 gigabytes (defined below) of memory.
Thus, a 64-bit computer is needed to take advantage of the larger
amounts of memory that are now available.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Cache</simpara>
</entry>
<entry>
<simpara>Human brains both perform computations and store information. A
computer CPU performs computations, but, for the most part, does not
store information. The CPU cache is the exception. Most modern CPUs
have a small, very fast section of memory built right onto the chip.
By guessing about what information the CPU is going to use next, it
can preload it into the cache and avoid waiting around for the slower
regular memory.</simpara>
<simpara>Over time, caches have become more complicated and often have multiple
levels. The first level is very small but incredibly fast. The second
level is larger and slower. And so on. It would be preferable to have
a large, first-level cache, but fast memory is expensive memory. Each
level is larger, slower, and cheaper than the last.</simpara>
<simpara>Cache size is not a heavily advertised CPU feature, but it makes a
huge difference in performance. A processor with a larger cache can
often outperform a processor that is faster in terms of clock rate.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Cores</simpara>
</entry>
<entry>
<simpara>Most laptops and desktops available today have <emphasis>multicore</emphasis> processors.
These processors contain two, four, six, or even more cores. Each core
is a processor capable of independently executing instructions, and
they can all communicate with the same memory.</simpara>
<simpara>In theory, having six cores could allow your computer to run six times
as fast. In practice, this speedup is rarely the case. Learning how to
get more performance out of multicore systems is one of the major
themes of this book. Chapters <xref linkend="chapter:Concurrent_Programming"/> and <xref linkend="chapter:Synchronization"/> as well as
sections marked <emphasis role="strong">Concurrency</emphasis> in other chapters are specifically
tailored for students interested in programming these multicore
systems to work effectively. If you aren&#8217;t interested in concurrent
programming, you can skip these chapters and sections and use this
book as a traditional introductory Java programming textbook. On the
other hand, if you are interested in the increasingly important area
of concurrent programming, <xref linkend="_concurrency_multicore_processors"/>
near the end of this chapter is the first <emphasis role="strong">Concurrency</emphasis> section of the
book and discusses multicore processors more deeply.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_memory">
<title>Memory</title>
<simpara>Memory is where all the programs and data on a computer are stored. The
memory in a computer is usually not a single piece of hardware. Instead,
the storage requirements of a computer are met by many different
technologies.</simpara>
<simpara>At the top of the pyramid of memory is primary storage, memory that the
CPU can access and control directly. On desktop and laptop computers,
primary storage usually takes the form of random access memory (RAM). It
is called random access memory because it takes the same amount of time
to access any part of RAM. Traditional RAM is volatile, meaning that its
contents are lost when it&#8217;s unpowered. All programs and data must be
loaded into RAM to be used by the CPU.</simpara>
<simpara>After primary storage comes secondary storage, which is dominated by
hard drives that store data on spinning magnetic platters. Optical
drives (such as CD, DVD, and Blu-ray), flash drives, and the now
virtually obsolete floppy drives fall into the category of secondary
storage as well. Secondary storage is slower than primary storage, but
it is non-volatile. Some forms of secondary storage such as CD-ROM and
DVD-ROM are read only, but most are capable of reading and writing.</simpara>
<simpara>Before we can compare these kinds of storage effectively, we need to
have a system for measuring how much they store. In modern digital
computers, all data is stored as a sequence of 0s and 1s. In memory, the
space that can hold either a single 0 or a single 1 is called a <emphasis>bit</emphasis>,
which is short for &#8220;binary digit.&#8221;</simpara>
<figure>
<title>Computer memory contains bits organized as bytes and words. One bit contains either a 0 or a 1.  A byte contains eight bits. A word may contain two or more bytes. Shown here is a word containing four bytes, or 32 bits. Computer scientists often number items starting at zero, as we discuss in <xref linkend="chapter:Arrays"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/01-computer-basics/images/bitsBytesFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>bitsBytesFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>A bit is a tiny amount of information. For organizational purposes, we
call a sequence of eight bits a <emphasis>byte</emphasis>. The word size of a CPU is two or
more bytes, but memory capacity is usually listed in bytes not words.
Both primary and secondary storage capacities have become so large that
it is inconvenient to describe them in bytes. Computer scientists have
borrowed prefixes from physical scientists to create suitable units.</simpara>
<simpara>Common units for measuring memory are bytes, kilobytes, megabytes,
gigabytes, and terabytes. Each unit is 1,024 times the size of the
previous unit. Notice that <inlineequation><alt><![CDATA[2^{10}]]></alt><mathphrase><![CDATA[2^{10}]]></mathphrase></inlineequation> (1,024) is almost the
same as <inlineequation><alt><![CDATA[10^3]]></alt><mathphrase><![CDATA[10^3]]></mathphrase></inlineequation> (1,000). Sometimes it is not clear which
value is meant. Disk drive manufacturers always use powers of 10 when
they quote the size of their disks. Thus, a 1 TB hard disk can hold
<inlineequation><alt><![CDATA[10^{12}]]></alt><mathphrase><![CDATA[10^{12}]]></mathphrase></inlineequation> (1,000,000,000,000) bytes, not
<inlineequation><alt><![CDATA[2^{40}]]></alt><mathphrase><![CDATA[2^{40}]]></mathphrase></inlineequation> (1,099,511,627,776) bytes. Standards organizations
have advocated that the terms kibibyte (KiB), mebibyte (MiB), gibibyte
(GiB), and tebibyte (TiB) be used to refer to the units based on powers
of 2, while the traditional names be used to refer only to the units
based on powers of 10, but the new terms have not yet become popular.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Unit</entry>
<entry align="left" valign="top">Size</entry>
<entry align="left" valign="top">Bytes</entry>
<entry align="left" valign="top">Practical Measure</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>byte</simpara></entry>
<entry align="left" valign="top"><simpara>8 bits</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>0</superscript> = 10<superscript>0</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>a single character</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>kilobyte (KB)</simpara></entry>
<entry align="left" valign="top"><simpara>1,024 bytes</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>10</superscript> &#x2248; 10<superscript>3</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>a
paragraph of text</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>megabyte (MB)</simpara></entry>
<entry align="left" valign="top"><simpara>1,024 kilobytes</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>20</superscript> &#x2248; 10<superscript>6</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>a
minute of MP3 music</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>gigabyte (GB)</simpara></entry>
<entry align="left" valign="top"><simpara>1,024 megabytes</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>30</superscript> &#x2248; 10<superscript>9</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>half
an hour of DVD video</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>terabyte (TB)</simpara></entry>
<entry align="left" valign="top"><simpara>1,024 gigabytes</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>40</superscript> &#x2248; 10<superscript>12</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>80% of a human&#8217;s memory capacity,<?asciidoc-br?>
estimated by Raymond Kurzweil</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>We called memory a pyramid earlier in this section. At the top there is
a small but very fast amount of memory. As we work down the pyramid, the
storage capacity grows but the speed slows down. Of course, the pyramid
for every computer is different. Below is a table that shows many kinds
of memory moving from the fastest and smallest to the slowest and
largest. Effective speed is hard to measure (and is changing as
technology progresses), but note that each layer in the pyramid tends to
be 10-100 times slower than the previous layer.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">Memory</entry>
<entry align="left" valign="top">Typical Capacity</entry>
<entry align="left" valign="top">Use</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Cache</simpara></entry>
<entry align="left" valign="top"><simpara>kilobytes or megabytes</simpara></entry>
<entry align="left" valign="top"><simpara>Cache is fast, temporary storage for the
CPU itself. Modern CPUs have two or three levels of cache that get
progressively bigger and slower.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RAM</simpara></entry>
<entry align="left" valign="top"><simpara>gigabytes</simpara></entry>
<entry align="left" valign="top"><simpara>The bulk of primary memory is RAM. RAM comes on sticks
that can be swapped out to upgrade a computer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Flash drives</simpara></entry>
<entry align="left" valign="top"><simpara>gigabytes or tens of gigabytes</simpara></entry>
<entry align="left" valign="top"><simpara>Flash drives mark the
beginning of secondary storage. Flash drives come as USB keychain drives
but also as drives that sit inside the computer (sometimes called <emphasis>solid
state drives</emphasis> or SSDs). As the price of flash drives drops, they are
expected to replace hard drives entirely. (Some expensive SSDs already
have capacities in the terabyte range.)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hard drives</simpara></entry>
<entry align="left" valign="top"><simpara>hundreds of gigabytes or terabytes</simpara></entry>
<entry align="left" valign="top"><simpara>Hard drives are still
the most common secondary storage for desktops, laptops, and servers.
They are limited in speed partly because of their moving parts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tape backup</simpara></entry>
<entry align="left" valign="top"><simpara>terabytes and beyond</simpara></entry>
<entry align="left" valign="top"><simpara>Some large companies still store
huge quantities of information on magnetic tape. Tape performs well for
long sequential accesses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Network storage</simpara></entry>
<entry align="left" valign="top"><simpara>terabytes and beyond</simpara></entry>
<entry align="left" valign="top"><simpara>Storage that is accessed through
a network is limited by the speed of the network. Many companies use
networked computers for backup and redundancy as well as distributed
computation. Microsoft, Amazon, Google, and others rent their network
storage systems at rates based on storage size and total data
throughput. These services are part of what is called <emphasis>cloud computing</emphasis>.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_i_o_devices">
<title>I/O devices</title>
<simpara>I/O devices have much more variety than CPUs or memory. Some I/O
devices, such as USB ports, are permanently connected by a printed
circuit board to the CPU. Other devices called <emphasis>peripherals</emphasis> are
connected to a computer as needed. Their types and features are many and
varied, and in this book, we do not go deeply into how to interact with
I/O devices.</simpara>
<simpara>Common input devices include mice, keyboards, touch pads, microphones,
game pads, and drawing tablets. Common output devices include monitors,
speakers, and printers. Some devices perform both input and output, such
as a network card.</simpara>
<simpara>Remember that our view of computer hardware as CPU, memory, and I/O
devices is only a model. A PCI Express socket can be considered an I/O
device, but the graphics card that fits into the socket can be
considered one as well. And the monitor that connects to the graphics
card is yet another one. Although the graphics card is an I/O device, it
has its own processor and memory, too. It&#8217;s pointless to get bogged down
in too many details. One of the most important skills in computer
science is finding the right level of detail and abstraction to view a
given problem.</simpara>
</section>
</section>
<section xml:id="_software">
<title>Software</title>
<simpara>Without hardware computers would not exist, but software is equally
important. Software is the programs and data that are executed and
stored by the computer. The focus of this book is learning to write
software.</simpara>
<simpara>Software includes the infinite variety of computer programs. With the
right tools (many of which are free), anyone can write a program that
runs on a Windows, Mac, or Linux machine. Although it would be nearly
impossible to list all the different kinds of software, a few categories
are worth mentioning.</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Operating Systems</simpara>
</entry>
<entry>
<simpara>The <emphasis>operating system</emphasis> (OS) is the software that manages the
interaction between the hardware and the rest of the software.
Programs called <emphasis>drivers</emphasis> are added to the OS for each hardware
device. For example, when an application wants to print a document, it
communicates with the printer via a printer driver that is customized
for the specific printer, the OS, and the computer hardware. The OS
also schedules, runs, and manages memory for all other programs. The
three most common OSes for desktop machines are Microsoft Windows, Mac
OS, and Linux. At the present time, all three run on similar hardware
based on the Intel x86 and x64 architectures.</simpara>
<simpara>Microsoft does not sell desktop computers, but many desktop and laptop
computers come bundled with Windows. For individuals and businesses
who assemble their own computer hardware, it is also possible to
purchase Windows separately. In contrast, most computers running Mac
OS are sold by Apple, and Mac OS is usually bundled with the computer.
Linux is <emphasis>open-source software</emphasis>, meaning that all the source code used
to create it is freely available. In spite of Linux being free, many
consumers prefer Windows or Mac OS because of ease of use,
compatibility with specific software, and technical support. Many
consumers are also unaware that hardware can be purchased separately
from an OS or that Linux is a free alternative to the other two.</simpara>
<simpara>Other computers have OSes as well. The Motorola Xoom and many kinds of
mobile telephones use the Google Android OS. The Apple iPad and iPhone
use the competing Apple iOS. Phones, microwave ovens, automobiles, and
countless other devices have computers in them that use some kind of
embedded OS.</simpara>
<simpara>Consider two applications running on a mobile phone with a single core
CPU. One application is a web browser and the other is a music player.
The user may start listening to music and then start the browser. In
order to function, both applications need to access the CPU at the
same time. Since the CPU only has a single core, it can execute only
one instruction at a time.</simpara>
<simpara>Rather than forcing the user to finish listening to the song before
using the web browser, the OS switches the CPU between the two
applications very quickly. This switching allows the user to continue
browsing while the music plays in the background. The user perceives
an illusion that both applications are using the CPU at the same time.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Compilers</simpara>
</entry>
<entry>
<simpara>A <emphasis>compiler</emphasis> is a kind of program that is particularly important to
programmers. Computer programs are written in special languages, such
as Java, that are human readable. A compiler takes this human-readable
program and turns it into instructions (often machine code) that a
computer can understand.</simpara>
<simpara>To compile the programs in this book, you use the Java compiler
<literal>javac</literal>, either directly by typing its name as a command or indirectly
as Eclipse, DrJava, or some other tool that runs the compiler for you.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Business Applications</simpara>
</entry>
<entry>
<simpara>Many different kinds of programs fall under the umbrella of business
or productivity software. Perhaps the most famous is the Microsoft
Office suite of tools, which includes the word-processing software
Word, the spreadsheet software Excel, and the presentation software
PowerPoint.</simpara>
<simpara>Programs in this category are often the first to come to mind when
people think of software, and this category has had tremendous
historical impact. The popularity of Microsoft Office led to the
widespread adoption of Microsoft Windows in the 1990s. A single
application that is so desirable that a consumer is willing to buy the
hardware and the OS just to be able to run it is sometimes called a
<emphasis>killer app</emphasis>.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Video Games</simpara>
</entry>
<entry>
<simpara>Video games are software like other programs, but they deserve special
attention because they represent an enormous, multi-billion dollar
industry. They are usually challenging to program, and the video game
development industry is highly competitive.</simpara>
<simpara>The intense 3D graphics required by modern video games have pushed
hardware manufacturers such as Nvidia, AMD, and Intel to develop
high-performance graphics cards for desktop and laptop computers. At
the same time, companies like Nintendo, Sony, and Microsoft have
developed computers such as the Wii, PS3, and Xbox 360 that specialize
in video games but are not designed for general computing tasks.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Web Browsers</simpara>
</entry>
<entry>
<simpara>Web browsers are programs that can connect to the Internet and
download and display web pages and other files. Early web browsers
could only display relatively simple pages containing text and images.
Because of the growing importance of communication over the Internet,
web browsers have evolved to include plug-ins that can play sounds,
display video, and allow for sophisticated real-time communication.</simpara>
<simpara>Popular web browsers include Microsoft Internet Explorer, Mozilla
Firefox, Apple Safari, and Google Chrome. Each has advantages and
disadvantages in terms of compatibility, standards compliance,
security, speed, and customer support. The Opera web browser is not
well known on desktop computers, but it is commonly used on mobile
telephones.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_examples">
<title>Examples</title>
<simpara>Here are a few examples of modern computers with a brief description of
their hardware and some of the software that runs on them.</simpara>
<simpara>The InspironÂ 560 Desktop is a modestly priced computer manufactured and
sold by Dell, Inc. It can be configured with different hardware options,
but one choice uses a 64-bit Intel Pentium E6700 CPU that runs at a
clock rate of 3.2 GHz with a 2 MB cache and two cores. In terms of
memory, you can choose between 4 and 6 GB worth of RAM. You can also
choose to have a 500 GB or 1 TB hard drive. The computer comes with a
DVD<inlineequation><alt><![CDATA[\pm]]></alt><mathphrase><![CDATA[\pm]]></mathphrase></inlineequation>RW optical drive.</simpara>
<simpara>For I/O, the computer has various ports for connecting USB devices,
monitors, speakers, microphones, and network cables. By default, it
includes a keyboard, a mouse, a network card, a graphics card, and an
audio card. For an additional charge, a monitor, speakers, and other
peripherals can be purchased.</simpara>
<simpara>A 64-bit edition of Microsoft Windows 7 is included. (Software often
uses version numbers to mark changes in features and support, but
Microsoft has adopted some very confusing numbering schemes. Windows 7
is the successor to Windows Vista, which is the successor to Windows XP.
Windows 7 is <emphasis role="strong">not</emphasis> the seventh version of the Windows OS, but Windows 8
is the successor to Windows 7. ) Depending on the price, different
configurations of Microsoft Office 2010 with more or fewer features can
be included.
<xref linkend="computerPictures"/> (a) shows a picture of the Dell Inspiron 560.</simpara>
<figure xml:id="computerPictures">
<title>(a) Dell Inspiron 560. (b) Apple iPhone 4. (c) Motorola Xoom.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/01-computer-basics/images/computerPictures.svg" width="100%"/>
</imageobject>
<textobject><phrase>computerPictures</phrase></textobject>
</mediaobject>
</figure>
<simpara>All mobile phones contain a computer, but a phone that has features like
a media player, calendar, GPS, or camera is often called a <emphasis>smartphone</emphasis>.
Such phones often have sophisticated software that is comparable to a
desktop computer. One example is the Apple iPhone 4.</simpara>
<simpara>This phone uses a CPU called the A4, which has a single core, a cache of
512 KB, and a maximum clock rate of 1 GHz, though the clock rate used in
the iPhone 4 is not publicly known. The phone has 512 MB of RAM and uses
either a 16 GB or 32 GB flash drive for secondary storage.</simpara>
<simpara>In terms of I/O, the iPhone 4 has a built-in liquid crystal display
(LCD) that is also a touch screen for input. It has two cameras, an LED
flash, a microphone, a speaker, a headphone jack, a docking connector,
buttons, gyroscopes, accelerometers, and the capability to communicate
on several kinds of wireless networks.</simpara>
<simpara>In addition to the Apple iOS 4 operating system, the iPhone runs a
variety of applications just like a desktop computer. These applications
are available from the iTunes App Store.
<xref linkend="computerPictures"/> (b) shows a picture of the iPhone 4.</simpara>
<simpara>The Motorola Xoom is a <emphasis>tablet computer</emphasis>. A tablet computer has a touch
screen and is generally lighter than a laptop. Some tablets have
keyboards, but many newer models use the touch screen instead.</simpara>
<simpara>The Xoom uses the Nvidia Tegra 2 CPU, which runs at 1 GHz and has 1 MB
of cache and two cores. It has 1 GB of RAM and a 32 GB flash drive for
storage. It has a built-in LCD that is also a touch screen for input,
with a connector for a monitor. It has two cameras, an LED flash, a
microphone, a speaker, a headset jack, buttons, gyroscopes,
accelerometers, a barometer, and the capability to communicate on
several kinds of wireless networks.</simpara>
<simpara>It uses the Google Android 3 operating system, which can run
applications available from the Android Market.
<xref linkend="computerPictures"/> (c) shows a picture of the Motorola Xoom.</simpara>
</section>
</section>
<section xml:id="_syntax_data_representation">
<title>Syntax: Data Representation</title>
<simpara>After each <emphasis role="strong">Concepts</emphasis> section, this book usually has a <emphasis role="strong">Syntax</emphasis> section.
Syntax is the rules for a language. These <emphasis role="strong">Syntax</emphasis> sections generally
focus on concrete Java language features and technical specifics that
are related to the concepts described in the chapter.</simpara>
<simpara>In this chapter, we are still trying to describe computers at a general
level. Consequently, the technical details we cover in this section will
not be Java syntax. Although everything we say applies to Java, it also
applies to many other programming languages.</simpara>
<section xml:id="_compilers_and_interpreters">
<title>Compilers and interpreters</title>
<simpara>This book is primarily about solving problems with computer programs.
From now on, we only mention hardware when it has an impact on
programming. The first step to writing a computer program is deciding
what language to use.</simpara>
<simpara>Most humans communicate via natural languages such as Chinese, English,
French, Russian, or Tamil. However, computers are poor at understanding
natural languages. As a compromise, programmers write programs
(instructions for a computer to follow) in a language more similar to a
natural language than it is to the language understood by the CPU. These
languages are called <emphasis>high-level languages</emphasis>, because they are closer to
natural language (the highest level) than they are to <emphasis>machine language</emphasis>
(the lowest level). We may also refer to machine language as <emphasis>machine
code</emphasis> or <emphasis>native code</emphasis>.</simpara>
<simpara>Thousands of programming languages have been created over the years, but
some of the most popular high level-languages of all time include
Fortran, Cobol, Visual Basic, C, C++, Python, Java, and C#.</simpara>
<simpara>As we mentioned in the previous section, a compiler is a program that
translates one language into another. In many cases, a compiler
translates a high-level language into a low level language that the CPU
can understand and execute. Because all the work is done ahead of time,
this kind of compilation is known as static or ahead-of-time
compilation. In other cases, the output of the compiler is an
intermediate language that is easier for the computer to understand than
the high-level language but still takes some translation before the
computer can follow the instructions.</simpara>
<simpara>An <emphasis>interpreter</emphasis> is a program that is similar to a compiler. However, an
interpreter takes code in one language as input and, on the fly, runs
each instruction on the CPU as it translates it. Interpreters generally
execute the code more slowly than if it had been translated to machine
language before execution.</simpara>
<simpara>Note that both compilers and interpreters are normal programs. They are
usually written in high-level languages and compiled into machine
language before execution. This raises a philosophical question: If you
need a compiler to create a program, where did the first compiler come
from?</simpara>
<figure>
<title>(a) Static compilation. (b) Interpreted execution. (c) Compilation into bytecode with later just-in-time compilation.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/01-computer-basics/images/compilerFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>compilerFigure</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_example_java_compilation">
<title>Example: Java compilation</title>
<simpara>Java is the popular high-level programming language we will focus on in
this book. The standard way to run a Java program has an extra step that
most compiled languages do not. Most compilers for Java, though not all,
translate a program written in Java to an intermediate language known as
<emphasis>bytecode</emphasis>. This intermediate version of the high-level program is used
as input for another program called the Java Virtual Machine (JVM). Most
popular JVMs translate the bytecode into machine code that is executed
directly by the CPU. This conversion from bytecode into machine code is
done with a just-in-time (JIT) compiler. It&#8217;s called &#8220;just-in-time&#8221;
because sections of bytecode are not compiled until the moment they are
needed. Because the output is going to be used for this specific
execution of the program, the JIT can do optimizations to make the final
machine code run particularly well in the current environment.</simpara>
<simpara>Why does Java use the intermediate step of bytecode? One of Java&#8217;s
design goals is to be platform independent, meaning that it can be
executed on any kind of computer. This is a difficult goal because every
combination of OS and CPU will need different low level instructions.
Java attacks the problem by keeping its bytecode platform independent.
You can compile a program into bytecode on a Windows machine and then
run the bytecode on a JVM in a Mac OS X environment. Part of the work is
platform independent, and part is not. Each JVM must be tailored to the
combination of OS and hardware that it runs on.</simpara>
<simpara>The Java language and original JVM were developed by Sun Microsystems,
Inc., which was bought by Oracle Corporation in 2009. Oracle continues
to produce HotSpot, the standard JVM, but many other JVMs exist,
including Apache Harmony and Dalvik, the Google Android JVM.</simpara>
</section>
<section xml:id="_numbers">
<title>Numbers</title>
<simpara>All data inside of a computer is represented with numbers. Although
we humans use numbers in our daily lives, the representation and
manipulation of numbers by computers work differently. In this
subsection we introduce the notions of number systems, bases, conversion
from one base to another, and arithmetic in number systems.</simpara>
<section xml:id="_a_few_number_systems">
<title>A few number systems</title>
<simpara>A number system is a way to represent numbers. It is easy to confuse the
<emphasis>numeral</emphasis> that represents the <emphasis>number</emphasis> with the number itself. You might
think of the number ten as &#8220;10&#8221;, a numeral made of two symbols, but
the number itself is the concept of <emphasis role="strong">ten-ness</emphasis>. You could express that
quantity by holding up all your fingers, with the symbol &#8220;X&#8221;, or by
knocking ten times.</simpara>
<simpara>Representing ten with &#8220;10&#8221; is an example of a <emphasis>positional number
system</emphasis>, namely base 10. In a positional number system, the position of
the digits determines the magnitude they represent. For example, the
numeral 3,432 contains the digit 3 twice. The first time, it represents
three groups of one thousand. The second time, it represents three
groups of ten. (The Roman numeral system is an example of a number
system that is <emphasis role="strong">not</emphasis> positional.)</simpara>
<simpara>The numeral 3,432 and possibly every other normally written number you
have seen is expressed in the base 10 or <emphasis>decimal</emphasis> system. It is called
base 10 because, as you move from the rightmost digit leftward, the
value of each position goes up by a factor of 10. Also, in base 10, ten
is the smallest positive integer that requires two digits for
representation. Each smaller number has its own digit: 0, 1, 2, 3, 4, 5,
6, 7, 8, and 9. Representing ten requires two existing digits to be
combined. Every base has the property that the number it is named after
takes two digits to write, namely &#8220;1&#8221; and &#8220;0.&#8221; (An exception is base
1, which does not behave like the other bases and is not a normal
positional number system.)</simpara>
</section>
<section xml:id="_example_decimal_numbers">
<title>Example: Decimal numbers</title>
<simpara>The number <inlineequation><alt><![CDATA[723]]></alt><mathphrase><![CDATA[723]]></mathphrase></inlineequation> can be written as
<inlineequation><alt><![CDATA[723=7 \times 10^2+2 \times 10^1+3 \times 10^0]]></alt><mathphrase><![CDATA[723=7 \times 10^2+2 \times 10^1+3 \times 10^0]]></mathphrase></inlineequation>.</simpara>
<simpara>Note that the rightmost digit is the ones place, which is equivalent to
<inlineequation><alt><![CDATA[10^0]]></alt><mathphrase><![CDATA[10^0]]></mathphrase></inlineequation>. Be sure to start with <inlineequation><alt><![CDATA[b^0]]></alt><mathphrase><![CDATA[b^0]]></mathphrase></inlineequation> and not
<inlineequation><alt><![CDATA[b^1]]></alt><mathphrase><![CDATA[b^1]]></mathphrase></inlineequation> when considering the value of a number written in base
<inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, no matter what <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation> is. The second digit
from the right is multiplied by <inlineequation><alt><![CDATA[10^1]]></alt><mathphrase><![CDATA[10^1]]></mathphrase></inlineequation>, and so on. The
product of a digit and the corresponding power of 10 tells us how much a
digit contributes to the number. In the above expansion, digit 7
contributes 700 to the number 723. Similarly, digits 2 and 3 contribute,
respectively, 20 and 3 to 723.</simpara>
<simpara>As we move to the right, the power of 10 goes down by one, and this
pattern works even for negative powers of 10. If we expand the
fractional value 0.324, we get
<inlineequation><alt><![CDATA[0.324=3\times10^{-1}+2\times10^{-2}+4\times10^{-3}]]></alt><mathphrase><![CDATA[0.324=3\times10^{-1}+2\times10^{-2}+4\times10^{-3}]]></mathphrase></inlineequation>.</simpara>
<simpara>We can combine the above two numbers to get
<inlineequation><alt><![CDATA[723.324=7 \times 10^2+2 \times 10^1+ 3\times 10^0+
3\times10^{-1}+2\times10^{-2}+4\times10^{-3}]]></alt><mathphrase><![CDATA[723.324=7 \times 10^2+2 \times 10^1+ 3\times 10^0+
3\times10^{-1}+2\times10^{-2}+4\times10^{-3}]]></mathphrase></inlineequation>.</simpara>
<simpara>We can expand these ideas to any base, checking our logic against the
familiar base 10. Suppose that a numeral consists of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>
symbols <inlineequation><alt><![CDATA[s_{n-1},
s_{n-2}, \ldots, s_1, s_0]]></alt><mathphrase><![CDATA[s_{n-1},
s_{n-2}, \ldots, s_1, s_0]]></mathphrase></inlineequation>. Furthermore, suppose that this numeral
belongs to the base <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation> number system. We can expand the
value of this numeral to:</simpara>
<informalequation>
<alt><![CDATA[s_{n-1} s_{n-2} \ldots s_1 s_0=s_{n-1}\times b^{n-1}+ s_{n-2}\times b^{n-2}+
\ldots +s_1\times b^1+ s_0\times b^0]]></alt>
<mathphrase><![CDATA[s_{n-1} s_{n-2} \ldots s_1 s_0=s_{n-1}\times b^{n-1}+ s_{n-2}\times b^{n-2}+
\ldots +s_1\times b^1+ s_0\times b^0]]></mathphrase>
</informalequation>
<simpara>The leftmost symbol in the numeral is the <emphasis>highest order digit</emphasis> and the
rightmost symbol is the <emphasis>lowest order digit</emphasis>. For example, in the
decimal numeral 492, 4 is the highest order digit and 2 the lowest order
digit.</simpara>
<simpara>Fractions can also be expanded in a similar manner. For example, a
fraction with <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> symbols
<inlineequation><alt><![CDATA[s_{1}, s_{2}, \ldots, s_{n-1}, s_{n}]]></alt><mathphrase><![CDATA[s_{1}, s_{2}, \ldots, s_{n-1}, s_{n}]]></mathphrase></inlineequation> in a number system
with base <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, can be expanded to:</simpara>
<informalequation>
<alt><![CDATA[0.s_{1} s_{2} \ldots s_{n-2} s_{n-1}=s_{1}\times b^{-1}+ s_{2}\times b^{-2}+
\ldots s_{n-1}\times b^{n-1}+s_{n}\times b^{-n}]]></alt>
<mathphrase><![CDATA[0.s_{1} s_{2} \ldots s_{n-2} s_{n-1}=s_{1}\times b^{-1}+ s_{2}\times b^{-2}+
\ldots s_{n-1}\times b^{n-1}+s_{n}\times b^{-n}]]></mathphrase>
</informalequation>
<simpara>To avoid confusion, the base number is always written in base 10. As
computer scientists, we are interested in base 2 because that&#8217;s the base
used to express numbers inside of a computer. Base 2 is also called
<emphasis>binary</emphasis>. The only symbols allowed to represent numbers in binary are
&#8220;0&#8221; and &#8220;1&#8221;, the binary digits or <emphasis>bits</emphasis>.</simpara>
<simpara>In the binary numeral 100110, the leftmost 1 is the highest order bit
and the rightmost 0 is the lowest order bit. By the rules of positional
number systems, the highest order bit represents
<inlineequation><alt><![CDATA[1 \times 2^5 = 32]]></alt><mathphrase><![CDATA[1 \times 2^5 = 32]]></mathphrase></inlineequation>.</simpara>
<simpara>Examples of numbers written in binary are 100, 111, 0111, and 10101.
Recall that the base of the binary number system is 2. Thus, we can
write a number in binary as the sum of products of powers of 2. For
example, the numeral 10011 can be expanded to:</simpara>
<informalequation>
<alt><![CDATA[10011 = 1 \times 2^4+0 \times 2^3+0 \times 2^2+1 \times 2^1+1 \times
2^0=16+0+0+2+1 = 19]]></alt>
<mathphrase><![CDATA[10011 = 1 \times 2^4+0 \times 2^3+0 \times 2^2+1 \times 2^1+1 \times
2^0=16+0+0+2+1 = 19]]></mathphrase>
</informalequation>
<simpara>By expanding the number, we have also shown how to convert a binary
numeral into a decimal numeral. Remember that both 10011 and 19
represent the same value, namely nineteen. The conversion between bases
changes only the way the number is written. As before, the rightmost bit
is multiplied by <inlineequation><alt><![CDATA[2^0]]></alt><mathphrase><![CDATA[2^0]]></mathphrase></inlineequation> to determine its contribution to the
binary number. The bit to its left is multiplied by <inlineequation><alt><![CDATA[2^1]]></alt><mathphrase><![CDATA[2^1]]></mathphrase></inlineequation> to
determine its contribution, and so on. In this case, the leftmost 1
contributes <inlineequation><alt><![CDATA[1 \times 2^4 = 16]]></alt><mathphrase><![CDATA[1 \times 2^4 = 16]]></mathphrase></inlineequation> to the value.</simpara>
<simpara>Another useful number system is <emphasis>base 16</emphasis>, also known as <emphasis>hexadecimal</emphasis>.
Hexadecimal is surprising because it requires more than the familiar 10
digits. Numerals in this system are written with 16 hexadecimal digits
that include the ten digits 0 through 9 and the six letters A, B, C, D,
E, and F. The six letters, starting from A, correspond to the values 10,
11, 12, 13, 14, and 15.</simpara>
<simpara>Hexadecimal is used as a compact representation of binary. Binary
numbers can get very long, but four binary digits can be represented
with a single hexadecimal digit.</simpara>
<simpara>39A, 32, and AFBC12 are examples of numbers written in hexadecimal. A
hexadecimal numeral can be expressed as the sum of products of powers of
16. For example, the hexadecimal numeral A0BF can be expanded to:</simpara>
<informalequation>
<alt><![CDATA[\mathrm{A} \times 16^3+0 \times 16^2+ \mathrm{B} \times 16^1+ \mathrm{F} \times
16^0]]></alt>
<mathphrase><![CDATA[\mathrm{A} \times 16^3+0 \times 16^2+ \mathrm{B} \times 16^1+ \mathrm{F} \times
16^0]]></mathphrase>
</informalequation>
<simpara>To convert a hexadecimal numeral to decimal, we must substitute the
values 10 through 15 for the digits A through F. Now we can rewrite the
sum of products from above as:</simpara>
<informalequation>
<alt><![CDATA[10 \times 16^3+0 \times 16^2+11 \times 16^1+15 \times 16^0=40960+0+176+15=41151]]></alt>
<mathphrase><![CDATA[10 \times 16^3+0 \times 16^2+11 \times 16^1+15 \times 16^0=40960+0+176+15=41151]]></mathphrase>
</informalequation>
<simpara>Thus, we get <inlineequation><alt><![CDATA[\mathrm{A}0\mathrm{BF}_{16} = 41151_{10}]]></alt><mathphrase><![CDATA[\mathrm{A}0\mathrm{BF}_{16} = 41151_{10}]]></mathphrase></inlineequation>.</simpara>
<simpara>The base 8 number system is also called <emphasis>octal</emphasis>. Like hexadecimal, octal
is used as a shorthand for binary. A numeral in octal uses the octal
digits 0, 1, 2, 3, 4, 5, 6, and 7. Otherwise the same rules apply. For
example, the octal numeral 377 can be expanded to:</simpara>
<informalequation>
<alt><![CDATA[377=3 \times 8^2+7 \times 8^1+7 \times 8^0=255]]></alt>
<mathphrase><![CDATA[377=3 \times 8^2+7 \times 8^1+7 \times 8^0=255]]></mathphrase>
</informalequation>
<simpara>You may have noticed that it is not always clear which base a numeral is
written in. The digit sequence 337 is a legal numeral in octal, decimal,
and hexadecimal, but it represents different numbers in each system.
Mathematicians use a subscript to denote the base in which a numeral is
written.</simpara>
<simpara>Thus, <inlineequation><alt><![CDATA[337_8 = 255_{10}]]></alt><mathphrase><![CDATA[337_8 = 255_{10}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[377_{10} = 377_{10}]]></alt><mathphrase><![CDATA[377_{10} = 377_{10}]]></mathphrase></inlineequation>,
and <inlineequation><alt><![CDATA[377_{16} = 887_{10}]]></alt><mathphrase><![CDATA[377_{16} = 887_{10}]]></mathphrase></inlineequation>. Base numbers are always written
in base 10. A number without a subscript is assumed to be in base 10. In
Java, there is no way to mark subscripts and so prefixes are used. A
prefix of is used for octal, no prefix is used for decimal, and a prefix
of is used for hexadecimal. A numeral cannot be marked as binary in
Java. The corresponding numerals in Java code would thus be written , ,
and . Be careful not to pad numbers with zeroes in Java. Remember that
the value is <emphasis role="strong">not</emphasis> the same as the value in Java.</simpara>
<simpara>The following table lists a few characteristics of the four number
systems we have discussed with representations of the numbers 7 and
29.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="middle">Number System</entry>
<entry align="center" valign="middle">Base</entry>
<entry align="left" valign="middle">Digits</entry>
<entry align="left" valign="middle">Math<?asciidoc-br?>
Numerals</entry>
<entry align="left" valign="middle">Java<?asciidoc-br?>
Numerals</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Binary</simpara></entry>
<entry align="center" valign="middle"><simpara>2</simpara></entry>
<entry align="left" valign="middle"><simpara>0, 1</simpara></entry>
<entry align="left" valign="middle"><simpara>111<subscript>2</subscript>, 11101<subscript>2</subscript></simpara></entry>
<entry align="left" valign="middle"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Octal</simpara></entry>
<entry align="center" valign="middle"><simpara>8</simpara></entry>
<entry align="left" valign="middle"><simpara>0, 1, 2, 3, 4, 5, 6, 7</simpara></entry>
<entry align="left" valign="middle"><simpara>7<subscript>8</subscript>, 35<subscript>8</subscript></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>07</literal>, <literal>035</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Decimal</simpara></entry>
<entry align="center" valign="middle"><simpara>10</simpara></entry>
<entry align="left" valign="middle"><simpara>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</simpara></entry>
<entry align="left" valign="middle"><simpara>7, 29</simpara></entry>
<entry align="left" valign="middle"><simpara><literal>7</literal>, <literal>29</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Hexadecimal</simpara></entry>
<entry align="center" valign="middle"><simpara>16</simpara></entry>
<entry align="left" valign="middle"><simpara>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F</simpara></entry>
<entry align="left" valign="middle"><simpara>7<subscript>16</subscript>, 1D<subscript>16</subscript></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>0x7</literal>,<literal>0x1D</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_conversion_across_number_systems">
<title>Conversion across number systems</title>
<simpara>It is often useful to know how to convert a number represented in one
base to the equivalent representation in another base. The examples have
shown how to convert a numeral in any base to decimal by expanding the
numeral in the sum-of-product form and then adding the different terms
together. But how do you convert a decimal numeral to another base?</simpara>
</section>
<section xml:id="_decimal_to_binary_conversion">
<title>Decimal to binary conversion</title>
<simpara>There are at least two different ways to convert a decimal numeral to
binary. One way is to write the decimal number as a sum of powers of two
as in the following conversion of the number 23.</simpara>
<informalequation>
<alt><![CDATA[23=16+0+4+2+1=1\times 2^4+0\times 2+3+1\times 2+2+1\times 2+1+1\times 2^0= 10111_2]]></alt>
<mathphrase><![CDATA[23=16+0+4+2+1=1\times 2^4+0\times 2+3+1\times 2+2+1\times 2+1+1\times 2^0= 10111_2]]></mathphrase>
</informalequation>
<simpara>First, find the largest power of two that is greater than or equal to
the number. In this case, 16 fits the bill because 32 is too large.
Subtract that value from the number, leaving 7 in this case. Then repeat
the process. The last step is to collect the coefficients of the powers
of two into a sequence to get the binary equivalent. We used 16, 4, 2,
and 1 but skipped 8. If we write a 1 for every place we used and a 0 for
every place we skipped, we get <inlineequation><alt><![CDATA[23=10111_2]]></alt><mathphrase><![CDATA[23=10111_2]]></mathphrase></inlineequation>. While this is a
straightforward procedure for decimal to binary conversion, it can be
cumbersome for larger numbers.</simpara>
<simpara>An alternate way to convert a decimal numeral to an equivalent binary
numeral is to divide the given number by 2 until the quotient is 0
(keeping only the integer part of the quotient). At each step, record
the remainder found when dividing by 2. Collect these remainders (which
will always be either 0 or 1) to form the binary equivalent. The least
significant bit is the remainder obtained after the first division, and
the most significant bit is the remainder obtained after the last
division.</simpara>
<simpara>Let&#8217;s use this method to convert 23 to its binary equivalent. The
following table shows the steps need for the conversion. The leftmost
column lists the step number. The second column contains the number to
be divided by 2 at each step. The third column contains the quotient for
each step, and the last column contains the current remainder.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Step</emphasis></entry>
<entry align="right" valign="top"><emphasis role="strong">Number</emphasis></entry>
<entry align="right" valign="top"><emphasis role="strong">Quotient</emphasis></entry>
<entry align="right" valign="top"><emphasis role="strong">Remainder</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>23</simpara></entry>
<entry align="right" valign="top"><simpara>11</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>11</simpara></entry>
<entry align="right" valign="top"><simpara>5</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="right" valign="top"><simpara>5</simpara></entry>
<entry align="right" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="right" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>We begin by dividing 23 by 2, yielding 11 as the quotient and 1 as the
remainder. The quotient 11 is then divided by 2, yielding 5 as the
quotient and 1 as the remainder. This process continues until we get a
quotient of 0 and a remainder of 1 in StepÂ 5. We now collect the
remainders and get the same result as before,
<inlineequation><alt><![CDATA[23 = 10111_2]]></alt><mathphrase><![CDATA[23 = 10111_2]]></mathphrase></inlineequation>.</simpara>
</section>
<section xml:id="_other_conversions">
<title>Other conversions</title>
<simpara>A decimal number can be converted to its hexadecimal equivalent by using
either of the two procedures described above. Instead of writing a
decimal number as a sum of powers of 2, one writes it as a sum of powers
of 16. Similarly, when using the division method, instead of dividing by
2, one divides by 16. Octal conversion is similar.</simpara>
<simpara>We use hexadecimal because it is straightforward to convert from it to
binary or back. The following table lists binary equivalents for the 16
hexadecimal digits.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="bottom">Hexadecimal<?asciidoc-br?>
digit</entry>
<entry align="center" valign="bottom">Binary</entry>
<entry align="center" valign="bottom">Hexadecimal<?asciidoc-br?>
digit</entry>
<entry align="center" valign="bottom">Binary</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="bottom"><simpara>0</simpara></entry>
<entry align="center" valign="bottom"><simpara>0000</simpara></entry>
<entry align="center" valign="bottom"><simpara>8</simpara></entry>
<entry align="center" valign="bottom"><simpara>1000</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>1</simpara></entry>
<entry align="center" valign="bottom"><simpara>0001</simpara></entry>
<entry align="center" valign="bottom"><simpara>9</simpara></entry>
<entry align="center" valign="bottom"><simpara>1001</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>2</simpara></entry>
<entry align="center" valign="bottom"><simpara>0010</simpara></entry>
<entry align="center" valign="bottom"><simpara>A</simpara></entry>
<entry align="center" valign="bottom"><simpara>1010</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>3</simpara></entry>
<entry align="center" valign="bottom"><simpara>0011</simpara></entry>
<entry align="center" valign="bottom"><simpara>B</simpara></entry>
<entry align="center" valign="bottom"><simpara>1011</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>4</simpara></entry>
<entry align="center" valign="bottom"><simpara>0100</simpara></entry>
<entry align="center" valign="bottom"><simpara>C</simpara></entry>
<entry align="center" valign="bottom"><simpara>1100</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>5</simpara></entry>
<entry align="center" valign="bottom"><simpara>0101</simpara></entry>
<entry align="center" valign="bottom"><simpara>D</simpara></entry>
<entry align="center" valign="bottom"><simpara>1101</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>6</simpara></entry>
<entry align="center" valign="bottom"><simpara>0110</simpara></entry>
<entry align="center" valign="bottom"><simpara>E</simpara></entry>
<entry align="center" valign="bottom"><simpara>1110</simpara></entry>
</row>
<row>
<entry align="center" valign="bottom"><simpara>7</simpara></entry>
<entry align="center" valign="bottom"><simpara>0111</simpara></entry>
<entry align="center" valign="bottom"><simpara>F</simpara></entry>
<entry align="center" valign="bottom"><simpara>1111</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>With the help of the table above, let&#8217;s convert
<inlineequation><alt><![CDATA[3\mathrm{FA}_{16}]]></alt><mathphrase><![CDATA[3\mathrm{FA}_{16}]]></mathphrase></inlineequation> to binary. By simple substitution,
<inlineequation><alt><![CDATA[3\mathrm{FA}_{16} = 0011\mbox{ }1111\mbox{ }1010_2]]></alt><mathphrase><![CDATA[3\mathrm{FA}_{16} = 0011\mbox{ }1111\mbox{ }1010_2]]></mathphrase></inlineequation>.
Note that we have grouped the binary digits into clusters of
4 bits each. Of course, the leftmost zeroes in the binary equivalent are
useless as they do not contribute to the value of the number.</simpara>
</section>
<section xml:id="_integer_representation_in_a_computer">
<title>Integer representation in a computer</title>
<simpara>In mathematics, binary numerals can represent arbitrarily big numbers.
Inside of a computer, the size of a number is constrained by the number
of bits used to represent it. For general purpose computation, 32- and
64-bit integers are the most commonly used. The largest integer that
Java represents with 32 bits is 2,147,483,647, which is good enough for
most tasks. For larger numbers, Java can represent up to
9,223,372,036,854,775,807 with 64 bits. Java also provides
representations for integers using 8 and 16 bits.</simpara>
<simpara>These representations are easy to determine for positive numbers: Find
the binary equivalent of the number and then pad the left side with
zeroes to fill the remaining space. For example,
<inlineequation><alt><![CDATA[19 = 10011_2]]></alt><mathphrase><![CDATA[19 = 10011_2]]></mathphrase></inlineequation>. If stored using 8 bits, 19 would be
represented as <literal>0001 0011</literal>. If stored using 16 bits, 19 would be
represented as <literal>0000 0000 0001 0011</literal>. (We separate groups of 4 bits for
easier reading.)</simpara>
</section>
<section xml:id="_binary_arithmetic">
<title>Binary arithmetic</title>
<simpara>Recall that computers deal with numbers in their binary representation,
meaning that all arithmetic is done on binary numbers. Sometimes it is
useful to understand how this process works and how it is similar and
different from decimal arithmetic. The table below lists rules for
binary addition.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<tbody>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">+</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">0</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">1</emphasis></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">0</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">1</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As indicated above, the addition of two 1s leads to a 0 with a carry of
1 into the next position to the left. Addition for numbers composed of
more than one bit use the same rules as any addition, carrying values
that are too large into the next position. In decimal addition, values
over 9 must to be carried. In binary addition, values over 1 must be
carried. The next example shows a sample binary addition. To simplify
its presentation, we assume that integers are represented with 8 bits.</simpara>
<simpara>Let&#8217;s add the numbers 60 and 6 in binary. Using the conversion
techniques described above, we can find that <inlineequation><alt><![CDATA[60 = 111100_2]]></alt><mathphrase><![CDATA[60 = 111100_2]]></mathphrase></inlineequation>
and <inlineequation><alt><![CDATA[6 = 110_2]]></alt><mathphrase><![CDATA[6 = 110_2]]></mathphrase></inlineequation>. Inside the computer, these numbers would
already be in binary and padded to fill 8 bits.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0011 1100</literal></simpara></entry>
<entry align="right" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>+</simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0100 0010</literal></simpara></entry>
<entry align="right" valign="top"><simpara>66</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The result is no surprise, but note that the addition can proceed in
binary without conversion to decimal at any point.</simpara>
<simpara>Subtraction in binary is also similar to subtraction in decimal. The
rules are given in the following table.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<tbody>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">-</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">0</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">1</emphasis></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">0</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><emphasis role="strong">1</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara>(1)1</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When subtracting a 1 from a 0, a 1 is borrowed from the next left
position. The next example illustrates binary subtraction.</simpara>
<simpara>Again, we&#8217;ll use 60 and 6 and their binary equivalents given above.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0011 1100</literal></simpara></entry>
<entry align="right" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0011 0110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>54</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_negative_integers_in_a_computer">
<title>Negative integers in a computer</title>
<simpara>Negative integers are also represented in computer memory as binary
numbers, using a system called <emphasis>two&#8217;s complement</emphasis>. When looking at the
binary representation of a signed integer in a computer, the leftmost
(most significant) bit will be 1 if the number is negative and 0 if it
is positive. Unfortunately, there&#8217;s more to finding the representation
of a negative number than flipping this bit.</simpara>
<simpara>Suppose that we need to find the binary equivalent of the decimal number
<inlineequation><alt><![CDATA[-12]]></alt><mathphrase><![CDATA[-12]]></mathphrase></inlineequation> using 8-bits in two&#8217;s complement form. The first step
is to convert 12 to its 8-bit binary equivalent. Doing so we get 12 =
<literal>0000 1100</literal>. Note that the leftmost bit of the representation is a 0,
indicating that the number is positive. Next we take the two&#8217;s
complement of the 8-bit representation in two steps. In the first step,
we flip every bit, i.e., change every 0 to 1 and every 1 to 0. This
gives us the <emphasis>one&#8217;s complement</emphasis> of the number, <literal>1111 0011</literal>. In the
second step, we add 1 to the one&#8217;s complement to get the two&#8217;s
complement. The result is <literal>1111 0011</literal> + <literal>1</literal> = <literal>1111 0100</literal>.</simpara>
<simpara>Thus, the 8-bit, two&#8217;s complement binary equivalent of -12 is
<literal>1111 0100</literal>. Note that the leftmost bit is a 1, indicating that this is
a negative number.</simpara>
<simpara>Let us convert -29 to its binary equivalent assuming that the number is
to be stored in 8-bit, two&#8217;s complement form. First we convert positive
29 to its 8-bit binary equivalent, <inlineequation><alt><![CDATA[29 =]]></alt><mathphrase><![CDATA[29 =]]></mathphrase></inlineequation> <literal>0001 1101</literal>.</simpara>
<simpara>Next we obtain the one&#8217;s complement of the binary representation by
flipping 0s to 1s and 1s to 0s. This gives us <literal>1110 0010</literal>. Finally, we
add 1 to the one&#8217;s complement representation to get <literal>1110 0010</literal> + <literal>1</literal> =
<literal>1110 0011</literal>, which is the desired binary equivalent of -29.</simpara>
<simpara>Let us now convert the 8-bit, two&#8217;s complement value <literal>1000 1100</literal> to
decimal. We note that the leftmost bit of this number is 1, making it a
negative number. Therefore, we reverse the process of making a two&#8217;s
complement. First, we subtract 1 from the representation, yielding
<literal>1000 1100</literal> - <literal>1</literal> = <literal>1000 1011</literal>. Next, we flip all the bits in this
one&#8217;s complement form, yielding <literal>0111 0100</literal>.</simpara>
<simpara>Now we convert this binary representation to its decimal equivalent,
yielding 116. Thus, the decimal equivalent of <literal>1000 1100</literal> is -116.</simpara>
<simpara>Why do we use two&#8217;s complement? First of all, we needed a system that
could represent both positive and negative numbers. We could have simply
used the leftmost bit as a sign bit and represented the rest of the
number as a positive binary number. Doing so would require a check on
the bit and some conversion for negative numbers every time a computer
wanted to perform an addition or subtraction.</simpara>
<simpara>Because of the way it&#8217;s designed, positive and negative integers stored
in two&#8217;s complement can be added or subtracted <emphasis role="strong">without</emphasis> any special
conversions. The leftmost bit is added or subtracted just like any other
bit, and values that carry past the leftmost bit are ignored. Two&#8217;s
complement has an advantage over one&#8217;s complement in that there is only
one representation for zero. The next example shows two&#8217;s complement in
action.</simpara>
<simpara>We&#8217;ll add -126 and 126. If you perform the needed conversions, their
8-bit, two&#8217;s complement representations are <literal>1000 0010</literal> and <literal>0111 1110</literal>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>1000 0010</literal></simpara></entry>
<entry align="right" valign="top"><simpara>-126</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>+</simpara></entry>
<entry align="right" valign="top"><simpara><literal>0111 1110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>126</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000</literal></simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As expected, the sum is 0.</simpara>
<simpara>Now, let&#8217;s add the two negative integers -126 and -2, whose 8-bit, two&#8217;s
complement representations are <literal>1000 0010</literal> and <literal>1111 1110</literal>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>1000 0010</literal></simpara></entry>
<entry align="right" valign="top"><simpara>-126</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>+</simpara></entry>
<entry align="right" valign="top"><simpara><literal>1111 1110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>-2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>1000 0000</literal></simpara></entry>
<entry align="right" valign="top"><simpara>-128</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The result is -128, which is the smallest negative integer that can be
represented in 8-bit two&#8217;s complement.</simpara>
</section>
<section xml:id="_overflow_and_underflow">
<title>Overflow and underflow</title>
<simpara>When performing an arithmetic or other operation on numbers, an overflow
is said occur when the result of the operation is larger than the
largest value that can be stored in that representation. An underflow is
said to occur when the result of the operation is smaller than the
smallest possible value.</simpara>
<simpara>Both overflows and underflows lead to wrapped around values. For
example, adding two positive numbers together can result in a negative
number or adding two negative numbers together can result in a positive
number.</simpara>
<simpara>Let&#8217;s add the numbers 124 and 6. Their 8-bit, two&#8217;s complement
representations are <literal>0111 1100</literal> and <literal>0000 0110</literal>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">Binary</emphasis></simpara></entry>
<entry align="right" valign="top"><simpara><emphasis role="strong">Decimal</emphasis></simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0111 1100</literal></simpara></entry>
<entry align="right" valign="top"><simpara>124</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>+</simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>1000 0010</literal></simpara></entry>
<entry align="right" valign="top"><simpara>-126</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This surprising result happens because the largest 8-bit two&#8217;s
complement integer is 127. Adding 124 and 6 yields 130, a value larger
than this maximum, resulting in overflow with a negative answer.</simpara>
<simpara>The smallest (most negative) number that can be represented in 8-bit
two&#8217;s complement is -128. A result smaller than this will result in
underflow. For example, -115 - 31 = 110. Try out the conversions needed
to test this result.</simpara>
</section>
<section xml:id="_bitwise_operators">
<title>Bitwise operators</title>
<simpara>Although we will most commonly manipulate numbers using traditional
mathematical operations such as addition, subtraction, multiplication,
and division, there are also operations that work directly on the binary
representations of the numbers. Some of these operators are equivalent
to mathematical operations, and some are not.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top">Operator</entry>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>&amp;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Bitwise AND</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation which has 1s in every position that both the original
representations have a 1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>|</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Bitwise OR</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation which has 1s in every position that either of the
original representations have a 1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>^</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Bitwise XOR</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation which has 1s in every position that the original
representations have different values</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>~</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Bitwise complement</simpara></entry>
<entry align="left" valign="top"><simpara>Takes a representation and creates a new
representation in which every bit is flipped from 0 to 1 and 1 to 0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&lt;&lt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Signed left shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the left, leaving the sign bit unchanged</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Signed right shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the right, padding the left with copies of the sign bit</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;&gt;&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unsigned right shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the right, padding with 0s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Bitwise AND, bitwise OR, and bitwise XOR take two integer
representations and combine them to make a new representation. In
bitwise AND, each bit in the result will be a 1 if <emphasis role="strong">both</emphasis> of the
original integer representations in that position are 1 and 0 otherwise.
In bitwise OR, each bit in the result will be a 1 if <emphasis role="strong">either</emphasis> of the
original integer representations in that position are 1 and 0 otherwise.
In bitwise XOR, each bit in the result will be a 1 if the two bits of
the original integer representations in that position are not the same
and 0 otherwise.</simpara>
<simpara>Bitwise complement is a unary operator like the negation operator ().
Instead of just changing the sign of a value (which it will also do),
its result has every 1 in the original representation changed to 0 and
every 0 to 1.</simpara>
<simpara>The signed left shift, signed right shift, and unsigned right shift
operators all create a new binary representation by shifting the bits in
the original representation a certain number of places to the left or
the right. The signed left shift moves the bits to the left, padding
with 0s, but does not change the sign bit. If you do a signed left shift
by <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> positions, it is equivalent to multiplying the number
by <inlineequation><alt><![CDATA[2^n]]></alt><mathphrase><![CDATA[2^n]]></mathphrase></inlineequation>. The signed right shift moves the bits to the
right, padding with whatever the sign bit is. If you do a signed right
shift by <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> positions, it is equivalent to dividing the
number by <inlineequation><alt><![CDATA[2^n]]></alt><mathphrase><![CDATA[2^n]]></mathphrase></inlineequation> (with integer division). The unsigned right
shift moves the bits to the right, including the sign bit, filling the
left side with 0s. And unsigned right shift will always make a value
positive but is otherwise similar to a signed right shift. A few
examples follow.</simpara>
<simpara>Here are a few examples of the result of bitwise operations. We will
assume that the values are represented using 32-bit two&#8217;s complement,
instead of using 8-bit values as before. In Java, bitwise operators
automatically convert smaller values to 32-bit representations before
proceeding.</simpara>
<simpara>Let&#8217;s consider the result of <inlineequation><alt><![CDATA[21 \& 27]]></alt><mathphrase><![CDATA[21 \& 27]]></mathphrase></inlineequation>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 0101</literal></simpara></entry>
<entry align="right" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&amp;</literal></simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 1011</literal></simpara></entry>
<entry align="right" valign="top"><simpara>27</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 0001</literal></simpara></entry>
<entry align="right" valign="top"><simpara>17</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note how this result is different from <inlineequation><alt><![CDATA[21 | 27]]></alt><mathphrase><![CDATA[21 | 27]]></mathphrase></inlineequation>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 0101</literal></simpara></entry>
<entry align="right" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>|</literal></simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 1011</literal></simpara></entry>
<entry align="right" valign="top"><simpara>27</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0001 1111</literal></simpara></entry>
<entry align="right" valign="top"><simpara>31</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>And also from <inlineequation><alt><![CDATA[21 \land 27]]></alt><mathphrase><![CDATA[21 \land 27]]></mathphrase></inlineequation>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top">Binary</entry>
<entry align="right" valign="top">Decimal</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 0101</literal></simpara></entry>
<entry align="right" valign="top"><simpara>21</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>^</literal></simpara></entry>
<entry align="right" valign="top"><simpara><literal>0000 0000 0000 0000 0000 0000 0001 1011</literal></simpara></entry>
<entry align="right" valign="top"><simpara>27</simpara></entry>
</row>
<row>
<entry align="center" valign="top"></entry>
<entry align="right" valign="top"><simpara><literal>0000 1110</literal></simpara></entry>
<entry align="right" valign="top"><simpara>14</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Ignoring overflows, signed left shifting is equivalent to repeated
multiplications by 2. Consider <literal>11 &lt;&lt; 3</literal>. The representation
<literal>0000 0000 0000 0000 0000 0000 0000 1011</literal> is shifted to the left to make
<literal>0000 0000 0000 0000 0000 0000 0101 1000</literal>
<inlineequation><alt><![CDATA[= 88 = 11\times 2^3]]></alt><mathphrase><![CDATA[= 88 = 11\times 2^3]]></mathphrase></inlineequation>.</simpara>
<simpara>Signed right shifting is equivalent to repeated integer divisions by 2.
Consider <literal>-104 &gt;&gt; 2</literal>. The representation
<literal>1111 1111 1111 1111 1111 1111 1001 1000</literal> is shifted to the right to
make <literal>1111 1111 1111 1111 1111 1111 1110 0110</literal>
<inlineequation><alt><![CDATA[= -26 = -104\div 2^2]]></alt><mathphrase><![CDATA[= -26 = -104\div 2^2]]></mathphrase></inlineequation>.</simpara>
<simpara>Unsigned right shifting is the same as signed right shifting except when
it is done on negative numbers. Since their sign bit is replaced by <literal>0</literal>,
an unsigned right shift produces a (generally large) positive number.
Consider <literal>-104 &gt;&gt;&gt; 2</literal>. The representation
<literal>1111 1111 1111 1111 1111 1111 1001 1000</literal> is shifted to the right to
make <literal>0011 1111 1111 1111 1111 1111 1110 0110</literal>
<inlineequation><alt><![CDATA[= 1,073,741,798]]></alt><mathphrase><![CDATA[= 1,073,741,798]]></mathphrase></inlineequation>.</simpara>
<simpara>Because of the way two&#8217;s complement is designed, bitwise complement is
equivalent to negating the sign of the number and then subtracting
<inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation>. Consider <literal>~(-104)</literal>. The
representation <literal>1111 1111 1111 1111 1111 1111 1001 1000</literal> is complemented
to <literal>0000 0000 0000 0000 0000 0000 0110 0111</literal> <inlineequation><alt><![CDATA[=
103]]></alt><mathphrase><![CDATA[=
103]]></mathphrase></inlineequation>.</simpara>
</section>
<section xml:id="_rational_numbers">
<title>Rational numbers</title>
<simpara>We have seen how to represent positive and negative integers in computer
memory. In this section we see how rational numbers, such as 12.33,
-149.89, and 3.14159, can be converted into binary and represented.</simpara>
</section>
<section xml:id="_scientific_notation">
<title>Scientific notation</title>
<simpara><emphasis>Scientific notation</emphasis> is closely related to the way a computer
represents a rational number in memory. Scientific notation is a tool
for representing very large or very small numbers without writing a lot
of zeroes. A decimal number in scientific notation is written
<inlineequation><alt><![CDATA[a\times 10^b]]></alt><mathphrase><![CDATA[a\times 10^b]]></mathphrase></inlineequation> where <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> is called the
<emphasis>mantissa</emphasis> and <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation> is called the <emphasis>exponent</emphasis>.</simpara>
<simpara>For example, the number 3.14159 can be written in scientific notation as
<inlineequation><alt><![CDATA[0.314159\times 10^1]]></alt><mathphrase><![CDATA[0.314159\times 10^1]]></mathphrase></inlineequation>. In this case, <inlineequation><alt><![CDATA[0.314159]]></alt><mathphrase><![CDATA[0.314159]]></mathphrase></inlineequation>
is the mantissa, and <inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation> is the exponent. Here a few more
examples of writing numbers in scientific notation.<?asciidoc-br?>
<inlineequation><alt><![CDATA[\begin{array}{ l c l}
3.14159&=&3.14159\times 10^0\\
3.14159&=&314159\times 10^{-5}\\
-141.324&=&-0.141324\times10^2\\
30,000&=& .3\times10^5\\
\end{array}]]></alt><mathphrase><![CDATA[\begin{array}{ l c l}
3.14159&=&3.14159\times 10^0\\
3.14159&=&314159\times 10^{-5}\\
-141.324&=&-0.141324\times10^2\\
30,000&=& .3\times10^5\\
\end{array}]]></mathphrase></inlineequation><?asciidoc-br?>
There are many ways of writing a number in scientific notation. A more
standardized way of writing real numbers is <emphasis>normalized scientific
notation</emphasis>. In this notation, the mantissa is always written as a number
whose absolute value is less than 10 but greater than or equal to 1.
Following are a few examples of decimal numbers in normalized scientific
notation.<?asciidoc-br?>
<inlineequation><alt><![CDATA[\begin{array}{ l c l}
3.14159&=&3.14159\times 10^0\\
-141.324&=&-1.41324\times10^3\\
30,000&=& 3.0\times10^4\\
\end{array}]]></alt><mathphrase><![CDATA[\begin{array}{ l c l}
3.14159&=&3.14159\times 10^0\\
-141.324&=&-1.41324\times10^3\\
30,000&=& 3.0\times10^4\\
\end{array}]]></mathphrase></inlineequation><?asciidoc-br?>
A shorthand for scientific notation is E notation, which is written with
the mantissa followed by the letter `E' followed by the exponent. For
example, 39.2 in E notation can be written <inlineequation><alt><![CDATA[3.92\mathrm{E}1]]></alt><mathphrase><![CDATA[3.92\mathrm{E}1]]></mathphrase></inlineequation>
or <inlineequation><alt><![CDATA[0.392\mathrm{E}2]]></alt><mathphrase><![CDATA[0.392\mathrm{E}2]]></mathphrase></inlineequation>. The letter `E' should be read
``multiplied by 10 to the power.'' E notation can be used to represent
numbers in scientific notation in Java. Instead of writing the number in
Java code, or could be used instead.</simpara>
</section>
<section xml:id="_fractions">
<title>Fractions</title>
<simpara>A rational number can be broken into an integer part and a fractional
part. In the number 3.14, 3 is the integer part, and .14 is the
fractional part. We have already seen how to convert the integer part to
binary. Now we will see how to convert the fractional part into binary.
We can then combine the binary equivalents of the integer and fractional
parts to find the binary equivalent of a decimal real number.</simpara>
<simpara>A decimal fraction <inlineequation><alt><![CDATA[f]]></alt><mathphrase><![CDATA[f]]></mathphrase></inlineequation> is converted to its binary equivalent
by successively multiplying it by 2. At the end of each multiplication
step, either a 0 or a 1 is obtained as an integer part and is recorded
separately. The remaining fraction is again multiplied by 2 and the
resulting integer part recorded. This process continues until the
fraction reduces to zero or enough binary digits for the desired
precision have been found. The binary equivalent of <inlineequation><alt><![CDATA[f]]></alt><mathphrase><![CDATA[f]]></mathphrase></inlineequation> then
consists of the bits in the order they have been recorded, as shown in
the next example.</simpara>
<simpara>Let&#8217;s convert 0.8125 to binary. The table below shows the steps to do
so.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="right" valign="top">Step</entry>
<entry align="right" valign="top"><inlineequation><alt><![CDATA[f]]></alt><mathphrase><![CDATA[f]]></mathphrase></inlineequation></entry>
<entry align="right" valign="top"><inlineequation><alt><![CDATA[f \times 2]]></alt><mathphrase><![CDATA[f \times 2]]></mathphrase></inlineequation></entry>
<entry align="right" valign="top">Integer part</entry>
<entry align="right" valign="top">Remainder</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.8125</simpara></entry>
<entry align="right" valign="top"><simpara>1.625</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.625</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>0.625</simpara></entry>
<entry align="right" valign="top"><simpara>1.25</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.25</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>3</simpara></entry>
<entry align="right" valign="top"><simpara>0.25</simpara></entry>
<entry align="right" valign="top"><simpara>0.5</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>0.5</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>4</simpara></entry>
<entry align="right" valign="top"><simpara>0.5</simpara></entry>
<entry align="right" valign="top"><simpara>1.0</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>We then collect all the integer parts and get 0.1101 as the binary
equivalent of 0.8125. We can convert this binary fraction back into
decimal to verify that it is correct.</simpara>
<informalequation>
<alt><![CDATA[0.1101=1\times 2^{-1}+1\times2^{-2}+0\times 2^{-3}+1\times
2^{-4}=0.5+0.25+0+0.0625=0.8125]]></alt>
<mathphrase><![CDATA[0.1101=1\times 2^{-1}+1\times2^{-2}+0\times 2^{-3}+1\times
2^{-4}=0.5+0.25+0+0.0625=0.8125]]></mathphrase>
</informalequation>
<simpara>In some cases, the process described above will never have a remainder
of 0. In such cases we can only find an approximate representation of
the given fraction as demonstrated in the next example.</simpara>
<simpara>Let us convert 0.3 to binary assuming that we have only five bits in
which to represent the fraction. The following table shows the five
steps in the conversion process.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="right" valign="top">Step</entry>
<entry align="right" valign="top"><inlineequation><alt><![CDATA[f]]></alt><mathphrase><![CDATA[f]]></mathphrase></inlineequation></entry>
<entry align="right" valign="top"><inlineequation><alt><![CDATA[f \times 2]]></alt><mathphrase><![CDATA[f \times 2]]></mathphrase></inlineequation></entry>
<entry align="right" valign="top">Integer part</entry>
<entry align="right" valign="top">Remainder</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.3</simpara></entry>
<entry align="right" valign="top"><simpara>0.6</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>0.6</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>0.6</simpara></entry>
<entry align="right" valign="top"><simpara>1.2</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.2</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>3</simpara></entry>
<entry align="right" valign="top"><simpara>0.2</simpara></entry>
<entry align="right" valign="top"><simpara>0.4</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>0.4</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>4</simpara></entry>
<entry align="right" valign="top"><simpara>0.4</simpara></entry>
<entry align="right" valign="top"><simpara>0.8</simpara></entry>
<entry align="right" valign="top"><simpara>0</simpara></entry>
<entry align="right" valign="top"><simpara>0.8</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>5</simpara></entry>
<entry align="right" valign="top"><simpara>0.8</simpara></entry>
<entry align="right" valign="top"><simpara>1.6</simpara></entry>
<entry align="right" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>0.6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Collecting the integer parts we get 0.01001 as the binary representation
of 0.3. Let&#8217;s convert this back to decimal to see how accurate it is.</simpara>
<informalequation>
<alt><![CDATA[0.01001=0\times2^{-1}+1\times 2^{-2}+ 0\times2^{-3}+ 0\times 2^{-4}+ 1\times
2^{-5}= 0.25+0.03125=0.28125]]></alt>
<mathphrase><![CDATA[0.01001=0\times2^{-1}+1\times 2^{-2}+ 0\times2^{-3}+ 0\times 2^{-4}+ 1\times
2^{-5}= 0.25+0.03125=0.28125]]></mathphrase>
</informalequation>
<simpara>Five bits are not enough to represent 0.3 fully. In this case, we have
an error of <inlineequation><alt><![CDATA[0.3 - 0.28125=0.01875]]></alt><mathphrase><![CDATA[0.3 - 0.28125=0.01875]]></mathphrase></inlineequation>. Most computers use many
more bits to represent fractions and obtain much better accuracy in
their representation.</simpara>
<simpara>Now that we understand how integers as well as fractions can be
converted from one number base to another, we can convert any rational
number from one base to another. The next example demonstrates one such
conversion.</simpara>
<simpara>Let&#8217;s convert 14.3 to binary assuming that we will only use six bits to
represent the fractional part. First we convert 14 to binary using the
technique described earlier. This gives us <inlineequation><alt><![CDATA[14 = 1110_{2}]]></alt><mathphrase><![CDATA[14 = 1110_{2}]]></mathphrase></inlineequation>.
Taking the method outlined in ExampleÂ  one step further, our six bit
representation of 0.3 is 0.010011. Combining the two representations
gives <inlineequation><alt><![CDATA[14.3_{10} = 1110.010011_{2}]]></alt><mathphrase><![CDATA[14.3_{10} = 1110.010011_{2}]]></mathphrase></inlineequation>.</simpara>
</section>
<section xml:id="_floating_point_notation">
<title>Floating point notation</title>
<simpara><emphasis>Floating point notation</emphasis> is a system used to represent rational numbers
in computer memory. In this notation a number is represented as
<inlineequation><alt><![CDATA[a\times b^{e}]]></alt><mathphrase><![CDATA[a\times b^{e}]]></mathphrase></inlineequation>, where <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> gives the
<emphasis>significant digits</emphasis> (mantissa) of the number and <inlineequation><alt><![CDATA[e]]></alt><mathphrase><![CDATA[e]]></mathphrase></inlineequation> is the
exponent. The system is very similar to scientific notation, but
computers usually have base <inlineequation><alt><![CDATA[b = 2]]></alt><mathphrase><![CDATA[b = 2]]></mathphrase></inlineequation> instead of
<inlineequation><alt><![CDATA[10]]></alt><mathphrase><![CDATA[10]]></mathphrase></inlineequation>.</simpara>
<simpara>For example, we could write the binary number 1010.1 in floating point
notation as <inlineequation><alt><![CDATA[10.101\times 2^2]]></alt><mathphrase><![CDATA[10.101\times 2^2]]></mathphrase></inlineequation> or as
<inlineequation><alt><![CDATA[101.01\times2^1]]></alt><mathphrase><![CDATA[101.01\times2^1]]></mathphrase></inlineequation>. In any case, this number is equivalent to
10.5 in decimal.</simpara>
<simpara>In standardized floating point notation, <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> is written so
that only the most significant non-zero digit is to the left of the
decimal point. Most computers use the IEEE 754 floating point notation
to represent rational numbers. In this notation, the memory to store the
number is divided into three segments: one bit used to mark the sign of
the number, <inlineequation><alt><![CDATA[m]]></alt><mathphrase><![CDATA[m]]></mathphrase></inlineequation> bits to represent the mantissa (also known
as the <emphasis>significand</emphasis>), and <inlineequation><alt><![CDATA[e]]></alt><mathphrase><![CDATA[e]]></mathphrase></inlineequation> bits to represent the
exponent.</simpara>
<simpara>In IEEE floating point notation, numbers are commonly represented using
32 bits (known as <emphasis>single precision</emphasis>) or using 64 bits (known as <emphasis>double
precision</emphasis>). In single precision, <inlineequation><alt><![CDATA[m = 23]]></alt><mathphrase><![CDATA[m = 23]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[e = 8]]></alt><mathphrase><![CDATA[e = 8]]></mathphrase></inlineequation>. In double precision, <inlineequation><alt><![CDATA[m = 52]]></alt><mathphrase><![CDATA[m = 52]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[e = 11]]></alt><mathphrase><![CDATA[e = 11]]></mathphrase></inlineequation>. To represent positive and negative exponents, the
exponent has a <emphasis>bias</emphasis> added to it so that the result is never negative.
This bias is 127 for single precision and 1,023 for double precision.
The packing of the sign bit, the exponent, and the mantissa is shown in
<xref linkend="numberRepresentationFigure"/> (a) and (b).</simpara>
<simpara>The following is a step-by-step demonstration of how to construct the
single precision binary representation in IEEE format of the number
10.5.</simpara>
<orderedlist numeration="start">
<listitem>
<simpara>Convert 10.5 to its binary equivalent using methods described
earlier, yielding <inlineequation><alt><![CDATA[10.5_{10} = 1010.1_{2}]]></alt><mathphrase><![CDATA[10.5_{10} = 1010.1_{2}]]></mathphrase></inlineequation>. Unlike the case
of integers, the sign of the number is taken care of separately for
floating point. Thus, we would use <inlineequation><alt><![CDATA[1010.1_2]]></alt><mathphrase><![CDATA[1010.1_2]]></mathphrase></inlineequation> for
<inlineequation><alt><![CDATA[-10.5]]></alt><mathphrase><![CDATA[-10.5]]></mathphrase></inlineequation> as well.</simpara>
</listitem>
<listitem>
<simpara>Write this binary number in standardized floating point notation,
yielding <inlineequation><alt><![CDATA[1.0101\times2^3]]></alt><mathphrase><![CDATA[1.0101\times2^3]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>Remove the leading bit (always a 1 for non-zero numbers), leaving <literal>0101</literal>.</simpara>
</listitem>
<listitem>
<simpara>Pad the fraction with zeroes on the right to fill the 23-bit
mantissa, yielding <literal>0101 0000 0000 0000 0000 000</literal>. Note that the decimal
point is ignored in this step.</simpara>
</listitem>
<listitem>
<simpara>Add 127 to the exponent. This gives us an exponent of
<inlineequation><alt><![CDATA[3+127=130]]></alt><mathphrase><![CDATA[3+127=130]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>Convert the exponent to its 8-bit unsigned binary equivalent. Doing
so gives us <inlineequation><alt><![CDATA[130_{10}=10000011_2]]></alt><mathphrase><![CDATA[130_{10}=10000011_2]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>Set the sign bit to 0 if the number is positive and to 1 otherwise.
Since 10.5 is positive, we set the sign bit to 0.</simpara>
</listitem>
</orderedlist>
<simpara>We now have the three components of 10.5 in binary. The memory
representation of 10.5 is shown in <xref linkend="numberRepresentationFigure"/> (c).
Note in the figure how the sign bit, the exponent, and the mantissa are
packed into 32 bits.</simpara>
<figure xml:id="numberRepresentationFigure">
<title>Layouts for floating point representation (a) in single precision, (b) in double precision, and (c) of <inlineequation><alt><![CDATA[10.5_{10}]]></alt><mathphrase><![CDATA[10.5_{10}]]></mathphrase></inlineequation> in single precision.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/01-computer-basics/images/numberRepresentationFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>numberRepresentationFigure</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_largest_and_smallest_numbers">
<title>Largest and smallest numbers</title>
<simpara>Fixing the number of bits used for representing a real number limits the
numbers that can be represented in computer memory using the floating
point notation. The largest rational number that can be represented in
single precision has an exponent of 127 (254 after bias) with a mantissa
consisting of all 1s:<?asciidoc-br?>
<literal>0 1111 1110 1111 1111 1111 1111 1111 111</literal><?asciidoc-br?>
This number is approximately <inlineequation><alt><![CDATA[3.402\times10^{38}]]></alt><mathphrase><![CDATA[3.402\times10^{38}]]></mathphrase></inlineequation>. To
represent the smallest (closest to zero) non-zero number, we need to
examine one more complication in the IEEE format. An exponent of 0
implies that the number is unnormalized. In this case, we no longer
assume that there is a 1 bit to the left of the mantissa. Thus, the
smallest non-zero single precision number has its exponent set to 0 and
its mantissa set to all zeros with a 1 in its
23<inlineequation><alt><![CDATA[^{\mathrm{rd}}]]></alt><mathphrase><![CDATA[^{\mathrm{rd}}]]></mathphrase></inlineequation> bit:<?asciidoc-br?>
<literal>0 0000 0000 0000 0000 0000 0000 0000 001</literal><?asciidoc-br?>
Unnormalized single precision values are considered to have an exponent
of -126. Thus, the value of this number is
<inlineequation><alt><![CDATA[2^{-23} \times 2^{-126} =
2^{-149} \approx 1.4 \times 10^{-45}.]]></alt><mathphrase><![CDATA[2^{-23} \times 2^{-126} =
2^{-149} \approx 1.4 \times 10^{-45}.]]></mathphrase></inlineequation> Now that we know the rules for
storing both integers and floating point numbers, we can list the
largest and smallest values possible in 32- and 64-bit representations
in Java as shown in the following table. Note that <emphasis role="strong">largest</emphasis> means the
largest positive number for both integers and floating point values, but
<emphasis role="strong">smallest</emphasis> means the most negative number for integers and the smallest
positive non-zero value for floating point values.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Format</entry>
<entry align="left" valign="top">Largest number</entry>
<entry align="left" valign="top">Smallest number</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>32-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara>2,147,483,647</simpara></entry>
<entry align="left" valign="top"><simpara>-2,147,483,648</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>64-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara>9,223,372,036,854,775,807</simpara></entry>
<entry align="left" valign="top"><simpara>-9,223,372,036,854,775,808</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32-bit floating point</simpara></entry>
<entry align="left" valign="top"><simpara>3.4028235 Ã 10<superscript>38</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>1.4 Ã 10<superscript>-45</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>64-bit floating point</simpara></entry>
<entry align="left" valign="top"><simpara>1.7976931348623157 Ã 10<superscript>308</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>4.9<superscript>-324</superscript></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Using the same number of bits, floating point representation can store
much larger numbers than integer representation. However, floating point
numbers are not always exact, resulting in approximate results when
performing arithmetic. Always use integer formats when fractional parts
are not needed.</simpara>
</section>
<section xml:id="_special_numbers">
<title>Special numbers</title>
<simpara>Several binary representations in the floating point notation correspond
to special numbers. These numbers are set aside and not used for results
in normal computation.</simpara>
<variablelist>
<varlistentry>
<term>0.0 and -0.0</term>
<listitem>
<simpara>When the exponent as well as the mantissa is 0, the number is
interpreted as a 0.0 or -0.0 depending on the sign bit. For example,
in a Java program, dividing 0.0 by -1.0 results in -0.0. Similarly,
-0.0 divided by -1.0 is 0.0. Positive and negative zeroes only exist
for floating point values. -0 is the same as 0 for integers. Dividing
the integer 0 by -1 in Java results in 0 and not in -0.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Positive and negative infinity</term>
<listitem>
<simpara>An overflow or an underflow might occur while performing arithmetic on
floating point values. In the case of an overflow, the resulting
number is the special value that Java recognizes as infinity. In the
case of an underflow, it is a special negative infinity value. For
example, dividing 1.0 by 0.0 in Java results in infinity and dividing
-1.0 by 0.0 results in negative infinity. These values have well
defined behavior. For example, adding 1.0 to infinity yields infinity.
+
Note that floating point values and integers do not behave in the same
way. Dividing the integer 1 by the integer 0 creates an error that can
crash a Java program.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Not-a-number (<literal>NaN</literal>)</term>
<listitem>
<simpara>Some mathematical operations may result in an undefined number. For
example, <inlineequation><alt><![CDATA[\sqrt{-2}]]></alt><mathphrase><![CDATA[\sqrt{-2}]]></mathphrase></inlineequation> is an imaginary number. Java has a
value set aside for results that are not rational numbers. When we
discuss how to find the square root of a value in Java, this
not-a-number value will be the answer for the square root of a
negative number.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_errors_in_floating_point_arithmetic">
<title>Errors in floating point arithmetic</title>
<simpara>As we have seen, many rational numbers can only be approximately
represented in computer memory. Thus, arithmetic done on the approximate
values yields approximate answers. For example, 1.3 cannot be
represented exactly using a 32-bit value. In this case, the product
<inlineequation><alt><![CDATA[1.3\times
3.0]]></alt><mathphrase><![CDATA[1.3\times
3.0]]></mathphrase></inlineequation> will be 3.8999999 instead of 3.9. This error will propagate as
additional operations are performed on previous results. The next
example illustrates this propagation of errors when a sequence of
floating point operations are performed.</simpara>
<simpara>Suppose that the price of several products is to be added to determine
the total price of a purchase at a cash register that uses floating-point arithmetic with a 32-bit variable (the equivalent of a <literal>float</literal> in Java).
For simplicity, let&#8217;s assume that all items have a
price of $1.99. We don&#8217;t know how many items will be purchased ahead of
time and simply add the price of each item until all items have been
scanned at the register. The table below shows the value of the total
cost for different number of items purchased.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="right" valign="top">Items</entry>
<entry align="right" valign="top">Correct Cost</entry>
<entry align="right" valign="top">Calculated Cost</entry>
<entry align="right" valign="top">Absolute Error</entry>
<entry align="right" valign="top">Relative Error</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara>100</simpara></entry>
<entry align="right" valign="top"><simpara>199.0</simpara></entry>
<entry align="right" valign="top"><simpara>1.9900015E02</simpara></entry>
<entry align="right" valign="top"><simpara>1.5258789E-04</simpara></entry>
<entry align="right" valign="top"><simpara>7.6677333E-07</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>500</simpara></entry>
<entry align="right" valign="top"><simpara>995.0</simpara></entry>
<entry align="right" valign="top"><simpara>9.9499670E02</simpara></entry>
<entry align="right" valign="top"><simpara>3.2958984E-03</simpara></entry>
<entry align="right" valign="top"><simpara>3.3124606E-06</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>1000</simpara></entry>
<entry align="right" valign="top"><simpara>1990.0</simpara></entry>
<entry align="right" valign="top"><simpara>1.9899918E03</simpara></entry>
<entry align="right" valign="top"><simpara>8.1787109E-03</simpara></entry>
<entry align="right" valign="top"><simpara>4.1099051E-06</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara>10000</simpara></entry>
<entry align="right" valign="top"><simpara>19900.0</simpara></entry>
<entry align="right" valign="top"><simpara>1.9901842E04</simpara></entry>
<entry align="right" valign="top"><simpara>1.8417969E00</simpara></entry>
<entry align="right" valign="top"><simpara>9.2552604E-05</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The first column in the table above is the number of items. The second
column is the correct cost of all items purchased. The third column is
the cost calculated by adding each item using single precision floating
point addition. The fourth and fifth columns give the absolute and
relative errors, respectively, of the calculated value. Note how the
error increases as the number of additions goes up. In the last row, the
absolute error is almost two dollars.</simpara>
<simpara>While the above example may seem unrealistic, it does expose the
inherent dangers of floating-point calculations. Although the errors are
much less when using double precision representations, they still exist.</simpara>
</section>
</section>
</section>
<section xml:id="_solution_buying_a_computer">
<title>Solution: Buying a computer</title>
<simpara>We pose a motivating problem in the <emphasis role="strong">Problem</emphasis> section near the beginning
of most chapters. Whenever there is a <emphasis role="strong">Problem</emphasis> section, there is a
<emphasis role="strong">Solution</emphasis> section near the end in which we give a solution to the
problem given earlier.</simpara>
<simpara>After all the discussion of the hardware, software, and data
representation inside of a computer, you might feel more confused about
which computer to buy than before. As a programmer, it is important to
understand how data is represented, but this information plays virtually
no role in deciding which computer to buy. Unlike most problems in this
book, there is no concrete answer we can give here. Because the
development of technology progresses so rapidly, any advice about
computer hardware or software has a short shelf-life.</simpara>
<simpara>Software is a huge consideration, beginning with the OS. Because the
choice of OS usually affects choice of hardware, we&#8217;ll start there. The
three major choices for a desktop or laptop OS are Microsoft Windows,
Mac OS X, and Linux.</simpara>
<simpara>Windows is the most commonly used and is also heavily marketed for
business use. Windows suffered from many stability and security issues,
but Microsoft has worked hard to address these. Mac OS (and the
computers it is installed on) are marketed to an artistic and
counter-culture population. Linux is popular among tech savvy users.
Putting marketing biases aside, the three operating systems have become
more similar to each other over time, and most people could be
productive using any of the three. The following table lists some pros
and cons for each OS.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">OS</entry>
<entry align="left" valign="top">Pros</entry>
<entry align="left" valign="top">Cons</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Microsoft Windows</emphasis></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Compatible with the largest number of programs</simpara>
</listitem>
<listitem>
<simpara>Can be purchased separately from hardware</simpara>
</listitem>
<listitem>
<simpara>Can run on Mac hardware</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Expensive</simpara>
</listitem>
<listitem>
<simpara>Security concerns</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mac OS</emphasis></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Polished user interface</simpara>
</listitem>
<listitem>
<simpara>Bundled with many useful programs</simpara>
</listitem>
<listitem>
<simpara>Tested for use on the hardware it comes with</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Most expensive</simpara>
</listitem>
<listitem>
<simpara>Many business applications and games are released late or not at all for OS X</simpara>
</listitem>
<listitem>
<simpara>Difficult to run on non-Mac hardware</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Linux</emphasis></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Free</simpara>
</listitem>
<listitem>
<simpara>Runs on almost any hardware</simpara>
</listitem>
<listitem>
<simpara>Highly customizable</simpara>
</listitem>
<listitem>
<simpara>Serviced by a community that develops many free applications for it</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Can be difficult to install or configure</simpara>
</listitem>
<listitem>
<simpara>Few commercial applications are available for it</simpara>
</listitem>
<listitem>
<simpara>Limited customer support</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Once you have decided on an OS, you can pick hardware and other software
that is compatible with it. For Mac OS X, most of your hardware choices
will be computers sold by Apple. For Windows and Linux, you can either
have a computer built for you or build your own. Although computer
hardware changes quickly, let&#8217;s examine some general guidelines.</simpara>
<variablelist>
<varlistentry>
<term>CPU</term>
<listitem>
<simpara>Remember that the speed of a CPU is measured in GHz (billions of clock
cycles per second). Higher GHz is generally better, but it&#8217;s hard to
compare performance across different designs of CPU. There is also a
diminishing returns effect: The very fastest, very newest CPUs are
often considerably more expensive even if they only provide slightly
better performance. It&#8217;s usually more cost effective to select a CPU
in the middle of the performance spectrum.</simpara>
<simpara>Cache size also has a huge effect on performance. The larger the
cache, the less often the CPU has to read data from much slower
memory. Since most new CPUs available today are 64-bit, the question
of word size is not significant.</simpara>
<simpara>Although some specialists may prefer one or the other, both Intel and
AMD make powerful, competitive consumer CPUs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Memory</term>
<listitem>
<simpara>Memory includes RAM, hard drives, optical drives, and any other
storage. RAM is usually easy to upgrade for desktop machines and less
easy (though often possible) for laptops. The price of RAM per
gigabyte goes down over time. It may be reasonable to start with a
modest amount of RAM and then upgrade after a year or two when it
becomes cheaper to do so. It takes a little bit of research to get
exactly the right kind of RAM for your CPU and motherboard. The amount
of RAM is dependent on what you want to do with your system. The
minimum amount of RAM to run Microsoft Windows 7 is 1 GB for 32-bit
versions and 2 GB for 64-bit versions. The minimum amount of RAM to
run Apple Mac OS X 10.7 &#8220;Lion&#8221; is 2 GB. One rule of thumb is to have
at least twice the minimum required RAM.</simpara>
<simpara>Hard drive storage is heavily dependent on how you expect to use your
computer. 500 GB and 1 TB drives are not very expensive, and this
represents a huge amount of storage. Only if you plan to have enormous
libraries of video or uncompressed audio data will you likely need
more. Corporate level databases and web servers and some other
business systems can also require huge amounts of space. Hard drive
speed is greatly affected by the hard drive&#8217;s cache size. As always, a
bigger cache means better performance. Using a solid state drive (SSD)
instead of a traditional hard drive has much better performance but
higher cost.</simpara>
<simpara>Installing optical drives and other storage devices depends on
individual needs. Note that a DVD<inlineequation><alt><![CDATA[\pm]]></alt><mathphrase><![CDATA[\pm]]></mathphrase></inlineequation>RW drive is an
inexpensive solution for backing up data or reinstalling an operating
system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>I/O Devices</term>
<listitem>
<simpara>The subject of I/O devices is very personal. It is difficult to say
what anyone should buy without considering his or her specific needs.
A monitor is the essential visual output device while a keyboard and
mouse are the essential input devices. Speakers are very important as
well. Most laptops have all of these things integrated in some form or
another.</simpara>
<simpara>Someone interested in video games might want to invest in a powerful
graphics card. Newer cards with more video RAM are generally better
than older cards with less, but which card is best at a given price
point is the subject of continual discussion at sites like AnandTech
(<link xl:href="http://www.anandtech.com/">http://www.anandtech.com/</link>) and Tom&#8217;s Hardware
(<link xl:href="http://www.tomshardware.com/">http://www.tomshardware.com/</link>).</simpara>
<simpara>Printers are still useful output devices. Graphics tablets can make it
easier to create digital art on a computer. The number of potentially
worthwhile I/O devices is limitless.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This section is just a jumping off point for purchasing a computer. As
you learn more about computer hardware and software, it will become
easier to know what combination of the two will serve your needs. Of
course, there is always more to know, and technology changes quickly.</simpara>
<section xml:id="_concurrency_multicore_processors">
<title>Concurrency: Multicore processors</title>
<simpara>In the last decade, the word &#8220;core&#8221; has been splattered all over CPU
packaging. Intel in particular has marketed the idea heavily with its
Core, Core 2, i3 Core, i5 Core, and i7 Core chips. What are all these
cores?</simpara>
<simpara>Looking back into the past, most consumer processors had a single
<emphasis>core</emphasis>, or brain. They could only execute one instruction at a time.
(Even this definition is a little hazy, because pipelining kept more
than one instruction in the process of being executed, but overall
execution proceeded sequentially.)</simpara>
<simpara>The advent of multicore processors has changed this design
significantly. Each processor has several independent cores, each of
which can execute different instructions at the same time. Before the
arrival of multicore processors, a few desktop computers and many
supercomputers had multiple separate processors that could achieve a
similar effect. However, since multicore processors have more than one
effective processor on the same silicon die, the communication time
between processors is much faster and the overall cost of a
multi-processor system is cheaper.</simpara>
<section xml:id="_the_good">
<title>The Good</title>
<simpara>Multicore systems have impressive performance. The first multicore
processors had two cores, but current designs have four, six, or eight,
and much greater numbers are expected. A processor with eight cores can
execute eight different programs at the same time. Or, when faced with a
computationally intense problem like matrix math, code breaking, or
scientific simulation, a processor with eight cores could solve the
problem eight times as fast. A desktop processor with 100 cores that can
solve a problem 100 times faster is not out of reach.</simpara>
<simpara>In fact, modern graphics cards are already blazing this trail. Consider
the 1080p standard for high definition video, which has a resolution of
1,920 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 1,080 <emphasis>pixels</emphasis>. Each pixel (short for picture
element) is a dot on the screen. A screen whose resolution is 1080p has
2,073,600 dots. To maintain the illusion of smooth movement, these dots
should be updated around 30 times per second. Computing the color for
more than 2 million dots based on 3D geometry, lighting, and physics
effects 30 times a second is no easy feat. Some of the cards used to
render computer games have hundreds or thousands of cores. These cores
are not general purpose or completely independent. Instead, they&#8217;re
specialized to do certain kinds of matrix transformations and floating
point computations.</simpara>
</section>
<section xml:id="_the_bad">
<title>The Bad</title>
<simpara>Although chip-makers have spent a lot of money marketing multicore
technology, they have not spent much money explaining that one of the
driving forces behind the ``multicore revolution'' is a simple failure
to make processors faster in other ways. In 1965, Gordon Moore, one of
the founders of Intel, remarked that the density of silicon
microprocessors had been doubling every year (though he later revised
this to every two years), meaning that twice as many transistors
(computational building blocks) could fit in the same physical space.
This trend, often called Moore&#8217;s Law, has held up reasonably well. For
years, clever designs relying on shorter communication times,
pipelining, and other schemes succeeded in doubling the effective
performance of processors every two years.</simpara>
<simpara>At some point, the tricks became less effective and exponential gains in
processor clock rate could no longer be maintained. As clock frequency
increases, the signal becomes more chaotic, and it becomes more
difficult to tell the difference between the voltages that represent 0s
and 1s. Another problem is heat. The energy that a processor uses is
related to the <emphasis role="strong">square</emphasis> of the clock rate. This relationship means that
increasing the clock rate of a processor by a factor of 4 will increase
its energy consumption (and heat generation) by a factor of 16.</simpara>
<simpara>The legacy of Moore&#8217;s Law lives on. We are still able to fit more and
more transistors into tinier and tinier spaces. After decades of
increasing clock rate, chip-makers began using the additional silicon
density to make processors with more than one core instead. Since 2005
or so, increases in clock rate have stagnated.</simpara>
</section>
<section xml:id="_the_ugly">
<title>The Ugly</title>
<simpara>Does a processor with eight cores solve problems eight times as fast as
its single core equivalent? Unfortunately, the answer is, &#8220;Almost
never.&#8221; Most problems are not easy to break into eight independent
pieces.</simpara>
<simpara>For example, if you want to build eight houses and you have eight
construction teams, then you probably can get pretty close to completing
all eight houses in the time it would have taken for one team to build a
single house. But what if you have eight teams and only one house to
build? You might be able to finish the house a little early, but some
steps necessarily come after others: The concrete foundation must be
poured and solid before framing can begin. Framing must be finished
before the roof can be put on. And so on.</simpara>
<simpara>Like building a house, most problems you can solve on a computer are
difficult to break into concurrent tasks. A few problems are like
painting a house and can be completed much faster with lots of
concurrent workers. Other tasks simply cannot be done faster with more
than one team on the job. Worse, some jobs can actually interfere with
each other. If a team is trying to frame the walls while another team is
trying to put the roof onto unfinished walls, neither will succeed, the
house might be ruined, and people could get hurt.</simpara>
<simpara>On a desktop computer, individual cores generally have their own level 1
cache but share level 2 cache and RAM. If the programmer isn&#8217;t careful,
he or she can give instructions to the cores that will make them fight
with each other, overwriting the memory that other cores are using and
potentially crashing the program or giving an incorrect answer. Imagine
if different parts of your brain were completely independent and fought
with one another. The words that came out of your mouth might be random
and chaotic and make no sense to your listener.</simpara>
<simpara>To recap, the first problem with concurrent programming is finding ways
to break down problems so that they can be solved faster with multiple
cores. The second problem is making sure that the different cores
cooperate so that the answer is correct and makes sense. These are not
easy problems, and many researchers are still working on finding better
ways to do both.</simpara>
<simpara>Some educators believe that beginners will be confused by concurrency
and should wait until later courses to confront these problems. We
disagree: Forewarned is forearmed. Concurrency is an integral part of
modern computation, and the earlier you get introduced to it, the more
familiar it will be.</simpara>
</section>
</section>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>This introductory chapter focused on the fundamentals of a computer. We
began with a description of computer hardware, including the CPU,
memory, and I/O devices. We also described the software of a computer,
highlighting key programs such as the operating system and compilers as
well as other useful programs like business applications, video games,
and web browsers.</simpara>
<simpara>Then, we introduced the topic of how numbers are represented inside the
computer. Various number systems and conversion from one system to
another were explained. We discussed how floating point notation is used
to represent rational numbers. A sound knowledge of data representation
helps a programmer decide what kind of data to use (integer or floating
point and how much precision) as well as what kind of errors to expect
(overflow, underflow, and floating point precision errors).</simpara>
<simpara>The next chapter extends the idea of data representation into the
specific types of data that Java uses and introduces representation
systems for individual characters and text.</simpara>
</section>
<section xml:id="_problems">
<title>Problems</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Name a few programming languages other than Java.</simpara>
</listitem>
<listitem>
<simpara>What is the difference between machine code and bytecode?</simpara>
</listitem>
<listitem>
<simpara>What are some advantages of JIT compilation over traditional,
ahead-of-time compilation?</simpara>
</listitem>
<listitem>
<simpara>Without converting to decimal, how can one find out whether a given
binary number is odd or even?</simpara>
</listitem>
<listitem>
<simpara>Convert the following positive binary numbers into decimal.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[100_2]]></alt><mathphrase><![CDATA[100_2]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[111_2]]></alt><mathphrase><![CDATA[111_2]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[100000_2]]></alt><mathphrase><![CDATA[100000_2]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[111101_2]]></alt><mathphrase><![CDATA[111101_2]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[10101_2]]></alt><mathphrase><![CDATA[10101_2]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Convert the following positive decimal numbers into binary.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[15]]></alt><mathphrase><![CDATA[15]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[100]]></alt><mathphrase><![CDATA[100]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[1025]]></alt><mathphrase><![CDATA[1025]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[567,899]]></alt><mathphrase><![CDATA[567,899]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>What is the process for converting the representation of a binary
integer given in one&#8217;s complement into two&#8217;s complement?</simpara>
</listitem>
<listitem>
<simpara>Perform the conversion from one&#8217;s complement to two&#8217;s complement on the
representation <literal>1011 0111</literal>, which uses 8 bits for storage.</simpara>
</listitem>
<listitem>
<simpara>Convert the following decimal numbers to their hexadecimal and octal
equivalents.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[29]]></alt><mathphrase><![CDATA[29]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[100]]></alt><mathphrase><![CDATA[100]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[255]]></alt><mathphrase><![CDATA[255]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[382]]></alt><mathphrase><![CDATA[382]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[4,096]]></alt><mathphrase><![CDATA[4,096]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a table similar to the one on pageÂ  that lists the binary
equivalents of octal digits. Hint: Each octal digit can be represented
as a sequence of three binary digits.</simpara>
</listitem>
<listitem>
<simpara>Use this table to convert the following octal numbers to binary.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[337_8]]></alt><mathphrase><![CDATA[337_8]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[24_8]]></alt><mathphrase><![CDATA[24_8]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[777_8]]></alt><mathphrase><![CDATA[777_8]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>The ternary number system has a base of 3 and uses symbols 0, 1, and 2
to construct numbers.</simpara>
</listitem>
<listitem>
<simpara>Convert the following decimal numbers to their ternary equivalents.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[23]]></alt><mathphrase><![CDATA[23]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[333]]></alt><mathphrase><![CDATA[333]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[729]]></alt><mathphrase><![CDATA[729]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Convert the following decimal numbers to 8-bit, two&#8217;s complement binary
representations.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[-15]]></alt><mathphrase><![CDATA[-15]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[-101]]></alt><mathphrase><![CDATA[-101]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[-120]]></alt><mathphrase><![CDATA[-120]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Given the following 8-bit binary representations in two&#8217;s complement,
find their decimal equivalents.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>1100 0000</literal></simpara>
</listitem>
<listitem>
<simpara><literal>1111 1111</literal></simpara>
</listitem>
<listitem>
<simpara><literal>1000 0001</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Perform the following arithmetic operation on the following 8-bit, two&#8217;s
complement binary representations of integers. Check your answers by
performing arithmetic on equivalent decimal numbers.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>0000 0011</literal> + <literal>0111 1110</literal> =</simpara>
</listitem>
<listitem>
<simpara><literal>1000 1110</literal> + <literal>0000 1111</literal> =</simpara>
</listitem>
<listitem>
<simpara><literal>1111 1111</literal> + <literal>1000 0000</literal> =</simpara>
</listitem>
<listitem>
<simpara><literal>0000 1111</literal> - <literal>0001 1110</literal> =</simpara>
</listitem>
<listitem>
<simpara><literal>1000 0001</literal> - <literal>1111 1100</literal> =</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Extrapolate the rules for decimal and binary addition to rules for the
hexadecimal system. Then, use these rules to perform the following
additions in hexadecimal. Check your answers by converting the values
and their sums to decimal.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[\mathrm{A}2\mathrm{F}_{16} + \mathrm{BB}_{16} =]]></alt><mathphrase><![CDATA[\mathrm{A}2\mathrm{F}_{16} + \mathrm{BB}_{16} =]]></mathphrase></inlineequation><?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[32\mathrm{C}_{16} + \mathrm{D}11\mathrm{F}_{16} =]]></alt><mathphrase><![CDATA[32\mathrm{C}_{16} + \mathrm{D}11\mathrm{F}_{16} =]]></mathphrase></inlineequation><?asciidoc-br?></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Expand ExampleÂ  assuming that you have ten bits to represent the
fraction. Convert the representation back to base 10. How far off is
this value from 0.3?</simpara>
</listitem>
<listitem>
<simpara>Will the process in ExampleÂ  ever terminate assuming that we can use as
many bits as needed to represent 0.3 in binary?</simpara>
</listitem>
<listitem>
<simpara>Derive the binary representation of the following decimal numbers
assuming 32-bit (single) precision representation using the IEEE
floating point format.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[0.0125]]></alt><mathphrase><![CDATA[0.0125]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[7.7]]></alt><mathphrase><![CDATA[7.7]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[-10.3]]></alt><mathphrase><![CDATA[-10.3]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>The IEEE 754 standard also defines a 16-bit (half) precision format. In
this format, there is one sign bit, five bits for the exponent, and ten
bits for the mantissa. This format is the same as single and double
precision in that it assumes that a bit with a value of 1 precedes the
ten bits in the mantissa. It also uses a bias of 15 for the exponent.
What is the largest decimal number that can be stored in this format?</simpara>
</listitem>
<listitem>
<simpara>Let <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation> denote three real numbers.
With real numbers, each of the equations below is true. Now suppose that
all arithmetic operations are performed using floating point
representations of these numbers. Indicate which of the following
expressions are still always true and which are sometimes false.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><inlineequation><alt><![CDATA[( a + b )+ c = a + ( b + c )]]></alt><mathphrase><![CDATA[( a + b )+ c = a + ( b + c )]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[a+b=b+a]]></alt><mathphrase><![CDATA[a+b=b+a]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[a \times b=b \times a]]></alt><mathphrase><![CDATA[a \times b=b \times a]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[a+0=a]]></alt><mathphrase><![CDATA[a+0=a]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[(a\times b)\times c=a\times (b\times c)]]></alt><mathphrase><![CDATA[(a\times b)\times c=a\times (b\times c)]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><inlineequation><alt><![CDATA[a\times (b+c)=(a\times b)+(a\times c)]]></alt><mathphrase><![CDATA[a\times (b+c)=(a\times b)+(a\times c)]]></mathphrase></inlineequation></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>What is a multicore microprocessor? Why do you think a multicore chip
might be better than a single core chip? Search on the Internet to find
the names of a few common multicore chips. Which chip does your computer
use?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Problem_Solving_and_Programming">
<title>Problem Solving and Programming</title>
<blockquote>
<attribution>
George PÃ³lya
</attribution>
<simpara>If you can&#8217;t solve a problem, then there is an easier problem you can solve: find it.</simpara>
</blockquote>
<section xml:id="_problem_how_to_solve_problems">
<title>Problem: How to solve problems</title>
<simpara>How do we solve problems in general? This question is the motivating
problem (or meta-problem, even) for this chapter. In fact, this question
is the motivating problem for this book. We want to understand the
process of solving problems with computers.</simpara>
<simpara>As we mentioned in the previous chapter, many <emphasis>computer programs</emphasis> such
as business applications and web browsers have already been created to
help people solve problems, but we want to solve new problems by writing
our own programs. The art of writing these programs is called <emphasis>computer
programming</emphasis> or just programming.</simpara>
<simpara>Many people reading this book will be computer science students, and
thatâs great. However, computers have found their way into every segment
of commercial enterprise and personal life. Consequently, programming
has become a general-purpose skill that can aid almost anyone in their
career, whether it is in transportation, medicine, the military,
commerce, or innumerable other areas.</simpara>
<section xml:id="_what_is_a_program">
<title>What is a program?</title>
<simpara>If you donât have a lot of experience with computer science, writing a
computer program may seem daunting. The programs that run on your
computer are complex and varied. Where would you start if you wanted to
create something like Microsoft Word or Adobe Photoshop?</simpara>
<simpara>A computer program is a sequence of instructions that a computer
follows. Even the most complex program is just a list of instructions.
The list can get very long, and sometimes the computer will jump around
the list when it makes decisions about what to do next.</simpara>
<simpara>Some people talk about how smart computers are becoming. A computer is
neither smart nor stupid because a computer has no intelligence to
measure. A computer is a machine like a sewing machine or an internal
combustion engine. It follows the instructions we give it blindly. It
doesnât have feelings or opinions about the instructions it receives.
Computers do exactly what we tell them to and rarely make mistakes.</simpara>
<simpara>Once in a while, a computer will make a mistake due to faulty
construction, a bad power source, or cosmic rays, but well over 99.999%
of the things that go wrong with computers are because some human
somewhere gave a bad instruction. This point is one of the most
challenging aspects of programming a computer. How do you organize your
thoughts so that you express to the computer exactly what you want it to
do? If you give a person directions to a drug store, you might say,
&#8220;Walk east for two blocks and then go into the third door on the
right.&#8221; The human will fill in all the necessary details: Stopping for
traffic, watching out for construction, and so on. Given a robot body, a
computer would do exactly what you say. The instructions never mentioned
<emphasis role="strong">opening</emphasis> the door, and so a computer might walk right through the
closed door, shattering glass in the process.</simpara>
</section>
<section xml:id="_what_is_a_programming_language">
<title>What is a programming language?</title>
<simpara>Whatâs the right level of detail for instructions for a computer? It
depends on the computer and the application. But how do we give these
instructions? Programs are composed of instructions written in a
<emphasis>programming language</emphasis>. In this book, we will use the Java programming
language.</simpara>
<simpara>Why canât the instructions be given in English or some other natural
language? If the previous example of a robot walking through a glass
door didnât convince you, consider the quote from Groucho Marx, &#8220;One
morning I shot an elephant in my pajamas. How he got into my pajamas,
Iâll never know.&#8221;</simpara>
<simpara>Natural languages are filled with idioms, metaphors, puns, and other
ambiguities. Good writers use these to improve their poetry and prose,
but our goal in this book is not to write poetry or prose. We want to
write instructions for a computer that are crystal clear.</simpara>
<simpara>Learning Java is not like learning Spanish or Swahili. Like most
programming languages, Java is highly structured. It has fewer than 100
reserved words and special symbols. There are no exceptions to its
grammatical rules. Donât confuse the process of designing a solution to
a problem with the process of implementing that solution in a
programming language. Learning to organize your thoughts into a
sequential list of instructions is different from learning how to
translate that list into Java or another programming language, but
thereâs a tight connection between the two.</simpara>
<simpara>Learning to program is patterning your mind to think like a machine, to
break everything down into the simplest logical steps. At first, Java
code will look like gobbledygook. Eventually, it will become so familiar
that a glance will tell you volumes about how a program works. Learning
to program is not easy, but the kind of logical analysis involved is
valuable even if you never program afterward. If you do need to learn
other programming languages in the future, it will be easy once youâve
mastered Java.</simpara>
</section>
<section xml:id="_an_example_problem">
<title>An example problem</title>
<simpara>This chapter takes a broad approach to solving problems with a computer,
but we need an example to make some of the steps concrete. We will use
the following problem from physics as an example throughout this
chapter.</simpara>
<simpara>A rubber ball is dropped on a flat, hard surface from height
<inlineequation><alt><![CDATA[h]]></alt><mathphrase><![CDATA[h]]></mathphrase></inlineequation>. What is the maximum height the ball will reach after
the <inlineequation><alt><![CDATA[k^{\mathrm{th}}]]></alt><mathphrase><![CDATA[k^{\mathrm{th}}]]></mathphrase></inlineequation> bounce? We will discuss the steps
needed to create a program to solve this problem in the next section.</simpara>
</section>
</section>
<section xml:id="_concepts_developing_software">
<title>Concepts: Developing software</title>
<section xml:id="_software_development_lifecycle">
<title>Software development lifecycle</title>
<simpara>The engineers who built the first digital computers also wrote the
programs for them. In those days, programming was closely tied to the
hardware, and the programs were not very long. As the capabilities of
computers have increased and programming languages have evolved,
computer programs have grown more and more complicated. Hundreds of
developers, testers, and managers are needed to write a set of programs
as complex as Microsoft Windows 10.</simpara>
<simpara>Organizing the creation of such complicated programs is challenging, but
the industry uses a process called the <emphasis>software development lifecycle</emphasis>
to help. This process makes large projects possible, but we can apply it
to the simpler programs we will write in this book as well. There are
many variations on the process, but we will use a straightforward
version with the following five steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Understand the problem:</emphasis> It seems obvious, but, when you go to
write a program, all kinds of details crop up. Consider a program that
stores medical records. Should the program give an error if a patientâs
age is over 150 years? What if advances in long life or cryogenic
storage make such a thing possible? What about negative ages? An unborn
child could be considered to have a negative age (or more outlandishly,
someone who had traveled back into the past using a time machine).</simpara>
<simpara>Even small details like these must be carefully considered to understand
a problem fully. In industry, understanding the problem is often tied to
a <emphasis>requirements document</emphasis>, in which a client lays out the features and
functionality that the final program should have. The &#8220;client&#8221; could
also be a manager or executive officer of the company you work for who
wants your development team to create a certain kind of program.
Sometimes the client does not have a strong technical background and
creates requirements that are difficult to fulfill or vaguely specified.
The creation of the requirements document can be a negotiation process
in which the software development team and their client decide together
what features are desirable and reasonable.</simpara>
<simpara>If you are taking a programming class, you can think of your instructor
as your client. Then, you can view a programming assignment as a
requirements document and your grade as your payment awarded based on
how well the requirements were fulfilled.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Design a solution:</emphasis> Once you have a good grasp on the problem, you
can begin to design a solution. For large scale projects, this may
include decisions about the kinds of hardware and software packages that
will be needed to solve the problem. For this book, we will only talk
about problems that can be solved on standard desktop or laptop
computers with Java installed.</simpara>
<simpara>We will be interested only in the steps that the computer will have to
take to solve the problem. A finite list of steps taken to solve a
problem is called an <emphasis>algorithm</emphasis>. If you have ever done long division
(or any other kind of arithmetic by hand), you have executed an
algorithm. The steps for long division will work for any real numbers,
and most human beings can follow the algorithm without difficulty.</simpara>
<simpara>An algorithm is often expressed in <emphasis>pseudocode</emphasis>, a high level, generic,
code-like system of notation. Pseudocode is similar to a programming
language, but it doesnât have the same detail. Algorithms are often
designed in pseudocode so that they arenât tied to any one programming
language.</simpara>
<simpara>When attacking a problem, it is typical to break it into several smaller
subproblems and then create algorithms for the subproblems. This
approach is called <emphasis>top-down</emphasis> programming.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Implement the solution:</emphasis> Once you have your solution planned, you
can <emphasis>implement</emphasis> it in a programming language. This step entails taking
all the pseudocode, diagrams, and any other plans for your solution and
translating them into code in a programming language. We will always use
Java for our language in this book, but real developers use whichever
language they feel is appropriate.</simpara>
<simpara>If you have designed your solution with several parts, you can implement
each one separately and then integrate the solutions together.
Professional developers often assign different parts of the solution to
different programmers or even different teams of programmers.</simpara>
<simpara>Students are often tempted to jump into the implementation step, but
never forget that this is the third step of the process. If you donât
fully understand the problem and have a plan to attack it, the
implementation process can become bogged down and riddled with mistakes.
At first, the problems we introduce and the programs needed to solve
them will be simple. As you move into more complicated problems in this
book and in your career as a programmer, a good understanding of the
problem and a good plan for a solution will become more and more
important.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Test the solution:</emphasis> Expressing your algorithm in a programming
language is difficult. If your algorithm was wrong, your program will
not always give the right answer. If your algorithm was right, but you
made a mistake implementing it in code, your program will still be
wrong. Programming is a very detail-oriented activity. Even experienced
developers make mistakes constantly.</simpara>
<simpara>Good design practices help, but all code must be thoroughly tested after
it has been implemented. It should be tested exhaustively with expected
and unexpected input. Tiny mistakes in software called <emphasis>bugs</emphasis> can lie
hidden for months or even years before they are discovered. Sometimes a
software bug is a source of annoyance to the user, but other times, as
in aviation, automotive, or medical software, people die because of
bugs.</simpara>
<simpara>Most of this book is dedicated to designing solutions to problems and
implementing them in Java, but ChapterÂ <xref linkend="chapter:Testing_and_Debugging"/>
is all about testing and debugging.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Maintenance:</emphasis> Imagine that you have gone through the previous four
steps: You understood all the details of a problem, planned a solution
to it, implemented that solution in a programming language, and tested
it until it was perfect. What happens next?</simpara>
<simpara>Presumably your program was shipped to your customers and they happily
use it. But what if a bug is discovered that slipped past your testing?
What if new hardware comes out that is not compatible with your program?
What if your customers demand that you change one little feature?</simpara>
<simpara>Particularly with complex programs that have a large number of
consumers, a software development company must spend time on customer
support. Responsible software developers are expected to fix bugs, close
security vulnerabilities, and polish rough features. This process is
called <emphasis>maintenance</emphasis>. Developers are often working on the next version
of the product, which could be considered maintenance or a new project
entirely.</simpara>
<simpara>Although we cannot stress the importance of the first four steps of the
software development lifecycle enough, maintenance is not something we
talk about in depth.</simpara>
</listitem>
</orderedlist>
<simpara>The software development lifecycle we presented above is a good guide,
but it does not go into details. Different projects require different
amounts of time and energy for each step. It is also useful to focus on
the steps because it is less expensive to fix a problem at an earlier
stage in development. It is impossible to set the exact numbers, but
some developers assume that it takes ten times as much effort to fix a
problem at the current step than it would at the previous step.</simpara>
<example>
<title>Rising costs of fixing an error</title>
<simpara>Imagine that your company works on computer-aided design (CAD) software.
The requirements document for a new program lists the formula for the
area of a triangle as <inlineequation><alt><![CDATA[base \times height]]></alt><mathphrase><![CDATA[base \times height]]></mathphrase></inlineequation> when the real
formula is <inlineequation><alt><![CDATA[\frac{1}{2} base
\times height]]></alt><mathphrase><![CDATA[\frac{1}{2} base
\times height]]></mathphrase></inlineequation>. If that mistake were caught while understanding the
problem, it would mean changing one line of text. Once the solution to
the problem has been designed, there may be more references to the
incorrect formula. Once the solution has been implemented, those
references will have turned into code that is scattered throughout the
program. If the project were poorly designed, several different pieces
of code might independently calculate the area of a triangle
incorrectly. Once the implementation has been tested, a change to the
code will mean that everything has to be tested from the very beginning,
since fixing one bug can cause other bugs to surface. Finally, once the
maintenance stage has been reached, the requirements, plan,
implementation, and testing would all need to be updated to fix the bug.
Moreover, customers would already have the faulty program. Your company
would have to create a patch to fix the bug and distribute it over the
Internet or by mailing out CD-ROMs.</simpara>
<simpara>Most bugs are more complicated and harder to fix, but even this simple
one causes greater and greater repercussions as it goes uncaught. A
factor of ten for each level implies that it takes 10,000 times more
effort to fix it in the maintenance phase than at the first phase. Since
fixing it at the first phase would have required a few keystrokes and
fixing it in the last phase would require additional development and
testing with web servers distributing patches and e-mails and
traditional letters apologizing for the mistake, a factor of 10,000
could be a reasonable estimate.</simpara>
</example>
<simpara>Now that we have a sense of the software development lifecycle, letâs
look at an example using the sample ball bouncing problem to walk
through a few steps.</simpara>
<example>
<title>Ball bouncing problem and plan</title>
<simpara>Recall the statement of the problem from the <emphasis role="strong">Problem</emphasis> section:</simpara>
<simpara>A rubber ball is dropped on a flat, hard surface from height
<inlineequation><alt><![CDATA[h]]></alt><mathphrase><![CDATA[h]]></mathphrase></inlineequation>. What is the maximum height the ball will reach after
the <inlineequation><alt><![CDATA[k^{\mathrm{th}}]]></alt><mathphrase><![CDATA[k^{\mathrm{th}}]]></mathphrase></inlineequation> bounce?</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Understand the problem:</emphasis> This problem requires an understanding of
some physics principles. When a ball is dropped, the height of its first
bounce depends on a factor known as the <emphasis>coefficient of restitution</emphasis>.</simpara>
<simpara>If <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation> is the coefficient of restitution, then the ball will
bounce back the first time to a height of <inlineequation><alt><![CDATA[h\times c]]></alt><mathphrase><![CDATA[h\times c]]></mathphrase></inlineequation>. Then,
we can act as if the ball were being dropped from this new height when
calculating the next bounce. Thus, it will bounce to a height of
<inlineequation><alt><![CDATA[h\times c^2]]></alt><mathphrase><![CDATA[h\times c^2]]></mathphrase></inlineequation> the second time. By examining this pattern for
the third and fourth bounce, it becomes clear that the ball will bounce
to a height of <inlineequation><alt><![CDATA[h\times c^k]]></alt><mathphrase><![CDATA[h\times c^k]]></mathphrase></inlineequation> on the
<inlineequation><alt><![CDATA[k^{\mathrm{th}}]]></alt><mathphrase><![CDATA[k^{\mathrm{th}}]]></mathphrase></inlineequation> time. See FigureÂ <xref linkend="bouncingBallFigure"/>
for a graphic description of this process.</simpara>
<simpara>We are assuming that <inlineequation><alt><![CDATA[k > 0]]></alt><mathphrase><![CDATA[k > 0]]></mathphrase></inlineequation> and that <inlineequation><alt><![CDATA[c < 1]]></alt><mathphrase><![CDATA[c < 1]]></mathphrase></inlineequation>.
Note that <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation> depends on many factors, such as the
elasticity of the ball and the properties of the floor on which the ball
is dropped. However, if we know that we will be given <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation>,
we donât need to worry about any other details.</simpara>
<figure role="text-center">
<title>A ball is dropped from height <inlineequation><alt><![CDATA[h]]></alt><mathphrase><![CDATA[h]]></mathphrase></inlineequation>. The ball rises to height <inlineequation><alt><![CDATA[h c]]></alt><mathphrase><![CDATA[h c]]></mathphrase></inlineequation> after the first bounce and to <inlineequation><alt><![CDATA[hc^2]]></alt><mathphrase><![CDATA[hc^2]]></mathphrase></inlineequation> after the second.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/bouncingBall.svg" width="75%"/>
</imageobject>
<textobject><phrase>bouncingBall</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara><emphasis role="strong">Design a solution:</emphasis> This problem is straightforward, but itâs
always useful to practice good design. Remember that youâve got to plan
your input and output as well as the computation in a program. As
practice for more complicated problems, letâs break this problem down
into smaller subproblems.</simpara>
<variablelist>
<varlistentry>
<term>Subproblem 1</term>
<listitem>
<simpara>Get the values of <inlineequation><alt><![CDATA[h]]></alt><mathphrase><![CDATA[h]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation>, and
<inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation> from the user.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Subproblem 2</term>
<listitem>
<simpara>Compute the height of the ball after the <inlineequation><alt><![CDATA[k^{\mathrm{th}}]]></alt><mathphrase><![CDATA[k^{\mathrm{th}}]]></mathphrase></inlineequation>
bounce.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Subproblem 3</term>
<listitem>
<simpara>Display the calculated height.</simpara>
<simpara>The solution to each of the three subproblems requires input and
generates an output. FigureÂ <xref linkend="subProblemRelationFigure"/> shows how these
solutions are connected. The first box in this figure represents the
solution to subproblem 1. It asks a user to input values of parameters
<inlineequation><alt><![CDATA[h]]></alt><mathphrase><![CDATA[h]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation>. It sends these
values to the next box, which represents a solution to subproblem 2.
This second box computes the height of the ball after <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation>
bounces and makes it available to the third box, which represents a
solution to subproblem 3. This third box displays the calculated height.</simpara>
<figure role="text-center">
<title>Connections between solutions to the three subproblems in the bouncing ball problem.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/subProblemRelation.svg" width="75%"/>
</imageobject>
<textobject><phrase>subProblemRelation</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
<simpara>Before we can continue on to Step 3, we need to learn some Java.
SectionÂ <xref linkend="syntax:Java_basics"/> introduces you to the Java youâll need to
solve this problem.</simpara>
</example>
</section>
<section xml:id="_acquiring_a_java_compiler">
<title>Acquiring a Java compiler</title>
<simpara>Before we introduce any Java syntax, you should make sure that you have
a Java compiler set up so that you can follow along and test your
solution. Programming is a hands-on skill. It is impossible to improve
your programming abilities without practice. No amount of reading about
programming is a substitute for the real thing.</simpara>
<simpara>Where can you get a Java compiler? Fortunately, there are free options
for almost every platform. Non-Windows computers may already have the
Java Runtime Environment (JRE) installed, allowing you to run Java
programs; however, most Java development options require you to have the
Java Development Kit (JDK). Oracle may change the website, but at the
time of writing you can download the JDK from
<link xl:href="http://www.oracle.com/technetwork/java/javase/downloads/">http://www.oracle.com/technetwork/java/javase/downloads/</link>. Download the
latest version (Jave SE 7 at the time of writing) of the Java Platform,
Standard Edition JDK and install it.</simpara>
<simpara>After having done so, you should be able to compile programs using the
<literal>javac</literal> command, whose name is short for &#8220;Java compiler.&#8221; To do so,
open a terminal window, also known as a command line interface or the
console. To open the terminal in Windows, choose the Command Prompt
option from the Start Menu or press Windows+R and type <literal>cmd</literal> into the
Run box (or the Search box in the Start Menu in Windows 7). To open the
terminal in Mac OS X, select Terminal from the Utilities folder. Linux
users are usually familiar with their terminal.</simpara>
<simpara>Provided that you have your path set correctly, you should be able to
open the terminal, navigate to a directory containing files that end in
<literal>.java</literal>, and compile them using the <literal>javac</literal> command. For example, to
compile a program called <literal>Example.java</literal> to bytecode, you would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">javac Example.java</programlisting>
<simpara>Compiling the program creates a <literal>.class</literal> file, in this case,
<literal>Example.class</literal>. To run the program contained in <literal>Example.class</literal>, you
would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">java Example</programlisting>
<simpara>Doing so fires up the JVM, which uses the JIT compiler to compile the
bytecode inside <literal>Example.class</literal> into machine code and run it. Note that
you would only type <literal>Example</literal> not <literal>Example.class</literal> when specifying the
program to run. Using just these commands from the terminal, you can
compile and run Java programs. The command line interface used to be the
only way to interact with a computer, and, though it seems primitive at
first, the command line has amazing power and versatility.</simpara>
<simpara>To use the command line interface to compile your own Java program, you
must first create a text file with your Java code in it. The world of
programming is filled with many text editor applications whose only
purpose is to make writing code easier. These editors are not like
Microsoft Word: They are not used to format the text into paragraphs or
apply bold or italics. Their output is a raw (&#8220;plain&#8221;) text file,
containing only unformatted characters, similar to the files created by
Notepad. Many text editors, however, have advanced features useful for
programmers, such as syntax highlighting (marking special words and
symbols in the language with corresponding colors or fonts),
language-appropriate auto-completion, and powerful find and replace
tools. Two of the most popular text editors for command line use are
vi-based editors, particularly Vim, and Emacs-based editors,
particularly GNU Emacs.</simpara>
<simpara>Many computer users, however, are used to a <emphasis>graphical user interface</emphasis>
(GUI), where a mouse can be used to interact with windows, buttons, text
boxes, and other elements of a modern user interface. There are many
Java programming environments that provide a GUI from which a user can
write Java code, compile it, execute it, and even test and debug it.
Because these tools are integrated into a single program, these
applications are called <emphasis>integrated development environments</emphasis> (IDEs).</simpara>
<simpara>Two of the most popular Java IDEs are Eclipse and the NetBeans IDE,
which are both open-source, free, and available at
<link xl:href="http://www.eclipse.org/">http://www.eclipse.org/</link> and <link xl:href="http://netbeans.org/">http://netbeans.org/</link>, respectively. At the
time of writing, Eclipse is the most popular Java IDE for professional
developers. Both Eclipse and NetBeans are powerful and complex tools.
DrJava is a much simpler (and highly recommended) IDE, designed for
students and Java beginners. It is also free and is available from
<link xl:href="http://www.drjava.org/">http://www.drjava.org/</link>.</simpara>
<simpara>Which command line text editor or graphical IDE you use is up to you.
Programming is a craft, and every craftsman has his or her favorite
tools. Most of the content of this book is completely independent from
the tools you use to write and compile your code. One exception is
ChapterÂ <xref linkend="chapter:Testing_and_Debugging"/>, in which we briefly discuss
the debugging tools in Eclipse and DrJava.</simpara>
<simpara>If you choose Eclipse, NetBeans, or another complex IDE, you may wish to
read some online tutorials to get started. These IDEs often require the
user to create a project and then put Java files inside. The idea of a
project that contains many related source code documents is a useful one
and is very common in software engineering, but it is not a part of Java
itself.</simpara>
</section>
</section>
<section xml:id="_syntax_java_basics">
<title>Syntax: Java basics</title>
<simpara>In this section, we start with the simplest Java programs and work up to
the solution to the bouncing ball problem. Java was first released in
1995, a long time ago in the history of computer science. However, Java
was based on many previous languages. Its <emphasis>syntax</emphasis> (the rules for
constructing legal Java programs, just as English grammar is the rules
for constructing legal English sentences) inherits ideas from C, C++,
and other languages.</simpara>
<simpara>Some critics have complained about elements of the syntax or semantics
of Java. <emphasis>Semantics</emphasis> are rules for what code means. Remember that Java
is an arbitrary system, designed by fallible human beings. The rules for
building Java programs are generally logical, but they are artificial.
Learning a new programming language is a process of accepting a set of
rules and coming up with ways to use those rules to achieve your own
ends.</simpara>
<simpara>There are reasons behind the rules, but we will not always be able to
explain those reasons in this book. As you begin to learn Java, you will
have to take it on faith that such-and-such a rule is necessary, even
though it seems useless or mysterious. In time, these rules will become
familiar and perhaps sensible. The mystery will fade away, and the rules
will begin to look like an organic and logical (though perhaps
imperfect) system.</simpara>
<section xml:id="_java_program_structure">
<title>Java program structure</title>
<simpara>The first rule of Java is that all code goes inside of a <emphasis>class</emphasis>. A
class is a container for blocks of code called <emphasis>methods</emphasis> and it can also
be used as a template to create <emphasis>objects</emphasis>. Weâll talk a bit more about
classes in this chapter and then focus on them heavily in
ChapterÂ <xref linkend="chapter:Classes"/>.</simpara>
<simpara>For now, you only need to remember that every Java program has at least
one class. It is possible to put more than one class in a file, but you
can only have one top-level <emphasis>public</emphasis> class per file. A public class is
one that can be used by other classes. Almost every class in this book
is public, and they should be clearly marked as such. To create a public
class called <literal>Example</literal>, you would type the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
}</programlisting>
<simpara>A few words in Java have a special meaning and cannot be used for
anything else (like naming a class). These are called <emphasis>keywords</emphasis> or
<emphasis>reserved words</emphasis>. The keyword <literal>public</literal> marks the class as public. The
keyword <literal>class</literal> states that you are declaring a class. The name
<literal>Example</literal> gives the name of the class. By convention, all class names
start with a capital letter. The braces (<literal>\{</literal> and <literal>\}</literal>) mark the start
and end of the contents of the class. Right now, our class contains
nothing.</simpara>
<simpara>This text should be saved in a file called <literal>Example.java</literal>. It is
required that the name of the public class matches the file that itâs
in, including capitalization. Once <literal>Example.java</literal> has been saved, you
can compile it into bytecode. However, since thereâs nothing in class
<literal>Example</literal>, you canât run it as a program.</simpara>
<simpara>A program is a list of instructions, and that list has to start
somewhere. For a normal Java application, that place is the <literal>main()</literal>
method. (Throughout this book, we always append parentheses <literal>()</literal> to mark
the name of a method.) If we want to do something inside of <literal>Example</literal>,
weâll have to add a <literal>main()</literal> method like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
    }
}</programlisting>
<simpara>There are several new items now. As before, <literal>public</literal> means that other
classes can use the <literal>main()</literal> method. The <literal>static</literal> keyword means that the
method is associated with the class as a whole and not a particular
object. The <literal>void</literal> keyword means that the method does not give back an
answer. The word <literal>main</literal> is obviously the name of the method, but it has
to be spelled exactly that way (including capitalization) to work.
Perhaps the most confusing part is the expression <literal>String[] args</literal>, which
is a list of text (strings) given as input to the <literal>main()</literal> method from
the command line. As with the class, the braces mark the start and end
of the contents of the <literal>main()</literal> method, which is currently empty.</simpara>
<simpara>Right now, you donât need to understand any of this. All you need to
know is that, to start a program, you need a <literal>main()</literal> method and its
syntax is always the same as the code listed above. If you save this
code, you can compile <literal>Example.java</literal> and then run it, andâ¦nothing
happens! It is a perfectly legal Java program, but the list of
instructions is empty.</simpara>
</section>
<section xml:id="_command_line_input_and_output">
<title>Command line input and output</title>
<simpara>An important thing for a Java program to do is to communicate with the
outside world (where we live). First, letâs look at printing data to the
command line and reading data in from the command line.</simpara>
<section xml:id="_the_literal_system_out_print_literal_method">
<title>The <literal>System.out.print()</literal> method</title>
<simpara>Methods allow us to perform actions in Java. They are blocks of code
packaged up with a name so that we can run the same piece of code
repeatedly but with different inputs. We discuss them in much greater
depth in ChapterÂ <xref linkend="chapter:Methods"/>.</simpara>
<simpara>A common method for output is <literal>System.out.print()</literal>. The input (usually
called <emphasis>arguments</emphasis>) to a method are given between its parentheses. Thus,
if we want to print <literal>42</literal> to the terminal, we type:</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.print(42);</programlisting>
<simpara>Note that the use of the method has a semicolon (<literal>;</literal>) after it. An
executable line of code in Java generally ends with a semicolon to
separate it from the next instruction. We can add this code to our
<literal>Example</literal> class, yielding:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.print(42);
    }
}</programlisting>
<simpara>If we want to print out text, we give it as the argument to
<literal>System.out.print()</literal>, surrounded by double quotes (<literal>"</literal>). It is necessary
to surround text with quotes so that Java knows it is text and not the
name of a class, method, or variable. Text surrounded by double quotes
is called a <emphasis>string</emphasis>. The following program prints <literal>Forty two</literal> onto the
terminal.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.print("Forty two");
    }
}</programlisting>
<simpara>Printing out one thing is great, but programs are usually composed of
many instructions. Consider the following program:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.print(2);
        System.out.print(4);
        System.out.print(6);
        System.out.print(8);
    }
}</programlisting>
<simpara>As you can see, each executable line ends with a semicolon, and they are
executed in sequence. This code prints 2, 4, 6, and 8 onto the screen.
However, we did not tell the program to move the cursor to a new line at
any point. So, the output on the screen is <literal>2468</literal>, which looks like a
single number. If we want them to be on separate lines, we can achieve
this with the <literal>System.out.println()</literal> method, which moves to a new line
after it finishes output.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.println(2);
        System.out.println(4);
        System.out.println(6);
        System.out.println(8);
    }
}</programlisting>
<simpara>This change makes the output into the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">2
4
6
8</programlisting>
<simpara>In Java, it is possible to insert some math almost anywhere. Consider
the following program, which uses the <literal>+</literal> operator.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.print(35 + 7);
    }
}</programlisting>
<simpara>This code prints out <literal>42</literal> to the terminal just like our earlier example,
because it does the addition before giving the result to
<literal>System.out.print()</literal> for output.</simpara>
</section>
<section xml:id="_the_literal_scanner_literal_class">
<title>The <literal>Scanner</literal> class</title>
<simpara>We want to be able to read input from the user as well. For command line
input, we need to create a <literal>Scanner</literal> object. This object is used to read
data from the keyboard. The following program asks the user for an
integer, reads in an integer from the keyboard, and then prints out the
value multiplied by 2.</simpara>
<programlisting language="java" linenumbering="unnumbered">import java.util.Scanner;

public class Example {
    public static void main(String[] args) {
        Scanner in;
        in = new Scanner(System.in);
        System.out.print("Enter an integer: ");
        int value;
        value = in.nextInt();
        System.out.print("That number doubled is: ");
        System.out.println(value * 2);
    }
}</programlisting>
<simpara>This program introduces several new elements. First, note that it begins
with<?asciidoc-br?>
<literal>import java.util.Scanner;</literal>. This line of code tells the compiler to use
the <literal>Scanner</literal> class that is in the <literal>java.util</literal> <emphasis>package</emphasis>. A package is a
way of organizing a group of related classes. Someone else wrote the
<literal>Scanner</literal> class and all the other classes in the <literal>java.util</literal> package,
but, by importing the package, we are able to use their code in our
program.</simpara>
<simpara>Then, skip down to the first line in the <literal>main()</literal> method. The code
<literal>Scanner in;</literal> <emphasis>declares</emphasis> a <emphasis>variable</emphasis> called <literal>in</literal> with <emphasis>type</emphasis> <literal>Scanner</literal>.
A variable can hold a value. The variable has a specific type, meaning
the kind of data that the value can be. In this case, the type is
<literal>Scanner</literal>, meaning that the variable <literal>in</literal> holds a <literal>Scanner</literal> object.
Declaring a variable creates a box that can hold things of the specified
type. To declare a variable, first put the type you want it to have,
then put its <emphasis>identifier</emphasis> or name, and then put a semicolon. We chose to
call the variable <literal>in</literal>, but we could have called it <literal>input</literal> or even
<literal>marmalade</literal> if we wanted. It is always good practice to name your
variable so that it is clear what it contains.</simpara>
<simpara>The next line <emphasis>assigns</emphasis> a value to <literal>in</literal>. The assignment operator (<literal>=</literal>)
looks like an equal sign from math, but think of it as an arrow that
points left. Whatever is on the right side of the assignment operator
will be stored into the variable on the left. So, the variable <literal>in</literal> was
an initially empty box that could hold a <literal>Scanner</literal> object. The code
<literal>new Scanner(System.in)</literal> creates a brand new <literal>Scanner</literal> object based on
<literal>System.in</literal>, which means that the input will be from the keyboard. The
assignment stored this object into the variable <literal>in</literal>. The fact that
<literal>System.in</literal> was used has <emphasis role="strong">nothing</emphasis> to do with the fact that our variable
was named <literal>in</literal>. Again, donât expect to understand all the details at
first. Any time you need to read data from the keyboard, youâll need
these two lines of code, which you should be able to copy verbatim. It
is possible to both declare a variable and assign its value in one line.
Instead of the two line version, most programmers would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner(System.in);</programlisting>
<simpara>Similarly, the line <literal>int value;</literal> declares a variable for holding integer
types. The next line uses the object <literal>in</literal> to read an integer from the
user by calling the <literal>nextInt()</literal> method. If we wanted to read a floating
point value, we would have called the <literal>nextDouble()</literal> method. If we
wanted to read some text, we would have called the <literal>next()</literal> method.
Unfortunately, these differences means that we have to know what type of
data the user is going to enter. If the user enters an unexpected type,
our program could have an error. As before, we could combine the
declaration and the assignment into a single line:</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = in.nextInt();</programlisting>
<simpara>The final two lines give output for our program. The former prints
<literal>That number doubled is: ` to the terminal. The latter prints out a
value that is twice whatever the user entered. The next two examples
illustrate how `Scanner</literal> can be used to read input while solving
problems. The first example shows how these elements can be applied to
subproblem 1 of the bouncing ball problem, and the second example
introduces and solves a new problem.</simpara>
<example>
<title>Command line input</title>
<simpara>Subproblem 1 requires us to get the height, coefficient of restitution,
and number of bounces from the user. ProgramÂ <xref linkend="program:GetInputCLI"/>
shows a Java program to solve this subproblem.</simpara>
<formalpara xml:id="program:GetInputCLI" xreflabel="GetInputCLI">
<title>A Java program to get the height, coefficient of restitution, and number of bounces from the command line.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class GetInputCLI {
	public static void main(String[] args) {
    	// Create an object named in for input
        Scanner in = new Scanner(System.in); /*@\label{createScannerGetInputDataObject}@*/

        // Declare variables to hold input data
        double height, coefficient;
        int bounces;

        // Declare user prompt strings
        String enterHeight = "Enter the height: ";
        String enterCoefficient =
        	"Enter restitution coefficient: ";
        String enterBounces = "Enter the number of bounces: ";

        // Prompt the user and read data from the keyboard
        System.out.println("Bouncing Ball: Subproblem 1");
        System.out.print(enterHeight);
        height = in.nextDouble();
        System.out.print(enterCoefficient);
        coefficient = in.nextDouble();
        System.out.print(enterBounces);
        bounces = in.nextInt();
    }
}</programlisting>
</para>
</formalpara>
<simpara>Unlike our earlier example, the first line of <literal>GetInputCLI.java</literal> is
<literal>import java.util.*;</literal>. Instead of just importing the <literal>Scanner</literal> class,
this line imports all the classes in the <literal>java.util</literal> package. The
asterisk (<literal>*</literal>) is known as a <emphasis>wildcard</emphasis>. The wildcard notation is
convenient if you need to import several classes from a package or if
you donât know in advance the names of all the classes youâll need.</simpara>
<simpara>After the import comes the class declaration, creating a class called
<literal>GetInputCLI</literal>. We put a <literal>CLI</literal> at the end of this class name to mark that
it uses the command line interface, contrasting with the GUI version
that weâre going to show next. Inside the class declaration is the
definition of the <literal>main()</literal> method, showing where the program starts. The
text that comes after double slashes (<literal>//</literal>) are called <emphasis>comments</emphasis>.
Comments allow us to make our code more readable to humans, but the
compiler ignores them.</simpara>
<simpara>If you follow the comments, youâll see that we declare two <literal>double</literal>
variables (for holding double precision floating-point numbers) and an
<literal>int</literal> variable (for holding an integer value). Next we declare three
<literal>String</literal> variables and assign them three strings (segments of text).</simpara>
<simpara>The last section of code first prints out the name of the problem. Then,
it prints out the value stored into <literal>enterHeight</literal>, which is
<literal>"Enter the height: "</literal>. After this prompt, the line
<literal>height = in.nextDouble();</literal> tries to read in the height from the user.
It waits until the user hits enter before reading the value and moving
on to the next line. The last four lines of the program prompt and read
in the coefficient of restitution and then the number of bounces. If you
compile and run this program, the execution should match the steps
described. Note that it only reads in the values needed to solve the
problem. We have not added the code to compute the answer or display it.</simpara>
</example>
<example>
<title>Input for distance computation</title>
<simpara>Letâs write a program that takes as input the speed of a moving object
and the time it has been moving. The goal is to compute and display the
total distance it travels. We can divide this problem into the following
three subproblems.</simpara>
<variablelist>
<varlistentry>
<term>Subproblem 1</term>
<listitem>
<simpara>Input speed and duration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Subproblem 2</term>
<listitem>
<simpara>Compute distance traveled.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Subproblem 3</term>
<listitem>
<simpara>Display the computed distance.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>ProgramÂ <xref linkend="program:Distance"/> solves each of these subproblems in order,
using the command-line input and output tools we have just discussed.</simpara>
<formalpara xml:id="program:Distance" xreflabel="Distance">
<title>Program to compute the distance a moving object travels.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Distance {
    public static void main(String[] args) {
	    // Create an object named in for input
	    Scanner in = new Scanner(System.in);
        double speed, time;
        double distance; // Distance to be computed

        // Solution to subproblem 1: Read input
        // Prompt the user and get speed and time
        System.out.print("Enter the speed: "); /*@\label{solutionSubProblemOneScanner}@*/
        speed = in.nextDouble();/*@\label{getSpeed}@*/
        System.out.print("Enter the time: ");
        time = in.nextDouble();/*@\label{getDuration}@*/

        // Solution to subproblem 2: Compute distance
        distance = speed*time;/*@\label{solutionSubProblemTwoScanner}@*/

        // Solution to subproblem 3: Display output
        System.out.print("Distance traveled: ");
        System.out.print( distance );
        System.out.println(" miles.");
    }
}</programlisting>
</para>
</formalpara>
<simpara>The program starts with import statements, the class definition, and the
definition of the <literal>main()</literal> method. At the beginning of the <literal>main()</literal>
method, we have code to declare and initialize a variable of type
<literal>Scanner</literal> named <literal>in</literal>. We also declare variables of type <literal>double</literal> to hold
the input speed and time and the resulting distance.</simpara>
<simpara>Starting at lineÂ <xref linkend="solutionSubProblemOneScanner"/>, we solve subproblem
1, prompting the user for the speed and the time and using our <literal>Scanner</literal>
object to read them in. Because they are both floating-point values with
type <literal>double</literal>, we use the <literal>nextDouble()</literal> method for input.</simpara>
<simpara>At lineÂ <xref linkend="solutionSubProblemTwoScanner"/>, we compute the distance
traveled by multiplying <literal>speed</literal> by <literal>time</literal> and storing the result in
<literal>distance</literal>. The last three lines of the <literal>main()</literal> method solve subproblem
3 by outputting <literal>"Distance traveled: "</literal>, the computed distance, and
<literal>" miles."</literal>. If you run the program, all three items are printed on the
same line on the terminal.</simpara>
</example>
</section>
</section>
<section xml:id="_gui_input_and_output">
<title>GUI input and output</title>
<simpara>If you are used to GUI-based programs, you might wonder how to do input
and output with a GUI instead of on the command line. GUIs can become
very complex, but in this chapter we introduce a relatively simple way
to do GUI input and output and expand on it further in
ChapterÂ <xref linkend="chapter:Simple_Graphical_User_Interfaces"/>. Then, we go into
GUIs in much more depth in ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>.</simpara>
<simpara>A limited tool for displaying output and reading input with a GUI is the
<literal>JOptionPane</literal> class. This class has a complicated method called
<literal>showMessageDialog()</literal> that opens a small <emphasis>dialog box</emphasis> to display a
message to the user. If we want to create the equivalent of the
command-line program that displays the number 42, the code would be as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">import javax.swing.JOptionPane;

public class Example {
    public static void main(String[] args) {
        JOptionPane.showMessageDialog(null, "42", "Output Example",
            JOptionPane.INFORMATION_MESSAGE); }
}</programlisting>
<simpara>Like <literal>Scanner</literal>, we need to import <literal>JOptionPane</literal> as shown above in order
to use it. The <literal>showMessageDialog()</literal> method takes several arguments to
tell it what to do. For our purposes, the first one is always the
special Java literal <literal>null</literal>, which represents an empty value. The next
is the message you want to display, but it has to be text. Thatâs why
<literal>"42"</literal> appears with quotation marks. The third argument is the title
that appears at the top of the dialog. The final argument gives
information about how the dialog should be presented.
<literal>JOptionPane.INFORMATION_MESSAGE</literal> is a flag values that specifies that
the dialog is giving information (instead of a warning or a question),
causing an appropriate, system-specific icon to be displayed on the
dialog.</simpara>
<simpara>If we wanted to make the call to <literal>showMessageDialog()</literal> a little easier
to read, we could store the arguments into variables with short, easy to
understand names. The following program does so and should behave
exactly like the previous program. FigureÂ <xref linkend="figure:showMessageDialog"/>
shows what the resulting GUI might look like.</simpara>
<programlisting language="java" linenumbering="unnumbered">import javax.swing.JOptionPane;

public class Example {
    public static void main(String[] args) {
        String message = "42";
        String title = "Output Example";
        JOptionPane.showMessageDialog(null, message, title,
            JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
<figure role="text-center">
<title>Example of <literal>showMessageDialog()</literal> used for output.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/showMessageDialog.png" contentwidth="45%" align="text-center"/>
</imageobject>
<textobject><phrase>showMessageDialog</phrase></textobject>
</mediaobject>
</figure>
<simpara>One way to do input with a GUI uses the <literal>showInputDialog()</literal> method,
which is also inside the <literal>JOptionPane</literal> class. The <literal>showInputDialog()</literal>
method <emphasis>returns</emphasis> a value. This means that it gives back an answer, which
you can store into a variable by putting the method call on the right
hand side of an assignment statement. Otherwise, it is nearly the same
as <literal>showMessageDialog()</literal>. The following program prompts the user for his
or her favorite word with a <literal>showInputDialog()</literal> method and then displays
it again using a <literal>showMessageDialog()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">import javax.swing.JOptionPane;

public class Example {
    public static void main(String[] args) {
        String message = "What is your favorite word?";
        String title = "Input Example";
        String word =
        JOptionPane.showInputDialog(null, message, title,
            JOptionPane.QUESTION_MESSAGE);
        JOptionPane.showMessageDialog(null, word, title,
            JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
<simpara>Note that whatever the user typed in will be stored in <literal>word</literal>. Finally,
the last line of the program displays whatever word was entered with
<literal>showMessageDialog()</literal>. FigureÂ <xref linkend="figure:showInputDialog"/> shows the
resulting GUI as the user is entering input.</simpara>
<figure role="text-center">
<title>Example of <literal>showInputDialog()</literal> used for input.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/showInputDialog.png" contentwidth="45%" align="text-center"/>
</imageobject>
<textobject><phrase>showInputDialog</phrase></textobject>
</mediaobject>
</figure>
<simpara>Remember that the value returned from the <literal>showInputDialog()</literal> method is
always text, that is, it always has type <literal>String</literal>. Although there are
lots of great things you can do with a <literal>String</literal> value, you cannot do
normal arithmetic like you can with an integer or a floating-point
number. However, there are ways to convert a <literal>String</literal> representation of
a number to the number itself. If you have a <literal>String</literal> that represents an
integer, you use the <literal>Integer.parseInt()</literal> method to convert it. If you
have a <literal>String</literal> that represents a floating-point number, you use the
<literal>Double.parseDouble()</literal> method to convert it. The following segment of
code shows a few illustrations of the issues involved.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = "41" * 3;
// Text cannot be multiplied by an integer

int y = Integer.parseInt("23");
// Correctly converts the text "23" to the integer 23

double z = Double.parseDouble("3.14159");
// Correctly converts the text "3.14159" to 3.14159

int a = Integer.parseInt("Twenty three");
// Causes the program to crash

double b = Double.parseDouble("pi");
// Causes the program to crash</programlisting>
<simpara>You might wonder why the computer isnât smart enough to know that <literal>"23"</literal>
means <literal>23</literal>. Remember, the computer has no intelligence. If something is
marked as text, it doesnât know that it can interpret it as a number.
What kind of data something is depends on its type, which doesnât
change. Weâll discuss types more deeply in ChapterÂ <xref linkend="chapter:Primitive
Types and Strings"/>.</simpara>
<simpara>The next example uses these two type conversion methods with methods
from <literal>JOptionPane</literal> in a GUI-based solution to subproblem 1 of the
bouncing ball problem.</simpara>
<example>
<title>GUI input</title>
<simpara>We can change the solution given in ProgramÂ <xref linkend="program:GetInputCLI"/> to
use the GUI-based input tools in <literal>JOptionPane</literal>.
ProgramÂ <xref linkend="program:GetInputCLI"/> this equivalent GUI-based Java program.</simpara>
<formalpara xml:id="program:GetInputGUI" xreflabel="GetInputGUI">
<title>Program to get the height, coefficient of restitution, and number of bounces using a GUI.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class GetInputGUI {
	public static void main(String[] args) {
        String title = "Bouncing Ball: Subproblem 1";

        // Declare variables to hold input data
        double height, coefficient;
        int bounces;

        // Declare user prompt strings
        String enterHeight = "Enter the height: ";
        String enterCoefficient =
        	"Enter restitution coefficient: ";
        String enterBounces = "Enter the number of bounces: ";

        // Prompt the user, get data, and convert it
        String response = JOptionPane.showInputDialog(null,/*@\label{inputDialogLineOne}@*/
        	enterHeight, title, JOptionPane.QUESTION_MESSAGE);
        height = Double.parseDouble(response); /*@\label{convertToDoubleLineOne}@*/
        response = JOptionPane.showInputDialog(null,/*@\label{inputDialogLineTwo}@*/
        	enterCoefficient, title, JOptionPane.QUESTION_MESSAGE);
        coefficient = Double.parseDouble(response);/*@\label{convertToDoubleLineTwo}@*/
        response = JOptionPane.showInputDialog(null,/*@\label{inputDialogLineThree}@*/
        	enterBounces, title, JOptionPane.QUESTION_MESSAGE);
        bounces = Integer.parseInt(response);/*@\label{convertToDoubleLineThree}@*/
    }
}</programlisting>
</para>
</formalpara>
<simpara>The code in this program is very similar to
ProgramÂ <xref linkend="program:GetInputCLI"/> until lineÂ <xref linkend="inputDialogLineOne"/>. At
that point, we use the <literal>showInputDialog()</literal> method to read a <literal>String</literal>
version of the height from the user. On the next line, we have to
convert this <literal>String</literal> version into the <literal>double</literal> version that we store in
the <literal>height</literal> variable. The next four lines read in the coefficient of
restitution and the number of bounces and convert them to their
appropriate numerical types.</simpara>
</example>
</section>
<section xml:id="_a_few_operations">
<title>A few operations</title>
<section xml:id="_basic_math">
<title>Basic math</title>
<simpara>To make our code useful, we can perform operations on values and
variables. For example, we used the expression <literal>35 + 7</literal> as an argument
to the <literal>System.out.print()</literal> method to print <literal>42</literal> to the screen. We can
use the add (<literal>+</literal>), subtract (<literal>-</literal>), multiply (<literal>*</literal>), and divide(<literal>/</literal>)
operators on numbers to solve arithmetic problems. These operators work
the way you expect them to (except that division has a few surprises).
Weâll go into these operators and others more deeply in
ChapterÂ <xref linkend="chapter:Primitive_Types_and_Strings"/>. Here are examples of
these four operators used with integer and floating-point numbers.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 2 + 3;         // a will hold 5
int b = 2 - 3;         // b will hold -1
int c = 2 * 3;         // c will hold 6
int d = 2 / 3;         // d will hold 0 (explained later)

double x = 1.6 + 3.2;  // x will hold 4.8
double y = 1.6 - 3.2;  // y will hold -1.6
double z = 1.6 * 3.2;  // z will hold 5.12
double w = 1.6 / 3.2;  // w will hold 0.5</programlisting>
</section>
<section xml:id="_other_operations">
<title>Other operations</title>
<simpara>These basic operations can mix values and variables together. As we will
discuss later, they can be arbitrarily complicated with order of
operations determining the final answer. Nevertheless, we also need ways
to accomplish other mathematical operations such as raising a number to
a power or finding its square root. The <literal>Math</literal> class has methods that
perform these and other functions. To raise a number to a power, we call
<literal>Math.pow()</literal> with two arguments: first the base and then the exponent.
To find the square root, we pass the number to the <literal>Math.sqrt()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">double p = Math.pow(3.0, 2.5);
// Raises 3 to the power 2.5, approximately 15.588457
double q = Math.sqrt(2.0);
// Finds the square root of 2.0, approximately 1.4142136</programlisting>
<example>
<title>Compute height</title>
<simpara>We compute the final height of the ball in subproblem 2 of the bouncing
ball problem. To do so, we have to multiply the height by the
coefficient of restitution raised to the power of the number of bounces.
The following program does so, using the <literal>Math.pow()</literal> method.</simpara>
<formalpara xml:id="program:ComputeHeight" xreflabel="ComputeHeight">
<title>Program to compute height of a ball after bounces.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class ComputeHeight {
	public static void main(String[] args) {
		// Use dummy values to test subproblem 2
        double height = 15, coefficient = 0.3;
        int bounces = 10;
        // Compute height after bounces
        double bounceHeight = height*Math.pow(coefficient,bounces);/*@\label{computeHeight}@*/
        System.out.println(bounceHeight); // For testing
    }
}</programlisting>
</para>
</formalpara>
<simpara>ProgramÂ <xref linkend="program:ComputeHeight"/> is only focusing on subproblem 2, but,
if we want to test it, we need to supply some dummy values for <literal>height</literal>,
<literal>coefficient</literal>, and <literal>bounces</literal>, since these are read in by the solution to
subproblem 1. Likewise, the output statement on the last line of the
<literal>main()</literal> method is just for testing purposes. The complete solution has
more complex output.</simpara>
</example>
</section>
<section xml:id="_literal_string_literal_concatenation">
<title><literal>String</literal> concatenation</title>
<simpara>Just as we can add numbers together, we can also &#8220;add&#8221; pieces of text
together. In Java, text has the type <literal>String</literal>. If you use the <literal>+</literal>
operator between two values or variables of type <literal>String</literal>, the result is
a new <literal>String</literal> that is the <emphasis>concatenation</emphasis> of the two previous <literal>String</literal>
values, meaning that the result is the two pieces of text pasted
together, one after the other. Concatenation doesnât change the <literal>String</literal>
values you are concatenating.</simpara>
<simpara>At this point, it becomes confusing if you mix types (<literal>String</literal>, <literal>int</literal>,
<literal>double</literal>) together when doing mathematical operations. However, feel
free to concatenate <literal>String</literal> values with any other type using the <literal>+</literal>
operator. When you do so, the other type is automatically converted into
a <literal>String</literal>. This behavior is useful since any <literal>String</literal> is easy to
output. Here are a few examples of <literal>String</literal> concatenation.</simpara>
<programlisting language="java" linenumbering="unnumbered">String word1 = "tomato";
String word2 = "sauce";
String text1 = word1 + word2;
// text1 will contain "tomatosauce"
String text2 = word1 + " " + word2;
// text2 will contain "tomato sauce"
String text3 = "potato " + word1;
// text3 will contain "potato tomato"
String text4 = 5 + " " + word1 + "es";
// text4 will contain "5 tomatoes"</programlisting>
<example>
<title>Display height</title>
<simpara>With <literal>String</literal> concatenation, subproblem 3 becomes a bit easier. We
concatenate the results together with an appropriate message and then
use the <literal>System.out.println()</literal> method for output. The following program
does so.</simpara>
<formalpara xml:id="program:DisplayHeightCLI" xreflabel="DisplayHeightCLI">
<title>Program to display height of a ball using the command line.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class DisplayHeightCLI {
	public static void main(String[] args) {
		// Use dummy values to test subproblem 3
        int bounces = 10;
        double bounceHeight = 2.0;
        String message = "After " + bounces +
        	" bounces the height of the ball is: " +
        	bounceHeight + " feet";
        System.out.println(message);
    }
}</programlisting>
</para>
</formalpara>
<simpara>ProgramÂ <xref linkend="program:DisplayHeightCLI"/> is only focusing on subproblem 3,
but, if we want to test it, we need to supply dummy values for <literal>bounces</literal>
and <literal>bounceHeight</literal>, since these are generated by the solution to earlier
subproblems.</simpara>
<simpara>The same concatenation can be used for GUI output as well. The only
difference is the use of<?asciidoc-br?>
<literal>JOptionPane.showMessageDialog()</literal> instead of <literal>System.out.println()</literal>.</simpara>
<formalpara xml:id="program:DisplayHeightGUI" xreflabel="DisplayHeightGUI">
<title>Program to display height of a ball using a GUI.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class DisplayHeightGUI {
	public static void main(String[] args) {
        String title = "Bouncing Ball: Subproblem 3";
        // Use dummy values to test subproblem 3
        int bounces = 10;
        double bounceHeight = 2.0;
        String message = "After " + bounces +
    		" bounces the height of the ball is: " +
    		bounceHeight + " feet";
        JOptionPane.showMessageDialog(null, message, title,
        	JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
</example>
</section>
</section>
<section xml:id="_java_formatting">
<title>Java formatting</title>
<simpara>Writing good Java code has some similarities to writing effectively in
English. There are rules you have to follow in order to make sense, but
there are also guidelines that you should follow in order to make your
code easier to read for yourself and everyone else.</simpara>
<section xml:id="_variable_and_class_naming">
<title>Variable and class naming</title>
<simpara>Java programs are filled with variables, and each variable should be
named to reflect its contents. Variable names are essentially unlimited
in length (although the JVM you use may limit this length to thousands
of characters). A tremendously long variable name can be hard to read,
but abbreviations can be worse. You want the meaning of your code to be
obvious to others and to yourself when you come back days or weeks
later.</simpara>
<simpara>Imagine you are writing a program that sells fruit. Consider the
following names for a variable that keeps track of the number of apples.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Attributes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>a</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Too short, gives no useful information</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>apps</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Too short, vague, could mean applications or appetizers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cntr</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Too short, vague, could mean center</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>counter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not bad, but counting what?</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>theVariableUsedToCountApples</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Too long for no good reason</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>appleCounter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Very clear</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>apples</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Concise and clear, unless there are multiple apple quantities
such as <literal>applesSold</literal> and <literal>applesBought</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Mathematics is filled with one letter variables, partly because there is
a history of writing mathematics on chalkboards and paper. Clarity is
more important than brevity with variables in computer programs. Some
variables need more than one word to be descriptive. In that case,
programmers of Java are encouraged to follow <emphasis>camel case</emphasis>. In camel
case, multi-word variables and methods start with a lowercase letter and
then use an uppercase letter to mark the beginning of each new word. It
is called camel case because the uppercase letters are reminiscent of
the humps of a camel. Examples include <literal>lastValue</literal>, <literal>symbolTable</literal>, and
<literal>makeHamSandwich()</literal>.</simpara>
<simpara>By convention, class names should always begin with a capital letter,
but they also use camel case with a capital letter for the beginning of
each new word. Examples include <literal>LinkedList</literal>, <literal>JazzPiano</literal>, and
<literal>GlobalNuclearWarfare</literal>.</simpara>
<simpara>Another convention is that constants, variables whose value never
changes, have names in all uppercase, separated by underscores. Examples
include <literal>PI</literal>, <literal>TRIANGLE_SIDES</literal>, and
<literal>UNIVERSAL_GRAVITATIONAL_CONSTANT</literal>.</simpara>
<simpara>Spaces are not allowed in variable, method, or class names. Recall that
a name in Java is called an identifier. The rules for identifiers
specify that they must start with an uppercase or lowercase letter (or
an underscore) and that the remaining characters must be letters,
underscores, or numerical digits. Thus, <literal>mÃ¶tleyCrÃ¼e</literal>, <literal>Tupac</literal>, and even
the absurd <literal><emphasis>_</emphasis>5</literal> are legal identifiers, but <literal>Motley Crue</literal> and
<literal>2Pac</literal> are not. Java has support for many of the worldâs languages,
allowing identifiers to contain characters from Chinese, Thai,
Devanagari, Cyrillic, and other scripts.</simpara>
<simpara>Remember that keywords cannot be used as identifiers. For example,
<literal>public</literal>, <literal>static</literal>, and <literal>class</literal> are all keywords in Java and can never
be the names of classes, variables, or methods.</simpara>
</section>
<section xml:id="_white_space">
<title>White space</title>
<simpara>Although you are not allowed to have spaces in a Java identifier, you
can usually use white space (spaces, tabs, and new lines) wherever you
want. Java ignores extra space. Thus, this line of code:</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = y + 5;</programlisting>
<simpara>is equivalent to this one:</simpara>
<programlisting language="java" linenumbering="unnumbered">int x=y+5;</programlisting>
<simpara>We chose to type our earlier example of a program performing output as
follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example {
    public static void main(String[] args) {
        System.out.print(42);
    }
}</programlisting>
<simpara>However, we could have been more chaotic with our use of whitespace:</simpara>
<programlisting language="java" linenumbering="unnumbered">        public
class          Example {
public
    static void
    main (String     [
        ] args
        ) {
            System.
    out
        .print(42

) ; } }</programlisting>
<simpara>Or used almost none at all:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example{public static void main(String[]args){System.out.print(42);}}</programlisting>
<simpara>These three programs are identical in the eyes of the Java compiler, but
the first one is easier for a human to read. You should use whitespace
to increase readability. Donât add too much whitespace with lots of
blank lines between sections of code. On the other hand, donât use too
little and cramp the code together. Whenever code is nested inside of a
set of braces, indent the contents so that it is easy to see the
hierarchical relationship.</simpara>
<simpara>The style we present in this book puts the left brace (<literal>\{</literal>) on the line
starting a block of code. Another popular style puts the left brace on
the next line. Here is the same example program formatted in this style:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Example
{
    public static void main(String[] args)
    {
        System.out.print(42);
    }
}</programlisting>
<simpara>There are people (including some authors of this book) who prefer this
style because it is easier to see where blocks of code begin and end.
However, the other style uses less space, and so we use it throughout
the book. You can make your own choices about style, but be consistent.
If you work for a software development company, they may have strict
standards for code formatting.</simpara>
</section>
<section xml:id="_comments">
<title>Comments</title>
<simpara>As we mentioned before, you can leave comments in your code whenever you
want someone reading the code to have extra information. Java has three
different kinds of comments. We described single-line comments, which
start with a <literal>//</literal> and continue until the end of the line.</simpara>
<simpara>If you have a large block of text you want as a comment, you can create
a block comment, which starts with a <literal>/*</literal> and continues until it reaches
a <literal>*/</literal>.</simpara>
<simpara>Beyond leaving messages for other programmers, you can also &#8220;comment
out&#8221; existing code. By making Java code a comment, it no longer affects
the program execution. This practice is very common when programmers
want to remove or change some code but are reluctant to delete it until
the new version of the code has been tested.</simpara>
<simpara>The third kind of comment is called a documentation comment and
superficially looks a lot like a block comment. A documentation comment
starts with a <literal>/**</literal> and ends with a <literal>*/</literal>. These comments are supposed to
come at the beginning of classes and methods and explain what they are
used for and how to use them. A tool called <literal>javadoc</literal> is used to run
through documentation comments and generate an HTML file that users can
read to understand how to use the code. This tool is one of the features
that has contributed greatly to the popularity of Java, since its
libraries are well-documented and easy to use. However, we do not
discuss documentation comments deeply in this book.</simpara>
<simpara>Here is our example output program heavily commented.</simpara>
<programlisting language="java" linenumbering="unnumbered">/**
 *  Class Example prints the number 42 to the screen.
 *  It contains an executable main() method.
 */
public class Example {
    /*
     * The main() method was last updated by Barry Wittman.
     */
    public static void main(String[] args) {
        System.out.print(42);  // answer to everything
    }
}</programlisting>
<simpara>Comments are a wonderful tool, but clean code with meaningful variable
names and careful use of whitespace doesnât require too much commenting.
Never hesitate to comment, but always ask yourself if there is a way to
write the code so clearly that a comment is unnecessary.</simpara>
</section>
</section>
</section>
<section xml:id="_solution_how_to_solve_problems">
<title>Solution: How to solve problems</title>
<simpara>The problem solving steps given in SectionÂ <xref linkend="concepts:Developing
software"/> are sound, but they depend on being able to implement your
planned solution in Java. We have introduced far too little Java so far
to expect to solve <emphasis role="strong">all</emphasis> the problems that can be solved with a computer
in this chapter. However, we can show the solution to the bouncing ball
problem and explain how our solution works through the software
development lifecycle.</simpara>
<section xml:id="_bouncing_ball_solution_command_line_version">
<title>Bouncing ball solution (command line version)</title>
<simpara>In ExampleÂ <xref linkend="example:Ball_bouncing_problem_and_plan"/> we made sure that
we understood the problem and then formed a three-part plan to read in
the input, compute the height of the bounce, and then output it.</simpara>
<simpara>In ProgramÂ <xref linkend="program:GetInputCLI"/>, we implemented subproblem 1, reading
the input from the command line. In ProgramÂ <xref linkend="program:ComputeHeight"/>,
we implemented subproblem 2, computing the height of the final bounce.
In ProgramÂ <xref linkend="program:DisplayHeightCLI"/>, we implemented subproblem 3,
displaying the height that was computed. In the final, integrated
program, the portion of the code that corresponds to solving subproblem
1 is below.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class BouncingBallCLI {
	public static void main(String[] args) {
    	// Solution to subproblem 1
    	// Create an object named in for input
        Scanner in = new Scanner(System.in); /*@\label{scannerObjectLine}@*/

        // Declare variables to hold input data
        double height, coefficient;
        int bounces;

        // Declare user prompt strings
        String enterHeight = "Enter the height: ";
        String enterCoefficient =
        	"Enter restitution coefficient: ";
        String enterBounces = "Enter the number of bounces: ";

        System.out.println("Bouncing Ball");

        // Prompt the user and read data from the keyboard
        System.out.println("Bouncing Ball: Subproblem 1");
        System.out.print(enterHeight);
        height = in.nextDouble(); /*@\label{inputDialogScannerIntegratedLineOne}@*/
        System.out.print(enterCoefficient);
        coefficient = in.nextDouble(); /*@\label{inputDialogScannerIntegratedLineTwo}@*/
        System.out.print(enterBounces);
        bounces = in.nextInt(); /*@\label{inputDialogScannerIntegratedLineThree}@*/</programlisting>
<simpara>With the imports, class declaration, and <literal>main()</literal> method set up by the
solution to subproblem 1, the solution to subproblem 2 is very short.</simpara>
<programlisting language="java" linenumbering="numbered">        // Solution to subproblem 2
        double bounceHeight = height*Math.pow(coefficient,bounces);/*@\label{solutionScannerSubProblemTwo}@*/</programlisting>
<simpara>The solution to subproblem 3 and the braces that mark the end of the
<literal>main()</literal> method and then the end of the class only take up a few
additional lines.</simpara>
<programlisting language="java" linenumbering="numbered">        // Solution to subproblem 3
        String message = "After " + bounces +
    		" bounces the height of the ball is: " +
    		bounceHeight + " feet";
        System.out.println(message);/*@\label{constructorExecutionIntegratedEnds}@*/
    }
}</programlisting>
</section>
<section xml:id="_bouncing_ball_solution_gui_version">
<title>Bouncing ball solution (GUI version)</title>
<simpara>If you prefer a GUI for your input and output, we can integrate the
GUI-based versions of the solutions to subproblems 1, 2, and 3 from
Programs <xref linkend="program:GetInputCLI"/>, <xref linkend="program:ComputeHeight"/>, and
<xref linkend="program:DisplayHeightGUI"/>. The final program is below. It only
differs from the command line version in a few details.</simpara>
<formalpara xml:id="program:BouncingBallGUI" xreflabel="BouncingBallGUI">
<title>Full program to compute the height of the final bounce of a ball and display the result with a GUI.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class BouncingBallGUI {
	public static void main(String [] args) {
		// Solution to sub-problem 1
		String title = "Bouncing Ball";
        double height, coefficient;
        int bounces;

        // Declare user prompt strings
        String enterHeight = "Enter the height: ";
        String enterCoefficient =
        	"Enter restitution coefficient: ";
        String enterBounces = "Enter the number of bounces: ";

        // Prompt the user, get data, and convert it
        String response = JOptionPane.showInputDialog(null,/*@\label{sampleDeclarationAndExecutableStatement}@*/
        	enterHeight, title, JOptionPane.QUESTION_MESSAGE);
        height = Double.parseDouble(response);
        response = JOptionPane.showInputDialog(null,
        	enterCoefficient, title, JOptionPane.QUESTION_MESSAGE);
        coefficient = Double.parseDouble(response);
        response = JOptionPane.showInputDialog(null,
        	enterBounces, title, JOptionPane.QUESTION_MESSAGE);
        bounces = Integer.parseInt(response);

        // Solution to sub-problem 2
        double bounceHeight = height*Math.pow(coefficient,bounces);

        // Solution to sub-problem 3
        String message = "After " + bounces +
			" bounces the height of the ball is: " +
			bounceHeight + " feet";
	    JOptionPane.showMessageDialog(null, message, title,
	    	JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_testing_and_maintenance">
<title>Testing and maintenance</title>
<simpara>Testing and maintenance are key elements of the software engineering
lifecycle and often take more time and resources than the rest. However,
we only discuss them briefly here.</simpara>
<simpara>The ball bouncing problem is not complex. There are a few obvious things
to test. We should pick a &#8220;normal&#8221; test case such as a height of 15
units, a coefficient of restitution of 0.3, and 10 bounces. The height
should be <inlineequation><alt><![CDATA[15\times 0.3^{10} = 0.0000885735]]></alt><mathphrase><![CDATA[15\times 0.3^{10} = 0.0000885735]]></mathphrase></inlineequation>. The result
computed by our program should be the same, ignoring floating point
error. We can also check some boundary test cases. If the coefficient of
restitution is 1, the ball should bounce back perfectly, reaching
whatever height we input. If the coefficient of restitution is 0, the
ball doesnât bounce at all, and the final height should be 0.</simpara>
<simpara>Our code does not account for users entering badly formatted data like
<literal>two</literal> instead of <literal>2</literal>. Likewise, our code does not detect invalid values
such as a coefficient of restitution greater than 1 or a negative number
of bounces. An industrial-grade program should. Weâll discuss testing
further in ChapterÂ <xref linkend="chapter:Testing_and_Debugging"/>.</simpara>
<simpara>As with most of the problems we discuss in this book, issues of
maintenance will not apply. We donât have a customer base to keep happy.
However, it is a good thought exercise to imagine a large-scale version
of this program that can solve many different kinds of physics problems.
Who are likely to be your clients? What are the kinds of bugs that are
likely to creep into such a program? How would you provide bug-fixes and
develop new features?</simpara>
</section>
</section>
<section xml:id="_concurrency_solving_problems_in_parallel">
<title>Concurrency: Solving problems in parallel</title>
<section xml:id="_parallelism_and_concurrency">
<title>Parallelism and concurrency</title>
<simpara>The terms <emphasis>parallelism</emphasis> and <emphasis>concurrency</emphasis> are often confused and
sometimes used interchangeably. Parallelism or parallel computing occurs
when multiple computations are being performed at the same time.
Concurrency occurs when multiple computations may interact with each
other. The distinction is subtle since many parallel computations are
concurrent and vice versa.</simpara>
<simpara>An example of parallelism without concurrency is two separate programs
running on a multicore system. They are both performing computations at
the same time, but, for the most part, they are not interacting with
each other. (Concurrency issues can arise if these programs try to
access a shared resource, such as a file, at the same time.)</simpara>
<simpara>An example of concurrency without parallelism is a program with multiple
threads of execution running on a single-core system. These threads will
not execute at the same time as each other. However, the OS or runtime
system will interleave the execution of these threads, switching back
and forth between them whenever it wants to. Since these threads can
share memory, they can still interact with each other in complicated and
often unpredictable ways.</simpara>
<simpara>With multicore computers, we want good and effective parallelism,
computing many things at the same time. Unfortunately, striving to reach
parallelism often means struggling with concurrency and carefully
managing the interactions between threads.</simpara>
</section>
<section xml:id="_sequential_versus_concurrent_programming">
<title>Sequential versus concurrent programming</title>
<simpara>Imagine that the evil Lellarap aliens are attacking Earth. They have
sent an extensive list of demands to the worldâs leaders, but only a few
people, including you, have mastered their language, Lellarapian. To
save the people of Earth, it is imperative that you translate their
demands as quickly as possible so that world leaders can decide what
course of action to take. If you do it alone, as illustrated in
FigureÂ <xref linkend="documentTranslationFigure"/>(a), the Lellaraps might attack
before you finish.</simpara>
<simpara>In order to finish the work faster, you hire a second translator whose
skills in Lellarap are as good as yours. As shown in
FigureÂ <xref linkend="documentTranslationFigure"/>(b), you divide the document into
two nearly equal parts, Document A and Document B. You translate
Document A and your colleague translates Document B. When both
translations are complete, you merge the two, check the translation, and
send the result to the worldâs leaders.</simpara>
<figure>
<title>(a)Â Translation by one translator. Time <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation> gives the sequential time taken. (b)Â Translation by translators A and B. Times <inlineequation><alt><![CDATA[t_1]]></alt><mathphrase><![CDATA[t_1]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[t_2]]></alt><mathphrase><![CDATA[t_2]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[t_3]]></alt><mathphrase><![CDATA[t_3]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[t_4]]></alt><mathphrase><![CDATA[t_4]]></mathphrase></inlineequation> give the times needed to do each component of the concurrent approach.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/documentTranslationFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>documentTranslationFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>Translating the demands alone is a <emphasis>sequential</emphasis> approach. In this
context, sequential mean non-parallel. Translating the demands with two
people is a parallel approach. It is concurrent as well because you have
to decide on how to split up the document and how to merge it back
together.</simpara>
<simpara>If you were to write a computer program to translate the demands using
the sequential approach, you would produce a <emphasis>sequential program</emphasis>. If
you write a computer program that uses the approach shown in
FigureÂ <xref linkend="documentTranslationFigure"/>(b), it would be a <emphasis>concurrent
program</emphasis>. A concurrent program is also referred to as a <emphasis>multi-threaded</emphasis>
program. <emphasis>Threads</emphasis> are sequences of code that can execute independently
and access each otherâs memory. Imagine you are one thread of execution
and your colleague is another. Thus, the concurrent approach will have
at least two threads. It may have more if separate threads are used to
divide up the document and merge it back together.</simpara>
<simpara>Because weâre interested in the time the process takes, we have labeled
different tasks in FigureÂ <xref linkend="documentTranslationFigure"/> with their
running times. We let <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation> be the time for one person to
complete the translation. The times <inlineequation><alt><![CDATA[t_1]]></alt><mathphrase><![CDATA[t_1]]></mathphrase></inlineequation> through
<inlineequation><alt><![CDATA[t_4]]></alt><mathphrase><![CDATA[t_4]]></mathphrase></inlineequation> mark the times needed to complete tasks 1 through 4,
indicated in FigureÂ <xref linkend="documentTranslationFigure"/>(b).
ExerciseÂ <xref linkend="exercise:translationTimingExercise"/> asks you to calculate
these times for the sequential and concurrent approaches.</simpara>
</section>
<section xml:id="_kinds_of_concurrency">
<title>Kinds of concurrency</title>
<simpara>A sequential program, like the single translator, uses a single
processor on a multi-processor system or a single core on a multicore
chip. To speed up the solution of a program on a multicore chip, it may
be necessary to divide a problem so that different parts of it can be
executed concurrently.</simpara>
<simpara>This process of dividing up a problem falls into the category of <emphasis>domain
decomposition</emphasis>, <emphasis>task decomposition</emphasis>, or some combination of the two. In
domain decomposition, we take a large amount of data or elements to be
processed and divide up the data among workers that all do the same
thing to different parts of the data. In task decomposition, each worker
is assigned a different task that needs to be done. The following two
examples explore each of these approaches.</simpara>
<example>
<title>Domain decomposition</title>
<simpara>Suppose we have an autonomous robot called the Room Rating Robot or
R<superscript>3</superscript>. The R<superscript>3</superscript> can measure the area of any home. Suppose that we want to
use an R<superscript>3</superscript> to measure the area of the home with two floors sketched in
FigureÂ <xref linkend="figure:floorPlan"/>.</simpara>
<figure role="text-center">
<title>A home with two floors.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/02-intro/images/floorPlan.svg" width="60%"/>
</imageobject>
<textobject><phrase>floorPlan</phrase></textobject>
</mediaobject>
</figure>
<simpara>One way to measure the area is to put an R<superscript>3</superscript> at the entrance of the
home on the first floor and give it the following instructions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Initialize total area to 0</simpara>
</listitem>
<listitem>
<simpara>Find area of next room and add to total area</simpara>
</listitem>
<listitem>
<simpara>Repeat Step 2 until all rooms have been measured</simpara>
</listitem>
<listitem>
<simpara>Move to second floor</simpara>
</listitem>
<listitem>
<simpara>Repeat Step 2 until all rooms have been measured</simpara>
</listitem>
<listitem>
<simpara>Display total area</simpara>
</listitem>
</orderedlist>
<simpara>By following these steps, the R<superscript>3</superscript> will systematically go through each
room, measure its area, and add the value to the total area found so
far. It will then climb up the stairs and repeat the process for the
second floor. It would then add the areas from the two floors and give
us the total living area of the house. This is a sequential approach for
measuring the area.</simpara>
<simpara>Now suppose we have two R<superscript>3</superscript> robots, named R<superscript>3</superscript>A and R<superscript>3</superscript>B. We can put
R<superscript>3</superscript>A on the first floor and R<superscript>3</superscript>B on the second. Both robots are then
instructed to find the area of the floor theyâre on using steps very
similar to the ones listed above for a sequential solution. When done,
we add together the answers from R<superscript>3</superscript>A and R<superscript>3</superscript>B to get the total. This
is a concurrent (and also parallel) approach for measuring the living
area of a home with two floors. Using two robots in this way can speed
up the time it takes to measure the area.</simpara>
</example>
<simpara>In the example above, the tasks are the same, i.e., measuring the area,
but are performed on two different input domains, i.e., the floors.
Thus, both robots are performing essentially the same operations but on
different floors. This type of task division is also known as domain
decomposition. Here, to achieve concurrency, we take the domain of the
problem (the house) and divide it into smaller subdomains (its floors).
Then, each processor (or robot in this example) performs the same task
on each subdomain. When done, the final answer is found by combining the
answers. Running the robots on each floor is purely parallel, but
combining the answers is concurrent since some interaction between the
robots is necessary.</simpara>
<simpara>Another way of solving a problem concurrently is to divide it into
fundamentally different tasks. The tasks could be executed on different
processors and perhaps on different input domains. Eventually, some
coordination of the tasks must be done to generate the final result. The
next example illustrates such a division.</simpara>
<example>
<title>Task decomposition</title>
<simpara>Letâs expand the problem given in ExampleÂ <xref linkend="example:Domain
decomposition"/>. R<superscript>3</superscript> robots can do more than just measure area. In
addition to calculating the living area of a home, we want an R<superscript>3</superscript> robot
to check if the electrical outlets are in working condition. The robot
should give us the area of the house as well as a list of electrical
outlets that are not working.</simpara>
<simpara>This problem can be solved in a sequential manner with just one robot.
One way to do so would be for a robot to make a first pass through all
floors and rooms and compute the living area. It can then make a second
pass and make a list of electrical outlets that are not working.</simpara>
<simpara>One way to solve this problem concurrently is to assign R<superscript>3</superscript>A to measure
the area and R<superscript>3</superscript>B to identify broken electrical outlets. Once the
respective tasks are assigned, we place the robots at the entrance to
the house and activate them. It is possible that the two robots will
bump into each other while working, and thatâs one of the difficulties
of concurrency. The burden is on the programmer to give instructions so
that the robots can avoid or recover from collisions. After the robots
are done, we ask R<superscript>3</superscript>A for the living area of the house and R<superscript>3</superscript>B for a
list of broken outlets.</simpara>
</example>
</section>
</section>
<section xml:id="_summary_2">
<title>Summary</title>
<simpara>In this chapter, we introduced an approach for developing software to
solve a problem with a computer. A number of examples illustrated how to
move from a problem statement to a complete Java program. Although we
have given rough explanations of all the Java programs in this chapter,
we encourage you to play with each program to expand its functionality.
Several exercises prompt you to do just that. It is impossible to learn
to program without actively practicing programming. Never be afraid of
&#8220;breaking&#8221; the program. Only by breaking it, changing it, and fixing
it will your understanding grow.</simpara>
<simpara>In addition to the software development lifecycle, we introduced several
building blocks of Java syntax including classes, <literal>main()</literal> methods,
import statements, and variable declarations. We also gave a preview of
different variable types (<literal>int</literal>, <literal>double</literal>, and <literal>String</literal>) and operations
that can be used with them. Material about types and operations on them
is covered in depth in the next chapter. Furthermore, we discussed input
and output using <literal>Scanner</literal> and <literal>System.out.print()</literal> for the command line
interface and <literal>JOptionPane</literal> methods for a GUI.</simpara>
<simpara>Finally, we introduced the notions of sequential and concurrent
solutions to problems and clarified the subtle difference between
parallelism and concurrency.</simpara>
</section>
<section xml:id="_exercises">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:problemSolvingExericise"/> When solving a problem using a
computer, what problem is solved by the programmer and what problem is
solved by the program written by the programmer? Are they the same?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:doubleTypeExercise"/> In ExampleÂ <xref linkend="example:Input for
distance computation"/>, we declared all variables to be of type
<literal>double</literal>. How would the program behave differently if we had declared
all the variables with type <literal>int</literal>?</simpara>
</listitem>
<listitem>
<simpara>What is the purpose of the statement at
lineÂ <xref linkend="createScannerGetInputDataObject"/> in
ProgramÂ <xref linkend="program:GetInputCLI"/>?</simpara>
</listitem>
<listitem>
<simpara>Explain the difference between a declaration and an assignment
statement.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:statementCategorizationExercise"/> Is the following
statement from lineÂ <xref linkend="sampleDeclarationAndExecutableStatement"/> of
ProgramÂ <xref linkend="program:BouncingBallGUI"/> a declaration, an assignment, or a
combination of the two?</simpara>
<programlisting language="java" linenumbering="unnumbered">String response = JOptionPane.showInputDialog(
    null, enterHeight, title,
    JOptionPane.QUESTION_MESSAGE);</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:textOutputGraphicalOutputComparison"/> When would you
prefer using the <literal>JOptionPane</literal> class for output over
<literal>System.out.print()</literal>? When might you prefer <literal>System.out.print()</literal> to
using <literal>JOptionPane</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:keywordLabeling"/> Review
ProgramÂ <xref linkend="program:BouncingBallGUI"/> and identify all the Java keywords
used in it.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:importStatementExercise"/> Try to recompile
ProgramÂ <xref linkend="program:BouncingBallGUI"/> after removing the <literal>import</literal>
statement at the top. Read and explain the error message generated by
the compiler.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:concurrentParallelExercise"/> Explain the difference
between parallel and concurrent tasks. Give examples of tasks that are
parallel but not concurrent, tasks that are concurrent but not parallel,
and tasks that are both.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:translationTimingExercise"/> Refer to
FigureÂ <xref linkend="documentTranslationFigure"/>. Suppose that you and your
colleague translate from English to Lellarapian at the rate of 200 words
per hour. Suppose that the list of demands contains 10,000 words.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Compute <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation>, the time for you to translate the entire
document alone, assuming that, after translation, you perform a final
check at the rate of 500 words per hour.</simpara>
</listitem>
<listitem>
<simpara>Now assume that the task of splitting up the document and handing
over the correct part to your colleague takes 15 minutes. Also, the task
of receiving the translated document from your colleague and merging
with the one you translated takes another 15 minutes. After merging the
two documents, you do a final check for correctness at a rate of 500
words per hour. Calculate the total time to complete the translation
using this concurrent approach. Let us refer to this time as
<inlineequation><alt><![CDATA[t_c]]></alt><mathphrase><![CDATA[t_c]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>One way to calculate the speedup of a concurrent solution is to
divide the sequential time by the concurrent time. In our case, the
speedup is <inlineequation><alt><![CDATA[t_s/t_c]]></alt><mathphrase><![CDATA[t_s/t_c]]></mathphrase></inlineequation>. Using the values you have computed in
(a) and (b), calculate the speedup.</simpara>
</listitem>
<listitem>
<simpara>Suppose that you have a total of two colleagues willing to help you
with the translation. Assuming that the three of you will perform the
translation and that the times needed to split, merge, and check are
unchanged, calculate the total time needed. Then, compute the speedup.</simpara>
</listitem>
<listitem>
<simpara>Now suppose that there are an unlimited number of people willing and
able to help you with the translation. Will the speedup keep on
increasing as you add more translators? Explain your answer.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:homeAreaCalculationAnalogyExercise"/> In
ExampleÂ <xref linkend="example:Domain_decomposition"/>, what aspect of a multicore
system do the robots represent?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:homeAreaCalculationExerciseDifferentHomeStructures"/> In
ExampleÂ <xref linkend="example:Domain_decomposition"/>, suppose that you have two R<superscript>3</superscript>
robots available. You would like to use these to measure the living area
of a single floor home. Suggest how two robots could be programmed to
work concurrently to measure the living area faster than one.</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:scannerPractice"/> Write a program that prompts the user
for three integers from the command line. Read each integer in using the
<literal>nextInt()</literal> method of a <literal>Scanner</literal> object. Compute the sum of these
values and print it to the screen using <literal>System.out.print()</literal> or
<literal>System.out.println()</literal>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:scannerAverage"/> Expand the program from
ExerciseÂ <xref linkend="exercise:scannerPractice"/> so that it finds the average of
the three numbers instead of the sum. (Hint: Try dividing by <literal>3.0</literal>
instead of <literal>3</literal> to get an average with a fractional part. Then, store the
result in a variable of type <literal>double</literal>.)</simpara>
</listitem>
<listitem>
<simpara>Rewrite your solution to ExerciseÂ <xref linkend="exercise:scannerAverage"/> so
that it uses a <literal>JOptionPane</literal>-based GUI instead of <literal>Scanner</literal> and
<literal>System.out.print()</literal>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:getInputDataExercise"/> Copy and paste
ProgramÂ <xref linkend="program:GetInputCLI"/> into the Java IDE you prefer. Compile
and run it and make sure that the program executes as intended. Then,
add statements to prompt the user for the color of the ball and read it
in. Store the color in a <literal>String</literal> value. Add an output statement that
mentions the color of the ball.</simpara>
</listitem>
<listitem>
<simpara>Rewrite your solution to ExerciseÂ <xref linkend="exercise:getInputDataExercise"/>
so that it uses a <literal>JOptionPane</literal>-based GUI instead of <literal>Scanner</literal> and
<literal>System.out.print()</literal>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:distanceComputationExercise"/> In ExampleÂ <xref linkend="example:Input
for distance computation"/>, we assumed that the speed is given in miles
per hour and the time in hours. Change ProgramÂ <xref linkend="program:Distance"/> to
compute the distance traveled by a moving object given its speed in
miles per hour but time in seconds. You will need to perform a
conversion from seconds to hours before you can find the distance.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:stringInputExercise"/> A program can use both a command
line interface and a GUI to interact with a user. Write a program that
uses the <literal>Scanner</literal> class to read a <literal>String</literal> value containing the userâs
favorite food. Then display the name of the food using <literal>JOptionPane</literal>.</simpara>
</listitem>
<listitem>
<simpara>Use the complete software development cycle to write a program that
reads in the lengths of two legs of a right triangle and computes the
length of its hypotenuse.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Make sure you understand the problem. How can you apply the
Pythagorean formula (<inlineequation><alt><![CDATA[a^2 + b^2 = c^2]]></alt><mathphrase><![CDATA[a^2 + b^2 = c^2]]></mathphrase></inlineequation>) to solve it?</simpara>
</listitem>
<listitem>
<simpara>Design a solution by listing the steps you will need to take to read
in the appropriate values, find the answer, and then output it.</simpara>
</listitem>
<listitem>
<simpara>Implement the steps as a Java program.</simpara>
</listitem>
<listitem>
<simpara>Test the solution with several known values. For example, a right
triangle with legs of lengths 3 and 4 has a hypotenuse of length 5.
Which values cause errors? How should your program react to those
errors?</simpara>
</listitem>
<listitem>
<simpara>Consider what other features your program should have. If your
intended audience is children who are learning geometry, should your
error handling be different from an audience of architects?</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Primitive_Types_and_Strings">
<title>Primitive Types and Strings</title>
<blockquote>
<attribution>
Jean Guitton
</attribution>
<simpara>Originality exists in every individual because each of us differs from the others. We are all
primary numbers divisible only by ourselves.</simpara>
</blockquote>
<section xml:id="_problem_college_cost_calculator">
<title>Problem: College cost calculator</title>
<simpara>Perhaps you&#8217;re a student. Perhaps you aren&#8217;t. In either case, you must
be aware of the rapidly rising cost of a college education. The
motivating problem for this chapter is to create a Java program that can
estimate the cost of a college education, including room and board. It
starts by reading a first name, a last name, the per-semester cost of
tuition, the monthly cost of rent, and the monthly cost of food as input
from a user. Many students take out loans for college. In fact, student
debt has surpassed credit card debt in the United States. We can
implement a feature to read in an interest rate and the number of years
expected to pay off the loan.</simpara>
<simpara>After taking all this data as input, we want to calculate the yearly
cost of such an education, the four year cost, the monthly loan payment,
and the total cost of the loan over time. Furthermore, we want to output
this information on the command line in an attractive way, customized
with the user&#8217;s name. Below is a sample execution of this program.</simpara>
<literallayout class="monospaced">Welcome to the College Cost Calculator!
Enter your first name:       <emphasis role="strong">Barry</emphasis>
Enter your last name:        <emphasis role="strong">Wittman</emphasis>
Enter tuition per semester:  $<emphasis role="strong">17415</emphasis>
Enter rent per month:        $<emphasis role="strong">350</emphasis>
Enter food cost per month:   $<emphasis role="strong">400</emphasis>
Annual interest rate:        <emphasis role="strong">.0937</emphasis>
Years to pay back your loan: <emphasis role="strong">10</emphasis>

College costs for Barry Wittman
***************************************
Yearly cost:                 $43830.00
Four year cost:              $175320.00
Monthly loan payment:        $2256.14
Total loan cost:             $270736.5</literallayout>
<simpara>Samples from a command line interface can be confusing because it is
difficult to see what is ouput and what is input. In this case, we have
marked the input in <emphasis role="strong">bold</emphasis> so that it&#8217;s clear what the user enters. In this program, the names, the tuition, the
rent, the food, the interest rate, and the years to pay back the loan
are taken as input. Note that the dollar signs are <emphasis role="strong">not</emphasis> part of the
input and are outputted as a cue to the user and to give visual polish.</simpara>
<simpara>If you are following the software development lifecycle, we hope you
have a good understanding of this problem, but there are a few
mathematical details worth addressing. First, the yearly cost is twice
the semester tuition plus 12 times the rent and food costs. The four
year cost is simply four times the yearly cost. The monthly loan payment
amount, however, requires a formula from financial mathematics. Let
<inlineequation><alt><![CDATA[P]]></alt><mathphrase><![CDATA[P]]></mathphrase></inlineequation> be the amount of the loan (the principal). Let
<inlineequation><alt><![CDATA[J]]></alt><mathphrase><![CDATA[J]]></mathphrase></inlineequation> be the monthly interest rate (the annual interest rate
divided by 12). Let <inlineequation><alt><![CDATA[N]]></alt><mathphrase><![CDATA[N]]></mathphrase></inlineequation> be the number of months to pay back
the loan (years of the loan times 12). Let <inlineequation><alt><![CDATA[M]]></alt><mathphrase><![CDATA[M]]></mathphrase></inlineequation> be the
monthly payment we want to calculate, then:</simpara>
<simpara><inlineequation><alt><![CDATA[M = P \times \frac{J}{1 - (1 + J)^{-N}}]]></alt><mathphrase><![CDATA[M = P \times \frac{J}{1 - (1 + J)^{-N}}]]></mathphrase></inlineequation></simpara>
<simpara>If you use the concepts and syntax from the previous chapter carefully,
you might be able to solve this problem without reading further.
However, there is a depth to the ideas of types and operations that we
have not explored fully. Getting a program to work is not enough.
Programmers must understand every detail and quirk of their tools to
avoid potential bugs.</simpara>
</section>
<section xml:id="_concepts_types">
<title>Concepts: Types</title>
<simpara>Every operation inside of a Java program manipulates data. Often, this
data is stored in <emphasis>variables</emphasis>, which look similar to variables from
mathematics. Consider the following mathematical equation.</simpara>
<simpara><inlineequation><alt><![CDATA[x + 3 = 7]]></alt><mathphrase><![CDATA[x + 3 = 7]]></mathphrase></inlineequation></simpara>
<simpara>In this equation, <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> has the value <inlineequation><alt><![CDATA[4]]></alt><mathphrase><![CDATA[4]]></mathphrase></inlineequation>, and it
always will. You can set up another equation in which <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>
has a different value, but it won&#8217;t change in this one. Java variables
are different. They are locations where you can store something. If you
decide later that you want to change what you stored there, you can put
something else into the same location, overwriting the old value.</simpara>
<simpara>In contrast to a variable is a <emphasis>literal</emphasis>. A literal is a concrete value
that does not change, though it can be stored in a variable. Numbers
like <literal>4</literal> or <literal>2.71828183</literal> are literals. We need to represent text and
single characters in Java as well, and there are literals like
<literal>"grapefruit segment"</literal> and <literal>'X'</literal> that fill these roles.</simpara>
<simpara>In Java, both variables and literals have <emphasis>types</emphasis>. If you think of a
variable as a box where you can hold something, its type is the shape of
the box. The kinds of literals that can be stored in that box must have
a matching shape. In the last chapter, we introduced the type <literal>int</literal> to
store integer values and the type <literal>double</literal> to store floating point
values. Java is a <emphasis>strongly typed</emphasis> language, meaning that, if we declare
a variable of type <literal>int</literal>, we can only put <literal>int</literal> values into it (with a
few exceptions).</simpara>
<simpara>This idea of a type takes some getting used to. From a mathematical
perspective 3 and 3.0 are identical.
However, if you have an <literal>int</literal> variable in Java, you can store <literal>3</literal> into
it, but you can&#8217;t store <literal>3.0</literal>. Types never change, but you can convert a
value from one type to an equivalent value in another type.</simpara>
<section xml:id="_types_as_sets_and_operations">
<title>Types as sets and operations</title>
<simpara>Before we go any further, let&#8217;s look deeper at what a type really is. We
can think of a type as a set of elements. For example, <literal>int</literal> represents
a set of integer values (specifically, the integers between
-2,147,483,648 and 2,147,483,647). Consider
the following declarations:</simpara>
<programlisting language="java" linenumbering="unnumbered">int x;
int y;</programlisting>
<simpara>These declarations indicate that the variables named <literal>x</literal> and <literal>y</literal> can
only contain integer values in this range. Furthermore, a type only
allows specific operations. In Java, the <literal>int</literal> type allows addition,
subtraction, multiplication, division, and several other operations we
will talk about in SectionÂ <xref linkend="syntax:Types_in_Java"/>, but you cannot
directly raise an <literal>int</literal> value to a power in Java. Let&#8217;s assume that <literal>x</literal>
is of type <literal>int</literal>. As we discussed in the previous chapter, the
expression <literal>x + 2</literal> performs addition between the variable represented by
<literal>x</literal> and the literal <literal>2</literal>. Some languages use the operator <literal>^</literal> to mean
raising a number to a power. Following this notation, some beginning
Java programmers are tempted to write <literal>x ^ 2</literal> to compute <literal>x</literal> squared.
The <literal>^</literal> operator does have a meaning in Java, but it does not raise
values to a power. Other combinations of operators are simply illegal,
such as <literal>x # 2</literal>.</simpara>
<simpara>The idea of using types this way gives structure to a program. All
operations are well-defined. For example, you know that adding two <literal>int</literal>
values together will give you another <literal>int</literal> value. Java is a <emphasis>statically
typed</emphasis> language. This means that it can analyze all the types you&#8217;re
using in your program at compile-time and warn you if you&#8217;re doing
something illegal. Consequently, you&#8217;ll get a lot of compiler warnings
and errors, but you can be more confident that your program is correct
if all the types make sense.</simpara>
</section>
<section xml:id="_primitive_and_reference_types_in_java">
<title>Primitive and reference types in Java</title>
<simpara>As shown in FigureÂ <xref linkend="typesInJavaFigure"/>(a), there are two kinds of
types in Java: <emphasis>primitive types</emphasis> and <emphasis>reference types</emphasis>. Primitive types
are like boxes that hold single, concrete values. The primitive types in
Java are <literal>byte</literal>, <literal>short</literal>, <literal>int</literal>, <literal>long</literal>, <literal>float</literal>, <literal>double</literal>, <literal>boolean</literal>,
and <literal>char</literal>. These are types provided by the designers of Java, and it is
not possible to create new ones. Each primitive type has a set of
<emphasis>operators</emphasis> that are legal for it. For example, all the numerical types
can be used with <literal>+</literal> and <literal>-</literal>. We&#8217;ll talk about these types and their
operators in great detail in SectionÂ <xref linkend="syntax:Types_in_Java"/>.</simpara>
<figure>
<title>(a)Â The two categories of types in Java. The <literal>int</literal> primitive type (b), the <literal>boolean</literal> primitive type (c), the <literal>String</literal> reference type (d), and a possible <literal>Aircraft</literal> reference type (e) are represented as sets of items with operations.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/03-strings-primitive-types/images/typesInJavaFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>typesInJavaFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>Reference types work differently from primitive types. For one thing, a
reference variable <emphasis role="strong">points at</emphasis> an object. This means that when you
assign one reference variable to another, you are not getting a whole
new copy of the object. Instead, you&#8217;re getting another arrow that
points at the same object. The result is that performing an operation on
one reference can effectively change another reference, if they are both
pointing at the same object.</simpara>
<simpara>Another difference is that reference variables (or simply <emphasis>references</emphasis>)
do not have a large set of operators that work on them. Every variable
can be used with the assignment (<literal>=</literal>) and the comparison (<literal>==</literal>)
operators. Every variable can also be concatenated with a <literal>String</literal> by
using the <literal>+</literal> operator, but even if two objects represent numerical
values, they cannot be added together with the <literal>+</literal> operator.</simpara>
<simpara>References should still be thought of as types defining a set of objects
and operations that can be done with them. Instead of using operators,
however, references use <emphasis>methods</emphasis>. You have seen methods such as
<literal>System.out.print()</literal> and <literal>JOptionPane.showInputDialog()</literal> in the previous
chapter. A method generally has a dot (<literal>.</literal>) before it and always has
parentheses afterwards. These parentheses contain the input <emphasis>parameters</emphasis>
or <emphasis>arguments</emphasis> that you give to a method. Using operators on primitive
types is convenient, but on the other hand, there is no limit to the
number, kind, or complexity of methods that can be used on references.</simpara>
<simpara>Another important feature of reference types is that anyone can define
them. So far, you have seen the reference types <literal>String</literal> and
<literal>JOptionPane</literal>. As we will discuss later, <literal>String</literal> is an unusual
reference type in that it is built deeply into the language. There are a
few other types like this (such as <literal>Object</literal>), but most reference types
could have been written by anyone, even you.</simpara>
<simpara>To create a new type, you write a class and define data and methods
inside of it. If you wanted to define a type to hold airplanes, you
might create the <literal>Airplane</literal> class and give it methods such as
<literal>takeOff()</literal>, <literal>fly()</literal>, and <literal>land()</literal> because those are operations that any
airplane should be able to do.</simpara>
<simpara>Once a class has been defined, it is possible to <emphasis>instantiate</emphasis> an
<emphasis>object</emphasis>. An object is a specific instance of the type. For example, the
type might be <literal>Airplane</literal>, but the object might be referenced by a
variable called <literal>sr71Blackbird</literal>. Presumably, this object has a weight, a
maximum speed, and other characteristics that mark it as a Lockheed
SR-71 &#8220;Blackbird,&#8221; the famous spy plane. To summarize: The object is a
concrete instance of the data. The reference is the variable that gives
a name to (points to) the object. The type is the class that both the
variable and the object have, which defines what kinds of data the
object has and what operations it can perform.</simpara>
<simpara>The following table lists some of the differences between primitive
types and reference types.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Primitive Types</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Reference Types</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Created by the designers of Java</simpara></entry>
<entry align="left" valign="top"><simpara>Created by any Java programmer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Use operators to perform operations</simpara></entry>
<entry align="left" valign="top"><simpara>Use methods to perform operations</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>There are only eight different primitive types</simpara></entry>
<entry align="left" valign="top"><simpara>The number of reference
types is unlimited and grows every time someone creates a new class</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hold a specific numbers of bytes of data depending on the type</simpara></entry>
<entry align="left" valign="top"><simpara>The
referenced object can hold arbitrary amounts of data</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Assignment copies a value from one place to another</simpara></entry>
<entry align="left" valign="top"><simpara>Assignment copies
an arrow that points at an object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Declaration creates a box to hold values</simpara></entry>
<entry align="left" valign="top"><simpara>Declaration creates an arrow
that can point at an object, but only instantiation creates a new object</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_type_safety">
<title>Type safety</title>
<simpara>Why do we have types? There are weakly typed languages where you can
store any value into almost any variable. Why bother with all these
complicated rules? Most assembly languages have no notion of types and
allow the programmer to manipulate memory directly.</simpara>
<simpara>Because Java is strongly typed, the type of every variable, whether
primitive or reference, must be declared prior to its use. This
constraint allows the Java compiler to perform many safety and sanity
checks during compilation, and the JVM performs a few more during
execution. These checks avoid errors during program execution that might
otherwise be hard to find. These errors could lead to catastrophic
failures of the program.</simpara>
<simpara>The ArianeÂ 5 rocket is an example of a catastrophic failure due to a
type error. On its first flight, the rocket left its flight path and
eventually exploded. The failure was caused because of errors that
resulted after converting a 64-bit floating point to 16-bit signed
integer value. The converted value was larger than the integer could
hold, resulting in a meaningless value.</simpara>
<simpara>Converting from one type to another is called <emphasis>casting</emphasis>. The ArianeÂ 5
failure was due to a problem with casting that was not caught. Even in
Java, it is possible for a human being to circumvent type safety with
irresponsible casting.</simpara>
</section>
</section>
<section xml:id="_syntax_types_in_java">
<title>Syntax: Types in Java</title>
<simpara>In this section we will dig deeper into the type system in Java,
starting with variables and moving on to the properties of the eight
primitive types and the properties of <literal>String</literal> and other reference
types.</simpara>
<section xml:id="_variables_and_literals">
<title>Variables and literals</title>
<simpara>To use a variable in Java, you must first <emphasis>declare</emphasis> it, which sets aside
memory to hold the variable and attaches a name to that space.
Declarations always follows the same pattern. The type is written first
followed by the identifier, or name, for the variable. Below we declare
a variable named <literal>value</literal> of type <literal>int</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int value;</programlisting>
<simpara>Note how we use the same pattern to declare a reference variable named
<literal>creature</literal> of type <literal>Wombat</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">Wombat creature;</programlisting>
<simpara>You are always free to declare a variable and then end the line with a
semicolon (<literal>;</literal>), but it is common to <emphasis>initialize</emphasis> a variable at the same
time. The following line simultaneously declares <literal>value</literal> and initializes
it to <literal>5</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = 5;</programlisting>
<warning>
<title>Pitfall: Multiple declarations</title>
<simpara>Don&#8217;t forget that you are declaring and initializing in a line like the
above. Beginning Java programmers sometimes try to declare a variable
more than once, as in the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = 5;
int value = 10;</programlisting>
<simpara>Java will not allow two variables with the same name to exist in the
same block of code. The programmer probably intended the following,
which reuses variable <literal>value</literal> and replaces its contents with <literal>10</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = 5;
value = 10;</programlisting>
<simpara>This error is more common when several other lines of code are between
the two assignments.</simpara>
</warning>
<simpara>In some of the examples above, we have stored the value <literal>5</literal> into our
variable <literal>value</literal>. The symbol <literal>5</literal> is an example of a <emphasis>literal</emphasis>. A literal
is a value represented directly in code. It cannot be changed, but it
can be stored into variables that have the same type. The values stored
into variables come from literals, input, or more complicated
expressions. Just like variables, literals have types. The type of <literal>5</literal>
is <literal>int</literal> while the type of <literal>5.0</literal> is <literal>double</literal>. Other types have literals
written in ways we&#8217;ll discuss below.</simpara>
</section>
<section xml:id="subsection:Primitive_types">
<title>Primitive types</title>
<simpara>The building blocks of all Java programs are primitive types. Even
objects must fundamentally contain primitive types deep down inside.
There are eight primitive types. Half of them are used to represent
integer values, and we&#8217;ll start by looking at those.</simpara>
<section xml:id="_integers_literal_byte_literal_literal_short_literal_literal_int_literal_and_literal_long_literal">
<title>Integers: <literal>byte</literal>, <literal>short</literal>, <literal>int</literal>, and <literal>long</literal></title>
<simpara>A variable intended to hold integer values can be declared with any of
the four types <literal>byte</literal>, <literal>short</literal>, <literal>int</literal>, or <literal>long</literal>. All of them are signed
(holding positive and negative numbers) and represent numbers in two&#8217;s
complement. They only differ by the range of values that each type can
hold. These ranges and the number of bytes used to represent variables
from each type are given in TableÂ <xref linkend="rangePrimitiveTypes"/>.</simpara>
<table role="center" frame="all" rowsep="1" colsep="1">
<title>Ranges for primitive integer types in Java.</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Bytes</emphasis></entry>
<entry align="right" valign="top"></entry>
<entry align="center" valign="top"><emphasis role="strong">Range</emphasis></entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">byte</literallayout></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="right" valign="top"><simpara>-128</simpara></entry>
<entry align="center" valign="top"><simpara>to</simpara></entry>
<entry align="left" valign="top"><simpara>127</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">short</literallayout></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="right" valign="top"><simpara>-32,768</simpara></entry>
<entry align="center" valign="top"><simpara>to</simpara></entry>
<entry align="left" valign="top"><simpara>32,767</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">int</literallayout></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="right" valign="top"><simpara>-2,147,483,648</simpara></entry>
<entry align="center" valign="top"><simpara>to</simpara></entry>
<entry align="left" valign="top"><simpara>2,147,483,647</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">long</literallayout></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="right" valign="top"><simpara>-9,223,372,036,854,775,808</simpara></entry>
<entry align="center" valign="top"><simpara>to</simpara></entry>
<entry align="left" valign="top"><simpara>9,223,372,036,854,775,807</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Note that the range of <literal>byte</literal> is included in that of <literal>short</literal>, of <literal>short</literal>
in that of <literal>int</literal>, and so on. We say that <literal>short</literal> is <emphasis>broader</emphasis> than
<literal>byte</literal>, <literal>int</literal> is broader than <literal>short</literal>, and <literal>long</literal> is broader than <literal>int</literal>.</simpara>
<simpara>A variable declared with type <literal>byte</literal> can only represent 256 different
values, the integers in the range -128 to 127. Why use <literal>byte</literal> at all,
then? Since a <literal>byte</literal> value only takes up a single byte, it can save
memory, especially if you have a list of variables called an <emphasis>array</emphasis>,
which we will discuss in ChapterÂ <xref linkend="chapter:Arrays"/>. However, too narrow
of a range will result in underflow and overflow. Java programmers are
advised to stick with <literal>int</literal> for general use. If you need to represents
values larger than 2 billion or smaller than -2 billion, use <literal>long</literal>.
Once you are an experienced programmer, you may occasionally use <literal>byte</literal>
and <literal>short</literal> to save space, but they should be used sparingly and for a
clear purpose.</simpara>
<example>
<title>Integer variables</title>
<simpara>Consider the following declarations.</simpara>
<programlisting language="java" linenumbering="unnumbered">byte age;
int numberOfRooms;
long foreverCounter = 0;</programlisting>
<simpara>The first of these statements declares <literal>age</literal> to be a variable of type
<literal>byte</literal>. This declaration means that <literal>age</literal> can assume any value from the
range for <literal>byte</literal>. For a human being, this limitation is reasonable (but
dangerously close to the limit) since there is no documented case of a
person living more than 122 years. Similarly, the next declaration
declares <literal>numberOfRooms</literal> to be of type <literal>int</literal>. The last declaration
declares <literal>foreverCounter</literal> to be of type <literal>long</literal> and initializes it to
<literal>0</literal>.</simpara>
<simpara>Since <literal>age</literal> is a variable, its value can change during program
execution. Note that the above declaration of <literal>age</literal> does not assign a
value to it. When they are declared, all integer variables are set to
<literal>0</literal> by Java. However, to make sure that the programmer is explicit about
what he or she wants, the compiler will give an error in most cases if a
variable is used without first having its value set.</simpara>
<simpara>Like any other integer variable, we can assign <literal>age</literal> a value as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">age = 32;</programlisting>
<simpara>Doing so assigns the value <literal>32</literal> to variable <literal>age</literal>. Note that the Java
compiler would not complain if you were to assign <literal>-10</literal> to the variable
<literal>age</literal>, even though it is impossible for a human to have a negative age
(at least, without a time machine). Java attaches no meaning to the name
you give to a variable.</simpara>
</example>
<simpara>Earlier, we said that variables had to match the type of literals you
want to store into them. In the example above, we declared <literal>age</literal> with
type <literal>byte</literal> and then stored <literal>32</literal> into it. What is the type of <literal>32</literal>? Is
it <literal>byte</literal>, <literal>short</literal>, <literal>int</literal>, or <literal>long</literal>? By default, all integer literals
have type <literal>int</literal>, but they can be used with <literal>byte</literal> or <literal>short</literal> variables
provided that they fit within the range. Thus, the following line causes
an error.</simpara>
<programlisting language="java" linenumbering="unnumbered">byte fingers = 128;</programlisting>
<simpara>If you want to specify a literal to have type <literal>long</literal>, you can append <literal>l</literal>
or <literal>L</literal> to it. Thus, <literal>42</literal> is an <literal>int</literal> literal, but <literal>42L</literal> is a <literal>long</literal>
literal. You should always use <literal>L</literal> since <literal>l</literal> can be difficult to
distinguish from <literal>1</literal>.</simpara>
<simpara>At the time of this writing, Java 7 is the newest version of Java, but
it has not yet become popular or widespread. In Java 7, you are allowed
to put any number of underscores (<literal>_</literal>) inside of numerical literals to
break them up for the sake of readability. Thus, <literal>123_45_6789</literal> might
represent a social security number, or you could use underscores instead
of commas to write three million as <literal>3_000_000</literal>. To use this syntax,
you must have a Java 7 compiler and be sure that your code will never
need to be compiled in an earlier version of Java. Note that you should
<emphasis role="strong">never</emphasis> use a comma in a numerical Java literal, no matter which version
of Java.</simpara>
</section>
<section xml:id="_floating_point_numbers_literal_float_literal_and_literal_double_literal">
<title>Floating point numbers: <literal>float</literal> and <literal>double</literal></title>
<simpara>To represent numbers with fractional parts, Java provides two floating
point types, <literal>double</literal> and <literal>float</literal>. Because of limits on floating point
precision discussed in ChapterÂ <xref linkend="chapter:Computer_Basics"/>, Java cannot
represent all rational or real numbers, but these types provide good
approximations. If you have a variable that takes on floating point
values such as 3.14, 1.707 Ã 10<superscript>25</superscript>,
9.8, and so on, it ought to be declared as a <literal>double</literal> or a
<literal>float</literal>.</simpara>
<example>
<title>Floating point declarations</title>
<simpara>Consider the following declarations.</simpara>
<programlisting language="java" linenumbering="unnumbered">float roomArea;
double avogadro = 6.02214179E23</programlisting>
<simpara>The first of the above two statements declares <literal>roomArea</literal> to be of type
<literal>float</literal>. Note that the declaration does not initialize <literal>roomArea</literal> to any
value. Similar to integer primitive types, an uninitialized floating
point variable contains <literal>0.0</literal>, but Java usually forces the programmer to
assign a value to a variable before using it. The second of the above
two statements declares <literal>avogadro</literal> to be a variable of type <literal>double</literal> and
initializes it to the well-known Avogadro constant
6.02214179 Ã 10<superscript>23</superscript>. Note the use of <literal>E</literal> to mean
&#8220;ten to the power of.&#8221; In Java, you could write
0.33 Ã 10<superscript>-12</superscript> as <literal>0.33E-12</literal>, or the number
-4.325 Ã 10<superscript>18</superscript> as <literal>-4.325E18</literal> (or even <literal>-4.325E+18</literal>
if you would like to write the sign of the exponent explicitly).</simpara>
</example>
</section>
<section xml:id="_accuracy_in_number_representation">
<title>Accuracy in number representation</title>
<simpara>As discussed in ChapterÂ <xref linkend="chapter:Computer_Basics"/>, integer types
within their specified ranges have their exact representations. For
example, if you assign <literal>19</literal> to a variable of type <literal>int</literal> and then print
this value, you always get exactly <literal>19</literal>. Floating point numbers do not
have this guarantee of exact representation.</simpara>
<example>
<title>Floating point accuracy</title>
<simpara>Try executing the following statements from within a Java program.</simpara>
<programlisting language="java" linenumbering="unnumbered">double test = 0.0;
test += 0.1;
System.out.println(test);
test += 0.1;
System.out.println(test);
test += 0.1;
System.out.println(test);</programlisting>
<simpara>Since we are adding 0.1 each time, one would expect to see outputs of
<literal>0.1</literal>, <literal>0.2</literal>, and <literal>0.3</literal>. The first two numbers print as expected, but
the third number prints out as <literal>0.30000000000000004</literal>. It may seem
counterintuitive, but 0.1 is a repeating decimal in binary, meaning that
it cannot be represented exactly using the 64-bit IEEE floating point
standard. The <literal>System.out.println()</literal> method hides this ugliness by
rounding the output past a certain level of precision, but by the third
addition, the number has drifted far enough away from 0.3 that an
unexpected number peeks out.</simpara>
</example>
<simpara>Variables of type <literal>float</literal> give you an accuracy of about 6 decimal digits
while those of type <literal>double</literal> give about 15 decimal digits. Does the
accuracy of floating point number representation matter? The answer to
this question depends on your application. In some applications, 6-digit
accuracy may be adequate. However, when doing large-scale simulations,
such as computing the trajectory of a spacecraft on a mission to Mars,
15-digit accuracy might be a matter of life or death. In fact, even
double precision may not be enough. There is a special <literal>BigDecimal</literal>
class which can perform arbitrarily high precision calculations, but due
to its low speed and high complexity, it should only be used in those
rare situations when a programmer requires a much higher level of
precision than what <literal>double</literal> provides.</simpara>
<simpara>Java programmers are recommended to use <literal>double</literal> for general purpose
computing. The <literal>float</literal> type should only be used in special cases where
storage or speed are critical and accuracy is not. Because of its
greater accuracy, <literal>double</literal> is considered a broader type than <literal>float</literal>.
You can store <literal>float</literal> values in a <literal>double</literal> without losing precision, but
the reverse is not true.</simpara>
<simpara>All floating point literals in Java have type <literal>double</literal> unless they have
an <literal>f</literal> or <literal>F</literal> appended on the end. Thus, <literal>3.14</literal> is a <literal>double</literal> literal,
but <literal>3.14f</literal> is a <literal>float</literal> literal.</simpara>
</section>
<section xml:id="_floating_point_output">
<title>Floating point output</title>
<simpara>Formatting output for floating point numbers has an extra complication
compared to integers: How many digits after the decimal point should be
displayed? If you are representing money, it is common to show exactly
two digits after the decimal point. By default, all of the non-zero
digits are shown.</simpara>
<simpara>Instead of using <literal>System.out.print()</literal>, you can use <literal>System.out.format()</literal>
to control formatting. When using <literal>System.out.format()</literal>, the first
argument to the method is a <emphasis>format string</emphasis>, a piece of text that gives
all the text you want to output as well as special format specifiers
that indicate where other data is to appear and how it should be
formatted. This method takes an additional argument for each format
specifier you use. The specifier <literal>%d</literal> is for integer values, the
specifier <literal>%f</literal> is for floating point values (including both <literal>float</literal> and
<literal>double</literal> types), and the specifier <literal>%s</literal> is for text. Consider the
following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.format("%s! I broke %d records in %f seconds.\n",
    "Bob", 3, 2.4985);</programlisting>
<simpara>The output of this code is</simpara>
<programlisting language="java" linenumbering="unnumbered">Bob! I broke 3 records in 2.4985 seconds.</programlisting>
<simpara>This kind of output is based on the <literal>printf()</literal> function used for output
in the C programming language. It allows the programmer to have a
holistic picture of what the final output might look like, but it also
gives control of formatting through the format specifiers. For example,
you can choose the number of digits for a floating point value to
display after the decimal point by putting a <literal>.</literal> and the number between
the <literal>%</literal> and the <literal>f</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.format("$%.2f\n", 123.456789 );</programlisting>
<simpara>The output of this code is</simpara>
<programlisting language="java" linenumbering="unnumbered">$123.46</programlisting>
<simpara>rounding the last digit appropriately. To learn about other ways to use
format strings to manipulate output, read the documentation at
<link xl:href="http://download.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">http://download.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax</link>.</simpara>
</section>
<section xml:id="_basic_arithmetic">
<title>Basic arithmetic</title>
<simpara>The following table lists the arithmetic operators available in Java.
All of these operators can be used on both the integer primitive types
and the floating point primitive types.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Operator</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">+</literallayout></entry>
<entry align="left" valign="top"><simpara>Add</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">-</literallayout></entry>
<entry align="left" valign="top"><simpara>Subtract</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">*</literallayout></entry>
<entry align="left" valign="top"><simpara>Multiply</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">/</literallayout></entry>
<entry align="left" valign="top"><simpara>Divide</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">%</literallayout></entry>
<entry align="left" valign="top"><simpara>Modulus (remainder)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The first four of these should be familiar to you. Addition,
subtraction, and multiplication work as you would expect, provided that
the result is within the range defined for the types you&#8217;re using, but
division is a little confusing. If you divide two integer values in
Java, you&#8217;ll get an integer as a result. If there would have been a
fractional part, it will be truncated, not rounded. Consider the
following.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 1999/1000;</programlisting>
<simpara>In normal mathematics, 1,999 Ã· 1,000 = 1.999. In Java,
<literal>1999/1000</literal> yields <literal>1</literal>, and that&#8217;s what is stored in <literal>x</literal>. For floating
point numbers, Java works much more like normal mathematics.</simpara>
<programlisting language="java" linenumbering="unnumbered">double y = 1999.0/1000.0;</programlisting>
<simpara>In this case, <literal>y</literal> contains <literal>1.999</literal>. The literals <literal>1999.0</literal> and <literal>1000.0</literal>
have type <literal>double</literal>. The type of <literal>y</literal> does not affect the division, but it
had to be <literal>double</literal> to be a legal place to store the result.</simpara>
<warning>
<title>Pitfall: Unexpected integer division</title>
<simpara>It&#8217;s easy to focus on the variable and forget about the types involved
in the operation. Consider the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">double z = 1999/1000;</programlisting>
<simpara>Because <literal>z</literal> has type <literal>double</literal>, it seems that the result of the division
should be <literal>1.999</literal>. However, the dividend and the divisor have type
<literal>int</literal>, and the result is <literal>1</literal>. This value is converted into <literal>double</literal> and
stored in <literal>z</literal> as <literal>1.0</literal>. This mistake is more commonly seen in the
following scenario.</simpara>
<programlisting language="java" linenumbering="unnumbered">double half = 1/2;</programlisting>
<simpara>The code looks fine at first, but <literal>1/2</literal> yields <literal>0</literal>. If the result is to
be stored in a <literal>double</literal> variable, it is better to multiply by <literal>0.5</literal>
instead of dividing by <literal>2</literal>.<?asciidoc-br?></simpara>
</warning>
<simpara>You may not have thought about this idea since elementary school, but
the division operator (<literal>/</literal>) finds the quotient of two numbers. The
modulus operator (<literal>%</literal>) finds the remainder. For example, <literal>15 / 6</literal> is
<literal>2</literal>, but <literal>15 \% 6</literal> is <literal>3</literal> because <literal>6</literal> goes into <literal>15</literal> twice with <literal>3</literal> left
over. The modulus operator is usually used with integer values, but it
is also defined to work with floating point values in Java. It&#8217;s easy to
dismiss the modulus operator because we don&#8217;t often use it in daily
life, but it is incredibly useful in programming. On its face, it allows
us to see the remainder after division. This idea can be applied to see
if a number is even or odd. It can also be used to compress a large
range of random integers to a smaller range. Keep an eye out for it.
We&#8217;ll use it many times in this book.</simpara>
</section>
<section xml:id="_precedence">
<title>Precedence</title>
<simpara>Although all the previous examples use only one mathematical operator,
you can combine several operators and operands into a larger expression
like the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">((a + b) * (c + d)) % e</programlisting>
<simpara>Such expressions are evaluated from left to right, using the standard
order of operations: The <literal>*</literal> and <literal>/</literal> (and also <literal>%</literal>) operators are given
precedence over the <literal>+</literal> and <literal>-</literal> operators. Like in mathematics,
parentheses have the highest precedence and can be used to add clarity.
Thus, the order of evaluation of <literal>a + b / c</literal> is the same as
<literal>a + (b / c)</literal> but different from <literal>(a + b) / c</literal>.</simpara>
<example>
<title>Order of operations</title>
<simpara>Consider the following lines of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 31;
int b = 16;
int c = 1;
int d = 2;
a = b + c * d - a / b / d;</programlisting>
<simpara>What is the result? The first operation to be evaluated is <literal>c * d</literal>,
yielding <literal>2</literal>. The next is <literal>a / b</literal>, yielding <literal>1</literal>, which is then divided
by <literal>d</literal>, yielding <literal>0</literal>. Next <literal>b + 2</literal> gives <literal>18</literal>, and <literal>18 - 0</literal> is still
<literal>18</literal>. Thus, the value stored in <literal>a</literal> is <literal>18</literal>.</simpara>
<simpara>Your inner mathematician might be nervous that <literal>a</literal> is used in the
expression on the right side of the assignment and is also the variable
where the result is stored. This situation is very common in
programming. The value of <literal>a</literal> doesn&#8217;t change until after all the math
has been done. The assignment always happens last.</simpara>
</example>
<simpara>All of the operators we have discussed so far are <emphasis>binary</emphasis> operators.
This use of the word &#8220;binary&#8221; has nothing to do with base 2. A binary
operator takes two things and does something, like adding them together.
A <emphasis>unary</emphasis> operator takes a single operand and does something. The <literal>-</literal>
operator can be used as a unary operator to negate a literal, variable,
or expression. A unary negation has a higher precedence than the other
operators, just like in mathematics. In other words, the variable or
expression will be negated before it is multiplied or divided. The <literal>+</literal>
operator can be used anywhere you would use a unary negation, although
it doesn&#8217;t actually do anything. Consider the following statements.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = - 4;
int b = -c + d / -(e * f);
int s = +t + (-r);</programlisting>
</section>
<section xml:id="_shortcuts">
<title>Shortcuts</title>
<simpara>Some operations happen frequently in Java. For example, increasing a
variable by some amount is a common task. If you want to increase the
value of variable <literal>value</literal> by 10, you can write the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">value = value + 10;</programlisting>
<simpara>Although the statement above is not excessively long, increasing a
variable is common enough that there&#8217;s shorthand for it. To achieve the
same effect, you can use the <literal>+=</literal> operator.</simpara>
<programlisting language="java" linenumbering="unnumbered">value += 10;</programlisting>
<simpara>The <literal>+=</literal> operator gets the value of the variable, in this case <literal>value</literal>,
adds whatever is on its right side, in this case <literal>10</literal>, and stores the
result back into the variable. Essentially, it saves you from writing
the name of the variable twice. And <literal>+=</literal> is not the only shortcut. It is
only one member of a family of shortcut operators that perform a binary
operation between the variable on the left side and the expression on
the right side and then store the value back into the variable. There is
a <literal>-=</literal> operator that decreases a variable, a <literal>*=</literal> operator that scales a
variable, and several others, including shortcuts for bitwise operations
we cover in the next subsection.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="middle"><emphasis role="strong">Operator</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Example</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">+=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a += b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a + b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">-=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a -= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a - b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">*=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a *= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a * b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">/=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a /= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a / b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">%=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a %= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a % b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&amp;=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a &amp;= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a &amp; b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">^=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a ^= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a ^ b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">|=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a |= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a | b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&lt;&lt;=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a &lt;&lt;= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a &lt;&lt; b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&gt;&gt;=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a &gt;&gt;= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a &gt;&gt; b;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&gt;&gt;&gt;=</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a &gt;&gt;&gt;= b;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a &gt;&gt;&gt; b;</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These assignment shortcuts are useful and can make a line shorter and
easier to read.</simpara>
<warning>
<title>Pitfall: Weak type checking with assignment shortcuts</title>
<simpara>Because you can lose precision, it is not allowed to store a <literal>double</literal>
value into an <literal>int</literal> variable. Thus, the following lines of code are
illegal and will not compile.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 0;
x = x + 0.1;</programlisting>
<simpara>In this case, the check makes a lot of sense. If you were able to add
<literal>0.1</literal> to <literal>0</literal> and then store that value into an <literal>int</literal> variable, the
fractional part would be truncated, keeping <literal>0</literal> in the variable.
However, this safeguard against lost precision is not done with
assignment shortcuts. Even though we expect the following lines to be
functionally identical to the previous ones, they will compile (but
still do nothing).</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 0;
x += 0.1;</programlisting>
<simpara>This kind of error can cause problems when the program expects the value
of <literal>x</literal> to grow and eventually reach some level.</simpara>
</warning>
<simpara>There are also two unary shortcuts. Incrementing a value by one and
decrementing a value by one are such common operations that they get
their own special operators, <literal>++</literal> and <literal>--</literal>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="middle"><emphasis role="strong">Operator</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Example</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">++</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a++;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a + 1;</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">--</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a--;</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">a = a - 1;</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Using either an increment or decrement changes the value of a variable.
In all other cases, the use of an assignment operator is required to
change a variable. Even in the binary shortcuts given before, the
programmer is reminded that an assignment is occurring because the <literal>=</literal>
symbol is present.</simpara>
<simpara>Both the increment and decrement operators come in prefix and postfix
flavors. You can write the <literal>++</literal> (or the <literal>--</literal>) in front of the variable
you are changing or behind it.</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = 5;
value++; //now value is 6
++value; //now value is 7
value--; //value is 6 again</programlisting>
<simpara>When used in a line by itself, each flavor works exactly the same.
However, the incremented (or decremented) variable can also be used as
part of a larger expression. In a larger expression, the prefix form
increments (or decrements) the variable <emphasis role="strong">before</emphasis> the value is used in
the expression. Conversely, the postfix form gives back a copy of the
original value, effectively incrementing (or decrementing) the variable
<emphasis role="strong">after</emphasis> the value is used in the expression. Consider the following
example.</simpara>
<programlisting language="java" linenumbering="unnumbered">int prefix = 7;
int prefixResult = 5 + ++prefix;

int postfix = 7;
int postfixResult = 5 + postfix++;</programlisting>
<simpara>After the code is executed, the values of <literal>prefix</literal> and <literal>postfix</literal> are
both <literal>8</literal>. However, <literal>prefixResult</literal> is <literal>13</literal> while <literal>postfixResult</literal> is only
<literal>12</literal>. The original value of <literal>postfix</literal>, which is <literal>7</literal>, is added to <literal>5</literal>,
and then the increment operation happens afterwards.</simpara>
<warning>
<title>Pitfall: Increment confusion</title>
<simpara>Incrementing a variable in Java is a very common operation. Expressions
like <literal>i` and `i</literal> pop up so often that it is easy to forget exactly
what they mean. Programmers occasionally forget that they are shorthand
for <literal>i = i + 1</literal> and begin to think of them as a fancy way to write
<literal>i + 1</literal>.</simpara>
<simpara>When confused, a programmer might write something like the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 14;
i = i++;</programlisting>
<simpara>At first glance, it may appear that the second line of code really means
<literal>i = i = i + 1</literal>. Assigning <literal>i</literal> an extra time is pointless, but it does
no harm. However, remember that the postfix version gives back a copy of
the original value, before it has been incremented. In this case, <literal>i</literal>
will be incremented, but then its original value will be stored back
into itself. In the code given above, the final value of <literal>i</literal> is still
<literal>14</literal>.</simpara>
</warning>
<simpara>In general it is unwise to perform increment or decrement operations in
the middle of larger expressions, and we advise against doing so. In
some cases, code can be shortened by cleverly hiding an increment in the
middle of some other expression. However, when reading back over the
code, it always takes a moment to be sure that increment or decrement is
doing exactly what it should. The additional confusion caused by this
cleverness is not worth the line of code saved. Furthermore, the
compiler will translate the operations into exactly the same bytecode,
meaning that the shorter version is no more efficient than the longer
version.</simpara>
<simpara>Nevertheless, many programmers enjoy squeezing their code down to the
smallest number of lines of code possible. You may have to read code
that uses increments and decrements in clever (if obscure) ways, but you
should always strive to make your own code as readable as possible.</simpara>
</section>
<section xml:id="_bitwise_operators_2">
<title>Bitwise operators</title>
<simpara>In addition to normal mathematical operators, Java provides a set of
<emphasis>bitwise</emphasis> operators corresponding to the operations we discussed in
ChapterÂ <xref linkend="chapter:Computer_Basics"/>. These operators perform bitwise
operations on integer values. The bitwise operators are <literal>&amp;</literal>, <literal>|</literal>, <literal>^</literal>,
and <literal>~</literal> (which is unary). In addition, there are bitwise <emphasis>shift</emphasis>
operators: <literal>&lt;&lt;</literal> for signed left shift, <literal>&gt;&gt;</literal> for signed right shift, and
<literal>&gt;&gt;&gt;</literal> for unsigned right shift. There is no unsigned left shift operator
in Java.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="middle"><emphasis role="strong">Operator</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&amp;</literallayout></entry>
<entry align="center" valign="middle"><simpara>Bitwise AND</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation that has 1s in every position that both the original
representations have a 1</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">|</literallayout></entry>
<entry align="center" valign="middle"><simpara>Bitwise OR</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation that has 1s in every position that either of the original
representations have a 1</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">^</literallayout></entry>
<entry align="center" valign="middle"><simpara>Bitwise XOR</simpara></entry>
<entry align="left" valign="top"><simpara>Combines two binary representations into a new
representation that has 1s in every position that the original
representations have different values</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">~</literallayout></entry>
<entry align="center" valign="middle"><simpara>Bitwise NOT</simpara></entry>
<entry align="left" valign="top"><simpara>Takes a representation and creates a new
representation in which every bit is flipped from 0 to 1 and 1 to 0</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&lt;&lt;</literallayout></entry>
<entry align="center" valign="middle"><simpara>Signed left shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the left, shifting 0s into the rightmost bits</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&gt;&gt;</literallayout></entry>
<entry align="center" valign="middle"><simpara>Signed right shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the right, padding the left with copies of the sign bit</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">&gt;&gt;&gt;</literallayout></entry>
<entry align="center" valign="middle"><simpara>Unsigned right shift</simpara></entry>
<entry align="left" valign="top"><simpara>Moves all the bits the specified number of
positions to the right, padding with 0s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When used with <literal>byte</literal> and <literal>short</literal>, all bitwise operators will
automatically convert their operands to 32-bit <literal>int</literal> values. It is
crucial to remember this conversion since the number of bits used for
representation is a fundamental part of bitwise operators.</simpara>
<simpara>The following example shows these operators in use. In order to
understand the output, you need to understand how integers are
represented in the binary number system, which is discussed in
SectionÂ <xref linkend="syntax:Data_representation"/>.</simpara>
<example>
<title>Binary operators in Java</title>
<simpara>The following code shows a sequence of bitwise operations performed with
the values <literal>3</literal> and <literal>-7</literal>. To understand the results, remember that, in
32-bit two&#8217;s complement representation, <literal>3</literal> =
<literal>0000 0000 0000 0000 0000 0000 0000 0011</literal> and <literal>-7</literal> =
<literal>1111 1111 1111 1111 1111 1111 1111 1001</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 3;
int y = -7;
int z = x &amp; y;
System.out.println("x &amp; y\t= " + z);
z = x | y;
System.out.println("x | y\t= " + z);
z = x ^ y;
System.out.println("x ^ y\t= " + z);
z = x &lt;&lt; 2;
System.out.println("x &lt;&lt; 2\t= " + z);
z = y &gt;&gt; 2;
System.out.println("y &gt;&gt; 2\t= " + z);
z = y &gt;&gt;&gt; 2;
System.out.println("y &gt;&gt;&gt; 2\t= " + z);</programlisting>
<simpara>The output of this fragment of code is:</simpara>
<programlisting language="java" linenumbering="unnumbered">x &amp; y   = 1
x | y   = -5
x ^ y   = -6
x &lt;&lt; 2  = 12
y &gt;&gt; 2  = -2
y &gt;&gt;&gt; 2 = 1073741822</programlisting>
<simpara>Note how the escape sequence <literal>\t</literal> is used to put a tab character in the
output, making the results line up.</simpara>
</example>
<simpara>Why use the bitwise operators at all? Sometimes you may read data as
individual <literal>byte</literal> values, and you might need to combine four of these
values into a single <literal>int</literal> value. Although the signed left shift (<literal>&lt;&lt;</literal>)
and signed right shift (<literal>&gt;&gt;</literal>) are, respectively, equivalent to repeated
multiplications by 2 or repeated divisions by 2, they are faster than
doing these operations over and over. Finally, some of these operations
are used for cryptographic or random number generation purposes.</simpara>
</section>
<section xml:id="castSection">
<title>Casting</title>
<simpara>Sometimes you need to use different types (like integers and floating
point values) together. Other times, you have a value in one type, but
you need to store it in another (like when you are rounding a <literal>double</literal>
to the nearest <literal>int</literal>). Some combinations of operators and types are
allowed, but others cause compiler errors.</simpara>
<simpara>The guiding rule is that Java allows an assignment from one type to
another, provided that no precision is lost. That is, we can copy a
value of one type into a variable of another type, provided that the
destination variable has a broader type than the source value. The next
few examples illustrate how to convert between different numerical
types.</simpara>
<example>
<title>Upcast with integers</title>
<simpara>Consider the following statements.</simpara>
<programlisting language="java" linenumbering="unnumbered">short x = 341;
int y = x;</programlisting>
<simpara>Because the type of <literal>y</literal> is <literal>int</literal>, which is broader than <literal>short</literal>, the
type of <literal>x</literal>, it is legal to assign the value in <literal>x</literal> to variable <literal>y</literal>. In
the assignment, a value with the narrower type <literal>short</literal> is converted to
an equivalent value with the broader type <literal>int</literal>. Converting from a
narrower type to a broader type is called an <emphasis>upcast</emphasis> or a <emphasis>promotion</emphasis>,
and Java allows it with no complaint. Most languages allow upcasts
without any special syntax because it is always safer to move from a
narrower, more restrictive type to a broader, less restrictive one.</simpara>
</example>
<example>
<title>Downcast error</title>
<simpara>Consider these statements that declare variables <literal>a</literal>, <literal>b</literal>, and <literal>c</literal> and
compute a value for <literal>c</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 10;
int b = 2;
byte c;
c = a + b;</programlisting>
<simpara>If you try compiling these statements as part of a Java program, you get
an error message like the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">Error: possible loss of precision
found: int
required: byte</programlisting>
<simpara>The compiler generates the error above because the sum of two <literal>int</literal>
values is another <literal>int</literal> value, which could be greater than the maximum
value you can store in <literal>c</literal>, of type <literal>byte</literal>. In this example, <emphasis role="strong">you</emphasis> know
that the value of <literal>12</literal> does not exceed the maximum of <literal>127</literal>, but the
Java compiler is inherently cautious. It complains whenever the type of
the expression to be evaluated is broader than the type of the
destination variable.</simpara>
</example>
<example>
<title>Upcast from integers to floating point</title>
<simpara>Integers are automatically converted to floating point when needed.
Consider the following statement.</simpara>
<programlisting language="java" linenumbering="unnumbered">double tolerance = 3;</programlisting>
<simpara>The literal <literal>3</literal> has type <literal>int</literal>, but it is automatically converted to the
floating point value <literal>3.0</literal> with type <literal>double</literal>. Again, <literal>double</literal> (and also
<literal>float</literal>) are considered broader types than any integer types.
Consequently, this type conversion is an upcast and is completely legal.</simpara>
<simpara>Upcasts also occur with arithmetic operations. Whenever you try to do
arithmetic with two different numerical types, the narrower type is
automatically upcast to the broader one.</simpara>
<programlisting language="java" linenumbering="unnumbered">double value = 3 + 7.2;</programlisting>
<simpara>In this statement, <literal>3</literal> is automatically upcast to its <literal>double</literal> version
<literal>3.0</literal> because <literal>7.2</literal> has the broader <literal>double</literal> type.</simpara>
</example>
<simpara>In order to perform a downcast, the programmer has to mark that he or
she intends for the conversion to happen. A downcast is marked by
putting the result type in parentheses before the expression you want
converted. The next example illustrates how to cast a <literal>double</literal> value to
type <literal>int</literal>.</simpara>
<example>
<title>Downcast from double to int</title>
<simpara>The following statements cause a compiler error because an expression
with type <literal>double</literal> cannot be stored into a variable with type <literal>int</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">double roomArea = 3.5;
int houseArea = roomArea * 4.0;</programlisting>
<simpara>A downcast can lose precision, and that&#8217;s why Java doesn&#8217;t allow it.
Sometimes a downcast is necessary, and you can override Java&#8217;s type
system with an explicit cast. To do so, we put the expected (or desired)
result type in parentheses before the expression. In this case (and many
others), it is also necessary to surround the expression with
parentheses so that the entire expression (and not just <literal>roomArea</literal>) is
converted to type <literal>int</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">double roomArea = 3.5;
int houseArea = (int) (roomArea * 4.0);</programlisting>
<simpara>In this case, the expression has value <literal>14.0</literal>. Consequently, the <literal>int</literal>
version is <literal>14</literal>. In general, the value could have a fractional part.
When casting from a floating point type to an integer type, the
fractional part is truncated <emphasis role="strong">not</emphasis> rounded. Consider the following
statement:</simpara>
<programlisting language="java" linenumbering="unnumbered">int count = (int) 15.99999;</programlisting>
<simpara>Mathematically, it seems obvious that <literal>15.99999</literal> should be rounded to
the nearest <literal>int</literal> value of <literal>16</literal>, but Java does not do this. Instead, the
code above stores <literal>15</literal> into <literal>count</literal>. If you want to round the value,
Java provides a method for rounding in the <literal>Math</literal> class. The rounding
(instead of truncating) version is given below.</simpara>
<programlisting language="java" linenumbering="unnumbered">int count = (int) Math.round(15.99999);</programlisting>
<simpara>The value given back by <literal>Math.round()</literal> has type <literal>long</literal>. The designers of
the <literal>Math</literal> class did this so that the same method could be used to round
large <literal>double</literal> values into a <literal>long</literal> value, since the result might not
fit in an <literal>int</literal> value. Since <literal>long</literal> is a broader type than <literal>int</literal>, we
have to downcast the result to an <literal>int</literal> so that we can store it in
<literal>count</literal>.</simpara>
</example>
<example>
<title>Conversion from double to float</title>
<simpara>Consider the following declaration and assignment of variable
<literal>roomArea</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">float roomArea;
roomArea = 2.0;</programlisting>
<simpara>This assignment is illegal in Java, and the compiler gives an error
message like the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">Error: possible loss of precision
found: double
required: float</programlisting>
<simpara>As we mentioned earlier, the literal <literal>2.0</literal> has type <literal>double</literal>. When you
try to assign a <literal>double</literal> value to a <literal>float</literal> variable, there is always a
risk that precision will be lost. The best way to avoid the error above
is to declare <literal>roomArea</literal> with type <literal>double</literal>. Alternatively, we could
store the <literal>float</literal> literal <literal>2.0f</literal> into <literal>roomArea</literal>. We could also assign
<literal>2</literal> instead of <literal>2.0</literal> to <literal>roomArea</literal>, since the upcast from <literal>int</literal> is done
automatically.</simpara>
<simpara>Remember, you should almost always use the <literal>double</literal> type to represent
floating point numbers. Only in rare cases when you need to save memory
should you use <literal>float</literal> values. By making it illegal to store <literal>2.0</literal> into
a <literal>float</literal> variable, Java is encouraging you to use high precision
storage.</simpara>
</example>
<simpara>Numerical types and the conversions between them are critical elements
of programming in Java, which has a strong mathematical foundation. In
addition to these numerical types, Java also provides two other types
that represent individual characters and Boolean values. We examine
these next.</simpara>
</section>
<section xml:id="_characters_literal_char_literal">
<title>Characters: <literal>char</literal></title>
<simpara>Sentences are made up of words. Words are made up of letters. Although
we have discussed many powerful tools for representing numbers in Java,
we need a way to represent letters and other characters that we might
find in printed text. Values with the <literal>char</literal> type are used to represent
individual letters.</simpara>
<simpara>In the older languages of C and C++, the <literal>char</literal> type used 8 bits for
storage. From ChapterÂ <xref linkend="chapter:Computer_Basics"/>, you know that you can
represent up to 2<superscript>8</superscript> = 256 values with 8 bits. The Latin
alphabet, which is used to write English, uses 26 letters. If we need to
represent upper and lower case letters, the 10 decimal digits,
punctuation marks, and quite a few other special symbols, 256 values is
plenty. However, people all over the world use computers and want to
store text from their language written in their script digitally. Taking
the Chinese character system alone, some Chinese dictionaries list over
100,000 characters!</simpara>
<simpara>Java uses a standard called the UTF-16 encoding to represent characters.
UTF-16 is part of a larger international standard called Unicode, which
is an attempt to represent most of the world&#8217;s writing systems as
numbers that can be stored digitally. Most of the inner workings of
Unicode aren&#8217;t important for day-to-day Java programming, but you can
visit <link xl:href="http://www.unicode.org/">http://www.unicode.org/</link> if you want more information.</simpara>
<simpara>In Java, each variable of type <literal>char</literal> uses 16 bits of storage.
Therefore, each character variable could assume any value from among a
total of 2<superscript>16</superscript> = 65,536 possibilities (although a few of
these are not legal characters). Here are a few declarations and
assignments of variables of type <literal>char</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">char letter = 'A';
char punctuation = '?';
char digit = '7';</programlisting>
<simpara>We are storing <literal>char</literal> literals into each of the variables above. Most of
the <literal>char</literal> literals you will use commonly are made by typing the single
character you want in <emphasis role="strong">single</emphasis> quotes (<literal>'</literal>), such a <literal>'z'</literal>. These
characters can be upper- or lowercase letters, single numerical digits,
or other symbols.</simpara>
<simpara>The space character literal is <literal>' '</literal>, but some characters are harder to
represent. For example, a new line (the equivalent of pressing
<literal>&lt;enter&gt;</literal>) is represented as a single character, but we can&#8217;t type a
single quote, hit <literal>&lt;enter&gt;</literal>, and then type the second quote. Instead,
the character to represent a new line is <literal>'\n'</literal>, which we will refer to
simply as a <emphasis>newline</emphasis>. Every <literal>char</literal> variable can only hold a single
character. It appears that <literal>'\n'</literal> has multiple characters in it, but it
does not. The use of the backslash (<literal>\</literal>) marks an <emphasis>escape sequence</emphasis>,
which is a combination of characters used to represent a specific
difficult to type or represent character. Here is a table of common
escape sequences.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Escape Sequence</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Character</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">\n</literallayout></entry>
<entry align="center" valign="top"><simpara>Newline</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">\t</literallayout></entry>
<entry align="center" valign="top"><simpara>Tab</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">\'</literallayout></entry>
<entry align="center" valign="top"><simpara>Single quote</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">\\</literallayout></entry>
<entry align="center" valign="top"><simpara>Backslash</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Remember, everything inside of a computer is represented with numbers,
and each <literal>char</literal> value has some numerical equivalent. These numbers are
arbitrary but systematic. For example, the character <literal>'a'</literal> has a
numerical value of <literal>97</literal>, and <literal>'b'</literal> has a numerical value of <literal>98</literal>. The
codes for all of the lowercase Latin letters are sequential in
alphabetical order. (The codes for uppercase letters are sequential too,
but there is a gap between them and the lowercase codes.)</simpara>
<simpara>Some Unicode characters are difficult to type because your keyboard or
operating system has no easy way to produce the character. Another kind
of escape sequence allows you to specify any character by its Unicode
value. There are large tables listing all possible Unicode characters by
numerical values. If you want to represent a specific literal, you type
<literal>'\uxxxx'</literal> where <literal>xxxx</literal> is a hexadecimal number representing the value.
For example, <literal>'\u0064'</literal> converted into decimal is
16 Ã 6 + 4 = 100, which is the letter <literal>'d'</literal>.</simpara>
<example>
<title>Printing single characters</title>
<simpara>If you print a <literal>char</literal> variable or literal directly, it prints the
character representation on the screen. For example, the following
statement prints <literal>A</literal> not <literal>65</literal>, the Unicode value of <literal>'A'</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println('A');</programlisting>
<simpara>However, the Unicode values <emphasis role="strong">are</emphasis> numbers. If you try to perform
arithmetic on them, Java will treat them like numbers. For example, the
following statement adds the integer equivalents of the characters
(65 + 66 = 131), concatenates the sum with the <literal>String</literal>
<literal>"C"</literal>, and concatenates the result with a <literal>String</literal> representation of the
<literal>int</literal> literal <literal>999</literal>. The final output is <literal>131C999</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println('A' + 'B' + "C" + 999);</programlisting>
</example>
</section>
<section xml:id="_booleans_literal_boolean_literal">
<title>Booleans: <literal>boolean</literal></title>
<simpara>If you are new to programming, it may seem useless to have a type
designed to hold only true and false values. These values are called
<emphasis>Boolean values</emphasis>, and the logic used to manipulate them turns out to be
crucial to almost every program. We use them to represent conditions in
Chapters <xref linkend="chapter:Selection"/>, <xref linkend="chapter:Repetition"/>, and beyond.</simpara>
<simpara>To store these truth values, Java uses the type <literal>boolean</literal>. There are
exactly two literals for type <literal>boolean</literal>: <literal>true</literal> and <literal>false</literal>. Here are
two declarations and assignments of <literal>boolean</literal> variables.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean awesome = true;
boolean testFailed = false;</programlisting>
<simpara>If we could only store these two literals, <literal>boolean</literal> variables would
have limited usefulness. However, Java provides a full range of
<emphasis>relational</emphasis> operators that allow us to compare values. Each of these
operators generates a <literal>boolean</literal> result. For example, we can test to see
if two numbers are equal, and the answer is either <literal>true</literal> or <literal>false</literal>.
All Java relational operators are listed in the table below. Assume that
all variables used in the <emphasis role="strong">Example</emphasis> column have a numeric type.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Symbol</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Read as</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">==</literallayout></entry>
<entry align="left" valign="top"><simpara>equal to</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x + 3 == y * 2</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">!=</literallayout></entry>
<entry align="left" valign="top"><simpara>not equal to</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x !=  y / 4</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">&lt;</literallayout></entry>
<entry align="left" valign="top"><simpara>less than</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x &lt; 3.5</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">&lt;=</literallayout></entry>
<entry align="left" valign="top"><simpara>less than or equal to</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x &lt;= y</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">&gt;</literallayout></entry>
<entry align="left" valign="top"><simpara>greater than</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x &gt; y+1</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><literallayout class="monospaced">&gt;=</literallayout></entry>
<entry align="left" valign="top"><simpara>greater than or equal to</simpara></entry>
<entry align="left" valign="top"><literallayout class="monospaced">x + y &gt;= z</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<example>
<title>Boolean variables</title>
<simpara>The following declarations and assignments illustrate some uses of
<literal>boolean</literal> variables. Note the use of the relational operators <literal>==</literal> and
<literal>&gt;</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 3;
int y = 4;
boolean same = (x == 3);
same = (x == y);
boolean xIsGreater = (x &gt; y);</programlisting>
<simpara>In the first use of <literal>==</literal> above, the value of <literal>same</literal> is <literal>true</literal> because
the value of <literal>x</literal> is <literal>3</literal>. In the second comparison, the value of <literal>same</literal>
is <literal>false</literal> because the values of <literal>x</literal> and <literal>y</literal> are different. The value of
<literal>xIsGreater</literal> is also <literal>false</literal> since the value of <literal>x</literal> is not greater than
the value of <literal>y</literal>.</simpara>
</example>
<simpara>In addition to the relational operators, Java also provides <emphasis>logical</emphasis>
operators that can be used to combine or negate <literal>boolean</literal> values. These
are the logical AND (<literal>&amp;&amp;</literal>), logical OR (<literal>||</literal>), logical XOR (<literal>^</literal>), and
logical NOT (<literal>!</literal>) operators.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="middle"><emphasis role="strong">Name</emphasis></entry>
<entry align="center" valign="middle"><emphasis role="strong">Operator</emphasis></entry>
<entry align="left" valign="middle"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara>AND</simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">&amp;&amp;</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if both values are <literal>true</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>OR</simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">||</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if either value is <literal>true</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>XOR</simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">^</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if values are different</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>NOT</simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">!</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns the opposite of the value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All of these operators, except for NOT, are binary operators. Logical
AND is used when you want your result to be <literal>true</literal> only if both the
operands being combined evaluate to <literal>true</literal>. Logical OR is used when you
want your result to be <literal>true</literal> if either operand is <literal>true</literal>. Logical XOR
is used when you want your result to be <literal>true</literal> if one but not both of
your operands is <literal>true</literal>. The unary logical NOT operator (<literal>!</literal>) results in
the opposite value of its operand, switching <literal>true</literal> to <literal>false</literal> or
<literal>false</literal> to <literal>true</literal>. Both the relational operators and the logical
operators are described in greater detail in
ChapterÂ <xref linkend="chapter:Selection"/>.</simpara>
</section>
</section>
<section xml:id="_reference_types">
<title>Reference types</title>
<simpara>Now we will move on to reference types, which vastly outnumber the
primitive types, with new types created all the time. Nevertheless, the
primitive types in Java are important, partly because they are the
building blocks for reference types.</simpara>
<simpara>Recall that a variable with a reference type does not contain a concrete
value like a primitive variable. Instead, the value it holds is a
reference or arrow pointing to the &#8220;real&#8221; object. It&#8217;s like a name for
an object. When you declare a reference variable in Java, it starts off
pointing at nothing, represented by the special literal <literal>null</literal>. For
example, the following code creates a <literal>Wombat</literal> variable called <literal>w</literal>,
which doesn&#8217;t point at anything.</simpara>
<programlisting language="java" linenumbering="unnumbered">Wombat w;</programlisting>
<simpara>To create an object in Java, you use the <literal>new</literal> keyword followed by the
name of the type and parentheses, which can either be empty or contain
data you want to use to initialize the object. This process is called
invoking the <emphasis>constructor</emphasis>, which creates space for the object and then
initializes it with the values you specify or with default values if you
leave the parentheses empty. Below we invoke the default <literal>Wombat</literal>
constructor and point the variable <literal>w</literal> at the resulting object.</simpara>
<programlisting language="java" linenumbering="unnumbered">w = new Wombat();</programlisting>
<simpara>Alternatively, the <literal>Wombat</literal> type might allow you to specify its mass in
kilograms when creating one, as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">w = new Wombat(26.3);</programlisting>
<simpara>Assignment of reference types points the two references to the same
object. Thus, we can have two different <literal>Wombat</literal> references pointing at
the same object.</simpara>
<programlisting language="java" linenumbering="unnumbered">Wombat w1 = new Wombat(26.3);
Wombat w2 = w1;</programlisting>
<figure role="text-center">
<title>Two <literal>Wombat</literal> references pointing at the same object.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/03-strings-primitive-types/images/wombat.svg" width="50%"/>
</imageobject>
<textobject><phrase>wombat</phrase></textobject>
</mediaobject>
</figure>
<simpara>Then, anything we do to <literal>w1</literal> will affect <literal>w2</literal> and vice versa. For
example, we can tell <literal>w1</literal> to eat leaves using the <literal>eatLeaves()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">w1.eatLeaves();</programlisting>
<simpara>Perhaps this will increase the mass of the object that <literal>w1</literal> points at to
<literal>26.9</literal> kilograms. But the mass of the object that <literal>w2</literal> points at will be
increased as well, because they are the <emphasis role="strong">same object</emphasis>. Since primitive
variables hold values and not references to objects, this kind of code
works very differently with them. Consider the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 10;
int b = a;
a = a + 5;</programlisting>
<simpara>In this code, <literal>a</literal> is initialized to have a value of <literal>10</literal> and <literal>b</literal> is
initialized to have whatever value <literal>a</literal> has, namely <literal>10</literal>. The third line
increases the value of <literal>a</literal> to <literal>15</literal>, but <literal>b</literal> is still <literal>10</literal>.</simpara>
<figure role="text-center">
<title>Because they are primitive, <literal>int</literal> variables store values, not references.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/03-strings-primitive-types/images/primitive.svg" width="25%"/>
</imageobject>
<textobject><phrase>primitive</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now that we&#8217;ve highlighted some of the differences between primitive and
reference types, we explain the <literal>String</literal> type more deeply. You use it
frequently, but it has a few unusual features that are not shared by any
other reference types.</simpara>
<section xml:id="_literal_string_literal_basics">
<title><literal>String</literal> basics</title>
<simpara>The <literal>String</literal> type is used to represent text in Java. A <literal>String</literal> object
contains a sequence of zero or more <literal>char</literal> values. Unlike every other
reference type, there is a literal form for <literal>String</literal> objects. These
literals are written with the text you want to represent inside of
double quotes (<literal>"</literal>), such as <literal>"Fight the power!"</literal>. You can declare a
<literal>String</literal> reference and initialize it by setting it equal to another
<literal>String</literal> reference or a <literal>String</literal> literal. Like any other reference, you
could leave it uninitialized.</simpara>
<simpara>There is a difference between an uninitialized <literal>String</literal> (a reference
that points to <literal>null</literal>) and a <literal>String</literal> of length 0. A <literal>String</literal> of length
0 is also known as an <emphasis>empty string</emphasis> and is written <literal>""</literal>. The space
character (<literal>' '</literal>) and escape sequences such as <literal>'\\n'</literal> can be a part of
a <literal>String</literal> and add to its length. For example, <literal>"ABC"</literal> contains three
characters, but the <literal>String</literal> <literal>"A B C"</literal> has five, because the spaces on
each side of <literal>'B'</literal> count. The next example illustrates some ways of
defining and using the <literal>String</literal> type.</simpara>
<example>
<title>String assignment</title>
<simpara>The following declarations define two <literal>String</literal> references named
<literal>greeting</literal> and <literal>title</literal> and initialize each with a literal.</simpara>
<programlisting language="java" linenumbering="unnumbered">String greeting = "Bonjour!"
String title = "French Greeting";</programlisting>
<simpara>As you have seen in ChapterÂ <xref linkend="chapter:Problem_Solving_and_Programming"/>,
<literal>String</literal> values can be output using <literal>System.out.print()</literal> and
<literal>JOptionPane</literal> methods.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println(greeting);
JOptionPane.showMessageDialog(null, greeting, title, JOptionPane.INFORMATION_MESSAGE);</programlisting>
<simpara>The first statement above displays <literal>Bonjour!</literal> on the terminal. The
second statement creates a dialog box with the title <literal>French Greeting</literal>
and the message <literal>Bonjour!</literal></simpara>
</example>
</section>
<section xml:id="_literal_string_literal_operations">
<title><literal>String</literal> operations</title>
<simpara>In ChapterÂ <xref linkend="chapter:Problem_Solving_and_Programming"/>, you saw that we
can <emphasis>concatenate</emphasis> two <literal>String</literal> objects into a third <literal>String</literal> object
using the <literal>+</literal> operator. This operator is unusual for a reference type.
Almost all other reference types are only able to use the assignment
operator (<literal>=</literal>) and the comparison operator (<literal>==</literal>). Like other reference
types, the <literal>String</literal> class provides methods for interaction. We introduce
a few <literal>String</literal> methods in this section and subsequent sections, but the
<literal>String</literal> class defines many more.</simpara>
<example>
<title>String concatenation</title>
<simpara>Here is another example of combining <literal>String</literal> objects using the <literal>+</literal>
operator.</simpara>
<programlisting language="java" linenumbering="unnumbered">String argument = "the cannon";
String phrase = "No argument but " + argument + "!";</programlisting>
<simpara>In these statements, we initialize <literal>argument</literal> to <literal>"the cannon"</literal>. We then
compute the value of <literal>phrase</literal> by adding, or concatenating, three
<literal>String</literal> values: <literal>"No argument but "</literal>, the value of <literal>argument</literal>, and
<literal>"!"</literal>. The result is <literal>"No argument but the cannon!"</literal>. If <literal>argument</literal> had
been initialized to <literal>"a pie in the face"</literal>, then <literal>phrase</literal> would point to
<literal>"No argument but a pie in the face!"</literal>.</simpara>
<simpara>Another way of concatenating two <literal>String</literal> objects is by using the
<literal>String</literal> <literal>concat()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">String argument = "the cannon";
String exclamation = "!";
String phraseStart = "No argument but ";
String phrase = phraseStart.concat(argument);
phrase = phrase.concat(exclamation);</programlisting>
<simpara>This sequence of statements gives the same result as the one above it
using the <literal>+</literal> operator. In practice, the <literal>concat()</literal> method is rarely
used because the <literal>+</literal> operator is so convenient. Note that <literal>String</literal>
objects in Java are <emphasis>immutable</emphasis>, meaning that calling a method on a
<literal>String</literal> object will never change it. In the code above, calling
<literal>concat()</literal> creates new <literal>String</literal> objects. The <literal>phrase</literal> reference points
first at one <literal>String</literal> then it points at a new <literal>String</literal> on the next line.
In this case the <emphasis role="strong">reference</emphasis> can be changed, but a <literal>String</literal> <emphasis role="strong">object</emphasis>
never changes once it has been created. This distinction is a subtle but
important one.</simpara>
</example>
<simpara>A host of other methods can be used on a <literal>String</literal> just like <literal>concat()</literal>.
For example, the length of a <literal>String</literal> can be found using the <literal>length()</literal>
method. The following statements prints <literal>30</literal> to the terminal.</simpara>
<programlisting language="java" linenumbering="unnumbered">String motto = "Fight for your right to party!";
System.out.println(motto.length()):</programlisting>
<simpara><literal>String</literal> literals are <literal>String</literal> objects as well, and you can call methods
on them. The following code stores <literal>11</literal> into <literal>letters</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int letters = "cellar door".length();</programlisting>
<simpara>Remember that a <literal>String</literal> is a sequence of <literal>char</literal> values. If you want to
find out what <literal>char</literal> is at a particular location within a <literal>String</literal>, you
can use the <literal>charAt()</literal> method.</simpara>
<simpara>This method is called with an <literal>int</literal> value giving the index you want to
know about. Indexes inside of a <literal>String</literal> start at 0, not at 1.
Zero-based numbering is used extensively in programming, and we discuss
it further in ChapterÂ <xref linkend="chapter:Arrays"/>. (It may help if you think of
the index as the number of characters that appear before the character
at the specified index.) The next example shows how <literal>charAt()</literal> can be
used.</simpara>
<example>
<title>Examining the char value at an index</title>
<simpara>To see what <literal>char</literal> is at a given location, we call <literal>charAt()</literal> with the
index in question, as shown below.</simpara>
<programlisting language="java" linenumbering="unnumbered">String word = "antidisestablishmentarianism";
char letter = word.charAt(11);</programlisting>
<simpara>In this case, <literal>letter</literal> is assigned the value <literal>'b'</literal>. Remember, indexes
for <literal>char</literal> values inside of a <literal>String</literal> start with 0. Thus, the <literal>char</literal> at
index 0 is <literal>'a'</literal>, the <literal>char</literal> at index 1 is <literal>'n'</literal>, the <literal>char</literal> at index 2
is <literal>'t'</literal>, and so on. If you count up to the twelfth <literal>char</literal> (which has
index 11), it should be <literal>'b'</literal>.</simpara>
<simpara>Every <literal>char</literal> inside of a <literal>String</literal> counts, whether it is a letter, a
digit, a space, punctuation, or some other symbol.</simpara>
<programlisting language="java" linenumbering="unnumbered">String text = "^_^ l337 #haxor# skillz!";
System.out.println(text.charAt(10));</programlisting>
<simpara>This code prints out <literal>h</literal> since <literal>'h'</literal> is the eleventh <literal>char</literal> (with index
10) in <literal>text</literal>.</simpara>
</example>
<simpara>A contiguous sequence of characters inside of a <literal>String</literal> is called a
<emphasis>substring</emphasis>. For example, a few substrings of
<literal>"Throw your hands in the air!"</literal> are <literal>"T"</literal>, <literal>"Throw"</literal>, <literal>"hands"</literal>, and
<literal>"ur ha"</literal>. Note that <literal>"Ty"</literal> is not a substring because these characters
do not appear next to each other.</simpara>
<simpara>The <literal>String</literal> class provides the <literal>indexOf()</literal> method to find the position
of a substring, as shown in the next example.</simpara>
<example>
<title>String search</title>
<simpara>Suppose we wish to find a <literal>String</literal> inside of another <literal>String</literal>. To do so,
we call the <literal>indexOf()</literal> method on the <literal>String</literal> we&#8217;re searching inside
of, with the <literal>String</literal> we&#8217;re searching for as the argument.</simpara>
<programlisting language="java" linenumbering="unnumbered">String countries = "USA Mexico China Canada";
String search = "China";
System.out.println(countries.indexOf(search));</programlisting>
<simpara>The <literal>indexOf()</literal> method returns an <literal>int</literal> value that gives the position of
the <literal>String</literal> we&#8217;re searching for. In the code above, the output is <literal>11</literal>
because <literal>"China"</literal> appears starting at index 11 inside the <literal>countries</literal>
<literal>String</literal>. (Alternatively, there are 11 characters before <literal>"China"</literal> in
the <literal>String</literal>.) If the given substring cannot be found, the <literal>indexOf()</literal>
method returns <literal>-1</literal>. For example, <literal>-1</literal> will be printed to the terminal
if we replace the print statement above with the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println(countries.indexOf("Honduras"));</programlisting>
</example>
<simpara>There are several other methods provided by <literal>String</literal> that we introduce
as the need arises. If you are curious, you should look into the Java
documentation for <literal>String</literal> at
<link xl:href="http://download.oracle.com/javase/7/docs/api/java/lang/String.html">http://download.oracle.com/javase/7/docs/api/java/lang/String.html</link> for a
complete list of available methods.</simpara>
</section>
</section>
<section xml:id="_assignment_and_comparison">
<title>Assignment and comparison</title>
<simpara>Both assigning one variable to another and testing two variables to see
if they are equal to each other are important operations in Java. These
operations are used on both primitive and reference types, but there are
subtle differences between the two that we discuss below.</simpara>
<section xml:id="_assignment_statements">
<title>Assignment statements</title>
<simpara>Assignment is the act of setting one variable to the value of another.
With a primitive type, the value held inside one variable is copied to
the other. With a reference type, the arrow that points at the object is
copied. All types in Java perform assignment with the assignment
operator (<literal>=</literal>).</simpara>
<simpara>As we have discussed, values can be computed and then assigned to
variables as in the following statement.</simpara>
<programlisting language="java" linenumbering="unnumbered">int value = Integer.parseInt(response);</programlisting>
<simpara>In Java, a statement that computes a value and assigns it is called an
<emphasis>assignment statement</emphasis>. The generic form of the assignment statement is
as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">identifier = expression;</programlisting>
<simpara>Here, <literal>identifier</literal> gives the name of some variable. For example, in the
statement above, <literal>value</literal> is the name of the variable.</simpara>
<simpara>The right-hand side of an assignment statement is an expression that
returns a value that is assigned to the variable on the left-hand side.
Even an assignment statement can be considered an expression, allowing
us to stack multiple assignments into one line, as in the following
code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a, b, c;
a = b = c = 15;</programlisting>
<simpara>The Java compiler checks for type compatibility between the left and the
right sides of an assignment statement. If the right-hand side is a
broader type than the left-hand side (or is completely mismatched), the
compiler gives an error, as in the following cases.</simpara>
<programlisting language="java" linenumbering="unnumbered">int number = 4.9;
String text = 9;</programlisting>
</section>
<section xml:id="_comparison">
<title>Comparison</title>
<simpara>Comparing two values to see if they are the same uses the comparison
operator (<literal>==</literal>) in Java. With primitive types, this kind of check is
intuitive: The comparison is <literal>true</literal>, if the two values are the same.
With reference types, the value held by the variable is the arrow
pointing to the object. Two reference variables could point to different
objects with identical contents and return <literal>false</literal> when compared to each
other. The following gives examples of these comparisons.</simpara>
<example>
<title>Comparison</title>
<simpara>Consider the following lines of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 5;
int y = 2 + 3;
boolean z = (x == y);</programlisting>
<simpara>The value of variable <literal>z</literal> is <literal>true</literal> because <literal>x</literal> and <literal>y</literal> contain the same
values. If <literal>x</literal> were assigned <literal>6</literal> instead, <literal>z</literal> would be <literal>false</literal>.</simpara>
<simpara>Now, consider the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">String thing1 = new String("Magical mystery");
String thing2 = new String("Magical mystery");
String thing3 = new String("Tragical tapestry");</programlisting>
<figure>
<title>Objects <literal>thing1</literal>, <literal>thing2</literal>, and <literal>thing3</literal> (a)Â in their initial states and (b)Â after the assignment <literal>thing1 = thing2;</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/03-strings-primitive-types/images/differentObjectsFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>differentObjectsFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>This code declares and initializes three <literal>String</literal> values. Although it is
possible to store <literal>String</literal> literals directly without invoking a <literal>String</literal>
constructor, we are using this style of <literal>String</literal> creation to make our
point because Java can do some confusing optimizations otherwise.
Variables <literal>thing1</literal> and <literal>thing2</literal> point to <literal>String</literal> values that contain
identical sequences of characters. Variable <literal>thing3</literal> points to a
different <literal>String</literal>. Consider the following statement.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean same = (thing1 == thing3);</programlisting>
<simpara>In this case the value of <literal>same</literal> is clearly <literal>false</literal> because the two
<literal>String</literal> values are not the same. What about the following case?</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean same = (thing1 == thing2);</programlisting>
<simpara>Again, <literal>same</literal> contains <literal>false</literal>. Although, <literal>thing1</literal> and <literal>thing2</literal> point at
identical objects, they point at <emphasis role="strong">different</emphasis> identical objects. Since
the value held by a reference is the arrow that points to the object,
the comparison operator only shows that two references are the same if
they point at the same object.</simpara>
<simpara>To better understand comparison between reference types, consider
FigureÂ <xref linkend="differentObjectsFigure"/>(a), which shows three different
objects. Note that each reference points at a distinct object, even
though two objects have the same contents.</simpara>
<simpara>Now consider the following assignment.</simpara>
<programlisting language="java" linenumbering="unnumbered">thing1 = thing2;</programlisting>
<simpara>As shown in FigureÂ <xref linkend="differentObjectsFigure"/>(b), this assignment points
reference <literal>thing1</literal> to the same location as reference <literal>thing2</literal>. Then,
<literal>(thing1 == thing2)</literal> would be <literal>true</literal>.</simpara>
<simpara>The <literal>==</literal> operator is generally not very useful with references, and the
<literal>equals()</literal> method should be used instead. This method compares the
contents of objects in whatever way the designer of the type specifies.
For example,</simpara>
<programlisting language="java" linenumbering="unnumbered">thing1.equals(thing2)</programlisting>
<simpara>is <literal>true</literal> when <literal>thing1</literal> and <literal>thing2</literal> are pointing at distinct but
identical <literal>String</literal> objects.</simpara>
</example>
</section>
</section>
<section xml:id="_constants">
<title>Constants</title>
<simpara>In addition to normal variables, we can define <emphasis>named constants</emphasis>. A
named constant is similar to a variable of the same type except that its
value cannot be changed once set. A constant in Java is declared like
any other variable with the addition of the keyword <literal>final</literal> before the
declaration.</simpara>
<simpara>The convention in Java (and many other languages) is to name constants
with all capital letters. Because camel case can no longer be used to
tell where one word starts and another ends, an <emphasis>underscore</emphasis> (<literal>_</literal>) is
used to separate words. Here are a few examples of named constant
declarations.</simpara>
<programlisting language="java" linenumbering="unnumbered">final int POPULATION = 25000;
final double PLANCK_CONSTANT = 6.626E-34;
final boolean FLAG = false;
final char FIRST_INITIAL = 'A';
final String MESSAGE = "All your base are belong to us.";</programlisting>
<simpara>In this code, the value of <literal>POPULATION</literal> is <literal>25000</literal> and cannot be
changed. For example, if you now write <literal>population = 30000;</literal> on a later
line, your compiler will give an error. <literal>PLANCK_CONSTANT</literal>, <literal>FLAG</literal>,
<literal>FIRST_INITIAL</literal>, and <literal>MESSAGE</literal> are also defined as named constants.
Because of the syntax Java uses, these constants are sometimes referred
to as <emphasis>final variables</emphasis>.</simpara>
<simpara>In the case of <literal>MESSAGE</literal> and all other reference variables, being
<literal>final</literal> means that the reference can never point at a different object.
Even with a <literal>final</literal> reference, the objects themselves can change if
their methods allow it. (Since they are immutable, <literal>String</literal> objects can
never change.)</simpara>
<simpara>Named constants are useful in two ways. First, a well-named constant can
make your code more readable than using a literal. Second, if you do
need to change the value to a different constant, you only have to
change it in one place. For example, if you have used <literal>25000</literal> in five
different places in your program, changing it to <literal>30000</literal> requires five
changes. If you have used <literal>POPULATION</literal> throughout your program instead
of a literal, you only have to change it in one place.</simpara>
</section>
</section>
<section xml:id="_syntax_useful_libraries">
<title>Syntax: Useful libraries</title>
<simpara>Computer software is difficult to write, but many of the same problems
come up over and over. If we had to solve these problems every time we
wrote a program, we&#8217;d never get anywhere. Java allows us to use code
other people have written called <emphasis>libraries</emphasis>. One selling point of Java
is its large standard library that can be used by any Java programmer
without special downloads. You have already used the <literal>Scanner</literal> class,
the <literal>Math</literal> class, and perhaps the <literal>JOptionPane</literal> class, which are all
part of libraries. Below, we&#8217;ll go deeper into the <literal>Math</literal> class and a
few other useful libraries.</simpara>
<section xml:id="_the_literal_math_literal_library">
<title>The <literal>Math</literal> library</title>
<simpara>Basic arithmetic operators are useful, but Java also provides a rich set
of mathematical methods through the <literal>Math</literal> class.
TableÂ <xref linkend="mathFunctionsTable"/> lists a few of the methods available. For a
complete list of methods provided by the <literal>Math</literal> class at the time of
writing, visit
<link xl:href="http://download.oracle.com/javase/7/docs/api/java/lang/Math.html">http://download.oracle.com/javase/7/docs/api/java/lang/Math.html</link>.</simpara>
<formalpara>
<title>A sample of methods available in the Java <literal>Math</literal> class. Arguments to</title>
<para>trigonometric methods are given in radians.</para>
</formalpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="middle"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="middle"><emphasis role="strong">Sample use</emphasis></entry>
<entry align="left" valign="middle"><emphasis role="strong">Purpose</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle" namest="col_1" nameend="col_3"><simpara>Trigonometric functions</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">cos()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double adjacent = hypotenuse * Math.cos(theta);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Find the cosine of the argument.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">sin()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double opposite = hypotenuse * Math.sin(theta);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Find the sine of the argument.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">tan()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double opposite = adjacent * Math.tan(theta);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Find the tangent of the argument.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle" namest="col_1" nameend="col_3"><simpara>Exponentiation and logarithms</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">exp()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double population = 250 * Math.exp(0.03 * time);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Compute <inlineequation><alt><![CDATA[e^x]]></alt><mathphrase><![CDATA[e^x]]></mathphrase></inlineequation>, where <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> is the
argument.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">log()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double digits = Math.log(1000000);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Compute the natural logarithm of the argument.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">pow()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double money = principal * Math.pow(1.0 + rate, time);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Compute <inlineequation><alt><![CDATA[a^b]]></alt><mathphrase><![CDATA[a^b]]></mathphrase></inlineequation>, where <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>
are the first and second arguments.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle" namest="col_1" nameend="col_3"><simpara>Miscellaneous</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">random()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double percent = Math.random();</literallayout></entry>
<entry align="left" valign="middle"><simpara>Generate a random number <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> where
<inlineequation><alt><![CDATA[0.0 \leq x < 1.0]]></alt><mathphrase><![CDATA[0.0 \leq x < 1.0]]></mathphrase></inlineequation>.</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">round()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">long items = Math.round(material);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Round to the nearest <literal>long</literal> (or nearest <literal>int</literal> when
rounding a <literal>float</literal>).</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><literallayout class="monospaced">sqrt()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">double hypotenuse = Math.sqrt(a*a+b*b);</literallayout></entry>
<entry align="left" valign="middle"><simpara>Compute the square root of the argument.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<example>
<title>Math library usage</title>
<simpara>Here is a program that uses the <literal>Math.pow()</literal> method to compute compound
interest. Unlike <literal>Scanner</literal> and <literal>JOptionPane</literal>, the <literal>Math</literal> class is
imported by default in Java programs and requires no explicit import
statement.</simpara>
<formalpara xml:id="program:CompoundInterestCalculator" xreflabel="CompoundInterestCalculator">
<title>Program to compute interest earned and new balance.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

class CompoundInterestCalculator {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
    	System.out.println("Compound Interest Calculator");
    	System.out.println();
        System.out.print("Enter starting balance: ");
        double startingBalance = in.nextDouble();
        System.out.print("Enter interest rate: ");
        double rate = in.nextDouble();
        System.out.print("Enter time in years: ");
        double years = in.nextDouble();
        System.out.print("Enter compounding frequency: ");
        double frequency = in.nextDouble();
        double newBalance = startingBalance *
        	Math.pow(1.0 + rate/frequency, frequency*years);
        double interest = newBalance - startingBalance;
        System.out.println("Interest earned: $" + interest);
        System.out.println("New balance: $" + newBalance);
    }
}</programlisting>
</para>
</formalpara>
</example>
<simpara>In addition to methods, the <literal>Math</literal> library contains named constants
including Euler&#8217;s number <inlineequation><alt><![CDATA[e]]></alt><mathphrase><![CDATA[e]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[\pi]]></alt><mathphrase><![CDATA[\pi]]></mathphrase></inlineequation>. These
are written in code as <literal>Math.E</literal> and <literal>Math.PI</literal>, respectively. For
example, the following assignment statement computes the circumference
of a circle with radius given by the variable <literal>radius</literal>, using the
formula <inlineequation><alt><![CDATA[2\pi r]]></alt><mathphrase><![CDATA[2\pi r]]></mathphrase></inlineequation>.</simpara>
<programlisting language="java" linenumbering="unnumbered">double circumference = 2*Math.PI*radius;</programlisting>
</section>
<section xml:id="_random_numbers">
<title>Random numbers</title>
<simpara>Random numbers are often needed in applications such as games and
scientific simulations. For example, card games require a random
distribution of cards. To simulate a deck of 52 cards, we could
associate an integer from 1 to 52 with each card. If we had a list of
these values, we could swap each value in the list with a value at a
random location later in the list. Doing so is equivalent to shuffling
the deck.</simpara>
<simpara>Java provides the <literal>Random</literal> class in package <literal>java.util</literal> to generate
random values. Before you can generate a random number with this class,
you need to create a <literal>Random</literal> object as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Random random = new Random();</programlisting>
<simpara>Here we have created an object named <literal>random</literal> of type <literal>Random</literal>.
Depending on the kind of random value you need, you can use the
<literal>nextInt()</literal>, <literal>nextBoolean()</literal>, or <literal>nextDouble()</literal> to generate a random
value of the corresponding type.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Random integer with all values possible
int balance = random.nextInt();

// Random integer between 0 (inclusive) and 130 (exclusive)
int humanAge = random.nextInt(130);

// Random boolean value
 boolean gender = random.nextBoolean();

// Random floating point value between 0.0 (inclusive)
// and 1.0 (exclusive)
double percent = random.nextDouble();</programlisting>
<simpara>In these examples, <emphasis>inclusive</emphasis> means that the number could be generated,
while <emphasis>exclusive</emphasis> means that the number cannot be. Thus, the call
<literal>random.nextInt(130)</literal> generates the integers 0 through 129, but never
130. Exclusive upper bounds on ranges of random values are very common
in programming.</simpara>
<simpara>To generate a random <literal>int</literal> between values <literal>a</literal> and <literal>b</literal>, not including
<literal>b</literal>, use the following code, assuming you have a <literal>Random</literal> object named
<literal>random</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int count = random.nextInt(b - a) + a;</programlisting>
<simpara>The <literal>nextInt()</literal> method call generates a value between <literal>0</literal>
and <literal>b - a</literal>, and adding <literal>a</literal> shifts it into the
range from <literal>a</literal> up to (but not including) <literal>b</literal>.</simpara>
<simpara>Generating a random <literal>double</literal> between values <literal>a</literal> and <literal>b</literal> is similar
except that <literal>nextDouble()</literal> always generates a value between <literal>0.0</literal> and
<literal>1.0</literal>, not including <literal>1.0</literal>. Thus, you must scale the output by <literal>b - a</literal>
as shown below.</simpara>
<programlisting language="java" linenumbering="unnumbered">double value = random.nextDouble()*(b - a) + a;</programlisting>
<simpara>The following example illustrates a potential use of random numbers in a
video game.</simpara>
<example>
<title>Dragon attribute generation</title>
<simpara>Suppose you are designing a video in which the hero must fight a dragon
with random attributes. ProgramÂ <xref linkend="program:DragonAttributes"/> generates
random values for the age, height, gender, and hit points of the dragon.</simpara>
<formalpara xml:id="program:DragonAttributes" xreflabel="DragonAttributes">
<title>Program to set attributes of a randomly generated dragon for a video game.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class DragonAttributes {
    public static void main(String[] args) {
    	Random random = new Random();/*@\label{createRandomNumberGeneratorLine}@*/
        int age = random.nextInt(100) + 1;/*@\label{generateAgeLine}@*/
        double height = random.nextDouble()*30;/*@\label{generateHeightLine}@*/
        boolean gender = random.nextBoolean();/*@\label{generateStatusLine}@*/
        int hitPoints = random.nextInt(51) + 25;
        System.out.println("Dragon Statistics");/*@\label{displayTurtleAttributesLine}@*/
        System.out.println("Age:\t\t" + age);
        System.out.format("Height:\t\t%.1f feet\n", height);
        System.out.println("Female:\t\t" + gender);
        System.out.println("Hit points:\t" + hitPoints);
    }
}</programlisting>
</para>
</formalpara>
<simpara>Note that we begin by importing <literal>java.util.*</literal> to include all the classes
in the <literal>java.util</literal> package, including <literal>Random</literal>. At
lineÂ <xref linkend="createRandomNumberGeneratorLine"/>, we create an object <literal>random</literal>
of type <literal>Random</literal>. At lineÂ <xref linkend="generateAgeLine"/>, we use it to generate a
random <literal>int</literal> between <literal>0</literal> and <literal>99</literal>, to which we add <literal>1</literal>, making an age
between <literal>1</literal> and <literal>100</literal>. To generate the height, we multiply a random
<literal>double</literal> by <literal>75</literal>, yielding a value between <literal>0.0</literal> and <literal>75.0</literal> (exclusive).
Since there are only two choices for a dragon&#8217;s gender, we generate a
random <literal>boolean</literal> value, interpreting <literal>true</literal> as female and <literal>false</literal> as
male. Finally, we determine the number of hit points the dragon has by
generating a random <literal>int</literal> between <literal>0</literal> and <literal>50</literal>, then add <literal>25</literal> to it,
yielding a value between <literal>25</literal> and <literal>75</literal>.</simpara>
<simpara>Because we are using random values, the output of
ProgramÂ <xref linkend="program:DragonAttributes"/> changes every time we run the
program. Sample output is given below.</simpara>
<literallayout class="monospaced">Dragon Statistics
Age:            90
Height:         13.7 feet
Female:         true
Hit points:     67</literallayout>
</example>
<simpara>If you only need a random <literal>double</literal> value, you can generate a number
between <literal>0.0</literal> and <literal>1.0</literal> (exclusive) using the <literal>Math.random()</literal> method
from the <literal>Math</literal> class. This method is a quick and dirty way to generate
random numbers without importing <literal>java.util.Random</literal> or creating a
<literal>Random</literal> object.</simpara>
<simpara>The random numbers generated by the <literal>Random</literal> class and by
<literal>Math.random()</literal> are <emphasis>pseudorandom</emphasis> numbers, meaning that they are
generated by a mathematical formula instead of truly random events. Each
number is computed using the previous one, and the starting number is
determined using time information from the OS. For most purposes, these
pseudorandom numbers are good enough. Since each number can be predicted
from the previous one, pseudorandom numbers are insufficient for some
security applications. For those cases, Java provides the <literal>SecureRandom</literal>
class, which is slower than <literal>Random</literal> but produces random numbers that
are much harder to predict.</simpara>
</section>
<section xml:id="_wrapper_classes">
<title>Wrapper classes</title>
<simpara>Reference types have methods that allow a user to interact with them in
many useful ways. The primitive types (<literal>byte</literal>, <literal>short</literal>, <literal>int</literal>, <literal>long</literal>,
<literal>float</literal>, <literal>double</literal>, <literal>char</literal>, and <literal>boolean</literal>) do not have methods, but we
sometimes need to manipulate them with methods or store them in a place
that can only take a reference type.</simpara>
<simpara>To deal with such situations, Java uses <emphasis>wrapper classes</emphasis>, reference
types that correspond to each primitive type. Following Java conventions
for class names, the wrapper types all start with an uppercase letter
but are otherwise similar to the name of the primitive type they
support: <literal>Byte</literal>, <literal>Short</literal>, <literal>Integer</literal>, <literal>Long</literal>, <literal>Float</literal>, <literal>Double</literal>,
<literal>Character</literal>, and <literal>Boolean</literal>.</simpara>
<section xml:id="_literal_string_literal_to_numerical_conversions">
<title><literal>String</literal> to numerical conversions</title>
<simpara>A common task for a wrapper class is to convert a <literal>String</literal>
representation of a number such as <literal>"37"</literal> or <literal>"2.097"</literal> to its
corresponding numeric value. We had such a situation in
ProgramÂ <xref linkend="program:GetInputGUI"/>, where we did the conversion as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">String response = JOptionPane.showInputDialog(null, enterHeight, title, JOptionPane.QUESTION_MESSAGE);
height = Double.parseDouble(response);</programlisting>
<simpara>This code uses the <literal>JOptionPane.showInputDialog()</literal> method to get from
the user the height from which a ball is dropped. This method always
returns data as a <literal>String</literal>. In order for us to do computation with the
value, we need to convert it to a numeric type, such as an <literal>int</literal> or a
<literal>double</literal>. To do so, we use the appropriate <literal>Byte.parseByte()</literal>,
<literal>Short.parseShort()</literal>, <literal>Integer.parseInt()</literal>, <literal>Long.parseLong()</literal>,
<literal>Float.parseFloat()</literal>, or <literal>Double.parseDouble()</literal> method.</simpara>
<simpara>The following example shows conversions from a <literal>String</literal> to a number
using three of these methods.</simpara>
<example>
<title>String to numeric conversion</title>
<simpara>Consider the following statements that show how a string can be
converted to a numerical value.</simpara>
<programlisting language="java" linenumbering="unnumbered">String text = "15";
int count = Integer.parseInt(text);
float value = Float.parseFloat(text);
double tolerance = Double.parseDouble(text);</programlisting>
<simpara>In this example, we declare a <literal>String</literal> object named <literal>text</literal> and
initialize it to <literal>"15"</literal>. Since <literal>text</literal> is a <literal>String</literal> and not a number,
arithmetic expressions such as <literal>(text*29)</literal> are illegal.</simpara>
<simpara>To use the <literal>String</literal> <literal>"15"</literal> in a numerical computation, we need to
convert it to a number. We used the <literal>Integer.parseInt()</literal>,
<literal>Float.parseFloat()</literal>, and <literal>Double.parseDouble()</literal> methods to convert the
<literal>String</literal> to <literal>int</literal>, <literal>float</literal>, and <literal>double</literal> values, respectively. Each
method gives us 15 stored as the appropriate type.</simpara>
</example>
<simpara>What happens if the <literal>String</literal> <literal>"15.5"</literal> (or even <literal>"cinnamon"</literal>) is given as
input to the <literal>Integer.parseInt()</literal> method? If the <literal>String</literal> is not
formatted as the appropriate kind of number, Java throws a
<literal>NumberFormatException</literal>, probably crashing the program. An <emphasis>exception</emphasis>
is an error that happens in the middle of running a program. We discuss
how to work with exceptions in ChapterÂ <xref linkend="chapter:Exceptions"/>.</simpara>
</section>
<section xml:id="_literal_character_literal_methods">
<title><literal>Character</literal> methods</title>
<simpara>When working with <literal>char</literal> values, it can be useful to know whether a
particular value is a digit, a letter, or has a particular case. It may
also be useful to convert a <literal>char</literal> to upper or lower case. Here is a
partial list of the methods provided by the <literal>Character</literal> wrapper class to
do these tasks.<?asciidoc-br?></simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="middle"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="middle"><emphasis role="strong">Purpose</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isDigit(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is a numerical digit
and <literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isLetter(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is a letter and
<literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isLetterOrDigit(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is a digit or
a letter and <literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isLowerCase(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is a lower case
letter and <literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isUpperCase(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is an upper case
letter and <literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">isWhitespace(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if <literal>value</literal> is a whitespace
character such as space, tab, or newline and <literal>false</literal> otherwise.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">toLowerCase(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns a lower case version of <literal>value</literal>,
with no change if it is not a letter.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">toUpperCase(char value)</literallayout></entry>
<entry align="left" valign="middle"><simpara>Returns an upper case version of <literal>value</literal>,
with no change if it is not a letter.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For example, the variable <literal>test</literal> contains <literal>true</literal> after the following
code is executed.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean test = Character.isLetter('x');</programlisting>
<simpara>And the variable <literal>letter</literal> contains <literal>'M'</literal> after the following code is
executed.</simpara>
<programlisting language="java" linenumbering="unnumbered">char letter = Character.toUpperCase('m');</programlisting>
<simpara>These methods can be especially useful when processing input.</simpara>
</section>
<section xml:id="_maximum_and_minimum_values">
<title>Maximum and minimum values</title>
<simpara>As you recall from ChapterÂ <xref linkend="chapter:Computer_Basics"/>, integer
arithmetic in Java has limitations. If you increase a large positive
number past its maximum value, it becomes a large magnitude negative
number, a phenomenon called overflow. Conversely, if you decrease a
large magnitude negative number past its minimum value, it becomes a
large positive number, a phenomenon called underflow.</simpara>
<simpara>With floating point numbers, increasing their magnitudes past their
maximum values results in special values that Java reserves to represent
either positive or negative infinity, as the case may be. If a floating
point value gets too close to zero, it eventually rounds to zero.</simpara>
<simpara>In addition to useful conversion methods, the numerical wrapper classes
also have constants for the maximum and minimum values for each type.
Instead of trying to remember that the largest positive <literal>int</literal> value is
2,147,483,647, you can use the equivalent
<literal>Integer.MAX_VALUE</literal>.</simpara>
<simpara>The <literal>MAX_VALUE</literal> constants are always the largest positive number that
can be represented with the corresponding type. The <literal>MIN_VALUE</literal> is more
confusing. For integer types, it is the largest magnitude negative
number. For floating point types, it is the smallest positive non-zero
value that can be represented. Here is a table listing all these
constants.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="middle"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="middle"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Byte.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most positive value a <literal>byte</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Byte.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most negative value a <literal>byte</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Short.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most positive value a <literal>short</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Short.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most negative value a <literal>short</literal> value</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Integer.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most positive value an <literal>int</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Integer.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most negative value an <literal>int</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Long.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most positive value a <literal>long</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Long.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Most negative value a <literal>long</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Float.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Largest absolute value a <literal>float</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Float.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Smallest absolute value a <literal>float</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Double.MAX_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Largest absolute value a <literal>double</literal> value can have</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">Double.MIN_VALUE</literallayout></entry>
<entry align="left" valign="middle"><simpara>Smallest absolute value a <literal>double</literal> value can have</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The wrap-around nature of integer arithmetic means that adding 1 to<?asciidoc-br?>
<literal>Integer.MAX_VALUE</literal> results in <literal>Integer.MIN_VALUE</literal>. Note that all
integer arithmetic in Java is done assuming type <literal>int</literal>, unless
explicitly specified otherwise. Thus, <literal>Short.MAX_VALUE + 1</literal> does not
overflow to a negative value unless you store the result into a <literal>short</literal>.
The same rules apply to underflow.</simpara>
<simpara>Overflow and underflow do not work in the same way with the floating
point numbers represented by <literal>float</literal> and <literal>double</literal>. The expression
<literal>Double.MAX_VALUE + 1</literal> results in <literal>Double.MAX_VALUE</literal> because <literal>1</literal> is so
small in comparison that it is lost in rounding error. However,
<literal>1.5*Double.MAX_VALUE</literal> results in <literal>Double.POSITIVE_INFINITY</literal>, a
constant used to represent any value larger than <literal>Double.MAX_VALUE</literal>
Since <literal>Double.MIN_VALUE</literal> is the smallest non-zero number,
<literal>Double.MIN_VALUE - 1</literal> evaluates to <literal>-1.0</literal>.</simpara>
</section>
<section xml:id="_using_wrapper_classes_for_storage">
<title>Using wrapper classes for storage</title>
<simpara>Wrapper classes in Java have a split personality. On the one hand, the
classes themselves can be used for the utility methods and constants we
have described above. However, <emphasis>objects</emphasis> of these same wrapper classes
can be used in an entirely separate way to store primitive values. Each
primitive type can be stored in its wrapper type as shown below.</simpara>
<programlisting language="java" linenumbering="unnumbered">Integer fingers = new Integer(5);
Double pi = new Double(3.141592);
Character question = new Character('?');</programlisting>
<simpara>Why would we want to do this? There are many situations in which a
library method or data structure requires a reference type, not a
primitive type. These wrappers were specially designed to handle these
cases when you have to treat a primitive type as an object.</simpara>
<programlisting language="java" linenumbering="unnumbered">Object value = new Integer(42);</programlisting>
<simpara>To make working with wrapper classes easier, Java 5 and higher support
automatic boxing and unboxing, meaning that primitive types will
automatically be converted to their wrapper types (and vice versa) when
appropriate. Thus, the earlier code could be written as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Integer fingers = 5;
Double pi = 3.141592;
Character question = '?';</programlisting>
<simpara>Programmers who do not understand wrapper classes will sometimes use
primitive types and wrapper classes interchangeably, mixing <literal>double</literal> and
<literal>Double</literal>, for example. You should avoid using wrapper classes whenever
possible, since it requires more memory and more computation to perform
operations with wrapper classes.</simpara>
<simpara>Fortunately, automatic boxing and unboxing reduces the need to think
about wrapper classes, and most programmers will rarely need to declare
an explicit wrapper reference. We will discuss wrapper classes further
in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>, where they are used to
allow generic classes<emphasis>generic class</emphasis> to store primitive types as well
as reference types.</simpara>
</section>
</section>
</section>
<section xml:id="_solution_college_cost_calculator">
<title>Solution: College cost calculator</title>
<simpara>In this chapter, we have introduced and more fully explained many
aspects of manipulating data in Java, including declaring variables,
assigning values, performing simple arithmetic and more advanced math,
inputting and outputting data, and using the type system, which has
small differences for primitive and reference types. Our solution to the
college cost calculator problem posed at the beginning of the chapter
uses all of these features at some level.</simpara>
<simpara>We present this solution below. The first step in our solution is to
import <literal>java.util.*</literal> so that we can use the <literal>Scanner</literal> class. Then, we
start the enclosing <literal>CollegeCosts</literal> class, begin the <literal>main()</literal> method,
print a welcome message for the user, and create a <literal>Scanner</literal> object.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class CollegeCosts {
	public static void main(String[] args) {
		System.out.println(
			"Welcome to the College Cost Calculator!");
		Scanner in = new Scanner(System.in);</programlisting>
<simpara>Next is a sequence of prompts to the user interspersed with input done
with the <literal>Scanner</literal> object. The program reads the user&#8217;s first name as a
<literal>String</literal>, the user&#8217;s last name as a <literal>String</literal>, the per-semester tuition
cost as a <literal>double</literal>, the monthly cost of rent as a <literal>double</literal>, the monthly
cost of food as a <literal>double</literal>, the interest rate for the loan as a
<literal>double</literal>, and the number of years needed to pay back the loan as an
<literal>int</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.print("Enter your first name:\t\t");
		String firstName = in.next();
		System.out.print("Enter your last name:\t\t");
		String lastName = in.next();
		System.out.print("Enter tuition per semester:\t$");
		double semesterTuition = in.nextDouble();
		System.out.print("Enter rent per month:\t\t$");
		double monthlyRent = in.nextDouble();
		System.out.print("Enter food cost per month:\t$");
		double monthlyFood = in.nextDouble();
		System.out.print("Annual interest rate:\t\t");
		double annualInterest = in.nextDouble();
		System.out.print("Years to pay back your loan:\t");
		int years = in.nextInt();</programlisting>
<simpara>The next segment of code completes the computations needed. First, it
finds the total yearly cost by doubling the semester cost, multiplying
the monthly rent and food costs by 12, and summing the answers together.
The four year cost is simply four times the yearly cost. To find the
monthly payment, we find the monthly interest by dividing the annual
interest rate by 12 and plugging this value into the formula from the
beginning of the chapter. Finally, the total cost of the loan is the
monthly payment times 12 times the number of years.</simpara>
<programlisting language="java" linenumbering="numbered">		double yearlyCost = semesterTuition * 2.0 +
			(monthlyRent + monthlyFood) * 12.0;
		double fourYearCost = yearlyCost * 4.0;
		double monthlyInterest = annualInterest / 12.0;
		double monthlyPayment = fourYearCost * monthlyInterest /
			(1.0 - Math.pow(1.0 + monthlyInterest,
			-years * 12.0));
		double totalLoanCost = monthlyPayment * 12.0 * years;</programlisting>
<simpara>All that remains is to print out the output. First, we output a header
describing the following output as college costs for the user. Using
<literal>System.out.format()</literal> as described in SubsectionÂ <xref linkend="subsection:Primitive_types"/>, we print out the yearly cost, four year cost, monthly loan
payment, and total cost, all formatted with dollar signs, 2 places after
the decimal point, and tabs so that the output lines up.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.println("\nCollege costs for " +
				firstName + " " + lastName );
		System.out.println(
				"***************************************");
		System.out.print("Yearly cost:\t\t\t$");
		System.out.format("%.2f\n", yearlyCost);
		System.out.print("Four year cost:\t\t\t$");
		System.out.format("%.2f\n", fourYearCost);
		System.out.print("Monthly loan payment:\t\t$");
		System.out.format("%.2f\n", monthlyPayment);
		System.out.print("Total loan cost:\t\t$");
		System.out.format("%.2f\n", totalLoanCost );
	}
}</programlisting>
</section>
<section xml:id="_concurrency_expressions">
<title>Concurrency: Expressions</title>
<simpara>In SectionÂ <xref linkend="concurrency:Solving_problems_in_parallel"/>, we introduced
the ideas of task and domain decomposition that could be used to solve a
problem in parallel. By splitting up the jobs to be done (as in task
decomposition) or dividing a large amount of data into pieces (as in
domain decomposition), we can attack a problem with several workers and
finish the work more quickly.</simpara>
<section xml:id="_splitting_expressions">
<title>Splitting expressions</title>
<simpara>Performing arithmetic is some of the only Java syntax we have introduced
that can be used to solve problems directly, but evaluating a single
mathematical expression usually does not warrant concurrency. If the
terms in the expression are themselves complex functions (such as
numerical integrations or simulations that produce answers), it might be
reasonable to evaluate these functions concurrently.</simpara>
<simpara>In this section, we will give an example of splitting an expression into
smaller sub-expressions that could be evaluated concurrently. The basic
steps underlying the concurrent evaluation of expressions are the
following.</simpara>
<itemizedlist>
<listitem>
<simpara>Identify sub-expressions that are independent of each other.</simpara>
</listitem>
<listitem>
<simpara>Create a separate thread that evaluates each sub-expression.</simpara>
</listitem>
<listitem>
<simpara>Combine the results from each thread to obtain a final answer.</simpara>
</listitem>
</itemizedlist>
<simpara>While this sequence of steps looks simple, each step can be complex.
Worse, being careless at any step could result in a concurrent solution
that runs slower than the sequential solution or even gives the wrong
answer. The following example illustrates these steps.</simpara>
<example>
<title>Split expression</title>
<simpara>Consider the following statement:</simpara>
<programlisting language="java" linenumbering="unnumbered">double value = f(a,b)*g(c);</programlisting>
<simpara>This statement evaluates methods <literal>f()</literal> and <literal>g()</literal>, multiplies the
computed values, and assigns the result to variable <literal>value</literal>. In
FigureÂ <xref linkend="splitExpressionFigure"/>, we show two ways of evaluating the
expression <literal>f(a,b)*g(c)</literal>. FigureÂ <xref linkend="splitExpressionFigure"/>(a) shows
sequential evaluation of the expression, where <literal>f()</literal> is computed, <literal>g()</literal>
follows, and then the two results are multiplied to get the final value.
FigureÂ <xref linkend="splitExpressionFigure"/>(b) shows evaluation of the expression
in which <literal>f()</literal> and <literal>g()</literal> are evaluated concurrently instead.</simpara>
<figure>
<title>Computation of <literal>value = f(a,b)*g(c)</literal> with (a)Â sequential and (b)Â concurrent approaches.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/03-strings-primitive-types/images/splitExpressionFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>splitExpressionFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>On a multicore processor, the computation of <literal>f()</literal> and <literal>g()</literal> could be
carried out on separate cores. We can create one thread for each method
and wait for the threads to complete. Upon completion, we can retrieve
the results of each computation and multiply them together as in
FigureÂ <xref linkend="splitExpressionFigure"/>(b). ProgramÂ <xref linkend="program:SplitExpression"/>
illustrates this concurrent approach.</simpara>
<simpara>In ProgramÂ <xref linkend="program:SplitExpression"/>, we create two objects named
<literal>fThread</literal> and <literal>gThread</literal> at linesÂ <xref linkend="createFLine"/> and <xref linkend="createGLine"/>,
respectively. Both of these objects have types that extend the <literal>Thread</literal>
class, which means that they can be made to run independently. Object
<literal>fThread</literal> needs two arguments (<literal>3.14</literal> and <literal>2.99</literal> in this example), and
<literal>gThread</literal> needs one (<literal>5.55</literal>).</simpara>
<formalpara xml:id="program:SplitExpression" xreflabel="SplitExpression">
<title>Program for concurrent evaluation of an expression.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class SplitExpression {
    public static void main(String[] args) {
        ComputeF fThread = new ComputeF(3.14, 2.99);/*@\label{createFLine}@*/
        ComputeG gThread = new ComputeG(5.55);/*@\label{createGLine}@*/
        fThread.start();/*@\label{startFComputationLine}@*/
        gThread.start();/*@\label{startGComputationLine}@*/
        try {
            fThread.join();  /*@\label{waitForFToFiniLinesh}@*/
            gThread.join(); /*@\label{waitForGToFiniLinesh}@*/
            double fResult = fThread.getResult();/*@\label{getResultFromFLine}@*/
            double gResult = gThread.getResult();/*@\label{getResultFroLineG}@*/
            double answer = fResult*gResult;/*@\label{computeFinalValueLine}@*/
            System.out.println("Result of f: " + fResult );
            System.out.println("Result of g: " + gResult );
            System.out.println("Final answer: " + answer);
        }
        catch(InterruptedException e){
        	System.out.println("Computation interrupted!");
        }
    }
}</programlisting>
</para>
</formalpara>
<simpara>Once the thread objects have been created, we start the threads at
linesÂ <xref linkend="startFComputationLine"/> and <xref linkend="startGComputationLine"/>. Every
object whose type is <literal>Thread</literal> (or a child of <literal>Thread</literal>, which we will
discuss in ChapterÂ <xref linkend="chapter:Inheritance"/>) has a <literal>start()</literal> method which
begins its execution as a separate thread.</simpara>
<simpara>How do we know when a thread is done executing? Every <literal>Thread</literal> object
has a <literal>join()</literal> method. If some code calls a thread&#8217;s <literal>join()</literal> method,
the method will not return until the thread is finished. When code is
waiting for a thread to finish, it is possible for it to be interrupted
if some other thread has gotten tired of the code waiting around doing
nothing. If that happens, an <literal>InterruptedException</literal> is thrown.
Exceptions are the way that Java deals with errors and other unusual
situations. We will discuss them further in
ChapterÂ <xref linkend="chapter:Exceptions"/>, but, for now, you only need to know that
code (like the <literal>join()</literal> method) that can cause certain kinds of
exceptions (like the <literal>InterruptedException</literal>) needs to be enclosed in a
<literal>try</literal> block. After the <literal>try</literal> block comes a <literal>catch</literal> block that says what
to do in the even of that exception. In our case, we print out
<literal>"Computation interrupted!"</literal></simpara>
<simpara>Once the threads have completed their respective tasks, the execution of
ProgramÂ <xref linkend="program:SplitExpression"/> resumes at
lineÂ <xref linkend="getResultFromFLine"/>, where we obtain the result of the
computation done by <literal>fThread</literal> by calling its <literal>getResult()</literal> method. On
the next line, we call the <literal>getResult()</literal> method on <literal>gThread</literal> to obtain
its result. Note that we could have called these <literal>getResult()</literal> methods
before the <literal>join()</literal> calls, but the computations might not have
completed, yielding invalid or incorrect results (or crashing the
program). Finally, at lineÂ <xref linkend="computeFinalValueLine"/>, these two computed
values are multiplied to get the final result, which is assigned to
<literal>value</literal> and printed.</simpara>
</example>
<simpara>We would like to show how classes <literal>ComputeF</literal> and <literal>ComputeG</literal> are written,
but we will hold off since they use concepts relating to methods, class
design, and inheritance that we will not cover until Chapters
<xref linkend="chapter:Methods"/>, <xref linkend="chapter:Classes"/>, and <xref linkend="chapter:Inheritance"/>.</simpara>
<simpara>If you don&#8217;t understand all the elements of
ProgramÂ <xref linkend="program:SplitExpression"/>, don&#8217;t despair. We&#8217;re trying to give
you an example of what concurrency looks like in Java, but you cannot be
expected to master all the details at this stage. However, concurrency
in Java will often follow the steps shown:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Creation of <literal>Thread</literal> (or children of <literal>Thread</literal>) objects</simpara>
</listitem>
<listitem>
<simpara>Calling the <literal>start()</literal> method on these objects to start them
executing</simpara>
</listitem>
<listitem>
<simpara>Calling the <literal>join()</literal> method on them to wait for them to finish</simpara>
</listitem>
<listitem>
<simpara>Retrieving the results (if any) of the computations done by the
objects</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_care_in_splitting_expressions">
<title>Care in splitting expressions</title>
<simpara>The above example illustrates how you could split an expression and
evaluate it concurrently. Note the following points when deciding
whether or not to use concurrency. First, your program will run faster
concurrently only if the work done is complex enough that its
computation takes significantly longer than the time to create the
necessary threads. In the example above, the methods <literal>f()</literal> and <literal>g()</literal>
must be complex enough that it takes a significant amount of time to
evaluate them. Otherwise, concurrency will not reduce the running time.
This aspect of speedup is explained in detail in
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>.</simpara>
<simpara>Second, splitting an expression (or any complex sequence of
computations) is easy when its individual components are independent. If
they are interdependent, splitting requires care or subtle programming
errors can occur. Consider the expression <literal>f(a)+g(b)</literal> and suppose that
<literal>f()</literal> modifies the value of <literal>b</literal> during execution. Such a modification is
called a <emphasis>side effect</emphasis>. This side effect creates a dependency between
<literal>f()</literal> and <literal>g()</literal>. Concurrent execution of these two methods must be done
carefully, if it can be done at all. ChapterÂ <xref linkend="chapter:Synchronization"/>
discusses concurrency in the presence of dependencies.</simpara>
</section>
</section>
<section xml:id="_summary_3">
<title>Summary</title>
<simpara>In a strongly typed language such as Java, types are an important
concept. Every literal and variable in Java has a type, which specifies
the possible values items with that type could have and the operations
that can be done with them. Types are used to catch programming errors
at compile time.</simpara>
<simpara>Java has a small set of primitive types such as <literal>int</literal> and <literal>double</literal>,
which hold single values and use operators to manipulate them. Java also
has reference types, which use primitive types as building blocks, can
be created by any Java programmer, can contain arbitrarily complex data,
and are manipulated with methods. One of the most commonly used
reference types is <literal>String</literal>, which is used to store text of any length.</simpara>
<simpara>A number of library classes have been provided by the developers of
Java. Programs performing mathematical operations beyond simple
arithmetic may need to use methods from the <literal>Math</literal> class. Programs that
need to generate random numbers can use methods from the <literal>Random</literal> class.
Conversions and other useful manipulations of primitive types are
provided by wrapper classes.</simpara>
<simpara>We also gave a taste of the syntax for creating, running, and waiting
for the completion of threads. Such threads could be used to speed up
the evaluation of mathematical computations on multicore processors, but
only if the computations are long, complex, and not too interdependent.</simpara>
</section>
<section xml:id="_exercises_2">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:mathematicsAndIntExercise"/> What is the difference
between the set of integers from mathematics and the sets defined by
<literal>int</literal> and <literal>long</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Downcast"/> In ExampleÂ <xref linkend="example:Downcast_error"/>, the sum
of two <literal>int</literal> variables was another <literal>int</literal> value, which could not be
stored into a <literal>byte</literal> variable. Would this code have worked if variables
<literal>a</literal> and <literal>b</literal> had been declared with type <literal>byte</literal>? What if <literal>a</literal> was assigned
<literal>121</literal> and <literal>b</literal> was assigned <literal>98</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:floatFloatExampleExercise"/> The following three
statements are legal Java (if properly included inside of a method).
However, if we changed <literal>2</literal> to <literal>2.0</literal> or <literal>5</literal> to <literal>5.0</literal>, the statements
would not be legal. Explain why.</simpara>
<programlisting language="java" linenumbering="unnumbered">float roomArea = 2;
float homeArea = 5;
float area = roomArea * homeArea;</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:logicalOperatorExercise"/> Consider the following variable
declarations.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 3, y = 4, z = -9;
float p = 3.99f, q = -9.89f;
int population1 = 15000, population2 = 8000;
final double MAXIMUM_LEVEL = 350;
double limitPerCapita = 0.03;
int age = 14;
final int MAXIMUM_AGE = 23;
boolean allowed = false;</programlisting>
<simpara>Now evaluate each of the following expressions to <literal>true</literal> or <literal>false</literal>.
a.  <literal>MAXIMUM_LEVEL/population1 &gt; limitPerCapita &amp;&amp;</literal><?asciidoc-br?>
<literal>MAXIMUM_LEVEL/population2 &lt; limitPerCapita</literal>
b.  <literal>MAXIMUM_LEVEL/population1 &gt; limitPerCapita ||</literal><?asciidoc-br?>
<literal>MAXIMUM_LEVEL/population2 &lt; limitPerCapita</literal>
c.  <literal>age &lt; MAXIMUM_AGE &amp;&amp; allowed</literal>
d.  <literal>(x &lt; y &amp;&amp; y &gt; z) || (p &gt; q &amp;&amp; population1 &lt; population2)</literal></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:bitwiselOperatorExercise"/> Evaluate the following
expressions by hand and then check the results with a Java compiler.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>5 &amp; 6</literal></simpara>
</listitem>
<listitem>
<simpara><literal>5 | 6</literal></simpara>
</listitem>
<listitem>
<simpara><literal>5 ^ 6</literal></simpara>
</listitem>
<listitem>
<simpara><literal>~5</literal></simpara>
</listitem>
<listitem>
<simpara><literal>5 &gt;&gt; 2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>5 &lt;&lt; 2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>5 &gt;&gt;&gt; 2</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:overflowUnderflowExercise"/> Evaluate the following
expressions by hand and then check the results with a Java compiler.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Byte.MIN_VALUE - 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Byte.MAX_VALUE + 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Integer.MIN_VALUE - 1</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:floatingPointOverflowExercise"/> Evaluate the following
expressions by hand and then check the results with a Java compiler.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Float.MAX_VALUE + 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Double.MAX_VALUE - 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>-Double.MAX_VALUE - 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>-Double.MIN_VALUE - 1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>-Double.MIN_VALUE + 1</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:overFlowDoubleExercise"/> When evaluated in Java, the
expression <literal>2*Double.MAX_VALUE</literal> results in <literal>Double.POSITIVE_INFINITY</literal>
to indicate that the maximum representable value has been exceeded.
However, the expression <literal>Double.MAX_VALUE + 1</literal> results in
<literal>Double.MAX_VALUE</literal>. Why doesn&#8217;t the second case yield
<literal>Double.POSITIVE_INFINITY</literal> as well?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:conversionExercise"/> Explain what is printed when the
following statements are executed.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println(15 + 20);
System.out.println("15" + 20);
System.out.println("" + 15 + 20);</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:typeValueDeterminationExercise"/> For each of the
following Java expressions, indicate the types of each value being used
and the type of the result when the expression is evaluated.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>3 + 4</literal></simpara>
</listitem>
<listitem>
<simpara><literal>3 + 4.0</literal></simpara>
</listitem>
<listitem>
<simpara><literal>3.0 + 4.0</literal></simpara>
</listitem>
<listitem>
<simpara><literal>3.0f + 4.0</literal></simpara>
</listitem>
<listitem>
<simpara><literal>(double)(3 + 4)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>(double)(3.0 + 4.0)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Math.round(3 * 4.2)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Math.round(3.2 * 4.9)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Math.round(15.5 * 4.0)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>(int)(15.5 * 4.0)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Math.round(3.154)</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:splitExpressionEvaluationExercise"/> For each of the
following expressions, determine the maximum amount of concurrency that
can be achieved. Using a diagram similar to
FigureÂ <xref linkend="splitExpressionFigure"/>(b), show how the computation of each
expression will proceed. Assume there are no side effects. Note that you
can create separate threads for multiple instances of method <literal>f()</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>f(a) + f(b) + f(c)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>f(a * g(b))</literal></simpara>
</listitem>
<listitem>
<simpara><literal>f(g(a)) + f(b) + f(c)</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:referenceTypes"/> Answer the following questions about
types, values, and references.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>What is the difference between a value and the type that the value
has?</simpara>
</listitem>
<listitem>
<simpara>In Java, the primitive type <literal>int</literal> represents a limited set of
integers, not the entire set of integers from mathematics. Why is this
the case? Why didn&#8217;t the designers of Java allow <literal>int</literal> to represent all
integers?</simpara>
</listitem>
<listitem>
<simpara>How are operations defined for reference types?</simpara>
</listitem>
<listitem>
<simpara>Explain the subtle difference between a reference and an object in
Java.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:objectComparsonExercise"/> Consider the following
declarations of three <literal>Car</literal> objects.</simpara>
<programlisting language="java" linenumbering="unnumbered"> Car car1 = new Car("Mercedes", "C300 Sport", 75000);
 Car car2 = new Car("Pontiac", "Vibe", 17000);
 Car car3 = new Car("Mercedes", "C300 Sport", 75000);</programlisting>
<simpara>Let <literal>same</literal> be a variable of type <literal>boolean</literal>. What is the value of
variable <literal>same</literal> after each of the following statements? Assume that the
<literal>equals()</literal> method will return <literal>true</literal> if all of the attributes specified
by the constructors for the two objects are the same.
a.  <literal>same = (car1 == car2);</literal>
b.  <literal>same = (car1 == car3);</literal>
c.  <literal>same = car1.equals(car3);</literal>
d.  <literal>car2 = car3;</literal>
e.  <literal>same = (car2 == car1);</literal>
f.  <literal>same = (car2 == car3);</literal>
g.  <literal>same = car2.equals(car3);</literal></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:unicode"/> Characters <literal>'a'</literal> and <literal>'A'</literal> have Unicode values
<literal>\u0061</literal> and <literal>\u0041</literal>, respectively. Give the representation of these
two characters as 16-bit unsigned binary integers.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:representation"/> Assuming that each character occupies 16
bits (two bytes) in memory and is coded using Unicode, use hexadecimal
numbers to show how the word <literal>"Java"</literal> will be represented in computer
memory. Unicode values for the Latin alphabet are the same as the values
for the older ASCII standard. You can find a listing of these values on
many websites such as <link xl:href="http://www.asciitable.com/">http://www.asciitable.com/</link>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:stringLength"/> What is the output from the following
sequence of statements?</simpara>
<programlisting language="java" linenumbering="unnumbered">String p = "Break it";
String q = "down like this!";
System.out.println((p + q).length());</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:emptyStringsExercise"/> What is the output from the
following sequence of statements? Note that <literal>r</literal> contains a single space
character.</simpara>
<programlisting language="java" linenumbering="unnumbered">String p = "This is not a string.";
String q = "";
String r = " ";
System.out.println((p + q + r).length());</programlisting>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:uninitializedStringObjectExercise"/> Try compiling the
following program and observe the error reported by the compiler.</simpara>
<programlisting xml:id="program:UninitializedString" xreflabel="UninitializedString" language="java" linenumbering="numbered">public class UninitializedString {
	 public static void main(String[] args) {
          String greeting;
          System.out.println(greeting);/*@ \label{uninitializedStringPrintout}@*/
    }
}</programlisting>
<simpara>Now initialize the <literal>greeting</literal> object and rerun the program. Why does the
program compile now?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:stringToNumericConversionProgramExercise"/> Write a Java
program that prompts the user to enter the number of rooms in her home,
uses a <literal>Scanner</literal> object to read the input into an <literal>int</literal> variable named
<literal>rooms</literal>, and then outputs the value on the screen. If you compile and
execute your program and type in the value <literal>3.5</literal>, can you explain the
output you see?</simpara>
</listitem>
<listitem>
<simpara>Convert the college cost calculator solution given in
SectionÂ <xref linkend="solution:College_cost_calculator"/> to use<?asciidoc-br?>
<literal>JOptionPane</literal> methods for both input and output. Use the header giving
the user&#8217;s first and last name for the title of the output dialog and
omit the line of asterisks. If you put all the output in a single
<literal>String</literal> with a newline (<literal>\n</literal>) separating each line, the output will
display properly.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Selection">
<title>Selection</title>
<blockquote>
<attribution>
Albert Camus
</attribution>
<simpara>Life is a sum of all your choices.</simpara>
</blockquote>
<section xml:id="section:Monty_Hall">
<title>Problem: Monty Hall simulation</title>
<simpara>There is a famous mathematical puzzle called the Monty Hall problem,
based on the television show <emphasis>Letâs Make a Deal</emphasis> hosted by the eponymous
Monty Hall. In this problem, you are presented with three doors. Two of
the three doors have junk behind them. One randomly selected door
conceals something like a pile of gold. If you can choose that door, you
win the gold. After you make an initial choice, Monty, who knows which
door the pile of gold is behind, will open one of the two other doors,
always picking a door with junk behind it. If you chose the gold door,
Monty will pick between the two junk doors randomly. After opening a
door, Monty gives you a chance to switch to the other unopened door. You
decide to switch or not, the appropriate door is opened, and you win
either junk or a pile of gold, depending on your luck.</simpara>
<simpara>As it turns out, it is always a better strategy to switch doors. If you
keep your initial choice, you will win the gold with probability
<inlineequation><alt><![CDATA[\frac{1}{3}]]></alt><mathphrase><![CDATA[\frac{1}{3}]]></mathphrase></inlineequation>. However, if you switch doors, you will win
with probability <inlineequation><alt><![CDATA[\frac{2}{3}]]></alt><mathphrase><![CDATA[\frac{2}{3}]]></mathphrase></inlineequation>. The problem is
counterintuitive and leads many people, including mathematicians and
people holding advanced degrees, to the incorrect answer.</simpara>
<simpara>Think about it this way: Suppose you could pick two doors to open, and
if the gold was behind either one of them, you would win. Clearly, your
probability of winning would be <inlineequation><alt><![CDATA[\frac{2}{3}]]></alt><mathphrase><![CDATA[\frac{2}{3}]]></mathphrase></inlineequation>. Monty allows
you this option. Just pick the two doors you want and tell Monty the
third. He reveals one of your two initial doors as junk, and you switch
to the other one.</simpara>
<simpara>If you still arenât convinced, thatâs fine. Your goal is to write a
program that simulates the Monty Hall dilemma, allowing a user to guess
a door and then, potentially, switch. Once you have written the
simulation, you can choose to play repeatedly and see how well you do if
you switch.</simpara>
<simpara>A Monty Hall scenario has two significant features that distinguish it
from problems in previous chapters. First, randomness play a role.
Generating random numbers has become an important part of computer
science, and most languages provide programmers with tools for
generating random or nearly random numbers. Recall the <literal>Random</literal> class
from ChapterÂ <xref linkend="chapter:Primitive_Types_and_Strings"/>. With an object of
type <literal>Random</literal> called <literal>random</literal>, you can generate a random <literal>int</literal> between
<literal>0</literal> and <literal>n - 1</literal> by calling <literal>random.nextInt(n)</literal>.</simpara>
<simpara>The second and much more important feature of Java in the solution to
this problem is the element of choice. A random door is chosen to hide
gold, and the program must react appropriately. The user chooses a door,
and the program must carefully choose another door to open in response.
Finally, the user must decide whether or not he or she wants to switch
his or her choice. Inherent in this problem is the idea of <emphasis>conditional
execution</emphasis>. Every program from the previous chapter runs sequentially,
line by line. With conditional execution, only some of the code may be
executed, depending on input from the user or the values that random
numbers take. Previously, every program was deterministic, a series of
inevitable consequences. Now, that linear, one-thing-follows-another
paradigm has split into complex trees and webs of possible program
executions.</simpara>
</section>
<section xml:id="_concepts_choosing_between_options">
<title>Concepts: Choosing between options</title>
<simpara>Before we get to random numbers and the complex choices involved in the
Monty Hall problem, letâs talk about the simplified approach that most
programming languages take to conditional execution. When we come to a
point in a program where there is a choice to be made, we can think of
it as the question, &#8220;Do I want to perform this series of tasks?&#8221; Like
the classic game of 20 Questions, these questions in Java generally only
have two answers: &#8220;yes&#8221; or &#8220;no.&#8221; If the answer is &#8220;yes,&#8221; the
program completes Task A, otherwise it completes Task B. It is easier to
design programming languages that can handle yes-or-no questions than
any general question. If you have studied logic in the past, you have
probably run across <emphasis>Boolean logic</emphasis>. Boolean logic gives a set of rules,
similar to the rules of traditional algebra, that can be applied to a
system with only two values: true and false.</simpara>
<section xml:id="_simple_choices">
<title>Simple choices</title>
<simpara>Because we want to build a system using only yes-or-no questions,
Boolean logic is a perfect fit for computer science. To conform with
other computer scientists, we try to think of conditions in terms of
true and false, instead of yes and no. Thus, we can begin to formulate
the kinds of choices we want to make:</simpara>
<simpara><emphasis>If it is raining outside, then I will take my umbrella.</emphasis></simpara>
<simpara>This statement is a very simple program, even though it is not one
executed by a computer. The person following this program asks herself,
&#8220;Is it raining today?&#8221; If the answer is &#8220;yes,&#8221; then she will take
her umbrella. We can abstract this idea a bit further by saying that
<emphasis>raining outside</emphasis> is a condition <inlineequation><alt><![CDATA[p]]></alt><mathphrase><![CDATA[p]]></mathphrase></inlineequation> and that <emphasis>taking my
umbrella</emphasis> is an action <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation>. In other words, if
<inlineequation><alt><![CDATA[p]]></alt><mathphrase><![CDATA[p]]></mathphrase></inlineequation> is true, then do <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation>. We have not specified
what is to be done if <inlineequation><alt><![CDATA[p]]></alt><mathphrase><![CDATA[p]]></mathphrase></inlineequation> is not true, although it is
assumed that the actor in this drama will not take an umbrella.</simpara>
<simpara>If we want to view <inlineequation><alt><![CDATA[p]]></alt><mathphrase><![CDATA[p]]></mathphrase></inlineequation> as a decision to make, we can specify
what happens if it is not true. For example, we could formulate another
choice:</simpara>
<simpara><emphasis>If I have at least $50 in my pocket, then I will eat a lobster dinner,
otherwise I will eat fast food.</emphasis></simpara>
<simpara>In this case, we let <emphasis>having at least $50</emphasis> be condition <inlineequation><alt><![CDATA[q]]></alt><mathphrase><![CDATA[q]]></mathphrase></inlineequation>,
<emphasis>eating a lobster dinner</emphasis> be action <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, and <emphasis>eating fast
food</emphasis> be action <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation>. Now we have created a decision. If
<inlineequation><alt><![CDATA[q]]></alt><mathphrase><![CDATA[q]]></mathphrase></inlineequation> is true, the person will do action <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, but,
if it is false, she will do action <inlineequation><alt><![CDATA[c]]></alt><mathphrase><![CDATA[c]]></mathphrase></inlineequation>.</simpara>
</section>
<section xml:id="_boolean_operations">
<title>Boolean operations</title>
<simpara>Even by itself, the ability to pick between two options is powerful, but
we can augment this ability in a couple of ways. First, we donât have to
rely on simple conditions. Using Boolean logic, we can make arbitrarily
complex conditions.</simpara>
<simpara><emphasis>If I am bored, or it is late and I canât sleep, then I will watch
television.</emphasis></simpara>
<simpara>Someone following this program will watch television if he is bored or
if it is late and he also cannot sleep. We can break the condition into
three sub-conditions: <emphasis>I am bored</emphasis> is condition <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <emphasis>it is
late</emphasis> is condition <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <emphasis>I canât sleep</emphasis> is condition
<inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation>. We have connected these three conditions together using
the words &#8220;and&#8221; and &#8220;or.&#8221; These two simple words represent powerful
concepts in Boolean logic, AND and OR. When two conditions are combined
with AND, the result is true only if both conditions are true. When two
conditions are combined with OR, the result is true if either of the
conditions is true.</simpara>
<simpara>We can create a table called a <emphasis>truth table</emphasis> to show all the possible
values certain conditions can take. We are going to use the symbol
<inlineequation><alt><![CDATA[\land]]></alt><mathphrase><![CDATA[\land]]></mathphrase></inlineequation> to represent the concept of AND and the symbol
<inlineequation><alt><![CDATA[\lor]]></alt><mathphrase><![CDATA[\lor]]></mathphrase></inlineequation> to represent the concept of OR. We will also
abbreviate true to T and false to F.</simpara>
<simpara>Given a condition <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, a condition <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and the condition made by <inlineequation><alt><![CDATA[x \land y]]></alt><mathphrase><![CDATA[x \land y]]></mathphrase></inlineequation>, this truth table shows all possible values. As stipulated, <inlineequation><alt><![CDATA[x \land y]]></alt><mathphrase><![CDATA[x \land y]]></mathphrase></inlineequation> is true only when both <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> are true.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x \land y]]></alt><mathphrase><![CDATA[x \land y]]></mathphrase></inlineequation></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This truth table gives all the values for <inlineequation><alt><![CDATA[x \lor y]]></alt><mathphrase><![CDATA[x \lor y]]></mathphrase></inlineequation>. As you can see, <inlineequation><alt><![CDATA[x \lor y]]></alt><mathphrase><![CDATA[x \lor y]]></mathphrase></inlineequation> is true if <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> or <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> are true.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x \lor y]]></alt><mathphrase><![CDATA[x \lor y]]></mathphrase></inlineequation></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that there is confusion with the use of the word &#8220;or&#8221; in English.
Sometimes &#8220;or&#8221; is used in an exclusive sense to mean one or the other
but not both, as in, &#8220;Would you like lemonade or iced tea with your
meal?&#8221; In logic, this exclusive or exists as well and is called XOR.
This difference gives another reason for a formally structured language
like mathematics or Java to express ourselves precisely. When two
conditions are connected with XOR, the result is true if one or the
other but not both conditions are true. We use the symbol
<inlineequation><alt><![CDATA[\oplus]]></alt><mathphrase><![CDATA[\oplus]]></mathphrase></inlineequation> to represent the XOR operation in the truth table
below.</simpara>
<simpara>This truth table gives all the values for <inlineequation><alt><![CDATA[x \oplus y]]></alt><mathphrase><![CDATA[x \oplus y]]></mathphrase></inlineequation>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x \oplus y]]></alt><mathphrase><![CDATA[x \oplus y]]></mathphrase></inlineequation></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The operations AND, OR, and XOR are all binary operations like addition
and multiplication. They connect two conditions together to get a
result. There is a single unary operation in Boolean logic, the NOT
operator. A NOT simply reverses a condition. If a condition is true,
then NOT applied to that condition will yield false, and vice versa.</simpara>
<simpara>Here is a truth table for NOT, using the symbol <inlineequation><alt><![CDATA[\lnot]]></alt><mathphrase><![CDATA[\lnot]]></mathphrase></inlineequation> to represent the NOT operation.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[\lnot x]]></alt><mathphrase><![CDATA[\lnot x]]></mathphrase></inlineequation></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>F</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>F</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Now that we have nailed down some notation for Boolean logic, we can
express the complicated expression that sent us down this path in the
first place. Recall that <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> is <emphasis>I am bored</emphasis>,
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> is <emphasis>it is late</emphasis>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation> is <emphasis>I canât sleep</emphasis>.
Let <inlineequation><alt><![CDATA[d]]></alt><mathphrase><![CDATA[d]]></mathphrase></inlineequation> be the action <emphasis>I will watch television</emphasis>. We can
express the choice in this way: If <inlineequation><alt><![CDATA[x \lor (y \land z)]]></alt><mathphrase><![CDATA[x \lor (y \land z)]]></mathphrase></inlineequation>,
then do <inlineequation><alt><![CDATA[d]]></alt><mathphrase><![CDATA[d]]></mathphrase></inlineequation>. Using this notation, we have expressed
precisely the conditions for watching television, using parentheses to
clear up the ambiguity present in the original statement. If we can map
individual conditions to Boolean variables, we can build conditions of
arbitrary complexity.</simpara>
</section>
<section xml:id="_nested_choices">
<title>Nested choices</title>
<simpara>Making one choice is all well and good, but in life and computer
programs, we may have to make many interrelated choices. For example, if
you choose to eat at a seafood restaurant, then you might choose between
eating shrimp and lobster, but, if you choose instead to eat at a
steakhouse, the options of shrimp and lobster might not be available.</simpara>
<simpara>A <emphasis>nested</emphasis> choice is one that sits inside of another choice you have
already made. We could describe choices of restaurant and meal as
follows.</simpara>
<simpara><emphasis>If I want seafood, then I will eat at Sharkyâs, otherwise I will eat at
the Golden Calf. When dining at Sharkyâs, if I have at least $50, I will
order the lobster, otherwise I will order the shrimp. When dining at the
Golden Calf, if I have at least $30, I will order the filet mignon,
otherwise I will order the pork chops.</emphasis></simpara>
<simpara>The previous description is long, but it precisely expresses the
decisions our imaginary diner might make. This description in English
has drawbacks: It is long and repetitive, and the grouping of specific
meal choices with specific restaurants is not clear.</simpara>
<simpara>In the next section, we discuss the Java syntax that allows us to
express the same sorts of decision patterns. Unlike English, Java has
been designed to make these sequences of decisions clear and easy to
read.</simpara>
</section>
</section>
<section xml:id="_syntax_selection_in_java">
<title>Syntax: Selection in Java</title>
<simpara>With some theoretical background on the kinds of choices we are
interested in making, we are going to discuss the Java syntax used to
describe these choices. It was no accident that we kept repeating the
word &#8220;if,&#8221; because the main Java language feature for making choices
is called an <literal>if</literal> statement.</simpara>
<section xml:id="_literal_if_literal_statements">
<title><literal>if</literal> statements</title>
<simpara>The designers of Java studied Boolean logic and created a type called
<literal>boolean</literal>. Every condition used by an <literal>if</literal> statement must evaluate to a
<literal>boolean</literal> value, which can only be one of two things: <literal>true</literal> or <literal>false</literal>.</simpara>
<simpara>For example, we could have a <literal>boolean</literal> variable called <literal>raining</literal>. Stored
in this variable is the value <literal>true</literal> if it is raining and <literal>false</literal> if it
isnât. Using Java syntax, we could encode our first example in which our
actor takes her umbrella if it is raining.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( raining ) {
    umbrella.take();
}</programlisting>
<simpara>The action taken if it is raining is done by calling a <emphasis>method</emphasis> on an
<emphasis>object</emphasis>. Weâll discuss objects and methods further in
ChaptersÂ <xref linkend="chapter:Methods"/> and <xref linkend="chapter:Classes"/>. What weâre
focusing on now is that the line <literal>umbrella.take();</literal> is executed only if
<literal>raining</literal> has the value <literal>true</literal>. Nothing is done if it is <literal>false</literal>.
FigureÂ <xref linkend="figure:if"/> shows this pattern of conditional execution
followed by all <literal>if</literal> statements.</simpara>
<figure role="text-center">
<title>Execution goes inside the <literal>if</literal> statement when its condition is <literal>true</literal> and skips past it otherwise.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/04-selection/images/if.svg" width="50%"/>
</imageobject>
<textobject><phrase>if</phrase></textobject>
</mediaobject>
</figure>
<simpara>Our descriptions of logical scenarios from the previous section used the
word &#8220;then&#8221; to mark the actions that would be done if a condition was
true. Some languages use <literal>then</literal> as a keyword, but Java does not.
Instead, note the left brace (<literal>\{</literal>) and the right brace (<literal>\}</literal>) that
enclose the executable line <literal>umbrella.take();</literal>. These braces serve the
same role as the word &#8220;then,&#8221; clearly marking the action to be
performed if a condition is true. Braces are unambiguous because they
mark a start and an end. If there are many actions to be done, they can
all be put inside the braces, and there will be no question as to which
actions are associated with a given <literal>if</literal> statement.</simpara>
<simpara>For example, we may also need to close the window and put on a raincoat
if it is raining. We might accomplish these tasks in Java as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( raining ) {
    umbrella.take();
    window.close();
    raincoat.putOn();
}</programlisting>
<simpara>Within a matching pair of braces (<literal>\{\}</literal>), called a <emphasis>block</emphasis> of code,
execution proceeds normally, line by line. First, the JVM will cause the
umbrella to be taken, then the window to be closed, and finally the
raincoat to be put on.</simpara>
<simpara>If only a single line of code is contained within a block of code, the
braces can be left out. For example, many experienced Java programmers
would have written our first example as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( raining )
    umbrella.take();</programlisting>
<simpara>For beginning Java programmers, however, it is a good idea to use braces
even when you donât need to. Without braces, code can appear to be doing
one thing when it really is doing another.</simpara>
<simpara>Since programmers must often choose between two alternatives, Java
provides an <literal>else</literal> statement to specify code that should be run if the
condition of the <literal>if</literal> statement is false.</simpara>
<simpara>Let <literal>fiftyDollars</literal> be a <literal>boolean</literal> variable that is <literal>true</literal> if we have at
least $50 and is <literal>false</literal> otherwise. Now, we can choose between two
dining options based on how much money we have.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( fiftyDollars ) {
    lobsterDinner.eat();
}
else {
    fastFood.eat();
}</programlisting>
<simpara>This Java code matches the logical statements we wrote before. If we
have enough money, weâll eat a lobster dinner, otherwise, weâll eat fast
food. As with an <literal>if</literal> statement, we use braces to mark a block of code
for an <literal>else</literal> statement, too. Since a single line of code will be
executed in each case, the braces are optional here. We could have
written code with the same functionality as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( fiftyDollars )
    lobsterDinner.eat();
else
    fastFood.eat();</programlisting>
<simpara>FigureÂ <xref linkend="figure:else"/> shows the pattern of conditional execution
followed by all <literal>if</literal> statements that have a matching <literal>else</literal> statement.</simpara>
<figure role="text-center">
<title>Execution goes inside the <literal>if</literal> statement when its condition is <literal>true</literal> and jumps into the <literal>else</literal> statement otherwise.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/04-selection/images/else.svg" width="50%"/>
</imageobject>
<textobject><phrase>else</phrase></textobject>
</mediaobject>
</figure>
<warning>
<title>Pitfall: Misleading indentation</title>
<simpara>Indentation is used to make the code more readable, but Java ignores
whitespace, meaning that the indentation has no effect on the execution
of the code. To demonstrate, letâs assume that our imaginary diner knows
he will get a stomachache after eating fast food. Thus, he will take
some Pepto-Bismol after eating it. If you modified the code above, which
does not contain braces, you might get the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( fiftyDollars )
    lobsterDinner.eat();
else
    fastFood.eat();
    peptoBismol.take();</programlisting>
<simpara>Although it looks like both <literal>fastFood.eat();</literal> and <literal>peptoBismol.take();</literal>
are within the block of the <literal>else</literal> statement, only <literal>fastFood.eat();</literal> is.
The line <literal>peptoBismol.take();</literal> is not part of the <literal>if</literal>-<literal>else</literal> structure
at all and will be executed no matter what. The correct way to program
this decision is below.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( fiftyDollars )
    lobsterDinner.eat();
else {
    fastFood.eat();
    peptoBismol.take();
}</programlisting>
</warning>
</section>
<section xml:id="_the_literal_boolean_literal_type_and_its_operations">
<title>The <literal>boolean</literal> type and its operations</title>
<simpara>Recall that Java uses the type <literal>boolean</literal> for values that can only be
true or false. Just like the numerical types <literal>double</literal> and <literal>int</literal>, the
<literal>boolean</literal> type has specific operations that can be used to combine them
together. By design, these operations correspond exactly to the logical
operations we described before. Here is a table giving the Java
operators that are equivalent to the logical Boolean operations.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="bottom">Name</entry>
<entry align="center" valign="bottom">Math<?asciidoc-br?>
Symbol</entry>
<entry align="center" valign="bottom">Java<?asciidoc-br?>
Operator</entry>
<entry align="left" valign="bottom">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara>AND</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\land]]></alt><mathphrase><![CDATA[\land]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>&amp;&amp;</literal></simpara></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if both values are <literal>true</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>OR</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\lor]]></alt><mathphrase><![CDATA[\lor]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>||</literal></simpara></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if either value is <literal>true</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>XOR</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\oplus]]></alt><mathphrase><![CDATA[\oplus]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>^</literal></simpara></entry>
<entry align="left" valign="middle"><simpara>Returns <literal>true</literal> if values are different</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>NOT</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\lnot]]></alt><mathphrase><![CDATA[\lnot]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>!</literal></simpara></entry>
<entry align="left" valign="middle"><simpara>Returns the opposite of the value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Using these operators, we can create <literal>boolean</literal> values and combine them
together.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean x = true;
boolean y = false;
boolean z = !((x || y) ^ (x &amp;&amp; y));</programlisting>
<simpara>When this code is executed, the value of <literal>z</literal> will be <literal>false</literal>. Although
it is perfectly legal to perform <literal>boolean</literal> operations this way, it is
much more common to combine them &#8220;on the fly&#8221; inside of the condition
of an <literal>if</literal> statement. Recall the statement from the previous section:</simpara>
<simpara><emphasis>If I am bored, or it is late and I canât sleep, then I will watch
television.</emphasis></simpara>
<simpara>If we let <literal>bored</literal>, <literal>late</literal>, and <literal>canSleep</literal> be <literal>boolean</literal> variables whose
values indicate if we are bored, if it is late, and if we can sleep,
respectively, we can encode this statement in Java like so.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( bored || (late &amp;&amp; !canSleep) )
    television.watch();</programlisting>
<simpara>Combining the <literal>||</literal> operator with other <literal>||</literal> operators is both
commutative and associative: order and grouping doesnât matter.
Likewise, combining the <literal>&amp;&amp;</literal> operator with other <literal>&amp;&amp;</literal> operators is
also commutative and associative. However, once you start mixing <literal>||</literal>
with <literal>&amp;&amp;</literal>, it is a good idea to use parentheses for grouping. If, in
the above example, <literal>bored</literal> is <literal>true</literal>, <literal>late</literal> is <literal>false</literal>, and <literal>canSleep</literal>
is <literal>true</literal>, then the expression <literal>bored || (late &amp;&amp; !canSleep)</literal> will be
<literal>true</literal>. However, with the same values, the expression
<literal>bored || late &amp;&amp; !canSleep</literal> will be <literal>false</literal>.</simpara>
<simpara>Now that we are discussing ordering, it is important to note that <literal>||</literal>
and <literal>&amp;&amp;</literal> are <emphasis>short circuit</emphasis> operators. Short circuit means that, if
the value of the expression can be determined without evaluating the
rest of it, the JVM will not bother to compute any more of the
expression. With <literal>||</literal> this situation arises because <literal>true</literal> OR anything
else is still <literal>true</literal>. With <literal>&amp;&amp;</literal> this situations arises because <literal>false</literal>
AND anything else is still <literal>false</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( true || ((late &amp;&amp; !canSleep &amp;&amp; isTired &amp;&amp; isHungry) ||
    (wantsToFindOutWhatHappensNextInHisFavoriteShow ||
    likesTV )) )</programlisting>
<simpara>The condition of this <literal>if</literal> statement will always evaluate to <literal>true</literal> and
its body will always be executed. Because Java knows this, it will not
even bother to execute any of the code after the first <literal>||</literal> operator.
This short circuit evaluation is done at run time and will work if the
value of a variable at the beginning of an OR clause is <literal>true</literal>. It need
not be the literal <literal>true</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( false &amp;&amp; ((late || !canSleep || isTired || isHungry) &amp;&amp;
    (wantsToFindOutWhatHappensNextInHisFavoriteShow ||
    likesTV )) )</programlisting>
<simpara>The condition of this <literal>if</literal> statement will always evaluate to <literal>false</literal> and
its body will not be executed. As before, nothing after the first <literal>&amp;&amp;</literal>
will even be executed. If you are combining literals and <literal>boolean</literal>
values with the <literal>||</literal> and <literal>&amp;&amp;</literal> operators, it makes no difference that
short circuit evaluation occurs. However, if a method call is part of
the clauses, your code might miss valuable side-effects. For example,
let the <literal>boolean</literal> variable <literal>working</literal> be <literal>false</literal> in the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( working &amp;&amp; doSomethingImportant() )</programlisting>
<simpara>In this case, the <literal>doSomethingImportant()</literal> method must return a
<literal>boolean</literal> value to be a valid statement. Still, if <literal>working</literal> is <literal>false</literal>,
the <literal>doSomethingImportant()</literal> method will not be called. As soon as the
JVM realizes that it is applying the <literal>&amp;&amp;</literal> operation to a <literal>false</literal>
value, it will give up. In many cases, doing so is fine. In fact,
programmers will sometimes exploit this feature to allow code in a
method like <literal>doSomethingImportant()</literal> to run only if it is safe to do so.
In this case, if we assume that we always want to run the
<literal>doSomethingImportant()</literal> method (because it does something important)
every time the condition of the <literal>if</literal> statement is evaluated, we need to
restructure the code. For example, we can reverse the order of the two
terms in the AND clause to achieve this effect. Alternatively, Java
provides non-short circuit versions of the <literal>||</literal> and <literal>&amp;&amp;</literal> operators,
namely <literal>|</literal> and <literal>\&amp;</literal>, if you need to force full evaluation.</simpara>
<simpara>You may have been wondering where the majority of <literal>boolean</literal> values come
from. Most computer programs do not ask the user a long series of true
or false questions before spitting out an answer. Most <literal>boolean</literal> values
in Java programs are the result of comparisons, often of numerical data
types.</simpara>
<simpara>It is useful to compare two numbers to see if one is larger, smaller, or
equal to the other. For example, you might have a <literal>double</literal> variable
called <literal>pressure</literal> that gives the water pressure in a hydraulic system.
Perhaps you also have a constant called <literal>CRITICAL_PRESSURE</literal> that gives
the maximum safe pressure for your system. You can compare these values
using the <literal>&gt;</literal> operator.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( pressure &gt; CRITICAL_PRESSURE )
    emergencyShutdown();</programlisting>
<simpara>This code allows you to call the appropriate emergency method when
<literal>pressure</literal> is too high. Of course, the <literal>&gt;</literal> operator is not the only way
to compare two values in Java. We list all the relational operators in
ChapterÂ <xref linkend="chapter:Primitive_Types_and_Strings"/>, but
TableÂ <xref linkend="table:relational_operators"/> below shows them again in a
mathematical context.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="bottom">Name</entry>
<entry align="center" valign="bottom">Math<?asciidoc-br?>
Symbol</entry>
<entry align="center" valign="bottom">Java<?asciidoc-br?>
Operator</entry>
<entry align="left" valign="bottom">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Equals</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[=]]></alt><mathphrase><![CDATA[=]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>==</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the two values are equal</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Not Equals</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\neq]]></alt><mathphrase><![CDATA[\neq]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>!=</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the two values are not
equal</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Less Than</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[<]]></alt><mathphrase><![CDATA[<]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>&lt;</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the first value is strictly
less than the second</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Less Than or Equals</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\leq]]></alt><mathphrase><![CDATA[\leq]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>&lt;=</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the first
value is less than or equal to the second</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Greater Than</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[>]]></alt><mathphrase><![CDATA[>]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>&gt;</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the first value is
strictly greater than the second</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Greater Than or Equals</simpara></entry>
<entry align="center" valign="middle"><simpara><inlineequation><alt><![CDATA[\geq]]></alt><mathphrase><![CDATA[\geq]]></mathphrase></inlineequation></simpara></entry>
<entry align="center" valign="middle"><simpara><literal>&gt;=</literal></simpara></entry>
<entry align="left" valign="middle"><simpara><literal>true</literal> if the first
value is greater than or equal to the second</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The concepts and mathematical symbols for these operators should be
familiar from mathematics. There are a few differences from the
mathematical versions of these ideas that are worth pointing out. First,
only easy-to-type symbols are used for Java operators. Thus, we need two
characters to represent most operators in the language. These operators
can be used to compare any numerical type with any other numerical type,
including <literal>char</literal>. In the case of mismatched types, such as an <literal>int</literal> and
a <literal>double</literal>, the lower precision type is automatically cast to the higher
precision type. Care should be taken when using the <literal>==</literal> operator with
floating point types because of rounding errors. For example, the
expression <literal>(1.0/3.0 == 0.3333333333)</literal> always evaluates to <literal>false</literal>.</simpara>
<simpara>The <literal>==</literal> operator is not the same as the <literal>=</literal> operator from previous
chapters. In Java, the double equal sign <literal>==</literal> is used to compare two
things while the single equal sign <literal>=</literal> is used to assign one thing to
another.</simpara>
<simpara>Confusion can also arise because, in the mathematical world, relational
symbols are used to make a statement: <inlineequation><alt><![CDATA[x < y]]></alt><mathphrase><![CDATA[x < y]]></mathphrase></inlineequation> is an
announcement or a discovery that the value contained in <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>
is, in fact, smaller than the value contained in <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>. In the
Java world, the statement <literal>x &lt; y</literal> is a <emphasis role="strong">test</emphasis> whose answer is <literal>true</literal> if
the value contained in <literal>x</literal> is smaller than the value contained in <literal>y</literal>
and <literal>false</literal> otherwise. Using these operators means performing a test at
a specific point in the code, asking a question about the values that
certain variables or literals (or the results of method calls) have at
that moment in time. In another sense, using these comparisons is a way
to take numerical data and convert it into the language of <literal>boolean</literal>
values. Note that the following statement does not compile in Java.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( 4 )
    x = y + z;</programlisting>
<simpara>To be used in an <literal>if</literal> statement, the value <literal>4</literal> must be first compared
with some other numerical type to yield a <literal>true</literal> or <literal>false</literal>.<?asciidoc-br?></simpara>
<warning>
<title>Pitfall: Assignment instead of equality</title>
<simpara>Along these lines, a common pitfall is to forget one of the equal signs
in the comparison operator.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( x = 4 )
    x = y + z;</programlisting>
<simpara>Again, this code will not compile. If it did, the variable <literal>x</literal> would be
assigned the value <literal>4</literal>, which would in turn be given to the <literal>if</literal>
statement, but an <literal>if</literal> statement does not know what to do with anything
other than a <literal>boolean</literal> value. Extreme care should be taken when
comparing two <literal>boolean</literal> values. For example, we might have two <literal>boolean</literal>
values <literal>genderA</literal> and <literal>genderB</literal>, corresponding to the genders of two
different people. Letâs say that the value of each one is <literal>true</literal> if the
person is female and <literal>false</literal> otherwise. We could create an <literal>if</literal>
statement that would work only if their genders are the same.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( genderA == genderB )
    makeRoommates();</programlisting>
<simpara>This code correctly calls the <literal>makeRoommates()</literal> method only if the two
individuals have the same gender. However, a tiny mistake in the code
could yield the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( genderA = genderB )
    makeRoommates();</programlisting>
<simpara>In this case, <literal>genderA</literal> would be assigned to whatever <literal>genderB</literal> is.
Then, that value would be given to the <literal>if</literal> statement. In this
situation, the <literal>makeRoommates()</literal> method will be called only if <literal>genderB</literal>
is <literal>true</literal>, meaning female. Thus, the two people will become roommates if
the second one is female, and the gender of the first person wonât be
considered. Unlike the <literal>x = 4</literal> example, this code will compile with no
warning.</simpara>
</warning>
<simpara>The next few examples illustrate the use of the <literal>if</literal> statement. They
also use some methods from class <literal>Math</literal>.</simpara>
<example>
<title>Leap year</title>
<simpara>In the standard Gregorian calendar, leap years occur roughly once every
four years. During leap years, the month of February has 29 days instead
of 28. This extra day makes up for the fact that it takes almost 365.24
days for the earth to orbit the sun. Unfortunately, the orbit of the
earth around the sun does not match up in any exact way with the
rotation of the earth. So, there are exceptions to the rule of every
four years.</simpara>
<simpara>In fact, the official definition for a leap year is a year that is
evenly divisible by 4, except for those years that are evenly divisible
by 100, with the exception to the exception of years that are evenly
divisible by 400. For example, 1988 was a leap year because it was
divisible by 4. The year 1900 was not a leap year because it was
divisible by 100 but not by 400, and the year 2000 was a leap year
because it was divisible by 400.</simpara>
<simpara>Recall that the mod operator (<literal>\%</literal>) allows us to find the remainder
after integer division. Thus, if <literal>n \% 100</literal> gives zero, <literal>n</literal> has no
remainder after being divided by <literal>100</literal> and must be evenly divisible by
100.</simpara>
<formalpara xml:id="program:LeapYear" xreflabel="LeapYear">
<title>A program that prompts the user for a year and then determines whether or not it is a leap year.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class LeapYear {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a year: ");
		int year = in.nextInt();
		if( year % 400 == 0 )
			System.out.println(year + " is a leap year.");
		else if( year % 100 == 0 )
			System.out.println(year + " is not a leap year.");
		else if( year % 4 == 0 )
			System.out.println(year + " is a leap year.");
		else
			System.out.println(year + " is not a leap year.");
	}
}</programlisting>
</para>
</formalpara>
<simpara>As with all of the programs in this section, we begin by importing
<literal>java.util.*</literal>, which is needed for the <literal>Scanner</literal> class for input. The
program prompts the user for a year and reads it in. If the year is
evenly divisible by 400, the program outputs that it is a leap year.
Otherwise, if the year is evenly divisible by 100, the program outputs
that it is not a leap year. Otherwise, if the year is evenly divisible
by 4, the program outputs that it is a leap year. Finally, if all the
other conditions have failed, the program outputs that the year is not a
leap year.</simpara>
</example>
<example>
<title>Quadratic formula</title>
<simpara>The quadratic formula is a useful tool from mathematics. Using this
formula, you can solve equations of the form <inlineequation><alt><![CDATA[ax^2 + bx
+ c = 0]]></alt><mathphrase><![CDATA[ax^2 + bx
+ c = 0]]></mathphrase></inlineequation>. As you might recall, the quadratic equation that gives the
solutions is: <inlineequation><alt><![CDATA[\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}]]></alt><mathphrase><![CDATA[\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}]]></mathphrase></inlineequation></simpara>
<simpara>The <inlineequation><alt><![CDATA[b^2 - 4ac]]></alt><mathphrase><![CDATA[b^2 - 4ac]]></mathphrase></inlineequation> part of the formula is called the
<emphasis>discriminant</emphasis>. If the discriminant is positive, there will be two real
answers to the equation. If the discriminant is negative, there will be
two complex answers to the equation. Finally, if the discriminant is
zero, there will be a single real answer to the problem. If you want to
write a program to solve quadratic equations for you, it should take
these three possibilities into account.</simpara>
<formalpara xml:id="program:Quadratic" xreflabel="Quadratic">
<title>Program to solve a quadratic equation.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Quadratic {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.println("This program solves quadratic" +
			" equations of the form ax^2 + bx + c = 0.");
		System.out.print("Please enter a value for a: ");
		double a = in.nextDouble();
		System.out.print("Please enter a value for b: ");
		double b = in.nextDouble();
		System.out.print("Please enter a value for c: ");
		double c = in.nextDouble();
		double discriminant = b*b - 4*a*c;
		if( discriminant == 0.0 )
			System.out.println("The answer is x = " + (-b/(2*a)));
		else if( discriminant &lt; 0.0 )
			System.out.println("The answers are x = " +
                (-b / (2*a)) + " + " +
                Math.sqrt(-discriminant) / (2*a) + "i and x = " +
                (-b / (2*a)) + " - " +
                Math.sqrt(-discriminant) / (2*a) + "i");
		else
			System.out.println("The answers are x = " +
                (-b + Math.sqrt(discriminant))/(2*a) +
                " and x = " +
                (-b - Math.sqrt(discriminant))/(2*a));
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program begins by prompting the user and reading in values for <literal>a</literal>,
<literal>b</literal>, and <literal>c</literal>. Then, it computes the discriminant. In the first case, we
want to test to see if the discriminant is zero. If the discriminant was
not zero but is negative, we account for this situation in the next
case. We compute the real and complex parts separately and output the
two answers. Finally, if the discriminant is positive, we find the two
answers and output them. Note that braces were not needed for the <literal>if</literal>,
<literal>else</literal>-<literal>if</literal>, and <literal>else</literal> blocks because each is composed of only a single
line of code. Although these <literal>System.out.println()</literal> method calls may
take up more than one line visually, Java interprets them as single
lines because they each only have a single semicolon (<literal>;</literal>).</simpara>
<simpara>The line <literal>if( discriminant == 0.0 )</literal> is dangerous since we are using
<literal>double</literal> values. Because of rounding errors, the discriminant might not
be exactly zero even if it should be, mathematically. Industrial
strength code would probably check to see if the absolute value of the
discriminant is less than a very small number (such as 0.00000001).
Values that small would then be treated as if they were zero.</simpara>
</example>
<example>
<title>20 Questions</title>
<simpara>In the time-honored game of 20 Questions, one person mentally chooses
something, and the other participants must guess what the thing is by
asking questions whose answer is either &#8220;yes&#8221; or &#8220;no.&#8221; In one
popular version, the person who chooses the thing starts by declaring
whether it is animal, vegetable, or mineral.</simpara>
<simpara>Using counting principles from math, 20 yes-or-no questions makes it
possible to differentiate <inlineequation><alt><![CDATA[2^{20} = 1,048,576]]></alt><mathphrase><![CDATA[2^{20} = 1,048,576]]></mathphrase></inlineequation> items. If you
are told ahead of time whether the thing is animal, vegetable, or
mineral, it should be possible to guess over 3 million items! We are not
yet ready to deal with such a large range of possibilities. To keep the
size of the code reasonable, letâs narrow the field to 10 different
items: a lizard, an eagle, a dolphin, a human, some lead, a diamond, a
tomato, a peach, a maple tree, and a potato.</simpara>
<figure>
<title>Decision tree to distinguish 10 items.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/04-selection/images/flowchart.svg" width="100%"/>
</imageobject>
<textobject><phrase>flowchart</phrase></textobject>
</mediaobject>
</figure>
<simpara>Using these items, we can construct a tree of decisions to make,
starting with the decision between animal, vegetable, and mineral. If
the thing is an animal, we could then ask if it is a mammal. If it is a
mammal, we could ask if it lives on land, deciding between human and
dolphin. If it is not a mammal, we could ask if it flies, deciding
between an eagle and a lizard. We can construct similar questions for
the things in the vegetable and mineral categories, matching
FigureÂ <xref linkend="figure:flowchart"/>.</simpara>
<formalpara xml:id="program:TwentyQuestions" xreflabel="TwentyQuestions">
<title>Program to navigate the possible choices in the decision tree.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class TwentyQuestions {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Is it an animal, vegetable, or mineral?" +
			"('a', 'v', or 'm'): ");
		String response = in.next().toLowerCase();
		if( response.equals("a") ) {
			System.out.print("Is it a mammal? ('y' or 'n'): ");
			response = in.next().toLowerCase();
			if( response.equals("y") ) {
				System.out.print(
					"Does it live on land? ('y' or 'n'): ");
				response = in.next().toLowerCase();
				if( response.equals("y") )
					System.out.println("It's a human.");
				else //assume "n"
					System.out.println("It's a dolphin.");
			}
			else { //assume "n"
				System.out.print("Does it fly? ('y' or 'n'): ");
				response = in.next().toLowerCase();
				if( response.equals("y") )
					System.out.println("It's an eagle.");
				else //assume "n"
					System.out.println("It's a lizard.");
			}
		}
		else if( response.equals("v") ) {
			System.out.print("Is it a fruit? ('y' or 'n'): ");
			response = in.next().toLowerCase();
			if( response.equals("y") ) {
				System.out.print(
					"Does it grown on a vine? ('y' or 'n'): ");
				response = in.next().toLowerCase();
				if( response.equals("y") )
					System.out.println("It's a tomato.");
				else //assume "n"
					System.out.println("It's a peach.");
			}
			else { //assume "n"
				System.out.print("Is it a tree? ('y' or 'n'): ");
				response = in.next().toLowerCase();
				if( response.equals("y") )
					System.out.println("It's a maple tree.");
				else //assume "n"
					System.out.println("It's a potato.");
			}
		}
		else { //assume "m"
				System.out.print(
					"Is it the hardest mineral? ('y' or 'n'): ");
				response = in.next().toLowerCase();
				if( response.equals("y") )
					System.out.println("It's a diamond.");
				else //assume "n"
					System.out.println("It's lead.");
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>The code in this example is straightforward, although even 10 items
makes for a lot of <literal>if</literal> and <literal>else</literal> blocks. Other than the <literal>if</literal>-<literal>else</literal>
statements, only simple input and output are needed to make the program
function. For proper <literal>String</literal> comparison, it is necessary to use the
<literal>equals()</literal> method to test if two <literal>String</literal> values are the same.</simpara>
<simpara>Note that we have added comments specifying what we assume is the case
for each <literal>else</literal> block. If we were being more careful, we should test for
the <literal>"y"</literal> and <literal>"n"</literal> cases and then give an error message when the user
inputs something unexpected, like <literal>"x"</literal> or <literal>"149"</literal> or even <literal>"no"</literal>.
Again, note that no braces are needed for the final <literal>if</literal>-<literal>else</literal> blocks
in which the guess is made, since each of these guesses requires only a
single line of code.</simpara>
<simpara>You might be curious how to make a real 20 Questions game that could
learn over time. To do so, many more programming tools are necessary:
repetition, data structures (so that you can organize the questions),
and file input and output (so that you can store new information
permanently). These concepts are covered in later chapters.</simpara>
</example>
</section>
<section xml:id="subsection:switch_statements">
<title><literal>switch</literal> statements</title>
<simpara>The <literal>if</literal> statement is the workhorse of Java conditional execution. With
enough care, you can craft code that can make any fixed sequence of
decisions with arbitrary complexity. Even so, the <literal>if</literal> statement can be
a little clumsy because it only allows you to choose between two
alternatives. After all, a conditional can only be <literal>true</literal> or <literal>false</literal>.
Certainly, decisions can be nested, allowing for more than two
possibilities, but long lists of possibilities can be cumbersome.</simpara>
<simpara>For example, imagine that we want to create a program that determines
the appropriate gift for a wedding anniversary. Below is a table of
traditional categories of gifts based on the anniversary year.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="middle">Year</entry>
<entry align="left" valign="middle">Gift</entry>
<entry align="center" valign="middle">Year</entry>
<entry align="left" valign="middle">Gift</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara>1</simpara></entry>
<entry align="left" valign="middle"><simpara>Paper</simpara></entry>
<entry align="center" valign="middle"><simpara>13</simpara></entry>
<entry align="left" valign="middle"><simpara>Lace</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>2</simpara></entry>
<entry align="left" valign="middle"><simpara>Cotton</simpara></entry>
<entry align="center" valign="middle"><simpara>14</simpara></entry>
<entry align="left" valign="middle"><simpara>Ivory</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>3</simpara></entry>
<entry align="left" valign="middle"><simpara>Leather</simpara></entry>
<entry align="center" valign="middle"><simpara>15</simpara></entry>
<entry align="left" valign="middle"><simpara>Crystal</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>4</simpara></entry>
<entry align="left" valign="middle"><simpara>Fruit</simpara></entry>
<entry align="center" valign="middle"><simpara>20</simpara></entry>
<entry align="left" valign="middle"><simpara>China</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>5</simpara></entry>
<entry align="left" valign="middle"><simpara>Wood</simpara></entry>
<entry align="center" valign="middle"><simpara>25</simpara></entry>
<entry align="left" valign="middle"><simpara>Silver</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>6</simpara></entry>
<entry align="left" valign="middle"><simpara>Candy / Iron</simpara></entry>
<entry align="center" valign="middle"><simpara>30</simpara></entry>
<entry align="left" valign="middle"><simpara>Pearl</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>7</simpara></entry>
<entry align="left" valign="middle"><simpara>Wool / Copper</simpara></entry>
<entry align="center" valign="middle"><simpara>35</simpara></entry>
<entry align="left" valign="middle"><simpara>Coral</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>8</simpara></entry>
<entry align="left" valign="middle"><simpara>Bronze / Pottery</simpara></entry>
<entry align="center" valign="middle"><simpara>40</simpara></entry>
<entry align="left" valign="middle"><simpara>Ruby</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>9</simpara></entry>
<entry align="left" valign="middle"><simpara>Pottery / Willow</simpara></entry>
<entry align="center" valign="middle"><simpara>45</simpara></entry>
<entry align="left" valign="middle"><simpara>Sapphire</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>10</simpara></entry>
<entry align="left" valign="middle"><simpara>Tin / Aluminum</simpara></entry>
<entry align="center" valign="middle"><simpara>50</simpara></entry>
<entry align="left" valign="middle"><simpara>Gold</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>11</simpara></entry>
<entry align="left" valign="middle"><simpara>Steel</simpara></entry>
<entry align="center" valign="middle"><simpara>55</simpara></entry>
<entry align="left" valign="middle"><simpara>Emerald</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara>12</simpara></entry>
<entry align="left" valign="middle"><simpara>Silk / Linen</simpara></entry>
<entry align="center" valign="middle"><simpara>60</simpara></entry>
<entry align="left" valign="middle"><simpara>Diamond</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Let <literal>year</literal> be a variable of type <literal>int</literal> containing the year in question.
A structure of <literal>if</literal>-<literal>else</literal> statements that can determine the appropriate
gift based on the year is below.</simpara>
<programlisting language="java" linenumbering="unnumbered">String gift;
if( year == 1 )
    gift = "Paper";
else if( year == 2 )
    gift = "Cotton";
else if( year == 3 )
    gift = "Leather";
else if( year == 4 )
    gift = "Fruit";
else if( year == 5 )
    gift = "Wood";
else if( year == 6 )
    gift = "Candy / Iron";
else if( year == 7 )
    gift = "Wool / Copper";
else if( year == 8 )
    gift = "Bronze / Pottery";
else if( year == 9 )
    gift = "Pottery / Willow";
else if( year == 10 )
    gift = "Tin / Aluminum";
else if( year == 11 )
    gift = "Steel";
else if( year == 12 )
    gift = "Silk / Linen";
else if( year == 13 )
    gift = "Lace";
else if( year == 14 )
    gift = "Ivory";
else if( year == 15 )
    gift = "Crystal";
else if( year == 20 )
    gift = "China";
else if( year == 25 )
    gift = "Silver";
else if( year == 30 )
    gift = "Pearl";
else if( year == 35 )
    gift = "Coral";
else if( year == 40 )
    gift = "Ruby";
else if( year == 45 )
    gift = "Sapphire";
else if( year == 50 )
    gift = "Gold";
else if( year == 55 )
    gift = "Emerald";
else if( year == 60 )
    gift = "Diamond";
else
    gift = "No traditional gift";</programlisting>
<simpara>This code stores the correct value in <literal>gift</literal>. Note that we are using the
feature of <literal>if</literal> statements that treats an entire <literal>if</literal> statement as one
statement. If we used braces to group things properly, the code would
become unreadable and unmanageably large.</simpara>
<programlisting language="java" linenumbering="unnumbered">String gift;
if( year == 1 ) {
    gift = "Paper";
}
else {
    if( year == 2 ) {
        gift = "Cotton";
    }
    else {
        if( year == 3 ) {
            gift = "Leather";
        }
        else {
            if( year == 4 ) {
                gift = "Fruit";
            }
            .
            .
            .</programlisting>
<simpara>It appears that there is some kind of <literal>else if</literal> construct in Java, but
there is not. Still, careful use of the rules for braces allows us to
write code that nicely expresses a list of alternatives, even if the
true compiler interpretation looks a little different.</simpara>
<simpara>Another way of expressing a long sequence of choices is by using a
<literal>switch</literal> statement. A <literal>switch</literal> statement takes a single integer type
value (<literal>int</literal>, <literal>long</literal>, <literal>short</literal>, <literal>byte</literal>, <literal>char</literal>) or a <literal>String</literal> and jumps
to a case corresponding to the input. We can recode the anniversary gift
example using a <literal>switch</literal> statement as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">String gift;
switch( year ) {
    case 1:  gift = "Paper"; break;
    case 2:  gift = "Cotton"; break;
    case 3:  gift = "Leather"; break;
    case 4:  gift = "Fruit"; break;
    case 5:  gift = "Wood"; break;
    case 6:  gift = "Candy / Iron"; break;
    case 7:  gift = "Wool / Copper"; break;
    case 8:  gift = "Bronze / Pottery"; break;
    case 9:  gift = "Pottery / Willow"; break;
    case 10: gift = "Tin / Aluminum"; break;
    case 11: gift = "Steel"; break;
    case 12: gift = "Silk / Linen"; break;
    case 13: gift = "Lace"; break;
    case 14: gift = "Ivory"; break;
    case 15: gift = "Crystal"; break;
    case 20: gift = "China"; break;
    case 25: gift = "Silver"; break;
    case 30: gift = "Pearl"; break;
    case 35: gift = "Coral"; break;
    case 40: gift = "Ruby"; break;
    case 45: gift = "Sapphire"; break;
    case 50: gift = "Gold"; break;
    case 55: gift = "Emerald"; break;
    case 60: gift = "Diamond"; break;
    default: gift = "No traditional gift"; break;
}</programlisting>
<simpara>Just like an <literal>if</literal> statement, a <literal>switch</literal> statement always has parentheses
enclosing some argument. Unlike an <literal>if</literal>, the argument of a <literal>switch</literal> must
be some kind of data that can be expressed as an integer or a <literal>String</literal>,
not a <literal>boolean</literal>. For each of the possible values you want the <literal>switch</literal>
to handle, you write a <literal>case</literal> statement. A <literal>case</literal> statement consists of
the keyword <literal>case</literal> followed by a constant value, either a literal or a
named constant, then a colon. When executed, the JVM jumps to the
matching <literal>case</literal> label and starts executing code there. If there is no
matching <literal>case</literal> label, the JVM goes to the <literal>default</literal> label. If there is
no <literal>default</literal> label, the entire <literal>switch</literal> statement is skipped.</simpara>
<simpara>One unusual feature of <literal>switch</literal> statements is that execution <emphasis>falls
through</emphasis> <literal>case</literal> statements. This means that you can use many different
<literal>case</literal> statements for a single segment of executable code. The execution
of code in a <literal>switch</literal> statement jumps out when it hits a <literal>break</literal>
statement. However, <literal>break</literal> statements are not required, as shown in
this <literal>switch</literal> statement that gives location information for all of the
telephone area codes in New York state.</simpara>
<programlisting language="java" linenumbering="unnumbered">String location = "";
switch( code ) {
    case 917: location = "Cellular: ";
    case 212:
    case 347:
    case 646:
    case 718: location += "New York City"; break;

    case 315: location = "Syracuse"; break;

    case 516: location = "Nassau County"; break;

    case 518: location = "Albany"; break;

    case 585: location = "Rochester"; break;

    case 607: location = "South Central New York"; break;

    case 631: location = "Suffolk County"; break;

    case 716: location = "Buffalo"; break;

    case 845: location = "Lower Hudson Valley"; break;

    case 914: location = "Westchester County"; break;

    default:  location = "Unknown Area Code"; break;
}</programlisting>
<simpara>As you can see, five different area codes are used by New York City. By
leaving out the <literal>break</literal> statements, values of <literal>212</literal>, <literal>347</literal>, <literal>646</literal>, and
<literal>718</literal> all have <literal>"New York City"</literal> stored into <literal>location</literal>. Area code 917
was originally designated for cellular phones and pagers although now it
has some landlines. By cleverly putting the statement for <literal>917</literal> ahead of
the other New York City entries, a value of <literal>917</literal> first stores
<literal>"Cellular: "</literal> into <literal>location</literal> and then falls through and appends
<literal>"New York City"</literal>. For each of these five area codes, execution in the
<literal>switch</literal> statement ends only when the <literal>break</literal> statement is reached.</simpara>
<simpara>The remaining nine area codes are by themselves. Each of them does a
single assignment and then breaks out of the <literal>switch</literal> block. Finally,
the <literal>default</literal> label is used if the area code is not one of the ones
specified. Note that we have ordered the (non-NYC) area codes in
ascending order for the sake of readability. As you can see with the
<literal>917</literal> example, there is no rule about the ordering of the labels. Even
the <literal>default</literal> label can occur anywhere in the <literal>switch</literal> block you want,
although it is common to put it at the end. Also, the <literal>break</literal> after the
<literal>default</literal> label is unnecessary because execution exits the <literal>switch</literal>
block anyway. Nevertheless, it is always wise to end on a <literal>break</literal>, in
the event that you add more cases in later.</simpara>
<simpara>Carelessness is always something to watch out for in <literal>switch</literal>
statements. Leaving out a <literal>break</literal> statement can cause disastrous and
difficult to discover bugs. The compiler does not warn you about missing
<literal>break</literal> statements, either. It is entirely your job to use them
appropriately. Because of the dangers involved, it is often better to
use <literal>if</literal>-<literal>else</literal> statements. Any <literal>switch</literal> statement can be rewritten as
some combination of <literal>if</literal>-<literal>else</literal> statements, but the reverse is not true.
The main benefit of <literal>switch</literal> statements is the ability to list many
alternatives clearly. Their drawbacks include the ease of making a
mistake, an inability to express ranges of data or most types (<literal>double</literal>,
<literal>float</literal>, or any reference type other than <literal>String</literal>), and limited
expressive power. They should be used only when their benefit of clearly
displaying a list of data outweighs the drawbacks. Note that Java 7
added <literal>String</literal> values as legal input to a <literal>switch</literal>. If you are coding in
Java 7 or later, you can use <literal>String</literal> literals for your cases, but then
your code is not be compatible with earlier versions.</simpara>
<simpara>Next we give a number of examples to help you get more familiar with
<literal>switch</literal> statements.</simpara>
<example>
<title>Days in the month</title>
<simpara>The use of <literal>switch</literal> statements is usually a little more special purpose
than <literal>if</literal> statements. Nevertheless, there are many problems where their
fall-through behavior can be useful. Imagine that you need to write a
program that gives the length of each month (assume that February always
has 28 days). Given the month as a number, we can easily write a program
that maps the number of the month to the number of days it contains.</simpara>
<formalpara xml:id="program:DaysInMonth" xreflabel="DaysInMonth">
<title>This program computes the number of days in a given month.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class DaysInMonth {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please a month number (1-12): ");
		int month = in.nextInt();
		int days = 0;
		switch( month ) {
			case 2:  days = 28; break;

			case 4:
			case 6:
			case 9:
			case 11: days = 30; break;

			case 1:
			case 3:
			case 5:
			case 7:
			case 8:
			case 10:
			case 12: days = 31; break;
		}
		System.out.println("The month you entered has " +
			days + " days.");
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program has a single label for February setting <literal>days</literal> to 28. Then,
there are labels for April, June, September, and November, months that
each have 30 days. Finally, the large block of January, March, May,
July, August, October, and December all set <literal>days</literal> to 31. It would be
easy to extend this code to prompt the user for a year so that you could
integrate the leap year code from above for the February case. Note also
that we do not have a <literal>default</literal> label. You might want to set <literal>days</literal> to
some special value (like <literal>-1</literal>) for invalid months.</simpara>
</example>
<example>
<title>Ordinal numbers</title>
<simpara>The term <emphasis>ordinal numbers</emphasis> refers to numbers that are used for ordering
within a set of items: first, second, third, and so on. When writing
these numbers with numerals in English, it is common to append two
letters to the end of the numeral to give the reader a clue that these
numerals should be read with their ordinal names: 1st, 2nd, 3rd, and so
on.</simpara>
<simpara>Unlike most things in English, the rules for deciding which two letters
are relatively simple. If the number ends in a 1, the letters &#8220;st&#8221;
should generally be used. If the number ends in a 2, the letters &#8220;nd&#8221;
should generally be used. If the number ends in a 3, the letters &#8220;rd&#8221;
should generally be used. For most other numbers, the letters &#8220;th&#8221;
should be used. We can use a <literal>switch</literal> statement to write a program to
give the correct ordinal endings for most numbers as follows.</simpara>
<formalpara xml:id="program:Ordinals" xreflabel="Ordinals">
<title>This program appends the appropriate suffix to a numeral to make it an ordinal.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Ordinals {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a positive number: ");
		int number = in.nextInt();
		String ending;
		switch( number % 10 ) {
			case 1:  ending = "st"; break;
			case 2:  ending = "nd"; break;
			case 3:  ending = "rd"; break;
			default: ending = "th"; break;
		}
		System.out.println("Its ordinal version is "
			+ number + ending + ".");
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program prompts and then reads in an <literal>int</literal> from the user. We then
find the remainder of <literal>number</literal> when it is divided by 10, yielding its
last digit. Based on this digit, we can pick from the four possibilities
and output the correct ordinal number in most cases. Unfortunately, the
names for English numbers do not follow the normal pattern of tens place
name followed by ones place name between 11 and 19, inclusive, and the
ordinals for any number ending in 11, 12, or 13 will be given the wrong
suffix by our code. We leave a more complete solution as an exercise.</simpara>
</example>
<example>
<title>Astrology</title>
<simpara>Many cultures practice astrology, a tradition that the time of a
personâs birth impacts his or her personality or future. One important
element of Chinese astrology is their zodiac, consisting of 12 animals.
Each consecutive year in a 12-year cycle corresponds to an animal.
Because this system repeats, the year one is born in modulo 12
identifies the animal. Below is a table giving these values. For
example, if you were born in 1979, <inlineequation><alt><![CDATA[1979 \mod 12 \equiv 11]]></alt><mathphrase><![CDATA[1979 \mod 12 \equiv 11]]></mathphrase></inlineequation>,
and thus you would be a Ram. Note that this arrangement is based on
years in the Gregorian calendar. Chinese astrologers do not list the
Monkey as the first animal in the cycle.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="bottom">Animal</entry>
<entry align="center" valign="bottom">Year<?asciidoc-br?>
modulo 12</entry>
<entry align="left" valign="bottom">Animal</entry>
<entry align="center" valign="bottom">Year<?asciidoc-br?>
modulo 12</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="bottom"><simpara>Monkey</simpara></entry>
<entry align="center" valign="bottom"><simpara>0</simpara></entry>
<entry align="left" valign="bottom"><simpara>Tiger</simpara></entry>
<entry align="center" valign="bottom"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="bottom"><simpara>Rooster</simpara></entry>
<entry align="center" valign="bottom"><simpara>1</simpara></entry>
<entry align="left" valign="bottom"><simpara>Rabbit</simpara></entry>
<entry align="center" valign="bottom"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="bottom"><simpara>Dog</simpara></entry>
<entry align="center" valign="bottom"><simpara>2</simpara></entry>
<entry align="left" valign="bottom"><simpara>Dragon</simpara></entry>
<entry align="center" valign="bottom"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="bottom"><simpara>Boar</simpara></entry>
<entry align="center" valign="bottom"><simpara>3</simpara></entry>
<entry align="left" valign="bottom"><simpara>Snake</simpara></entry>
<entry align="center" valign="bottom"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="bottom"><simpara>Rat</simpara></entry>
<entry align="center" valign="bottom"><simpara>4</simpara></entry>
<entry align="left" valign="bottom"><simpara>Horse</simpara></entry>
<entry align="center" valign="bottom"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="bottom"><simpara>Ox</simpara></entry>
<entry align="center" valign="bottom"><simpara>5</simpara></entry>
<entry align="left" valign="bottom"><simpara>Ram</simpara></entry>
<entry align="center" valign="bottom"><simpara>11</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Unfortunately, this table is not very accurate because it is based on
numbering from the Gregorian calendar. The years in question actually
start and end based on Chinese New Year, which occurs between January 21
and February 20. As a consequence, you may miscalculate your animal if
your birthday is early in the year. Letâs ignore this problem for the
moment and write a program using a <literal>switch</literal> statement designed to
correctly output the animal corresponding to an input birth year.</simpara>
<formalpara xml:id="program:ChineseZodiac" xreflabel="ChineseZodiac">
<title>This program determines a Chinese zodiac animal based on birth year.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class ChineseZodiac {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a year: ");
		int year = in.nextInt();
		String animal = "";
		switch( year % 12 ) {
			case 0:  animal = "Monkey"; break;
			case 1:  animal = "Rooster"; break;
			case 2:  animal = "Dog"; break;
			case 3:  animal = "Boar"; break;
			case 4:  animal = "Rat"; break;
			case 5:  animal = "Ox"; break;
			case 6:  animal = "Tiger"; break;
			case 7:  animal = "Rabbit"; break;
			case 8:  animal = "Dragon"; break;
			case 9:  animal = "Snake"; break;
			case 10: animal = "Horse"; break;
			case 11: animal = "Ram"; break;
		}
		System.out.println("The Chinese zodiac animal for " +
			"this year is: " + animal);
	}
}</programlisting>
</para>
</formalpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Sign</entry>
<entry align="left" valign="top">Symbol</entry>
<entry align="left" valign="top">Date Range</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Aries</simpara></entry>
<entry align="left" valign="top"><simpara>The Ram</simpara></entry>
<entry align="left" valign="top"><simpara>March 21 to April 19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Taurus</simpara></entry>
<entry align="left" valign="top"><simpara>The Bull</simpara></entry>
<entry align="left" valign="top"><simpara>April 20 to May 20</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Gemini</simpara></entry>
<entry align="left" valign="top"><simpara>The Twins</simpara></entry>
<entry align="left" valign="top"><simpara>May 21 to June 20</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cancer</simpara></entry>
<entry align="left" valign="top"><simpara>The Crab</simpara></entry>
<entry align="left" valign="top"><simpara>June 21 to July 22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Leo</simpara></entry>
<entry align="left" valign="top"><simpara>The Lion</simpara></entry>
<entry align="left" valign="top"><simpara>July 23 to August 22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Virgo</simpara></entry>
<entry align="left" valign="top"><simpara>The Virgin</simpara></entry>
<entry align="left" valign="top"><simpara>August 23 to September 22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Libra</simpara></entry>
<entry align="left" valign="top"><simpara>The Scales</simpara></entry>
<entry align="left" valign="top"><simpara>September 23 to October 22</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Scorpio</simpara></entry>
<entry align="left" valign="top"><simpara>The Scorpion</simpara></entry>
<entry align="left" valign="top"><simpara>October 23 to November 21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sagittarius</simpara></entry>
<entry align="left" valign="top"><simpara>The Archer</simpara></entry>
<entry align="left" valign="top"><simpara>November 22 to December 21</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Capricorn</simpara></entry>
<entry align="left" valign="top"><simpara>The Sea-Goat</simpara></entry>
<entry align="left" valign="top"><simpara>December 22 to January 19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Aquarius</simpara></entry>
<entry align="left" valign="top"><simpara>The Water Bearer</simpara></entry>
<entry align="left" valign="top"><simpara>January 20 to February 19</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pisces</simpara></entry>
<entry align="left" valign="top"><simpara>The Fishes</simpara></entry>
<entry align="left" valign="top"><simpara>February 20 to March 20</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In Western astrology, an important element associated with a personâs
birth is also called a zodiac sign. The dates for determining this kind
of zodiac sign are given by the preceding table.</simpara>
<simpara>If you want to implement the rules for this zodiac in code, a <literal>switch</literal>
statement is a good place to start, but you also have to put <literal>if</literal>
statements for each month to test the exact range of dates.</simpara>
<formalpara xml:id="program:WesternZodiac" xreflabel="WesternZodiac">
<title>This program determines Western zodiac signs based on birth month and day.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class WesternZodiac {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a month number (1-12): ");
		int month = in.nextInt();
		System.out.print("Please enter a day number in that month (1-31): ");
		int day = in.nextInt();
		String sign = "";
		switch( month ) {
			case 1: if( day &lt; 20 )
					sign = "Capricorn";
				else
					sign = "Aquarius";
 				break;
			case 2: if( day &lt; 20 )
					sign = "Aquarius";
				else
					sign = "Pices";
 				break;
			case 3: if( day &lt; 20 )
					sign = "Pices";
				else
					sign = "Aries";
 				break;
			case 4: if( day &lt; 20 )
					sign = "Aries";
				else
					sign = "Taurus";
 				break;
			case 5: if( day &lt; 21 )
					sign = "Taurus";
				else
					sign = "Gemini";
 				break;
			case 6: if( day &lt; 21 )
					sign = "Gemini";
				else
					sign = "Cancer";
 				break;
			case 7: if( day &lt; 23 )
					sign = "Cancer";
				else
					sign = "Leo";
 				break;
			case 8: if( day &lt; 23 )
					sign = "Leo";
				else
					sign = "Virgo";
 				break;
			case 9: if( day &lt; 23 )
					sign = "Virgo";
				else
					sign = "Libra";
 				break;
			case 10:if( day &lt; 23 )
					sign = "Libra";
				else
					sign = "Scorpio";
 				break;
			case 11:if( day &lt; 22 )
					sign = "Scorpio";
				else
					sign = "Sagittarius";
 				break;
			case 12:if( day &lt; 20 )
					sign = "Sagittarius";
				else
					sign = "Capricorn";
 				break;
		}
		System.out.println("The zodiac sign is: " + sign);
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program is just slightly more complex than the program for the
Chinese zodiac. You still need to jump to 12 different cases (numbered
1-12 instead of 0-11), but additional day information is needed to pin
down the sign.</simpara>
</example>
</section>
</section>
<section xml:id="_solution_monty_hall">
<title>Solution: Monty Hall</title>
<simpara>We now return to the Monty Hall simulation described at the beginning of
the chapter. Recall that the <literal>Random</literal> class allows us to generate all
kinds of random values. To implement this simulation successfully, our
program must make all the decisions needed to set up the game for the
user as well as respond to the userâs input. We begin with the <literal>import</literal>
statement that is necessary to use both the <literal>Scanner</literal> and <literal>Random</literal> class
and then define the <literal>MontyHall</literal> class.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class MontyHall {
	public static void main(String[] args) {
		Random random = new Random();
		int winner = random.nextInt(3);
		Scanner in = new Scanner( System.in );
		System.out.print("Choose a door (enter 0, 1, or 2): ");
		int choice = in.nextInt();
		int alternative;
		int open;</programlisting>
<simpara>In the <literal>main()</literal> method we first decide which of the three doors is the
winner. To do so, we instantiate a <literal>Random</literal> object and use it to
generate a random number that is either 0, 1, or 2 by calling the
<literal>nextInt()</literal> method with an argument of <literal>3</literal>. We could have added 1 to
this value to get a random choice of 1, 2, or 3, but many counting
systems in computer science start with 0 instead of 1. You might as well
get used to it. Next, we prompt the user to pick from the three doors
and read the choice. Finally, we declare two more <literal>int</literal> values to keep
track of which door to open and which door is the alternative that the
user can choose to change over to.</simpara>
<programlisting language="java" linenumbering="numbered">		if( choice == winner ) {
			int low;
			int high;
			if( choice ==  0 ) {
				low = 1;
				high = 2;
			}
			else if( choice == 1 ) {
				low = 0;
				high = 2;
			}
			else { //choice == 2
				low = 0;
				high = 1;
			}
			//randomly choose between other two doors
			double threshold = random.nextDouble();
			if( threshold &lt; 0.5 ) {
				alternative = low;
				open = high;
			}
			else {
				alternative = high;
				open = low;
			}
		}</programlisting>
<simpara>Now we have to navigate a complicated series of decisions. In this
segment of code, we are tackling the possibility that the user happened
to choose the winning door. To obey the rules of the game, we must
randomly pick which of the two other doors to open. First, we determine
which are the other two doors and save them in <literal>low</literal> and <literal>high</literal>,
respectively. Then, we generated a random number. If the random number
is less than 0.5, we keep the lower numbered door as an alternative
choice for the user and open the higher numbered door. If the random
number is greater than or equal to 0.5, we do the opposite.</simpara>
<programlisting language="java" linenumbering="numbered">		else {
			alternative = winner;
			if( choice == 0 ) {
				if( winner == 1 )
					open = 2;
				else
					open = 1;
			}
			else if( choice == 1 ) {
				if( winner == 0 )
					open = 2;
				else
					open = 0;
			}
			else { //choice == 2
				if( winner == 0 )
					open = 1;
				else
					open = 0;
			}
		}</programlisting>
<simpara>This <literal>else</literal> block covers the case that the player did not pick the
winning door the first time. Unlike the previous code segment, we no
longer have a choice of which door to open. This time, we must always
make the winner the alternative for the user to pick. Then, we simply
determine which door is leftover so that we can open it. Note that the
braces surrounding the blocks for each of the braces surrounding the
blocks for each of the three possible values of <literal>choice</literal> are not
necessary but are included for readability.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.println("We have opened Door " + open +
			", and there is junk behind it!");
		System.out.print("Do you want to change to Door " +
			alternative + " from Door " + choice +
			"? (Enter 'y' or 'n'): ");
		String change = in.next();
		if( change.equals("y") )
			choice = alternative;
		System.out.println("You chose Door " + choice);
		if( choice == winner )
			System.out.println("You win a pile of gold!");
		else
			System.out.println("You win a pile of junk.");
	}
}</programlisting>
<simpara>This final segment of code informs the user which door has been opened
and prompts the user to change his or her decision. Depending on the
final choice, the program says whether or not the user wins gold or
junk.</simpara>
</section>
<section xml:id="_concurrency_selection">
<title>Concurrency: Selection</title>
<simpara>The selection primitives (<literal>if</literal> and <literal>switch</literal> statements) seem to have
little to do with concurrency or parallelism. Selection allows you to
choose between alternatives while concurrency is about the interaction
between different threads of execution. As it turns out, there are two
reasons why selection and concurrency are deeply related to each other.</simpara>
<simpara>The first reason is that selection is one of the most basic tools in
Java. It is impossible to go more than a few lines of a code without
encountering a selection primitive, usually an <literal>if</literal> statement.
Concurrent programs are not exempt from this dependence on <literal>if</literal>
statements. Making decisions is at the heart of all programming
languages running on all computers.</simpara>
<simpara>The second reason is more troubling and is related to a problem with
some concurrent programs called a <emphasis>race condition</emphasis>, which is discussed
in great detail in Chapter <xref linkend="chapter:Synchronization"/>. Remember, one of
the biggest challenges of programming a computer is thinking in a
completely sequential and logical way. Each line of code is executed one
after the other. Adding in <literal>if</literal> statements means that some code is
executed only if a condition is true and skipped otherwise. Consider the
following fragment of code:</simpara>
<programlisting language="java" linenumbering="unnumbered">if( !matches.areLit() &amp;&amp; !flyingSparks ) {
    storageRoom.enter();
    dynamite.unpack();
}</programlisting>
<simpara>In this <literal>if</literal> statement, the imaginary agent only enters the storage room
and unpacks the dynamite if the matches are not lit and there are no
flying sparks. When execution reaches the first line inside the <literal>if</literal>
block, we are certain that <literal>matches.areLit()</literal> returned <literal>false</literal> and
<literal>flyingSparks</literal> is <literal>false</literal>. This is a one-time check. If the first thing
that happens inside the <literal>if</literal> block is code that lights the matches, Java
will <emphasis role="strong">not</emphasis> jump out of the <literal>if</literal> statement.</simpara>
<simpara>As always, the programmer is responsible for making an <literal>if</literal> statement
that makes sense. It is possible that entering the storage room or
unpacking the dynamite causes sparks to fly or matches to burst into
flames spontaneously, but it seems unlikely. If the <literal>storageRoom</literal> and
<literal>dynamite</literal> objects were written by other people, we would expect their
documentation to explain unusual side-effects of this kind. In a
sequential program, the programmer can be reasonably sure that it is
safe to unpack the dynamite.</simpara>
<simpara>Consider another fragment of code:</simpara>
<programlisting language="java" linenumbering="unnumbered">matches.light();
flyingSparks = sparklers.light( matches );</programlisting>
<simpara>This code appears to light the matches and uses the lit matches to set
some sparklers on fire. Presumably, if the process was successful,
<literal>flyingSparks</literal> will have the value <literal>true</literal>. This code is reasonable and
potentially helpful. If you were celebrating the 4<superscript>th</superscript> of July or needed
to signal a passing helicopter to rescue you from a desert island,
lighting sparklers could be a great idea. This sparkler-lighting code
could occur before the dynamite-unpacking code or after it, but the
protection of the <literal>if</literal> statement keeps our hero from being blown up if
he tries to unpack the dynamite with lit sparklers, in a sequential
program.</simpara>
<simpara>In a concurrent program, all bets are off. Another thread of execution
can be operating at the very same time. Itâs as if our hero is trying to
unpack the dynamite while the villain is lighting sparklers and tossing
them into the storage room. If the thread of execution gets to the <literal>if</literal>
statement and makes sure that the matches arenât lit and that there are
no flying sparks, it continues onward. If sparks start flying after that
check, it still continues onward, oblivious of the fact. Even though
this risk of explosion exists, it depends on the timing of the two (or
more) concurrent threads of execution. It might be possible to run a
program 1,000 times with no problem. But if the timing is wrong on the
1,001<superscript>st</superscript> time, <emphasis role="strong">BOOM!</emphasis></simpara>
<simpara>At this point, you do not need to worry about values inside your <literal>if</literal>
statements being changed by other segments of code, but that problem is
at the heart of why concurrent programming can be so difficult. Whether
or not you are programming concurrently, it is always important to keep
in mind the assumptions your code makes and the way different parts of
your program interact with each other.</simpara>
</section>
<section xml:id="_exercises_3">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Given that <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation> are
propositions in Boolean logic, make a truth table for the expression
<inlineequation><alt><![CDATA[(\lnot(x \land \lnot y)
\oplus \lnot z)]]></alt><mathphrase><![CDATA[(\lnot(x \land \lnot y)
\oplus \lnot z)]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>What is the value of the Boolean expression <inlineequation><alt><![CDATA[\lnot((T
\oplus F) \land \lnot(F \lor T))]]></alt><mathphrase><![CDATA[\lnot((T
\oplus F) \land \lnot(F \lor T))]]></mathphrase></inlineequation>?</simpara>
</listitem>
<listitem>
<simpara>The calculation to determine the leap year given in
ExampleÂ <xref linkend="example:Leap_year"/> uses three <literal>if</literal> statements and three
<literal>else</literal> statements. Write the leap year calculation using a single <literal>if</literal>
and a single <literal>else</literal>. Feel free to use <literal>boolean</literal> connectors such as <literal>||</literal>
and <literal>&amp;&amp;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The XOR operator (<literal>^</literal>) is useful for combining <literal>boolean</literal> values, but
it can be replaced with a more commonly used <emphasis role="strong">relational</emphasis> operator in
Java. Which one?</simpara>
</listitem>
<listitem>
<simpara>De Morganâs laws are the following, which show that the process of
negating a clause changes an AND to an OR and vice versa.</simpara>
<simpara><inlineequation><alt><![CDATA[\lnot(x \land y) = \lnot x \lor \lnot y]]></alt><mathphrase><![CDATA[\lnot(x \land y) = \lnot x \lor \lnot y]]></mathphrase></inlineequation>
<inlineequation><alt><![CDATA[\lnot(x \lor y) = \lnot x \land \lnot y]]></alt><mathphrase><![CDATA[\lnot(x \lor y) = \lnot x \land \lnot y]]></mathphrase></inlineequation></simpara>
<simpara>Create truth tables to verify both of these statements.</simpara>
</listitem>
<listitem>
<simpara>Use De Morganâs laws given above to rewrite the following statement
in Java to an equivalent statement that contains no negations.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean value = !((x != 4) &amp;&amp; (y &lt; 2));</programlisting>
</listitem>
<listitem>
<simpara>Consider the following fragment of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 5;
int y = 3;
if( y &gt; 10 &amp;&amp; (x = 10) &gt; 5 )
    y++;
System.out.println("x: " + x);
System.out.println("y: " + y);</programlisting>
<simpara>What is the output? Is the output changed if the condition of the <literal>if</literal>
statement is changed to<?asciidoc-br?>
<literal>y &gt; 10 &amp; (x = 10) &gt; 5</literal>? Why?</simpara>
</listitem>
<listitem>
<simpara>Consider the following fragment of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 7;
if( a++ == 7 )
    System.out.println("Seven");
else
    System.out.println("Not seven");</programlisting>
<simpara>What is the output? Is the output changed if the condition of the <literal>if</literal>
statement is changed to <literal>++a == 7</literal>? Why? Note: It is generally wise to
avoid increment, decrement, and assignment statements in the condition
of an <literal>if</literal> statement because of the confusion that can arise.</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>This problem has two parts.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Write a program that reads in two <literal>double</literal> values and prints the
larger of the two of them.</simpara>
</listitem>
<listitem>
<simpara>Expand the ideas from the previous program into a program that reads
in <emphasis role="strong">three</emphasis> <literal>double</literal> values and prints the largest of the three out.
Note: You should use nested <literal>if</literal> statements.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:coins"/> Write programs that:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Read an <literal>int</literal> value from the user specifying a certain number of
cents. Use <literal>if</literal> statements to print out the name of the corresponding
coin in U.S. currency according to the table below. If the value doesnât
match any coin, print <literal>no coin</literal>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Cents</entry>
<entry align="center" valign="top">Coin</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>penny</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"><simpara>nickel</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>dime</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>25</simpara></entry>
<entry align="center" valign="top"><simpara>quarter</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>50</simpara></entry>
<entry align="center" valign="top"><simpara>half-dollar</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>100</simpara></entry>
<entry align="center" valign="top"><simpara>dollar</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Read a <literal>String</literal> value from the user that gives one of the 6 coin
names given in the table above. Use <literal>if</literal> statements to print out the
corresponding number of cents for the input. If the name doesnât many
any coin, print <literal>unknown coin</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Re-implement both parts from ExerciseÂ <xref linkend="exercise:coins"/> using
<literal>switch</literal> statements instead of <literal>if</literal> statements. Note: You cannot use
<literal>switch</literal> statements for (b) unless you are using Java 7 or later.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:ordinals"/> Expand the program given in
ExampleÂ <xref linkend="example:Ordinal_numbers"/> to give the correct suffixes (always
&#8220;th&#8221;) for numbers that end in 11, 12, and 13. Use the modulus operator
to find the last two digits of the number. Using either an <literal>if</literal>
statement, a <literal>switch</literal> statement, or a combination, check for those three
cases before going into the normal cases.</simpara>
</listitem>
<listitem>
<simpara>At the bottom of Section <xref linkend="subsection:switch_statements"/>, we use a
<literal>switch</literal> statement to determine the location of various area codes in
New York state. Write an equivalent fragment of code using <literal>if</literal>-<literal>else</literal>
statements instead.</simpara>
</listitem>
<listitem>
<simpara>Every member of your secret club has an ID number. These ID numbers
are between 1 and 1,000,000 and have two special characteristics: They
are multiples of 7 and all end with a 3 in the oneâs place. For example,
63 is the smallest such value, and 999,943 is the largest such value.
Write a program that prompts the user for an <literal>int</literal> value, read it in,
and then say whether or not it could be used as an ID number. Note: You
need to use the <literal>\%</literal> operator in two different ways to test the value
correctly.</simpara>
</listitem>
<listitem>
<simpara>According to the North American Numbering Plan (NANP) used by the
United States, Canada, and a number of smaller countries, a legal
telephone number takes the form <literal>XYY-XYY-YYYY</literal>, where <literal>X</literal> is any digit
2-9 and <literal>Y</literal> is any digit 0-9. Write a program that reads in a <literal>String</literal>
from the user and verifies that it is a legal NANP phone number. The
length of the entire <literal>String</literal> must be 12. The fourth and eight
characters in the <literal>String</literal> (with indexes <literal>3</literal> and <literal>7</literal>) must be hyphens
(<literal>-</literal>), and all the remaining digits must be in the correct range. Use
the <literal>charAt()</literal> method of the <literal>String</literal> class to get the <literal>char</literal> value at
each index. Note: There are several ways to structure the <literal>if</literal>
statements you need to use, but the number of conditions may become
large. (23 or more!)</simpara>
</listitem>
<listitem>
<simpara>Re-implement the solution to the Monty Hall program given in
SectionÂ <xref linkend="solution:Monty_Hall"/> using <literal>JOptionPane</literal> to generate GUIs for
input and output.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Repetition">
<title>Repetition</title>
<blockquote>
<attribution>
A Tribe Called Quest
</attribution>
<simpara><emphasis role="strong">Q-Tip:</emphasis> You on point, Phife?<?asciidoc-br?>
<emphasis role="strong">Phife Dawg:</emphasis> All the time, Tip.<?asciidoc-br?>
<emphasis role="strong">Q-Tip:</emphasis> You on point, Phife?<?asciidoc-br?>
<emphasis role="strong">Phife Dawg:</emphasis> All the time, Tip.<?asciidoc-br?>
<emphasis role="strong">Q-Tip:</emphasis> You on point, Phife?<?asciidoc-br?>
<emphasis role="strong">Phife Dawg:</emphasis> All the time, Tip.<?asciidoc-br?>
<emphasis role="strong">Q-Tip:</emphasis> Well, then grab the microphone and let your words rip.</simpara>
</blockquote>
<section xml:id="_problem_dna_searching">
<title>Problem: DNA searching</title>
<simpara>The world of bioinformatics is the intersection between biology and
computer science. Mapping the human genome would have been impossible
without computers. Sequencing genomes, determining the function of
specific genes, the analysis and prediction of protein structures, and
biomedical imaging are just a few of the areas under the umbrella of
bioinformatics. Much fascinating research is being done in this area as
biologists become better programmers and computer scientists learn more
about biology.</simpara>
<simpara>Because of its fundamental importance and the incredible amount of
information involved, with tens or hundreds of millions of base pairs of
DNA in each human chromosome, DNA is a central focus of bioinformatics.
As you may know, a DNA strand is made up of a sequence of four
nucleotide bases: adenine, cytosine, guanine, and thymine. These bases
are usually abbreviated as A, C, G, and T, respectively.</simpara>
<simpara>Searching for a specific DNA subsequence within a larger sequence is a
common task for biologists to perform. Your goal is to write a program
that will search for a subsequence and report how many times it was
found within the sequence. For example, if you are given the sequence
ATTAGACCATATA and asked to search for CAT, your program should output 1,
since there is exactly 1 occurrence of CAT within ATTAGACCATATA. One
feature of this problem that makes it more interesting is that
occurrences can overlap. For example, given the sequence TATTATTAGATTA
and asked to search for TATTA, the correct answer is 2. The sequence
begins with a TATTA, but the third T in the sequence is also the first T
in a second instance of TATTA.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Selection"/>, you learned tools that allow you to do
comparisons and make choices based on the results. These tools will
still be useful. For example, when you come across a <literal>char</literal> in the
sequence, you know how to compare it to a <literal>char</literal> in the subsequence you
are searching for. The tools you do not yet have are those that allow
repetition. Because this problem requires the program to process a DNA
sequence of arbitrary length, we will need some way to perform a
repetitive action.</simpara>
</section>
<section xml:id="_concepts_repetition">
<title>Concepts: Repetition</title>
<simpara>You now know how to write choices into a Java program, but, so far, each
choice can only be made once. So, if you want the computer to do a lot
of things, you have to type a lot of things. One of the big
disadvantages of computers is that they have no intelligence: They can
follow instructions blindly, but they cannot do anything else. One of
the big advantages of computers is that they are fast. Modern computers
can perform mathematical operations billions of times faster than human
beings. So, we need to give it some instructions that allow it to do
tasks over and over. Such an instruction must have two components to be
useful: It must have a way to change the task slightly each time so that
each task is useful. It must also have a way to decide when to stop,
otherwise it will continue forever.</simpara>
<simpara>The first component is the more subtle one. Crafting a set of
instructions so that each repetition of the task does the appropriate
thing will be different for every problem. The second component is
easier to describe: We are going to rely on Boolean logic, just as we
did for conditional statements. The main tool for repetition in Java and
many other languages is called a <emphasis>loop</emphasis>. The body of a loop contains the
task to be performed by the loop. The rest of the loop, at the very
least, contains a condition. Every time we finish the task given in the
body of the loop, we will check the condition. If the condition is true,
we will do the task again. If the condition is false, we are done with
the loop and can move on to the code that comes afterward.</simpara>
<simpara>One of the difficulties of programming a computer is that we must be
very explicit. Even the most obvious tasks must be spelled out
meticulously. Let&#8217;s consider a simple task, one that we perform every
day. If we are in a room and we want to leave, we simply walk out of the
nearest door. Assuming there is only one door in the room, how can we
describe this process by breaking it down into the steps we (literally)
take? Perhaps we could say the following.</simpara>
<informalexample>
<simpara><emphasis>Walk toward the door until you reach it.</emphasis></simpara>
</informalexample>
<simpara>This statement is a little more specific than <emphasis>Leave the room</emphasis>, but it
does not conform nicely to the paradigm of a loop, that is, a clearly
separated task and a condition. The following is better.</simpara>
<informalexample>
<simpara><emphasis>While you are not at the door,</emphasis></simpara>
<informalexample>
<simpara><emphasis>Take a step toward the door.</emphasis></simpara>
</informalexample>
</informalexample>
<simpara>Now we have good separation between the work done and the condition for
repeating. What is the task performed in the body of this loop and what
is the condition? The task is taking a step towards the door. The
condition is <emphasis role="strong">not</emphasis> being at the door. It seems a little awkward to
include that &#8220;not,&#8221; but, in our definition of loops, the body is
executed as long as the condition is true.</simpara>
<simpara>In a loop, we call each execution of the body of the loop an
<emphasis>iteration</emphasis>. When we say that a program <emphasis>iterates</emphasis> over the statements
in a loop, we are referring to a single pass through the body of a loop.
In this case, the loop will iterate however many times there are steps
to the door from the starting position. It is even possible that the
loop will iterate zero times: The person following this set of
instructions might already be at the door.</simpara>
<simpara>It&#8217;s hard to get away from numbers in a computer program, especially
since everything is fundamentally stored as numbers inside of a
computer. So, the most common kind of loop is one that iterates a fixed
number of times. For example, your morning exercise routine might
include jumping rope 100 times. We could formulate a loop to do that
like so.</simpara>
<informalexample>
<simpara><emphasis>Set your counter to 0.</emphasis><?asciidoc-br?>
<emphasis>While your counter is less than 100,</emphasis></simpara>
<informalexample>
<simpara><emphasis>Jump rope.</emphasis><?asciidoc-br?>
<emphasis>Increase your counter by 1.</emphasis></simpara>
</informalexample>
</informalexample>
<simpara>This loop required some set up to make sure that the counter value
started at the right place. Then, the work done by the loop is the
actual rope jumping and the counter increment. The condition is the
counter being less than 100. Note that this is strictly <emphasis role="strong">less</emphasis> than 100.
After the first jump, the counter will be incremented to 1. After the
100<superscript>th</superscript> jump, the counter will be incremented to 100. Since 100 is <emphasis role="strong">not</emphasis>
less than 100, the loop will exit. If the condition was the counter
being less than or equal to 100, the person following the instructions
would jump 101 times.</simpara>
<simpara>Input can also be a factor in loop repetitions. For example, you might
be a soldier training in the U.S. Marine Corps. Perhaps your drill
sergeant has commanded you to do push-ups until he says you can stop. We
might formulate a loop to do this as follows.<?asciidoc-br?></simpara>
<informalexample>
<simpara><emphasis>Do:</emphasis></simpara>
<informalexample>
<simpara><emphasis>Push-up.</emphasis><?asciidoc-br?>
<emphasis>Ask the drill sergeant if you can stop.</emphasis></simpara>
</informalexample>
<simpara><emphasis>While the answer is &#8220;no.&#8221;</emphasis></simpara>
</informalexample>
<simpara>As is the case with user input, you must often go into the loop at least
once to get the input. This loop requires the soldier to do at least one
push-up before asking to stop. Some systems might use input but have
other constraints. A more realistic version of this loop might be the
following.</simpara>
<informalexample>
<simpara><emphasis>Do:</emphasis></simpara>
<informalexample>
<simpara><emphasis>Push-up.</emphasis><?asciidoc-br?>
<emphasis>Ask the drill sergeant if you can stop.</emphasis></simpara>
</informalexample>
<simpara><emphasis>While the answer is &#8220;no&#8221; and you haven&#8217;t collapsed.</emphasis></simpara>
</informalexample>
<simpara>Remember, the condition for a loop should be a Boolean, and the loop
runs as long as the condition is true. However, there is no reason why
the Boolean cannot be a complicated expression using all the Boolean
logic we have come to know and love.</simpara>
<simpara>Of course it is possible to <emphasis>nest</emphasis> loops. Nesting loops means putting
one loop inside of another, similar to the way that conditional
statements could be nested inside of other conditional statements. Just
like any other statement, an inner loop will be run as many times as the
outer loop runs. Of course, the statements inside of the inner loop will
be run according to the conditions of that loop. So, if an outer loop
runs 10 times and an inner loop runs 50 times, a statement in the body
of an inner loop would run 500 times!</simpara>
<simpara>As an example, if you are working out, you might do several sets of
bench presses with a fixed number of reps in each set. If you did 3 sets
of 15 bench presses each, your workout program might look like this:<?asciidoc-br?></simpara>
<informalexample>
<simpara><emphasis>Set your set counter to 0.</emphasis><?asciidoc-br?>
<emphasis>While your set counter is less than 3,</emphasis><?asciidoc-br?></simpara>
<informalexample>
<simpara><emphasis>Set your rep counter to 0.</emphasis><?asciidoc-br?>
<emphasis>While your rep counter is less than 15,</emphasis></simpara>
<informalexample>
<simpara><emphasis>Do a bench press.</emphasis><?asciidoc-br?>
<emphasis>Increase your rep counter by 1.</emphasis></simpara>
</informalexample>
<simpara><emphasis>Rest for 2 minutes.</emphasis><?asciidoc-br?>
<emphasis>Increase your set counter.</emphasis></simpara>
</informalexample>
</informalexample>
<simpara>This way of describing the work out program seems tedious. Most of the
description is structural: conditions for the loops and increments for
the counters. The only &#8220;real&#8221; activities are the bench press and the
resting. As you can see, the bench press is inside the inner rep loop
and will be executed 15 times each time for each complete execution of
the inner rep loop. Since the inner rep loop sits inside the outer set
loop, it will be executed 3 times, giving a grand total of 45 bench
presses. Resting, however, is after the inner rep loop but still
contained in the outer set loop and will be executed 3 times, totaling 6
minutes of rest.</simpara>
<simpara>As with conditionals, writing out loops in English is tedious and
imprecise. In the next section, we will discuss the tools for writing
loops in Java. Because Java was designed with loops as a central tool,
we can write loops much more succinctly than in English, squeezing a lot
of information into a small space. Because we pack so much information
into them, loops can look daunting at first. Remember that the syntax we
will introduce is only the formal Java way of expressing a condition and
a list of instructions to execute repeatedly.</simpara>
</section>
<section xml:id="_syntax_loops_in_java">
<title>Syntax: Loops in Java</title>
<simpara>The Java programming language contains three differently named kinds of
loops: <literal>while</literal> loops, <literal>for</literal> loops, and <literal>do-while</literal> loops. All of them
allow you to write code that will be executed repeatedly. In fact, any
program that uses one style of loops to solve a problem could be
converted to use either of the other two kinds. The three kinds are
provided in Java partly so that it is easy to code certain typical kinds
of repetition and partly because the C language, an ancestor of Java,
contained these three. We will begin by describing <literal>while</literal> loops because
they have the simplest form and then move on to the other two kinds. We
will then explain the syntax for nesting together multiple loops and
finally discuss several of the common pitfalls encountered by
programmers who are coding loops.</simpara>
<section xml:id="_literal_while_literal_loops">
<title><literal>while</literal> loops</title>
<simpara>Superficially, the syntax of a <literal>while</literal> loop resembles an <literal>if</literal> statement.
It starts with the keyword <literal>while</literal> followed by a <literal>boolean</literal> condition in
parentheses with a block of code surrounded by braces (<literal>\{\}</literal>)
afterward. This similarity is not accidental. The only difference
between the two is that the body of the <literal>if</literal> statement will run a only
single time, while the body of the <literal>while</literal> loop will run as long as the
condition remains <literal>true</literal>. FigureÂ <xref linkend="figure:while"/> shows the pattern of
execution for <literal>while</literal> loops.</simpara>
<figure role="text-center">
<title>If the condition is <literal>true</literal>, all of the statements in the body of the loop are executed, and then the condition is checked again. When the check is <literal>false</literal>, execution skips past the body of the loop.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/05-repetition/images/while.svg" width="75%"/>
</imageobject>
<textobject><phrase>while</phrase></textobject>
</mediaobject>
</figure>
<simpara>If we assume that the <literal>boolean</literal> value <literal>atDoor</literal> says whether or not we
have reached the door and the method <literal>walkTowardsDoor()</literal> allows us to
take one step closer to the door, we could formulate our example from
the beginning of the previous section as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">while( !atDoor ) {
    atDoor = walkTowardsDoor();
}</programlisting>
<simpara>Here we assume that the <literal>walkTowardsDoor()</literal> method gives back a
<literal>boolean</literal> value that is <literal>true</literal> if we have reached the door and <literal>false</literal>
otherwise. Unless the <literal>walkTowardsDoor()</literal> method is able to change the
value of <literal>atDoor</literal>, the loop will repeat forever, a phenomenon known as
an <emphasis>infinite loop</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">while( true ) {
    System.out.println("Help me!");
}</programlisting>
<simpara>This loop is an example of an infinite loop. If you run this code inside
of a program, it will print out an endless succession of <literal>Help me!</literal>
messages. Be prepared to stop the program by typing <literal>Ctrl-C</literal> (hold down
the <literal>Control</literal> key and press <literal>C</literal>) because it will not end otherwise. Not
all infinite loops are this obvious. A programmer will not usually use
<literal>true</literal> as the condition of a loop, but doing so is not always wrong.
Some loops are expected to continue for quite some time with no definite
end. To leave a loop abruptly, you can use the <literal>break</literal> command.</simpara>
<programlisting language="java" linenumbering="unnumbered">while( true ) {
    System.out.println("Help me!");
    break;
}</programlisting>
<simpara>This loop will only print out a single <literal>Help me!</literal> before exiting. A
<literal>break</literal> command can be used with an <literal>if</literal> statement to make a loop that
repeats more than once.</simpara>
<programlisting language="java" linenumbering="unnumbered">int counter = 0;
while( true ) {
    System.out.print("the loop ");
    counter++;
    if( counter &gt;= 3 )
        break;
}
System.out.println("is on fire!");</programlisting>
<simpara>This loop will print out <literal>the loop the loop the loop is on fire!</literal> Of
course, the <literal>break</literal> statement unnecessarily complicates the code. We
could have written equivalent code as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">int counter = 0;
while( counter &lt; 3 ) {
    System.out.print("the loop ");
    counter++;
}
System.out.println("is on fire!");</programlisting>
<simpara>Now we move on to a more complicated example that can print out the
binary equivalent of a number.</simpara>
<example>
<title>Binary Conversion</title>
<simpara>As we discussed in ChapterÂ <xref linkend="chapter:Computer_Basics"/>, binary numbers
are the building blocks of every piece of data inside of a modern
computer&#8217;s memory. Integers are stored in binary. The representation of
floating point numbers is more complicated, but it also uses 1s and 0s.
Even the <literal>char</literal> data type and the <literal>String</literal> values built from them are
fundamentally stored as binary numbers. For this reason, computer
scientists tend to be familiar with the base 2 number system and how to
convert between it and base 10, our usual number system.</simpara>
<simpara>In base 10, the number 379 is equal to
<inlineequation><alt><![CDATA[3 \cdot 100 + 7 \cdot 10 + 9 \cdot 1 = 3 \cdot 10^2 + 7 \cdot 10^1 + 9 \cdot 10^0]]></alt><mathphrase><![CDATA[3 \cdot 100 + 7 \cdot 10 + 9 \cdot 1 = 3 \cdot 10^2 + 7 \cdot 10^1 + 9 \cdot 10^0]]></mathphrase></inlineequation>.
Moving from right to left, the value of each place increases by a factor
of 10. A binary number is the same, except that the increase is by a
factor of 2 and no single digit is greater than 1. Thus, the number
<inlineequation><alt><![CDATA[101011_2 = 1 \cdot 2^5 + 0 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2 + 1 \cdot 2^0 = 1 \cdot 32 + 0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 1 \cdot 0 = 43]]></alt><mathphrase><![CDATA[101011_2 = 1 \cdot 2^5 + 0 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2 + 1 \cdot 2^0 = 1 \cdot 32 + 0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 1 \cdot 0 = 43]]></mathphrase></inlineequation>.
In binary, the number <inlineequation><alt><![CDATA[379 = 101111011_2]]></alt><mathphrase><![CDATA[379 = 101111011_2]]></mathphrase></inlineequation>.</simpara>
<simpara>To convert a number <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> to binary, we first find the largest
power of 2 that is not larger than <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. Then, we begin a
repetitive process that stops when the power of 2 under consideration is
0. If 2 raised to the current power is bigger than <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, we
print out a 0 because that power is too big for <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>.
Otherwise, we print out a 1, subtract 2 raised to that power from
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, and move on to the next smaller power of 2. This
process will print a 0 for every power of 2 that is not in
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> and a 1 for every one that is, giving exactly the
definition of a number written in base 2.</simpara>
<formalpara xml:id="program:DecimalToBinary" xreflabel="DecimalToBinary">
<title>This program outputs a binary representation of a decimal number.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class DecimalToBinary {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a base 10 number: ");
		int number = in.nextInt();
		int power = 1;
		while( power &lt;= number/2 )
			power *= 2;
		while( power &gt; 0 ) {
			if( power &gt; number )
				System.out.print(0);
			else {
				System.out.print(1);
				number -= power;
			}
			power /= 2;
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>The first <literal>while</literal> loop in this program doubles the value of <literal>power</literal>
until doubling it again would make it larger than <literal>number</literal>. We go up to
and including <literal>number/2</literal>, otherwise we would stop when <literal>power</literal> was
larger than <literal>number</literal>. After that loop, we begin repeatedly checking to
see if a given power of 2 is bigger than the value left in <literal>number</literal>. If
it is, we know that we do not use that power. If it is not, we do and
must remove that power from the value of <literal>number</literal>.</simpara>
<simpara>You may have been tempted to solve this problem by determining if a
given number is even or odd. If it is even, then you record a 0, and if
it is odd, then you record a 1. You could then divide the number by two
and repeat the process of determining whether it is even or odd. You
could continue this process until the number became 0. This procedure
requires only a single <literal>while</literal> loop and would give the digits of the
number in base 2. Unfortunately, you would get the digits in reverse
order. Because we write our numbers with the most significant digit on
the left, we had to use the code given above to first find the largest
value and work backwards, in order to determine the binary digits in the
correct sequence.</simpara>
</example>
</section>
<section xml:id="_literal_for_literal_loops">
<title><literal>for</literal> loops</title>
<simpara>Let&#8217;s return to our code that prints out
<literal>the loop the loop the loop is on fire!</literal></simpara>
<programlisting language="java" linenumbering="unnumbered">int counter = 0;
while( counter &lt; 3 ) {
    System.out.print("the loop ");
    counter++;
}
System.out.println("is on fire!");</programlisting>
<simpara>This code involves some initialization, a condition, and an update, as
many loops do. The initialization sets <literal>counter</literal> to <literal>0</literal>. The condition
checks to make sure that <literal>counter</literal> is less than <literal>3</literal>. The update
increments <literal>counter</literal> by 1 every iteration of the loop. These three
elements are so common that a special kind of loop called the <literal>for</literal> loop
was designed with them explicitly in mind. Most <literal>for</literal> loops are
dependent on a single counting variable. To make the loop easy to read,
the initialization, condition, and update, all of which relate to this
variable, are pulled into the header of the loop. We could code the
previous <literal>while</literal> loop example more cleanly, using a <literal>for</literal> loop, as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; 3; i++ ) {
    System.out.print("the loop ");
}
System.out.println("is on fire!");</programlisting>
<simpara>The header of a <literal>for</literal> loop consists of those three parts: the
initialization, the condition, and the update, all separated by
semicolons. FigureÂ <xref linkend="figure:for"/> shows the pattern of execution for
<literal>for</literal> loops.</simpara>
<figure role="text-center">
<title>The loop is initialized. If the condition is <literal>true</literal>, all of the statements in the body of the loop are executed, followed by the increment step. Then the condition is checked again. When the check is <literal>false</literal>, execution skips past the body of the loop.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/05-repetition/images/for.svg" width="75%"/>
</imageobject>
<textobject><phrase>for</phrase></textobject>
</mediaobject>
</figure>
<simpara>You may have noticed that we have changed the variable name used within
the loop from <literal>counter</literal> to <literal>i</literal>. Doing so does not change the function of
the code. We did so because using the variables <literal>i</literal>, <literal>j</literal>, and sometimes
<literal>k</literal> is a very common practice with <literal>for</literal> loops. By using variables named
like this, we are indicating that the variable is just a dummy counter
that we are using to make the loop work, not some variable with a
grander purpose. Also, with three uses of a single variable in the
header of a <literal>for</literal> loop, a long variable name will take up a lot of
space.</simpara>
<simpara><literal>for</literal> loops are used in Java programs more than the other two loops.
They work well when you know how many times you want to iterate through
the loop, which you often do. You can think of the first part of the
<literal>for</literal> loop header as the starting point, the second part as the ending
point, and the third part as how you get from the start to the end. Many
beginning programmers get stuck on the idea that every <literal>for</literal> loop starts
with <literal>int i = 0</literal> and ends with <literal>i++</literal>. While this pattern is often true,
there are many other ways to use a for loop. For example, we could print
the powers of 2 that are less than 1000.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 1; i &lt; 1000; i *= 2 ) {
    System.out.println(i);
}</programlisting>
<simpara>This segment of code prints out <literal>1</literal>, <literal>2</literal>, <literal>4</literal>, <literal>8</literal>, <literal>16</literal>, <literal>32</literal>, <literal>64</literal>,
<literal>128</literal>, <literal>256</literal>, and <literal>512</literal> on separate lines, which are the powers of
<inlineequation><alt><![CDATA[2]]></alt><mathphrase><![CDATA[2]]></mathphrase></inlineequation> from <inlineequation><alt><![CDATA[2^0]]></alt><mathphrase><![CDATA[2^0]]></mathphrase></inlineequation> up to <inlineequation><alt><![CDATA[2^9]]></alt><mathphrase><![CDATA[2^9]]></mathphrase></inlineequation>. As you
know from discussion about binary numbers, powers of two have a special
interest to computer scientists. Both of the examples of <literal>for</literal> loops we
have given have only had a single executable line in the body of the
loop. Like <literal>if</literal> statements, loops only require braces if their bodies
have more than one executable line. Many of the <literal>while</literal> loops from the
previous subsection could have been written without braces.</simpara>
<simpara>Just because a <literal>for</literal> loop already has a counting mechanism doesn&#8217;t mean
that we will not need other variables to perform useful tasks. For
example, given a <literal>String</literal>, we could try to find the letter of the
alphabet in the <literal>String</literal> which is closest to the end of the alphabet.
For the <literal>String</literal> <literal>"Pluto is no longer a planet"</literal>, the latest letter in
the alphabet is <literal>'u'</literal>. To write code that will do this job, we must use
the counting variable from the <literal>for</literal> loop as an <emphasis>index</emphasis> into the
<literal>String</literal>. Then, we must also have a temporary variable where we keep the
latest letter found so far. To get the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript> <literal>char</literal> from a
<literal>String</literal>, we can use the <literal>charAt()</literal> method. The index of the first
<literal>char</literal> in a <literal>String</literal> is 0, and the index of the last <literal>char</literal> is one less
than the length of the <literal>String</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">String s = "The quick brown fox jumps over the lazy dog.";
String lower = s.toLowerCase();
char latest = ' ';
char c;
for( int i = 0; i &lt; lower.length(); i++ ) {
    c = lower.charAt(i);
    if( c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; c &gt; latest )
        latest = c;
}
System.out.println("The latest character in the alphabet " +
    "from your message is: '" + latest + "'.");</programlisting>
<simpara>The first thing we do in this example is convert <literal>s</literal> to lower case, so
that we are comparing all <literal>char</literal> values in the same case. Next, we run
through <literal>lower</literal>, starting at index 0 and going until we reach the end of
the <literal>String</literal>. For each <literal>char</literal>, we check to see if it is an alphabetic
character and then if it is later in the alphabet than our current
latest. If it is, we store it into <literal>latest</literal>. After the loop, we print
out the value in <literal>latest</literal>. We have chosen the <literal>char</literal> <literal>' '</literal> because it is
numerically earlier than all the letters in the alphabet. If the output
is a space, we would know that none of the characters in <literal>s</literal> were
alphabetic.</simpara>
<simpara>For the example given, the latest character in the alphabet is <literal>'z'</literal>
because of the word <literal>"lazy"</literal>. One weakness in this code is that it will
always search through the entire <literal>String</literal>, even if the letter <literal>'z'</literal> has
already been found. For the <literal>String</literal>
<literal>"The quick brown fox jumps over the lazy dog."</literal>, we are not wasting too
much time. However, if the <literal>String</literal> were <literal>"Zanzibar!"</literal> followed by the
full text of <emphasis>War and Peace</emphasis>, we would be wasting thousands and
thousands of operations reading characters when we knew that <literal>'z'</literal> was
going to be the latest letter, no matter what. So, we can rewrite our
<literal>for</literal> loop so that it quits early if it reaches a <literal>'z'</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; lower.length(); i++ ) {
    c = lower.charAt(i);
    if( c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; c &gt; latest )
        latest = c;
    if( latest == 'z' )
        break;
}</programlisting>
<simpara>This version of the <literal>for</literal> loop will break out immediately if the latest
is already a <literal>'z'</literal>. This code will work efficiently, but many
professional programmers discourage the use of <literal>break</literal> except when
absolutely necessary (like in a <literal>switch</literal> statement). If a <literal>break</literal> is
used to exit the loop, this logic can be encoded into the condition of
the loop. Thus, the same loop written with better style would be the
following.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; lower.length() &amp;&amp; latest != 'z'; i++ ) {
    c = lower.charAt(i);
    if( c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; c &gt; latest )
        latest = c;
}</programlisting>
<simpara>For this final version of the loop, we have made the conditional portion
of the header more complex. The comparison using <literal>&lt;</literal> gives a <literal>boolean</literal>
that we combine using <literal>\&amp;\&amp;</literal> with the <literal>boolean</literal> from the comparison
using <literal>!=</literal>. As always, remember that the loop will continue iterating as
long as the condition is <literal>true</literal>. Since we need both parts of the
condition to be <literal>true</literal> to continue executing, we use the <literal>\&amp;\&amp;</literal> operator
to connect them.</simpara>
<simpara>We apologize to international readers for focusing on the Latin alphabet
used by English and many other Western European languages. It should be
possible to make a localized version of this example with any alphabet
by checking the return value of <literal>Character.isLetter(c)</literal>, which is valid
for all single-character Unicode values, although the idea of
alphabetical order does not really apply to some character systems like
the hanzi and kanji of Chinese and Japanese. Regardless, using the
<literal>Character.isLetter()</literal> method is recommended for almost all
applications, since it is more general and more readable.</simpara>
<example>
<title>Primality testing</title>
<simpara>Prime numbers are numbers whose only factors are 1 and themselves. If
you have encountered prime numbers before, they probably seemed like a
mathematical curiosity and nothing more. In fact, prime numbers are the
basis of a very practical application of mathematics: cryptography. With
the use of some math and very large prime numbers, computer scientists
have devised techniques that make shopping online safer.</simpara>
<simpara>These techniques are beyond the scope of this book, but we can at least
write some code to determine if a number <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is prime. To do
so, we can simply divide <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> by all the numbers between 2
and <inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation>. If none of the numbers divide it evenly, it
must be prime. Here is this basic solution.</simpara>
<formalpara xml:id="program:PrimalityTester0" xreflabel="PrimalityTester0">
<title>This program gives a naive approach for testing if a number is prime.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class PrimalityTester0 {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a number: ");
		long number = in.nextLong();
		boolean prime = true;
		for( long i = 2; i &lt; number &amp;&amp; prime; i++ )
			if( number % i  ==  0 )
				prime = false;
		if( prime )
			System.out.println("" + number + " is prime.");
		else
			System.out.println("" + number + " is not prime.");
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program has a <literal>for</literal> loop that runs from <literal>2</literal> up to <literal>number - 1</literal>,
provided that we don&#8217;t find a number that evenly divides <literal>number</literal>. This
optimization means that the program will output the moment that it knows
that the number is not prime, but we will still have to wait for it to
check all the other possibilities before it is sure that the number is
prime.</simpara>
<simpara>One insight that we can use to make the program more efficient is that,
after checking 2, we don&#8217;t have to divide it by any even numbers. So, we
can do half the checking with a few simple modifications.</simpara>
<formalpara xml:id="program:PrimalityTester1" xreflabel="PrimalityTester1">
<title>This program gives a slightly cleverer approach for testing if a number is prime.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class PrimalityTester1 {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a number: ");
		long number = in.nextLong();
		boolean prime = (number % 2 != 0);
		for( long i = 3; i &lt; number &amp;&amp; prime; i += 2  )
			if( number % i  ==  0 )
				prime = false;
		if( prime )
			System.out.println("" + number + " is prime.");
		else
			System.out.println("" + number + " is not prime.");
	}
}</programlisting>
</para>
</formalpara>
<simpara>This version of the program sets the <literal>boolean</literal> variable <literal>prime</literal> to
<literal>false</literal> if <literal>number</literal> is divisible by 2 and <literal>true</literal> otherwise. Then, it
starts the search at 3 and continues in jumps of 2. Although we are
saving half the time, we can still do better. Note that if a number
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is divisible by 2, then it is also divisible by
<inlineequation><alt><![CDATA[\frac{n}{2}]]></alt><mathphrase><![CDATA[\frac{n}{2}]]></mathphrase></inlineequation>. So, if a number is <emphasis role="strong">not</emphasis> divisible by 2, it
is not divisible by any number larger than <inlineequation><alt><![CDATA[\frac{n}{2}]]></alt><mathphrase><![CDATA[\frac{n}{2}]]></mathphrase></inlineequation>. If
it is not divisible by 2 or 3, then it is not divisible by any number
larger than <inlineequation><alt><![CDATA[\frac{n}{3}]]></alt><mathphrase><![CDATA[\frac{n}{3}]]></mathphrase></inlineequation>. If it is not divisible by 2 or 3
or 4, it is not divisible by any number larger than
<inlineequation><alt><![CDATA[\frac{n}{4}]]></alt><mathphrase><![CDATA[\frac{n}{4}]]></mathphrase></inlineequation>, and so on. Thus, we do not have to check all
the way up to <inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation>. If we are checking to see if
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is divisible by <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and learning that
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is not divisible by anything larger than
<inlineequation><alt><![CDATA[\frac{n}{x}]]></alt><mathphrase><![CDATA[\frac{n}{x}]]></mathphrase></inlineequation>, the point where <inlineequation><alt><![CDATA[x = \frac{n}{x}]]></alt><mathphrase><![CDATA[x = \frac{n}{x}]]></mathphrase></inlineequation>
is when <inlineequation><alt><![CDATA[x = \sqrt{n}]]></alt><mathphrase><![CDATA[x = \sqrt{n}]]></mathphrase></inlineequation>. Thus, we only need to search up to
<inlineequation><alt><![CDATA[\sqrt{n}]]></alt><mathphrase><![CDATA[\sqrt{n}]]></mathphrase></inlineequation>, which will save even more time.</simpara>
<formalpara xml:id="program:PrimalityTester2" xreflabel="PrimalityTester2">
<title>This program gives a much faster approach for testing if a number is prime.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class PrimalityTester2 {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a number: ");
		long number = in.nextLong();
		boolean prime = (number % 2 != 0);
		long root = (long)Math.sqrt(number);
		for( long i = 3; i &lt;= root &amp;&amp; prime; i += 2  )
			if( number % i  ==  0 )
				prime = false;
		if( prime )
			System.out.println("" + number + " is prime.");
		else
			System.out.println("" + number + " is not prime.");
	}
}</programlisting>
</para>
</formalpara>
<simpara>Note in this version of the program we do go up to and including <literal>root</literal>,
because there is the possibility that <literal>number</literal> is a perfect square.</simpara>
</example>
<example>
<title>DNA reverse complement</title>
<simpara>DNA is usually double stranded, with each base paired to another
specific base, called its complementary base. The following table shows
the association between each base and its complementary base.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="center" valign="top">Base</entry>
<entry align="center" valign="top">Abbreviation</entry>
<entry align="center" valign="top">Complementary Base</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>Adenine</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Cytosine</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
<entry align="center" valign="top"><simpara>G</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Guanine</simpara></entry>
<entry align="center" valign="top"><simpara>G</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Thymine</simpara></entry>
<entry align="center" valign="top"><simpara>T</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>A simple but common task is finding the reverse complement of a DNA
sequence. The reverse complement of a DNA sequence is its sequence of
complementary bases given in reverse order. For example, the reverse
complement of ACATGAG is CTCATGT. This sequence is found by first
finding the complement of ACATGAG, which is TGTACTC, and then reversing
its order.</simpara>
<simpara>We will write a program that finds the reverse complement of a DNA
sequence entered by a user. This sequence will be entered as a sequence
of characters made up of the four abbreviations for the bases: A, C, G,
and T. We will store this sequence as a <literal>String</literal> and perform some
manipulations on it to get the reverse complement.</simpara>
<formalpara xml:id="program:ReverseComplement" xreflabel="ReverseComplement">
<title>This program finds the reverse complement of a DNA sequence.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class ReverseComplement {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a DNA sequence: ");
		String sequence = in.next().toUpperCase();
		String complement = "";
		for( int i = 0; i &lt; sequence.length(); i++ )
			switch( sequence.charAt(i) ) { //get complements
				case 'A': complement += "T"; break;
				case 'C': complement += "G"; break;
				case 'G': complement += "C"; break;
				case 'T': complement += "A"; break;
			}
		String reverseComplement = "";
		//reverse the complement
		for( int i = complement.length() - 1; i &gt;= 0; i-- )
			reverseComplement += complement.charAt(i);
		System.out.println("Reverse complement: " +
			reverseComplement);
	}
}</programlisting>
</para>
</formalpara>
<simpara>This example first creates a <literal>String</literal> filled with the complement of the
base pairs from the input <literal>String</literal>. Then, in a second step, it creates a
new <literal>String</literal> that is the reverse of the complement sequence. Note how
<literal>complement</literal> is created by appending the <literal>char</literal> corresponding to the
complementary base at the <emphasis role="strong">end</emphasis> of <literal>complement</literal>. If we inserted each
<literal>char</literal> at the beginning of <literal>complement</literal>, we would not need to reverse in
a separate step.</simpara>
<formalpara xml:id="program:CleverReverseComplement" xreflabel="CleverReverseComplement">
<title>This program more cleverly finds the reverse complement of a DNA sequence.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class CleverReverseComplement {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("Please enter a DNA sequence: ");
		String sequence = in.next().toUpperCase();
		String reverseComplement = "";
		for( int i = 0; i &lt; sequence.length(); i++ )
			switch( sequence.charAt(i) ) { //get complements
				case 'A': reverseComplement = "T" +
					reverseComplement; break;
				case 'C': reverseComplement = "G" +
					reverseComplement; break;
				case 'G': reverseComplement = "C" +
					reverseComplement; break;
				case 'T': reverseComplement = "A" +
					reverseComplement; break;
			}
		System.out.println("Reverse complement: " +
			reverseComplement);
	}
}</programlisting>
</para>
</formalpara>
</example>
</section>
<section xml:id="_literal_do_while_literal_loops">
<title><literal>do-while</literal> loops</title>
<simpara>Use this rule of thumb for deciding which kind of loop to use: If you
know how many times you want the loop to execute, use a <literal>for</literal> loop. If
you don&#8217;t know how many times you want it to execute, use a <literal>while</literal>
loop. Clearly, this rule is not iron-clad. In the previous example, we
used a <literal>for</literal> loop even though it would stop executing as soon as a <literal>'z'</literal>
was encountered. Nevertheless, it seems like we have covered all of the
possible situations with <literal>while</literal> and <literal>for</literal> loops. When should we use
<literal>do-while</literal> loops? The simple answer is: never.</simpara>
<simpara>You never <emphasis role="strong">have</emphasis> to use a <literal>do-while</literal> loop. With a little bit of effort,
you use a single kind of loop for every job. The key difference between
a <literal>do-while</literal> loop and a regular <literal>while</literal> loop is that a <literal>do-while</literal> loop
will always run at least once. Neither of the other two loops give you
that guarantee. The syntax for a <literal>do-while</literal> loop is a <literal>do</literal> at the top of
a loop body enclosed in braces, with a normal <literal>while</literal> header at the end,
including a condition in parentheses, followed by a semicolon.
FigureÂ <xref linkend="figure:do-while"/> shows the pattern of execution for <literal>do-while</literal>
loops.</simpara>
<figure role="text-center">
<title>The statements in the body of the loop are executed, and then the condition is checked. When the check is <literal>false</literal>, execution skips past the body of the loop. A <literal>do-while</literal> loop is guaranteed to run at least once.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/05-repetition/images/dowhile.svg" width="75%"/>
</imageobject>
<textobject><phrase>dowhile</phrase></textobject>
</mediaobject>
</figure>
<simpara>We can use a <literal>do-while</literal> loop to print out the first 10 perfect squares
as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 1;
do {
    System.out.println(x*x);
    x++;
} while( x &lt;= 10 );</programlisting>
<simpara>This loop behaves exactly the same as the following loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 1;
while( x &lt;= 10 ) {
    System.out.println(x*x);
    x++;
}</programlisting>
<simpara>The time when a <literal>do-while</literal> loop is really going to shine is when your
program will work incorrectly if the loop doesn&#8217;t run at least once.
This situation often occurs with input, when the loop must run at least
once before checking the condition. For example, imagine that you want
to write a program that picks a random number between 1 and 100 and lets
the user guess what it is until the user gets it right. You need a loop
because it is a repetitive activity, but you need to let the user guess
at least once so that you can check to see if he or she was right. The
following program fragment does exactly that.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner( System.in );
Random random = new Random();
int guess = 0;
int number = random.nextInt(100) + 1;
do {
    System.out.print("What is your guess? ");
    guess = in.nextInt();
} while( guess != number );
System.out.println("You got it! The number was " + number + ".");</programlisting>
<simpara>You could perform the same function with a <literal>while</literal> loop, but you will
need to get some input from the user before the loop starts. Using the
<literal>do-while</literal> loop is a little more elegant.</simpara>
</section>
<section xml:id="_nested_loops">
<title>Nested loops</title>
<simpara>As with <literal>if</literal> statements, it is possible to nest loops inside of other
loops. In the simplest case, you may have some repetitive activity that
itself needs to be performed several times. For example, when you were
younger, you probably had to learn your multiplication tables. For each
number, a multiplication table gave the value of the product of that
number by every integer between 1 and 12. We can write code to print out
out the multiplication table for every number from 1 to 10 by simply
repeating the process.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int number = 1; number &lt;= 10; number++ ) {
    for( int factor = 1; factor &lt;= 12; factor++ ) {
        System.out.println( number + " x " + factor +
            " = " + (number*factor));
    }
    System.out.println();
}</programlisting>
<simpara>The outer loop incrementing <literal>number</literal> will run 10 times. The inner loop
incrementing <literal>factor</literal> runs 12 times for each iteration of the outer
loop. So, the code in the inner loop will run a total of 120 times.
Every 12 iterations, the inner loop will stop, and an extra blank line
will be added by the <literal>System.out.println()</literal> method in the outer loop.</simpara>
<example>
<title>Triangular numbers</title>
<simpara>The sequence consisting of 1, 3, 6, 10, 15, and so on is known as the
triangular numbers. The <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript> triangular number is the sum
of the first <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation> integers. They are called triangular
numbers because they can be drawn as equilateral triangles in a very
natural way, if you use a number of dots equal to the number.</simpara>
<simpara>We can use nested loops to print out the first <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>
triangular numbers, where <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is specified by the user.</simpara>
<formalpara xml:id="program:TriangularNumbers" xreflabel="TriangularNumbers">
<title>This program prints out triangular numbers.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class TriangularNumbers {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("How many triangular numbers? ");
		int n = in.nextInt();
		int sum;
		for( int i = 1; i &lt;= n; i++ ) {
			sum = 0;
			for( int j = 1; j &lt;= i; j++ )
				sum += j;
			System.out.println(sum);
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>As you can see, the outer loop iterates through each of the <literal>n</literal>
different triangular numbers. Then, the inner loop does the summation
needed to compute the given triangular number. Producing a sequence of
triangular numbers this way is, unfortunately, not the most efficient
way to do it. Nested loops are an effective way to solve many problems,
particularly certain types of problems using arrays, but we can generate
triangular numbers using only a single <literal>for</literal> loop. The key insight is
that we can keep track of the previous triangular number and add
<inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation> to it, as <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation> increases.</simpara>
<formalpara xml:id="program:CleverTriangularNumbers" xreflabel="CleverTriangularNumbers">
<title>This program prints out triangular numbers more cleverly.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class CleverTriangularNumbers {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("How many triangular numbers? ");
		int n = in.nextInt();
		int triangular = 0;
		for( int i = 1; i &lt;= n; i++ ) {
			triangular += i;
			System.out.println(triangular);
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>By removing the inner <literal>for</literal> loop, the total amount of work needed is
greatly reduced.</simpara>
</example>
</section>
<section xml:id="subsection:common_pitfalls">
<title>Common pitfalls</title>
<simpara>With great power comes great responsibility. The power to repeat things
a large number of times means that we can also repeat our mistakes a
large number of times. Many classic bugs occur as a result of logical or
typographical errors in loops. Below we will list a few of the most
common.</simpara>
<warning>
<title>Pitfall: Infinite loops</title>
<simpara>It is possible to create a loop that never terminates. Your program may
be taking a long time to finish, but if it takes much longer than you
expect, an infinite loop might be the culprit. Infinite loops might
occur because you forgot to include an appropriate statement to advance
a counter.</simpara>
<programlisting language="java" linenumbering="unnumbered">int number = 1;
while( number &lt;= 100 )
    System.out.println(number);
}</programlisting>
<simpara>This code is presumably intended to print out the first 100 integers,
but there is no code that increases the value of <literal>number</literal>. As a
consequence, the number <literal>1</literal> will be printed out over and over until the
user stops the program from executing. Usually, the cause is more
subtle, as in the following code.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; 10; i += 0.5 )
    System.out.println("Half a step forward, half a step back...");</programlisting>
<simpara>One might expect this code to print out 20 lines of output. However,
remember that <literal>i</literal> is an <literal>int</literal>. Adding <literal>0.5</literal> to <literal>0</literal> and then casting it
to an <literal>int</literal> gives <literal>0</literal> again. What is particularly insidious about this
loop is that it compiles without even a warning in Java. Usually
conversion from a <literal>double</literal> to an <literal>int</literal> requires an explicit cast, but
the <literal>+=</literal> operator (and other similar operators) behave a little
differently for technical reasons.</simpara>
</warning>
<warning>
<title>Pitfall: Almost infinite loops</title>
<simpara>Many loops are truly infinite; others take a really long time. For
example, if you intended to run a loop down from 10 to 0, but increment
your counter instead of decrementing it, overflow means that you will
eventually get to a number less than 0, but it will take more than 2
billion increments instead of the expected 10 decrements.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 10; i &gt; 0; i++ )
    System.out.println(i);
System.out.println("Blast off!");</programlisting>
<simpara>This loop will significantly slow your code. Everyone will be so tired
of waiting that they might leave the space shuttle launch. Of course,
another problem with almost infinite loops is that you are dealing with
the wrong values. No one expects to hear the number <literal>2147483647</literal> in a
countdown.</simpara>
</warning>
<warning>
<title>Pitfall: Fencepost errors</title>
<simpara>Perhaps the most common loop errors are fencepost errors, often known as
off-by-one errors. The name &#8220;fencepost&#8221; comes from a related mistake
that someone might make when putting up a fence. Imagine that you want
to erect a 10 meter long chain link fence and you need to have a support
post every meter, how many posts do you need? In fact, we have not given
you enough information to answer the question correctly. If your fence
is built in a straight line, then you will need 11 posts so that you
have a post at each end. However, if your fence is a rectangular
enclosure, say 3 meters by 2 meters, you will only need 10 posts.</simpara>
<simpara>In loops, fencepost errors are often due to zero-based counting. A <literal>for</literal>
loop that iterates 10 times is below.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; 10; i++ )
    System.out.println(i);</programlisting>
<simpara>Of course, sometimes we need one-based counting instead. After being
used to zero-based counting, a programmer might make the following loop
that incorrectly iterates 9 times.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 1; i &lt; 10; i++ )
    System.out.println(i);</programlisting>
<simpara>The correct version that iterates 10 times is below.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 1; i &lt;= 10; i++ )
    System.out.println(i);</programlisting>
<simpara>If you want to iterate <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> times, start at 0 and go up to
but not including <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> or start at 1 and go up to and
including <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. To keep loop headers consistent, some
programmers always start at 0 and then adjust the values inside the
loop, printing out <literal>i + 1</literal> in this case.</simpara>
</warning>
<warning>
<title>Pitfall: Skipped loops</title>
<simpara>A loop runs as long as its condition is <literal>true</literal>. For <literal>for</literal> loops and
<literal>while</literal> loops, this could mean that the loop is never even entered.
Sometimes, that behavior is intended by the programmer. Sometimes, the
programmer made a mistake.</simpara>
<simpara>For example, we can write a program that will add any number of positive
values. When the user is finished using the adder, he or she enters a
negative number. This negative number, called a <emphasis>sentinel value</emphasis>, tells
the program to stop executing the loop. Below is an incorrect
implementation of such a program.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner( System.in );
int number = 0;
int sum = 0;
while( number &gt; 0 ) {
    sum += number;
    System.out.print("Enter the next number to add: ");
    number = in.nextInt();
}
System.out.println("The total sum is " + sum);</programlisting>
<simpara>This loop will never be executed because <literal>0</literal> is not greater than <literal>0</literal>.
The program could be changed by making the condition of the <literal>while</literal> loop
<literal>number &gt;= 0</literal>. Doing so will allow the user to enter <literal>0</literal> as input, which
is fine since it does not change the value of the <literal>sum</literal>. If you want to
force the user to enter only numbers greater than zero, you could change
the loop into a <literal>do-while</literal> loop.</simpara>
</warning>
<warning>
<title>Pitfall: Misplaced semicolons</title>
<simpara>The idea of a statement in Java is often amorphous in the minds of
beginning programmers. An entire loop (with any number of loops nested
inside of it) is just one statement. An executable statement ending with
a semicolon is one statement as well, even when that executable
statement is empty. Thus, the following is a legal (but infinite) loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 100;
while( i &gt; 0 ); {
    System.out.println(i);
    i--;
}
System.out.println("Ready or not, here I come!");</programlisting>
<simpara>This code was supposed to count down from 100, just like in the game of
Hide and Seek; however, there is a semicolon after the condition of the
<literal>while</literal> loop. This semicolon is treated like an executable statement
that does nothing. As a consequence, the <literal>while</literal> loop does the single
statement, checks if the condition is <literal>true</literal> (which it is), and
continues to do the empty statement and check the condition, forever.
The extra braces enclose two statements unnecessarily, but Java allows
extra braces, as long as they are evenly matched.</simpara>
<simpara>This error is common especially for those new to loops and conditional
statements and are in the habit of putting semicolons after everything.
A misplaced semicolon does not always result in an infinite loop. Here
is the <literal>for</literal> loop version of the same code, also with a semicolon
inserted after the loop header.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 100; i &gt; 0; i-- ); {
    System.out.println(i);
}
System.out.println("Ready or not, here I come!");</programlisting>
<simpara>This version of the code will execute similarly, except the decrement is
built into the header of the loop. So, the loop will execute the empty
statement, but it will also decrement <literal>i</literal>. This code will decrement <literal>i</literal>
100 times, then print out <literal>0</literal> exactly once, then print
<literal>Ready or not, here I come!</literal>.</simpara>
<simpara>There are some cases when an empty statement for a loop body is actually
useful, although it is never necessary. In future chapters, we will
point out situations in which you may wish to use an empty statement
this way.</simpara>
</warning>
</section>
</section>
<section xml:id="_solution_dna_searching">
<title>Solution: DNA searching</title>
<simpara>Below we give a solution to the DNA searching problem posed at the
beginning of the second half of this chapter. Our solution prints out
the index within the main <literal>String</literal> when it finds a match with the
pattern it is looking for. Afterwards, it prints out the total number of
matches. Our code also does error checking to make sure that the user
only enters valid DNA sequences containing the letters A, C, G, and T.
We begin our code with the standard <literal>import</literal> statement and class
definition.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class DNASearch {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		String sequence, subsequence;
		boolean valid;
		char c;</programlisting>
<simpara>The <literal>main()</literal> method instantiates a <literal>Scanner</literal> object and declares both of
the <literal>String</literal> variables we&#8217;ll need to store the DNA sequences. The method
also declares a <literal>boolean</literal> and a <literal>char</literal> we will use for input checking.</simpara>
<programlisting language="java" linenumbering="numbered">		do {
			System.out.print(
				"Enter the DNA sequence you wish to search in: ");
			sequence = in.next().toUpperCase();
			valid = true;
			for(int i = 0; i &lt; sequence.length() &amp;&amp; valid; i++) {
				c = sequence.charAt(i);
				if( c != 'A' &amp;&amp; c != 'C' &amp;&amp; c != 'G' &amp;&amp; c != 'T') {
					System.out.println("Invalid DNA sequence!");
					valid = false;
				}
			}
		} while( !valid );</programlisting>
<simpara>Next, the user is prompted for a DNA sequence to search in. This
<literal>String</literal> stored in <literal>sequence</literal> is converted to upper case just in case
the user is not being consistent. The inner <literal>for</literal> loop in this code is
checking each <literal>char</literal> inside of <literal>sequence</literal>. If any <literal>char</literal> is not an
<literal>'A'</literal>, <literal>'C'</literal>, <literal>'G'</literal>, or <literal>'T'</literal>, then <literal>valid</literal> is set to <literal>false</literal>. As a
result, the <literal>for</literal> loop terminates. Also, the <literal>do-while</literal> loop repeats the
prompt and gets a new <literal>String</literal> for <literal>sequence</literal> from the user. This outer
<literal>do-while</literal> loop continues as long as the user keeps entering invalid DNA
sequences.</simpara>
<programlisting language="java" linenumbering="numbered">		do {
			System.out.print(
				"Enter the subsequence you wish to search for: ");
			subsequence  = in.next().toUpperCase();
			valid = true;
			for(int i = 0; i &lt; subsequence.length() &amp;&amp; valid; i++) {
				c = subsequence.charAt(i);
				if( c != 'A' &amp;&amp; c != 'C' &amp;&amp; c != 'G' &amp;&amp; c != 'T') {
					System.out.println("Invalid DNA sequence!");
					valid = false;
				}
			}
		} while( !valid );</programlisting>
<simpara>The code used to input <literal>subsequence</literal> while doing error checking is
virtually identical to the code to input <literal>sequence</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		int found = 0;
		for( int i = 0; i &lt; sequence.length() -
			subsequence.length() + 1; i++ ) {
			for( int j = 0; j &lt; subsequence.length(); j++ ) {
				if(subsequence.charAt(j) != sequence.charAt(i + j))
					break;
				if( j == subsequence.length() - 1 ) { //matches
					System.out.println("Match found at index " + i);
					found++;
				}
			}
		}</programlisting>
<simpara>The actual workhorse of the search is found in these nested <literal>for</literal> loops.
The outer loop iterates through every index in <literal>sequence</literal>, until it
comes to an index that is too late to be the start of a new subsequence
(since the subsequence would be too long to fit anymore). This happens
to be when the value of <literal>i</literal> is greater than or equal to
<literal>sequence.length() - subsequence.length() + 1</literal>. It may take some thought
to verify that this condition is the correct one. One way to think about
this problem is by noting that, when <literal>sequence</literal> and <literal>subsequence</literal> have
the same length, you need to check starting at index <literal>0</literal> of <literal>sequence</literal>
but not any later indexes. Also, if <literal>subsequence</literal> is one <literal>char</literal> longer
than <literal>sequence</literal>, there can never be a match. In that case, the value of
<literal>sequence.length() - subsequence.length() + 1</literal> would be <literal>0</literal>. Since <literal>0</literal>
is not less than <literal>0</literal>, the outer <literal>for</literal> loop would never execute.</simpara>
<simpara>The inner <literal>for</literal> loop iterates through the length of <literal>subsequence</literal>,
making sure that every <literal>char</literal> in <literal>sequence</literal>, starting at the appropriate
offset, exactly matches a <literal>char</literal> in <literal>subsequence</literal>. If, at any point, the
two <literal>char</literal> values do not match, the inner <literal>for</literal> loop will immediately
exit, using the <literal>break</literal> command. However, on the last iteration of the
inner <literal>for</literal> loop, when <literal>j</literal> is one less than the length of <literal>subsequence</literal>,
we know that all of <literal>subsequence</literal> matched a part of <literal>sequence</literal>. As a
result, we print out the index of <literal>sequence</literal> where <literal>subsequence</literal> started
and increment the <literal>found</literal> counter.</simpara>
<simpara>If you know the <literal>String</literal> class well, you can use the <literal>indexOf()</literal> method
to replace the inner <literal>for</literal> loop. We leave that approach as an exercise.</simpara>
<programlisting language="java" linenumbering="numbered">		if( found == 1 )
			System.out.println("One match found.");
		else
			System.out.println(found + " matches found.");
	}
}</programlisting>
<simpara>Finally, we print out the total number of matches found. In order to
avoid awkward output like <literal>1 matches found.</literal>, we used an <literal>if</literal>-<literal>else</literal> to
customize the output based on the value of <literal>found</literal>.</simpara>
<simpara>The ideas needed to correctly implement the solution are not difficult,
but catching all the off-by-one errors and getting every detail right
takes care. There is also more than one way to code this solution. For
example, we could have written the nested loops that do the searching as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">int found = 0;
for( int i = 0; i &lt; sequence.length() -
    subsequence.length() + 1; i++ ) {
    for( int j = 0; j &lt; subsequence.length() &amp;&amp;
        subsequence.charAt(j) == sequence.charAt(i + j); j++ )
        if( j == subsequence.length() - 1 ) { //matches
            System.out.println("Match found at index " + i);
            found++;
        }
    }
}</programlisting>
<simpara>This design is preferred by many since it removes the <literal>break</literal>. By using
an empty statement, it is possible to move the check to see if the
matching process is done outside of the inner <literal>for</literal> loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int found = 0;
int j;
for( int i = 0; i &lt; sequence.length() -
    subsequence.length() + 1; i++ ) {
    for( j = 0; j &lt; subsequence.length() &amp;&amp;
        subsequence.charAt(j) == sequence.charAt(i + j); j++ );
    if( j == subsequence.length() ) { //matches
        System.out.println("Match found at index " + i);
        found++;
    }
}</programlisting>
<simpara>In this case, note that we must declare <literal>j</literal> outside of the inner <literal>for</literal>
loop, since it will be used outside. This approach is more efficient
because we only need to perform the check once. Notice also that the
condition of the <literal>if</literal> statement has changed. Now, we know that all of
<literal>subsequence</literal> matches because the loop ran to completion. If the loop
did not run to completion, then <literal>j</literal> would be smaller than
<literal>subsequence.length()</literal> and the loop must have terminated because the two
<literal>char</literal> values did not match. Although more efficient, some programmers
would avoid this approach because it uses the confusing syntax in which
the body of the <literal>for</literal> loop is a single empty statement followed by a
semicolon. Likewise, the logic about exiting the loop and the condition
of the <literal>if</literal> statement is murkier.</simpara>
</section>
<section xml:id="_concurrency_loops">
<title>Concurrency: Loops</title>
<simpara>Many programmers use concurrency for speedup. They want their programs
to run faster. Most programs that run for a long time use loops to do
repetitive tasks. If these loops are doing the same operation to many
different pieces of data, we may be able to speed up the process by
splitting up the data and letting different threads operate on their own
segment of the data. Splitting up data this way is called <emphasis>domain
decomposition</emphasis> which allows us to achieve <emphasis>data parallelism</emphasis>. These
topics are discussed further in SectionÂ <xref linkend="concepts:Splitting_up_work"/>.</simpara>
<simpara>Performing repetitive tasks is one of the great strengths of computers.
For most programs that run a long time, incredible amounts of
computation are being done inside of (usually nested) loops. Domain
decomposition will not work for all of these programs. Some cannot be
parallelized at all, but this book is about finding problems that can
have parallel and concurrent solutions.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>, we will introduce tools
for writing a concurrent program with different threads of execution
running at the exactly the same time and potentially interacting. Using
only the power of loops, you can see parallelism in action now.</simpara>
<example>
<title>Parallelism without threads</title>
<simpara>Consider the problem of computing the sum of the sines of a range of
integers. At its heart is a loop from the start of the range to the end.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = start; i &lt;= end; i++ )
    sum += Math.sin(start);</programlisting>
<simpara>If we want to allow the user to specify the start and the end and print
out the sum, we need to make a program with a little bit of input and
output around this loop.</simpara>
<formalpara xml:id="program:SumSines" xreflabel="SumSines">
<title>Program to add the sines of all integers in a range specified by the user.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Scanner;

public class SumSines {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		System.out.print("Enter starting value: ");
		int start = in.nextInt();
		System.out.print("Enter ending value: ");
		int end = in.nextInt();

		double sum = 0;
		for( int i = start; i &lt;= end; i++ )
			sum += Math.sin(start);

		System.out.println("Sum of sines: " + sum );
	}
}</programlisting>
</para>
</formalpara>
<simpara>If you compile and run this program with <literal>1</literal> as the start value and
<literal>100000000</literal> as the end, the answer should be <literal>1.7136493465700542</literal>. One
hundred million values is a lot to find the sine for. Depending on your
machine, this task should take between 10 seconds and over a minute. Try
to time how long this takes as accurately as possible.</simpara>
<simpara>Now, open a total of four console windows and navigate them all to the
directory with <literal>SumSines.class</literal> in it. Run <literal>SumSines</literal> in each one. For
the first console, enter <literal>1</literal> as the start and <literal>25000000</literal> as the end. For
the second, enter <literal>25000001</literal> and <literal>50000000</literal>. For the third, enter
<literal>50000001</literal> and <literal>75000000</literal>. For the last, enter <literal>75000000</literal> and
<literal>100000000</literal>. Once they have run, you should get, respectively,
<literal>1.4912473269134603</literal>, <literal>-0.6795491754132104</literal>, <literal>-0.2893142602684644</literal>, and
<literal>1.1912654553381272</literal>. If you add these together using a calculator, you
should get <literal>1.7136493465699127</literal>, which is almost exactly the same answer
we got before. (Floating point rounding errors cause the slight
difference.)</simpara>
<simpara>If you try to start them computing at about the same time, you can try
to see how long it takes for all of them to complete. SDid it take less
time than before? If you have a single core processor, it might have
taken just as long or longer. If you have a dual-core processor, it
should have taken less time, and if you have a quad core processor, even
less. Since we are dividing the problem into four pieces, we will not
expect to see any improvement with more than four cores.</simpara>
<simpara>Most operating systems provide a graphical way of viewing the load on
each processor. If you examine your CPU usage while running those
programs, you should see it spike up when the programs start and then
come down when they finish. For multiple cores, how did we say which
core we wanted each program to run on? We didn&#8217;t. In general, it is
difficult to specify which core we want to run a program, process, or
thread on. The OS does the job of scheduling and picks a free processor
when it needs to run a program. It is even possible for programs and
threads to change from one core to another while running if the OS needs
to balance out the workload.</simpara>
<simpara>This sines example is similar to ExampleÂ <xref linkend="example:Array_summation"/>
which we will cover in in ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>. As
you may have noticed, running four programs is not convenient. You have
to open several windows, you have to type starting and ending points
very carefully, and you have to combine the answers at the end since
your programs cannot interact directly with each other. Features of Java
will make this job easier, allowing us to run more than one thread of
execution at a time without the need to run multiple programs by hand.</simpara>
</example>
</section>
<section xml:id="_exercises_4">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>If you have a <literal>String</literal> containing a long text and you want to count
the number of words in the text that begin with the letter <literal>'m'</literal>, which
of the three kinds of loops would you use, and why?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:primalityroot"/> In ExampleÂ <xref linkend="example:Primality_testing"/>,
our last version of the primality tester <literal>PrimalityTester2</literal> computes the
square root of the number being tested. Instead of computing this value
before the loop, how would performance be affected by changing the head
of the <literal>for</literal> loop to the following?</simpara>
<programlisting language="java" linenumbering="unnumbered">for(long i = 3; i &lt;= Math.sqrt(number) &amp;&amp; prime; i += 2)</programlisting>
</listitem>
<listitem>
<simpara>How many different DNA sequences of length <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> are
there?</simpara>
</listitem>
<listitem>
<simpara>There are three different errors in the following loop intended to
print out the numbers 1 through 10. What are they?</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 1; i &lt; 10; i-- );
{
    System.out.println(i);
}</programlisting>
</listitem>
<listitem>
<simpara>Consider the following code containing nested <literal>for</literal> loops.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner(System.in);
int n = in.nextInt();
int count = 0;
for( int i = 1; i &lt;= n; i++ )
    for( int j = 1; j &lt;= i; j++ )
        count++;</programlisting>
<simpara>In terms of the value of <literal>n</literal>, how many times is <literal>count</literal> incremented? If
it is not immediately obvious, trace through the execution of the
program by hand or run the code for several different values of <literal>n</literal> and
try to detect a pattern.</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Write a program that converts base 10 numbers into base 3 numbers.
If you find that task too easy, write a program that will convert base
10 numbers to any base in the range 2 to 16. Hint: Use letters A through
F, in order, to represent digits larger than 9.</simpara>
</listitem>
<listitem>
<simpara>The greatest common divisor (GCD) of two integers is the largest
integer that divides both of them evenly. The GCD for any two positive
integers is at least 1 and at most the smaller of the two numbers. Write
a program that prompts a user for two <literal>int</literal> values and finds their GCD.
Although there are more efficient methods, you can count down from
either number. If the counter ever divides <emphasis role="strong">both</emphasis> numbers evenly, it is
the GCD. The counter is guaranteed to divide them both if it reaches 1.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:String_indexOf"/> In the solution to the DNA searching
problem given in SectionÂ <xref linkend="solution:DNA_searching"/>, we used two <literal>for</literal>
loops to find occurrences of a DNA subsequence inside of a larger
sequence. Professional Java developers would have used a single <literal>for</literal>
loop and the <literal>indexOf()</literal> method in the <literal>String</literal> class. One version of
this method returns the index of a substring within a <literal>String</literal> object,
starting from a particular offset, as shown below.</simpara>
<programlisting language="java" linenumbering="unnumbered">String text = "fun dysfunction";
String search = "fun";
System.out.println("Location: " + text.indexOf(search, 4));</programlisting>
<simpara>This code will output <literal>Location: 7</literal> since the first occurrence of
<literal>"fun"</literal> from index <literal>4</literal> or later starts at index <literal>7</literal>. If there are no
more occurrences of the substring beyond the starting index, the method
will return <literal>-1</literal>. Rewrite the solution to the DNA searching problem,
replacing the inner searching <literal>for</literal> loop with the <literal>indexOf()</literal> method.</simpara>
</listitem>
<listitem>
<simpara>Write a program that reads a number <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> from a user and
then prints all possible DNA sequences of length <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. Be
careful not to supply too large of a value when you run this program.
Hint: Represent the sequence as a <literal>String</literal>. On each iteration, focus on
the last <literal>char</literal> in the <literal>String</literal>. If it is an <literal>'A'</literal>, change it to a
<literal>'C'</literal>. If it is a <literal>'C'</literal>, change it to a <literal>'G'</literal>. If it is a <literal>'G'</literal>, change
it to a <literal>'T'</literal>. If it is a <literal>'T'</literal>, change it back to an <literal>'A'</literal>, but
&#8220;carry&#8221; the increment over to the next <literal>char</literal>, like a rolling
odometer. You will have to design loops that can deal with carries that
cascade across multiple indexes.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the solution to the DNA searching program given in
SectionÂ <xref linkend="solution:DNA_searching"/> using <literal>JOptionPane</literal> to generate GUIs
for input and output.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Using a <literal>for</literal> loop, record the Monty Hall simulation so that you can
run it 100 times, always choosing to switch doors. Keep a record of how
many times you win. Change your code again to run the Monty Hall
simulation 100 more times, always choosing to keep your initial choice.
Again, keep a record of how many times you win. Compare the two records.
Choosing to switch should perform roughly twice as well as keeping the
first door. Increase the number of iterations to 1,000 and then 10,000
times. Does the performance of switching get closer to twice the
performance of not switching?</simpara>
</listitem>
<listitem>
<simpara>Write three nested <literal>for</literal> loops, each of which run 1,000 times.
Increment a counter in the innermost <literal>for</literal> loop. If that counter starts
at 0, its final value should be 1,000,000,000. Time how long your
program takes to run to completion using either a stopwatch or, if you
are on a Unix or Linux system, the <literal>time</literal> command. Feel free to increase
and decrease the amount that each loop runs to see the effect on the
time. However, if you increase the values of all three loops too much,
you may have to wait longer than you want.</simpara>
</listitem>
<listitem>
<simpara>In SectionÂ <xref linkend="subsection:common_pitfalls"/>, one of the common loop
mistakes we discuss is an almost infinite loop. Create your own almost
infinite loop that runs from <literal>10</literal> to <literal>0</literal>, incrementing instead of
decrementing. Time the execution of your program. Unlike our example, do
not use an output statement or your code will take too long to run. How
much longer would your code take to run if you used a <literal>long</literal> instead of
an <literal>int</literal>?</simpara>
</listitem>
<listitem>
<simpara>In ExampleÂ <xref linkend="example:Primality_testing"/>, we gave three programs to
test a number for primality. Run each of these prime testers on a large
prime such as 982,451,653 and time them. Is there a significant
difference in the running time of <literal>PrimalityTester0</literal> and
<literal>PrimalityTester1</literal>? What about <literal>PrimalityTester1</literal> and
<literal>PrimalityTester2</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:primes_less_than"/> In ExampleÂ <xref linkend="example:Parallelism
without threads"/>, we ran four programs at the same time to solve a
problem in parallel. Use the same framework (combined with your
knowledge of primes from ExampleÂ <xref linkend="example:Primality_testing"/>) to write
a program that can see how many prime numbers are in a user specified
range of integers. Then, use it to find the total number of primes
between 2 and 500,000,000. Now, run two copies of the program with one
starting at 2 and going up to 250,000,000 and the other starting at
250,000,001 and going up to 500,000,000. If you add the numbers
together, do you get the same answer? (If not, there is a bug in your
program.) Now, divide the work into four pieces. How much quicker, if at
all, is running all four programs instead of one? Does one of the four
pieces run significantly faster or slower than the others?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Arrays">
<title>Arrays</title>
<blockquote>
<attribution>
Mae West
</attribution>
<simpara>Too much of a good thing can be wonderful.</simpara>
</blockquote>
<section xml:id="_introduction">
<title>Introduction</title>
<simpara>With one exception, all of the types we have talked about in this book
have held a single value. For example, an <literal>int</literal> variable can only
contain a single <literal>int</literal> value. If you try to put a second <literal>int</literal> value
into a variable, it will overwrite the first.</simpara>
<simpara>The <literal>String</literal> type, of course, is the exception. <literal>String</literal> objects can
contain <literal>char</literal> sequences of any length from 0 up to a practically
limitless size (the theoretical maximum length of a Java <literal>String</literal> is
<literal>Integer.MAX_INT</literal>, more than 650 times the length of <emphasis>War and Peace</emphasis>).
As remarkable as <literal>String</literal> objects are, this chapter is about a more
general kind of list called an <emphasis>array</emphasis>. We can create arrays to hold a
list of any type of variable in Java.</simpara>
<simpara>The ability to work with lists expands the scope of problems that we can
solve. Beyond simple lists, we can use the same tools to create tables,
grids, and other structures to solve fascinating problems like the one
that comes next.</simpara>
</section>
<section xml:id="_problem_game_of_life">
<title>Problem: Game of Life</title>
<simpara>Some physicists insist that the rules governing the universe are
horribly complicated. Some insist that the fundamental laws are simple
and only their overall interaction is complex. With the power to do
simulations quickly, computer scientists have shown that some systems
can exhibit very complex interactions using simple rules. Perhaps the
best known examples of these systems are <emphasis>cellular automata</emphasis>, of which
Conway&#8217;s Game of Life is the most famous.</simpara>
<simpara>The framework for Conway&#8217;s Game of Life is an infinite grid made up of
squares called cells. Some cells in the grid are black (or alive, to
give it a biological flavor), and the rest are white (or dead). Any
given cell has 8 neighbors as shown in the figure below.</simpara>
<figure role="text-center">
<title>Cell (shown in gray) surrounded by 8 neighboring cells.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/cell.svg" width="25%"/>
</imageobject>
<textobject><phrase>cell</phrase></textobject>
</mediaobject>
</figure>
<simpara>The pattern of living and dead cells at any given time on the grid is
called a <emphasis>generation</emphasis>. To determine the next generation, we use the
following rules.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If a living cell has fewer than two living neighbors, it dies from
loneliness.</simpara>
</listitem>
<listitem>
<simpara>If a living cell has more than three neighbors, it dies because of
overcrowding.</simpara>
</listitem>
<listitem>
<simpara>If a living cell has exactly two or three living neighbors, it lives
to the next generation.</simpara>
</listitem>
<listitem>
<simpara>If a dead cell has exactly three live neighbors, it becomes a living
cell.</simpara>
</listitem>
</orderedlist>
<simpara>These four simple rules allow for surprisingly complex interactions. The
patterns that emerge from applying these rules to a starting
configuration of living and dead cells strike a balance between complete
chaos and rigid order. As the name of the game implies, the similarity
to biological patterns of development can be surprising.</simpara>
<simpara>Your problem is to create a Life simulator of size <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> x
<inlineequation><alt><![CDATA[m]]></alt><mathphrase><![CDATA[m]]></mathphrase></inlineequation>, specific values for which will be discussed below. The
program should simulate the process at a speed that is engaging to
watch, with a new generation every tenth of a second. The program should
begin by randomly making 10% of all the cells living and the rest dead.</simpara>
<section xml:id="_terminal_limitations">
<title>Terminal limitations</title>
<simpara>One problem you might be worrying about is how to display the
simulation. In ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/> you will learn how to make a graphical user interface (GUI)
that can display a grid of cells in black and white and much more
interesting things as well. For now, the main tool that we can use for
output is still the terminal. The output method we recommend is printing
an asterisk (<literal>'*'</literal>) for a living cell and a space (<literal>' '</literal>) for a dead
one. In this way you can easily see the patterns form on the screen and
change over time.</simpara>
<simpara>The classic terminal is not very big. For this reason, we suggest that
you set the height of your simulation to 24 rows and the width of your
simulation to 80 columns. These dimensions conform to the most ancient
terminal sizes. If your terminal screen is much larger, you can change
the width and height later to have a larger simulation. The ideal form
of the game is infinite, as well. Because our size is so limited, we
must deal with the problem of a cell on the boundary. Anything beyond
the boundaries should be counted as dead. Thus, a cell right on the edge
of the simulation grid can have a maximum of 5 neighbors. A cell in one
of the four corners can only have 3 neighbors.</simpara>
<simpara>In order to give the appearance of smooth transitions, you need to print
out each new generation of cells quickly, and in the same locations as
the previous generation. Simply printing one set after another will not
achieve this effect unless your terminal screen is exactly 24 rows tall.
So, you will need to clear the screen each time. In an effort to be
platform independent, Java does not provide an easy way to clear the
terminal screen. A quick and simple hack is to simply print out 100
blank lines before printing the next generation. This hack will work as
long as your terminal is not significantly more than 100 rows in height.
If it is, you will need to print a larger number of blank rows.</simpara>
<simpara>Finally, you need to wait a short period of time between generations so
that the user can see each configuration before it is cleared away and
replaced by the next one. The simplest way to do this is by having your
program go to sleep for a short period of time, a tenth of a second as
we suggested before. The code to make your program sleep for that amount
of time is:</simpara>
<programlisting language="java" linenumbering="unnumbered">try { Thread.sleep(100); }
catch( InterruptedException e ) {}</programlisting>
<simpara>We will explain this code in much greater detail in
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>. The key item of importance
is the number passed into the <literal>sleep()</literal> method. This value is the number
of milliseconds you want your program to sleep. 100 milliseconds is, of
course, one tenth of a second.</simpara>
<simpara>In order to simulate the Game of Life, we need to store information,
namely the liveness or deadness of cells, in a grid. First, we need to
discuss the simpler task of storing data in a list.</simpara>
</section>
</section>
<section xml:id="_concepts_lists_of_data">
<title>Concepts: Lists of data</title>
<simpara>Lists of data are of paramount importance in many different parts of
life: shopping lists, packing lists, lists of employees working at a
company, address books, top ten lists, and more. Lists are even more
important in programming. As you know, one of the great strengths of
computers is their speed. If we have a long list of data, we can use
that speed to perform some operation on all the data quickly. E-mail
contact lists, entries in a database, and cells in a spreadsheet are
just a few of the most obvious ways that lists come up in computer
applications.</simpara>
<simpara>Even in Java, there are many different ways to record a list of
information, but a list is only one form of <emphasis>data structure</emphasis>. As the
name implies, a data structure is a way to organize data, whether in a
list, in a tree, in sorted order, in some kind of hierarchy, or in any
other way that might be useful. We will only talk about the array data
structure in this chapter, but other data structures will be discussed
in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>. Below we give a short
explanation of some of the attributes any given data structure might
have.</simpara>
<section xml:id="_data_structure_attributes">
<title>Data structure attributes</title>
<variablelist>
<varlistentry>
<term>Contents</term>
<listitem>
<simpara>Keeping only a single value in a data structure defeats the purpose of
a data structure. But, if we can store more than a single value, must
all of those values come from the same type? If a data structure can
hold several different types of data, we call it <emphasis>heterogeneous</emphasis>, but
if it can only hold one type of data, we call it <emphasis>homogeneous</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Size</term>
<listitem>
<simpara>The size of a data structure may be something that is fixed when it is
created or it could change on the fly. If a data structure&#8217;s size or
length can change, we call it a <emphasis>dynamic</emphasis> data structure. If the data
structure has a size or length that can never change after it has been
created, we call it a <emphasis>static</emphasis> data structure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Element Access</term>
<listitem>
<simpara>One of the reasons that there are so many different data types is that
different ways of structuring data are better or worse for different
tasks. For example, if your task is to add a list of numbers, then you
are expecting to access every single element in the list. However, if
you are searching for a word in a dictionary, you do not want to check
every dictionary entry to find it.
+
Some data structures are optimized so that you can efficiently read,
insert, or delete only a single item, often the first (or last) item
in the data structure. Some data structures only allow you to move
through the structure sequentially, one item after another. Such a
data structure has what is called <emphasis>sequential access</emphasis>. Still others
allow you to jump randomly to any point you want inside the data
structure efficiently. These data structures have what is called
<emphasis>random access</emphasis>. Advanced programmers take into account many different
factors before deciding which data structure is best suited to their
problem.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_characteristics_of_an_array">
<title>Characteristics of an array</title>
<simpara>Now that we&#8217;ve defined these attributes, we can say that an array is a
homogeneous, static data structure with random access. An array is
homogeneous because it can only hold a list of a single type of data,
such as <literal>int</literal>, <literal>double</literal>, or <literal>String</literal>. An array is static because it has
a fixed length that is set only when the array is instantiated. An array
also has random access because jumping to any element in the array is
very fast and takes about the same amount of time as jumping to any
other.</simpara>
<simpara>An array is a list of a specific type of elements that has length
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, a length specified when the array is created. Each of
the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> elements is indexed using a number between 0 and
<inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation>. Once again, zero-based counting rears its ugly
head. Consider the following list of items:
<inlineequation><alt><![CDATA[\{9, 4, 2, 1, 6, 8, 3 \}]]></alt><mathphrase><![CDATA[\{9, 4, 2, 1, 6, 8, 3 \}]]></mathphrase></inlineequation></simpara>
<simpara>If this list is stored in an array, the first element, <inlineequation><alt><![CDATA[9]]></alt><mathphrase><![CDATA[9]]></mathphrase></inlineequation>,
would have index <inlineequation><alt><![CDATA[0]]></alt><mathphrase><![CDATA[0]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[4]]></alt><mathphrase><![CDATA[4]]></mathphrase></inlineequation> would have index
<inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation>, and so on, finishing at <inlineequation><alt><![CDATA[3]]></alt><mathphrase><![CDATA[3]]></mathphrase></inlineequation> with an index
of <inlineequation><alt><![CDATA[6]]></alt><mathphrase><![CDATA[6]]></mathphrase></inlineequation>, although the total number of items is
<inlineequation><alt><![CDATA[7]]></alt><mathphrase><![CDATA[7]]></mathphrase></inlineequation>. Not all languages use zero-based counting for array
indexes, but many do, including C, C++, and Java. The reason that
languages like C originally used zero-based counting for indexes is that
the variable corresponding to the array is an address inside the
computer&#8217;s memory giving the first element in the array. Thus, an index
of 0 is 0 times the size of an element added to the starting address,
and an index of 5 is 5 times the size of an element added to the
starting address. So, zero based indexes gave a quick way for the
program to compute where in memory a given element of an array is.</simpara>
</section>
</section>
<section xml:id="_syntax_arrays_in_java">
<title>Syntax: Arrays in Java</title>
<simpara>The idea of a list is not mysterious. Indexing each element of the list
using numbers is natural, even if the numbers start at 0 instead of 1.
Even so, arrays are the source of many errors that cause Java programs
to crash. Below we explain the basics of creating arrays, indexing into
arrays, and using arrays with loops. Then there is an extra subsection
explaining how to send data from a file to a program as if the file were
being typed in by a user. Using this technique can save you a lot of
time when you are experimenting with arrays.</simpara>
<section xml:id="_array_declaration_and_instantiation">
<title>Array declaration and instantiation</title>
<simpara>To create an array, you usually need to create an array variable first.
Remember that an array is a homogeneous data structure, meaning that it
can only store elements of a single type. When you create an array
variable, you have to specify what that type is. To declare an array
variable, you use the type it is going to hold, followed by square
brackets (<literal>[]</literal>), followed by the name of the variable. For example, if
you want to create an array called <literal>numbers</literal> that can hold integers, you
would type the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] numbers;</programlisting>
<simpara>If you have some C or C++ programming experience, you might be used to
the brackets being on the other side of the variable, like so.</simpara>
<programlisting language="java" linenumbering="unnumbered">int numbers[];</programlisting>
<simpara>In Java, both declarations are perfectly legal and equivalent. However,
the first declaration is preferred from a stylistic perspective. It
follows the pattern of using the type (an array of <literal>int</literal> values in this
case) followed by the variable name as the syntax for a declaration.</simpara>
<simpara>As we said, arrays are also static data structures, meaning that their
length is fixed at the time of their creation. Yet we did not specify a
length above. This declaration has not yet created an array, just a
variable that can point at an array. In the second half of this chapter,
we will further discuss this difference between the way an array is
created and the way an <literal>int</literal> or any other variable of primitive type is
created. To actually create the array, we need to use another step,
involving the keyword <literal>new</literal>. Here is how we instantiate an array of
<literal>int</literal> type with 10 elements.</simpara>
<programlisting language="java" linenumbering="unnumbered">numbers = new int[10];</programlisting>
<simpara>We use the keyword <literal>new</literal>, followed by the type of element, followed by
the number of elements the array can hold in square brackets. This new
array is stored into <literal>numbers</literal>. In other words, the variable <literal>numbers</literal>
is now a name for the array. Commonly, the two steps of declaring and
instantiating an array will be combined into one line of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] numbers = new int[10];</programlisting>
<simpara>It is always possible to separate the two steps. In some cases, a single
variable might be used to point at an array of one particular length,
then changed to point at an array of another length, and so on, as
below.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] numbers;
numbers = new int[10];
numbers = new int[100];
numbers = new int[1000];</programlisting>
<simpara>Here, the variable <literal>numbers</literal> starts off pointing at no array. Next, it
is made to point at a new array with 10 elements. Then, it is made to
point at a new array with 100 elements, ignoring the 10 element array.
Finally, it is made to point at an array with 1,000 elements, ignoring
the 100 element array. Remember, the arrays themselves are static; their
lengths cannot change. The array type variables, however, can point at
different arrays with different lengths, provided that they are still
the right type (in this case <literal>int</literal>).</simpara>
<simpara>What values are inside the array when it is first created? Let&#8217;s return
to the case where <literal>numbers</literal> points at a new array with 10 elements. Each
of those elements contains the <literal>int</literal> value <literal>0</literal>, as shown below.</simpara>
<figure>
<title>Array elements showing index values.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/array.svg" width="100%"/>
</imageobject>
<textobject><phrase>array</phrase></textobject>
</mediaobject>
</figure>
<simpara>Whenever an array is instantiated, each of its <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> elements
is set to some default value. For <literal>int</literal>, <literal>long</literal>, <literal>short</literal>, and <literal>byte</literal>
this value is <literal>0</literal>. For <literal>double</literal> and <literal>float</literal>, this value is <literal>0.0</literal>. For
<literal>char</literal>, this value is <literal>'\\0'</literal>, a special unprintable character. For
<literal>boolean</literal>, this value is <literal>false</literal>. For <literal>String</literal> or any other reference
type, this value is <literal>null</literal>, a special value that means there is no
object at that address.</simpara>
<simpara>It is also possible to use a list to initialize an array. For example,
we can create an array of type <literal>double</literal> that contains the values <literal>0.5</literal>,
<literal>1.0</literal>, <literal>1.5</literal>, <literal>2.0</literal>, and <literal>2.5</literal> using the following code.</simpara>
<programlisting language="java" linenumbering="unnumbered">double[] increments = {0.5, 1.0, 1.5, 2.0, 2.5};</programlisting>
<simpara>This line of code is equivalent to using the <literal>new</literal> keyword to create a
<literal>double</literal> array with 5 elements and then setting each to the values
shown.</simpara>
</section>
<section xml:id="_indexing_into_arrays">
<title>Indexing into arrays</title>
<simpara>To use a value in an array, you must <emphasis>index</emphasis> into the array, using the
square brackets once again. Returning to the example of the <literal>int</literal> array
<literal>numbers</literal> with length 10, we can read the value at index 4 from the
array and print it out.</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println( numbers[4] );</programlisting>
<simpara>Of course, the value of <literal>numbers[4]</literal> is <literal>0</literal> and so <literal>0</literal> is all that will
be printed out. We can set the value at <literal>numbers[4]</literal> to <literal>17</literal> as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">numbers[4] = 17;</programlisting>
<simpara>Then, if we try to print out <literal>numbers[4]</literal>, <literal>17</literal> will be printed. The
contents of the <literal>numbers</literal> array will look like this.</simpara>
<figure>
<title>Array showing contents of elements.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/array2.png"/>
</imageobject>
<textobject><phrase>array2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The key thing to understand about indexing into an array is that it
gives you an element of the specified type. In other words, <literal>numbers[4]</literal>
<emphasis role="strong">is</emphasis> an <literal>int</literal> variable in every possible sense. You can read its value.
You can change its value. You can pass it into a method. It can be used
anywhere a normal <literal>int</literal> can be used, as in the following example.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = numbers[4];
double y = Math.sqrt(numbers[2]) + numbers[4];
numbers[9] = (int)(y*x);</programlisting>
<simpara>Executing this code will store <literal>17</literal> into <literal>x</literal> and <literal>17.0</literal> into <literal>y</literal>. Then,
the product of those two, <literal>289</literal>, will be stored into <literal>numbers[9]</literal>.
Remember, in Java, the type on the left and the type on the right of the
assignment operator (<literal>=</literal>) must match, except in cases of automatic
casting, like storing an <literal>int</literal> value into a <literal>double</literal> variable. Since
they have the same type, it makes sense to store an element of an <literal>int</literal>
array like <literal>numbers[4]</literal> into an <literal>int</literal> variable like <literal>x</literal>. However, an
array of <literal>int</literal> values cannot be stored into an <literal>int</literal> type.</simpara>
<programlisting language="java" linenumbering="unnumbered">int z = numbers;</programlisting>
<simpara>This code will cause a compiler error. What would it mean? You can&#8217;t put
a list of variables into a single variable. And the converse is true as
well.</simpara>
<programlisting language="java" linenumbering="unnumbered">numbers = 31;</programlisting>
<simpara>This code will also cause a compiler error. A single value cannot be
stored into a whole list. You have to specify an index where it can be
stored. Furthermore, you must be careful to specify a legal index. No
negative index will ever be legal, and neither will an index greater
than or equal to the number of elements in the array.</simpara>
<programlisting language="java" linenumbering="unnumbered">numbers[10] = 99;</programlisting>
<simpara>This code will compile correctly. If you remember, we instantiated the
array that <literal>numbers</literal> points at to have 10 elements, numbered 0 through
9. Thus, we are trying to store <literal>99</literal> into the element that is one index
<emphasis role="strong">after</emphasis> the last legal element. As a result, Java will cause an error
called an <literal>ArrayIndexOutOfBoundsException</literal> to happen, which will crash
your program.</simpara>
</section>
<section xml:id="_using_loops_with_arrays">
<title>Using loops with arrays</title>
<simpara>One reason to use arrays is to avoid declaring 10 separate variables
just to have 10 <literal>int</literal> values to work with. But once you have the array,
you will often need an automated way to process it. Any of the three
kinds of loops provides a powerful tool for performing operations on any
array, but the <literal>for</literal> loop is an especially good match. Here is an
example of a <literal>for</literal> loop that sets the values in an array to their
indexes.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] values = new int[100];
for( int i = 0; i &lt; 100; i++ )
    values[i] = i;</programlisting>
<simpara>This sample of code shows how easy it is to iterate over every element
in an array with a <literal>for</literal> loop, but it has a flaw in its style. Note that
the number <literal>100</literal> is used twice: once in the instantiation of the array
and a second time in the termination condition of the <literal>for</literal> loop. This
fragment of code works fine, but if the programmer changes the length of
<literal>values</literal> to be <literal>50</literal> or <literal>500</literal>, the bounds of the <literal>for</literal> loop will also
need to change. Furthermore, the length of the array might be determined
by user input.</simpara>
<simpara>To make the code both more robust and readable, we can use the <literal>length</literal>
field of the <literal>values</literal> array for the bound of the <literal>for</literal> loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] values = new int[100];
for( int i = 0; i &lt; values.length; i++ )
    values[i] = i;</programlisting>
<simpara>The <literal>length</literal> field gives the length of the array that <literal>values</literal> points
to. If the programmer wants to instantiate the array with a different
length, that&#8217;s fine. The <literal>length</literal> field will always reflect the correct
value. Whenever possible, use the <literal>length</literal> field of arrays in your code.
Note that the <literal>length</literal> field is read-only. If you try to set
<literal>values.length</literal> to a specific value, your code will not compile.</simpara>
<simpara>Setting the values in an array is only one possible task you can perform
with a loop. Let&#8217;s assume that an array of type <literal>double</literal> named <literal>data</literal>
has been declared, instantiated, and filled with user input. We could
sum all its elements using the following code. A more elegant way to do
the same summation is discussed in SectionÂ <xref linkend="subsection:The_for-each_loop"/>.</simpara>
<programlisting language="java" linenumbering="unnumbered">double sum = 0.0;
for( int i = 0; i &lt; data.length; i++ )
    sum += data[i];
System.out.println("The sum of your data is: " + sum);</programlisting>
<simpara>So far, we have only discussed operations on the values in an array. It
is important to realize that the <emphasis role="strong">order</emphasis> of those values can be equally
important. We are going to create an array of <literal>char</literal> type named
<literal>letters</literal>, initialized with some values, and then reverse the order of
the array.</simpara>
<programlisting language="java" linenumbering="unnumbered">char[] letters = {'b', 'y', 'z', 'a', 'n', 't', 'i', 'n', 'e'};
int start = 0;
int end = letters.length - 1;
char temp;
while( start &lt; end ) {
    temp = letters[start];
    letters[start] = letters[end];
    letters[end] = temp;
    start++;
    end--;
}
for( int i = 0; i &lt; letters.length; i++ )
    System.out.print( letters[i] );</programlisting>
<simpara>This code will print out <literal>enitnazyb</literal>. After initializing the <literal>letters</literal>
array, we declare <literal>start</literal> and <literal>end</literal>, giving them the values <literal>0</literal>, the
first index of <literal>letters</literal>, and <literal>letters.length - 1</literal>, the last valid index
of <literal>letters</literal>, respectively. Then, the <literal>while</literal> loop continues as long as
the <literal>start</literal> is less than the <literal>end</literal>. The first three lines of each
iteration of the <literal>while</literal> loop will swap the <literal>char</literal> at index <literal>start</literal> with
the <literal>char</literal> at index <literal>end</literal>. The two lines after that will increment and
decrement <literal>start</literal> and <literal>end</literal>, respectively. When the two meet in the
middle, the entire array has been reversed. The simple <literal>for</literal> loop at the
end prints out each <literal>char</literal> in <literal>letters</literal>. Of course, we could have
printed out the array elements in reverse order without changing their
order, but we wanted to reverse them, perhaps because we will need them
reversed in the future.</simpara>
</section>
<section xml:id="_redirecting_input">
<title>Redirecting input</title>
<simpara>With arrays and loops, we can process a lot of data, but testing
programs that process a lot of data can be tedious. Instead of typing
data into the terminal, we can read data from a file. In Java, file I/O
is a messy process that involves several objects and method calls. We&#8217;re
going to talk about it in depth in ChapterÂ <xref linkend="chapter:File_I/O"/>, but for
now we can use a quick and easy workaround.</simpara>
<simpara>If you create a textÂ file using a simple text editor, you can <emphasis>redirect</emphasis>
the file as input to a program. Everything you have written in the text
file is treated as if it were being typed into the command line by a
person. To do so, you type the command using <literal>java</literal> to run your class
file normally, type the <literal>&lt;</literal> sign, and then type the name of the file you
want to use as input. For example, if you have a text file called
<literal>numbers.txt</literal> that you want to use as input to a program stored in
<literal>Summer.class</literal>, you could do so as follows.</simpara>
<simpara><literal>java Summer &lt; numbers.txt</literal></simpara>
<simpara>Redirecting input this way is not a part of Java. Instead, it is a
feature of the terminal running under your OS. Not all operating systems
support input redirection, but virtually every flavor of Linux and Unix
do, as well as the Windows command line and the Mac OS X terminal. We
could write the program mentioned above and give it the simple task of
summing all the numbers it gets as input.</simpara>
<formalpara xml:id="program:Summer" xreflabel="Summer">
<title>This program sums a list of numbers given as input.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Summer {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		System.out.print("How many numbers do you want to add? ");
		int n = in.nextInt();
		int sum = 0;
		for( int i = 0; i &lt; n; i++ ) {
			System.out.print("Enter next number: ");
			sum += in.nextInt();
		}
		System.out.println("The sum of the numbers is " + sum);
	}
}</programlisting>
</para>
</formalpara>
<simpara>Now, we can type out a file with a list of numbers in it and save it as
<literal>numbers.txt</literal>. To conform with the program we wrote, we should also put
the total count of numbers as the first value in the file. You can put
each number on a separate line or just leave a space between each one.
As long as they are separated by white space, the <literal>Scanner</literal> object will
take care of the rest. You will have to type the numbers into the file
once, but then you can test your program over and over with that file.</simpara>
<simpara>If you do run the program with the file you&#8217;ve created, you&#8217;ll notice
that the program still prompts you once for the total count of numbers
and then prompts you many times to enter the next number. With
redirected input, all that text runs together in a bizarre way. All the
input is coming from <literal>numbers.txt</literal>. If you expect a program to read
strictly from redirected input, you can design your code a little
differently. For one thing, you don&#8217;t need to have explicit prompts for
the user. For another, you can use a number of special methods from the
<literal>Scanner</literal> class. The <literal>Scanner</literal> class has a several methods like
<literal>hasNextInt()</literal> and <literal>hasNextDouble()</literal>. These methods will examine the
input and see if there is another legal <literal>int</literal> or <literal>double</literal> and return
<literal>true</literal> or <literal>false</literal> accordingly. If you expect a file to have only a long
sequence of <literal>int</literal> values, you can use <literal>hasNextInt()</literal> to determine if you
have reached the end of the file or not. Using <literal>hasNextInt()</literal>, we can
simplify the program and remove the expectation that the first number
gives the total count of numbers.</simpara>
<formalpara xml:id="program:QuietSummer" xreflabel="QuietSummer">
<title>This program sums a list of numbers given as input without prompting the user.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class QuietSummer {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		int sum = 0;
		while( in.hasNextInt() )
			sum += in.nextInt();
		System.out.println("The sum of the numbers is " + sum);
	}
}</programlisting>
</para>
</formalpara>
<simpara>On the other hand, you might be interested in the output of a program.
The output could be very long or it might take a lot of time to produce
or you might want to store it permanently. For these situations, it is
possible to <emphasis>redirect output</emphasis> as well. Instead of printing to the
screen, you can send the output to a file of your choosing. The syntax
for this operation is just like the syntax for input redirection except
that you use the <literal>&gt;</literal> sign instead of <literal>&lt;</literal>. To run <literal>QuietSummer</literal> with
input from <literal>numbers.txt</literal> and output to <literal>sum.txt</literal>, we could do the
following.</simpara>
<simpara><literal>java QuietSummer &lt; numbers.txt &gt; sum.txt</literal></simpara>
<simpara>You would be free to examine <literal>sum.txt</literal> at any time with your text editor
of choice. When using output redirection, it makes more sense run to
<literal>QuietSummer</literal> than <literal>Summer</literal>. If we had run <literal>Summer</literal>, all of that
unnecessary output prompting the user to enter numbers would be saved in
<literal>sum.txt</literal>.</simpara>
</section>
</section>
<section xml:id="_examples_array_usage">
<title>Examples: Array usage</title>
<simpara>Here are a few examples of practical array usage. We are going to
discuss some techniques useful mostly for searching and sorting.
Searching for values in a list seems mundane, but it is one of the most
practical tasks that a computer scientist routinely carries out. By
making a computer do the work, it saves human beings countless hours of
tedious searching and checking. Another important task is sorting.
Sorting a list can make future searches faster and is the simplest way
to find the median of a list of values. Sorting is a fundamental part of
countless real world problems.</simpara>
<simpara>In the examples below, we will first discuss finding the largest (or
smallest) value in a list, move on to sorting lists, and then talk about
a task that searches for words, like a dictionary look up.</simpara>
<example>
<title>King of the hill</title>
<simpara>Finding the largest value input by a user is not difficult. Applying
that knowledge to an array is pretty straightforward as well. This
simple task is also a building block of the sorting algorithm we will
discuss below. The key to finding the largest value in any list is to
keep a temporary variable that records the largest value found so far.
As we go along, we update the variable if we find a larger value. The
only trick is initializing the variable to some appropriate starting
value. We could initialize it to zero, but what if entire list of
numbers is negative? Then, our answer would be larger than any of the
numbers in the list. If our list of numbers is of type <literal>int</literal>, we could
initialize our variable to <literal>Integer.MIN_VALUE</literal>, the smallest possible
<literal>int</literal>. This approach works, but you have to remember the name of the
constant and it does not improve the readability of the code.</simpara>
<simpara>When working with an array, the best way to find the largest value in
the list is by setting your temporary variable to the first element
(index <literal>0</literal>) in the array. Below is a short snippet of code that finds
the largest value in an <literal>int</literal> array named <literal>values</literal> in exactly this way.</simpara>
<programlisting language="java" linenumbering="unnumbered">int largest = values[0];
for( int i = 1; i &lt; values.length; i++ )
    if( values[i] &gt; largest )
        largest = values[i];
System.out.println("The largest value is " + largest);</programlisting>
<simpara>Note that the <literal>for</literal> loop starts at <literal>1</literal> not <literal>0</literal>. Because <literal>largest</literal> is
initialized to be <literal>values[0]</literal>, there is no reason to repeat that value.
Doing so would still give the correct answer, but it wastes a tiny
amount of time.</simpara>
<simpara>What is the feature of this code that makes it find the largest value?
The key is the <literal>&gt;</literal> operator. With the change of a single character, we
could find the smallest value instead.</simpara>
<programlisting language="java" linenumbering="unnumbered">int smallest = values[0];
for( int i = 1; i &lt; values.length; i++ )
    if( values[i] &lt; smallest )
        smallest = values[i];
System.out.println("The smallest value is " + smallest);</programlisting>
<simpara>In addition to the necessary change from <literal>&gt;</literal> to <literal>&lt;</literal>, we also changed the
output and the name of the variable to avoid confusion. Now we will show
how repeatedly finding the smallest value in an array can be used to
sort it. The largest value could be used equally well, but we will use
the smallest.</simpara>
</example>
<example>
<title>Selection sort</title>
<simpara>Sorting is the bread and butter of computer scientists. Much research
has been devoted to finding the fastest ways to sort a list of data. The
rest of the world assumes that sorting a list of data is trivial because
computer scientists have done such a good job solving this problem. The
name of the sorting algorithm we are going to describe below is
<emphasis>selection sort</emphasis>. It is <emphasis role="strong">not</emphasis> one of the fastest ways to sort data, but
it is simple and easy to understand.</simpara>
<simpara>The idea behind selection sort is to find the smallest element in an
array and put it at index <literal>0</literal> of the array. Then, from the remaining
elements, find the smallest element and put it at index <literal>1</literal> of the
array. The process continues, filling the array up from the beginning
with the smallest values until the entire array is sorted. If the length
of the array is <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, we will need to look for the smallest
element in the array <inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation> times. By putting the code that
searches for the smallest value inside of an outer loop, we can write a
program that does selection sort of <literal>int</literal> values input by the user as
follows.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class SelectionSort {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		int n = in.nextInt();
		int[] values = new int[n];
		int smallest;
		int temp;
		for( int i = 0; i &lt; values.length; i++ )
			values[i] = in.nextInt();</programlisting>
<simpara>This program is not very long, but there&#8217;s a lot going on. After
instantiating a <literal>Scanner</literal>, we read in the total number of values the
list will hold. We cannot rely on the <literal>hasNextInt()</literal> method to tell us
when to stop reading values. We need to know up front how many values we
are going to store so that we can instantiate our array with the
appropriate length. Then, we read each value into the array using the
first <literal>for</literal> loop.</simpara>
<programlisting language="java" linenumbering="numbered">		for( int i = 0; i &lt; n - 1; i++ ) {
			smallest = i;
			for( int j = i + 1; j &lt; n; j++ )
				if( values[j] &lt; values[smallest] )
					smallest = j;
			temp = values[smallest];
			values[smallest] = values[i];
			values[i] = temp;
		}</programlisting>
<simpara>The next <literal>for</literal> loop is where the actual sort happens. We start at index
<literal>0</literal> and then try to find the smallest value to be put in that spot.
Then, we move on to index <literal>1</literal>, and so on, just as we described before.
Note that we only go up to <literal>n - 2</literal>. We don&#8217;t need to find the value to
put in index <literal>n - 1</literal>, because the rest of the list has the <literal>n - 1</literal>
smallest numbers in it and so the last number must already be the
largest. If you look carefully, you will notice that the inner <literal>for</literal>
loop has the same overall shape as the loop used to find the smallest
value in the previous example; however, there is one key difference.
Instead of storing the <emphasis role="strong">value</emphasis> of the smallest number in <literal>smallest</literal>, we
now store the <emphasis role="strong">index</emphasis> of the smallest number. We need to store the index
of the smallest number so that, in the next step, we can swap the
corresponding element with the element at <literal>i</literal>, the spot in the array we
are trying to fill. The three lines after the inner <literal>for</literal> loop are a
simple swap to do exactly that.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.print("The sorted list is: ");
		for( int i = 0; i &lt; values.length; i++ )
			System.out.print(values[i] + " ");
	}
}</programlisting>
<simpara>After all the sorting is done, the final <literal>for</literal> loop prints out the newly
sorted list. This program gives no prompts for user input, so it is well
designed for input redirection. If you are going to make a file
containing numbers you want to sort with this program, make sure that
the first number is the total count of numbers in the file.</simpara>
<simpara>Again, this program sorts the list in ascending order (from smallest to
largest). If you wanted to sort the list in descending order, you would
only need to change the <literal>&lt;</literal> to a <literal>&gt;</literal> in the comparison of the inner
<literal>for</literal> loop, although other changes are recommended for the sake of
readability.</simpara>
</example>
<example>
<title>Word search</title>
<simpara>In this example, we will read in a list of words and a long passage of
text and keep track of the number of times each word in the list occurs
in the passage. This kind of text searching has many applications.
Similar ideas are used in a spell checker that needs to look up words in
a dictionary. The incredibly valuable find and replace tools in modern
word processors use some of the same techniques.</simpara>
<simpara>To make this program work, however, we need to read in a (potentially
long) list of words and then a lot of text. We are forced to use input
redirection (or some other file input) because typing this text in
multiple times would be tedious. When we get to ChapterÂ <xref linkend="chapter:File
I/O"/>, we will talk about ways to read from multiple files at the same
time. Right now, we can only redirect input from a single file and so we
are forced to put the list of words at the top of the file, followed by
the text we want to search through.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class WordCount {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		int n = in.nextInt();
		String[] words = new String[n];
		int[] counts = new int[n];
		String temp;
		for( int i = 0; i &lt; words.length; i++ )
			words[i] = in.next().toLowerCase();</programlisting>
<simpara>As in the last example, this program begins by reading in the length of
the list of words. Then, it instantiates the <literal>String</literal> array <literal>words</literal> to
hold these words. It also instantiates an array <literal>counts</literal> of type <literal>int</literal>
to keep track of the number of times each word is found. By default,
each element in <literal>counts</literal> is initialized to <literal>0</literal>. The first <literal>for</literal> loop in
the program reads in each word and stores it into the array <literal>words</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		while( in.hasNext() ) {
			temp = in.next().toLowerCase();
			for( int i = 0; i &lt; n; i++ )
				if( temp.equals( words[i] )) {
					counts[i]++;
					break;
				}
		}
		System.out.println("The word counts are: ");</programlisting>
<simpara>The <literal>while</literal> loop reads in each word from the text following the list and
stores it in a variable called <literal>temp</literal>. Then, it loops through <literal>words</literal>
and tests to see if <literal>temp</literal> matches any of the elements in the list. If
it does, it increases the value of the element of <literal>counts</literal> that has the
same index and breaks out of the inner <literal>for</literal> loop.</simpara>
<programlisting language="java" linenumbering="numbered">		for( int i = 0; i &lt; words.length; i++ )
			System.out.println(words[i] + " " + counts[i]);
	}
}</programlisting>
<simpara>After all the words in the text have been processed, the final <literal>for</literal>
loop prints out each word from the list, along with its counts.</simpara>
<simpara>This program uses two different arrays for bookkeeping: <literal>words</literal> contains
the words we are searching for and <literal>counts</literal> contains the number of times
each word has been found. These two arrays are separate data structures.
The only link between them is the code we wrote to maintain the
correspondence between their elements.</simpara>
<simpara>To give a clear picture of how this program should behave, here is a
sample input file with two paragraphs from the beginning of <emphasis>The Counte
of Monte Cristo</emphasis> by Alexandre Dumas.</simpara>
<programlisting language="java" linenumbering="unnumbered">7
and
at
bridge
for
pilot
vessel
walnut
On the 24th of February, 1815, the look-out at Notre-Dame de la Garde
signalled the three-master, the Pharaon from Smyrna, Trieste, and
Naples.

As usual, a pilot put off immediately, and rounding the Chateau d'If,
got on board the vessel between Cape Morgion and Rion island.
Immediately, and according to custom, the ramparts of Fort Saint-Jean
were covered with spectators; it is always an event at Marseilles for a
ship to come into port, especially when this ship, like the Pharaon, has
been built, rigged, and laden at the old Phocee docks, and belongs to an
owner of the city.</programlisting>
<simpara>And here is the output one should get from running <literal>WordCount</literal> with
input redirected from the file given above.</simpara>
<programlisting language="java" linenumbering="unnumbered">The word counts are:
and 6
at 3
bridge 0
for 1
pilot 1
vessel 1
walnut 0</programlisting>
<simpara>For this example, the program works fine. However, our program would
have given incorrect output if <literal>ship</literal>, <literal>spectators</literal>, or several other
words in the text had been on the word list. You see, the <literal>next()</literal>
method in the <literal>Scanner</literal> class reads in <literal>String</literal> values separated by
white space. The word <literal>ship</literal> appears twice in the text, but the second
instance is followed by a comma. Since the words are separated by white
space only, the <literal>String</literal> <literal>"ship,"</literal> does not match the <literal>String</literal> <literal>"ship"</literal>.
Dealing with punctuation is not difficult, but it would increase the
length of the code, and we leave it as an exercise.</simpara>
</example>
<example>
<title>Statistics</title>
<simpara>Imagine that you are a teacher who has just given an exam. You want to
produce statistics for the class so that the students have some idea how
well they have done. You want to write a Java program to help you
produce the statistics, to save time now and in the future.</simpara>
<simpara>The statistics you want to collect are listed in the following table.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Statistic</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Maximum</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum score</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Minimum</simpara></entry>
<entry align="left" valign="top"><simpara>Minimum score</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mean</simpara></entry>
<entry align="left" valign="top"><simpara>Average of all the scores</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Standard Deviation</simpara></entry>
<entry align="left" valign="top"><simpara>Sample standard deviation of the scores</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Median</simpara></entry>
<entry align="left" valign="top"><simpara>Middle value of the scores when ordered</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Example <xref linkend="example:King_of_the_hill"/> covered how to find the maximum and
minimum scores in a list. The mean is simply the sum of all the scores
divided by the total number of scores. Standard deviation is a little
bit trickier. It gives a measurement of how spread out the data is. Let
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> be the number of data points, label each data point
<inlineequation><alt><![CDATA[x_i]]></alt><mathphrase><![CDATA[x_i]]></mathphrase></inlineequation>, where <inlineequation><alt><![CDATA[1 \leq i \leq n]]></alt><mathphrase><![CDATA[1 \leq i \leq n]]></mathphrase></inlineequation>, and let
<inlineequation><alt><![CDATA[\bar{x}]]></alt><mathphrase><![CDATA[\bar{x}]]></mathphrase></inlineequation> be the mean of all the data points. Then, the
formula for the sample standard deviation is as follows.</simpara>
<simpara><inlineequation><alt><![CDATA[\sigma = \sqrt{\frac{1}{n - 1}\sum_{i = 1}^n (x_i - \bar{x})^2}]]></alt><mathphrase><![CDATA[\sigma = \sqrt{\frac{1}{n - 1}\sum_{i = 1}^n (x_i - \bar{x})^2}]]></mathphrase></inlineequation></simpara>
<simpara>Finally, if you sort a list of numbers in order, the median is the
middle value in the list, or the average of the two middle values, if
the list has an even length.</simpara>
<simpara>These kinds of statistical operations are very useful and are packaged
into many important business applications such as Microsoft Excel. This
version will have a simple interface whose input comes from the command
line. First, the total number of scores will be entered. Then, each
score should be entered one by one. After all the data has been entered,
the program should compute and output the five values.</simpara>
<simpara>Below we give the solution to this statistics problem. Several different
tasks are combined here, but each of them should be reasonably easy to
solve after the previous examples.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Statistics {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		int n = in.nextInt();
		int[] scores = new int[n];
		for( int i = 0; i &lt; n; i++ )
			scores[i] = in.nextInt();</programlisting>
<simpara>In our solution, the <literal>main()</literal> method begins by reading in the total
number of scores and declaring an <literal>int</literal> array of that length named
<literal>scores</literal>. Then, we read in each of the scores and store them into
<literal>scores</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		int max = scores[0];
		int min = scores[0];
		int sum = scores[0];
		for( int i = 1; i &lt; n; i++ ) {
			if( scores[i] &gt; max )
				max = scores[i];
			if( scores[i] &lt; min )
				min = scores[i];
			sum += scores[i];
		}</programlisting>
<simpara>Here we declare variables <literal>max</literal>, <literal>min</literal>, and <literal>sum</literal> to hold, respectively,
the maximum, minimum, and sum of the elements in the array. Then, we set
all three variables to the value of the first element of the array.
These initializations make the following code work. In a single <literal>for</literal>
loop, we find the maximum, minimum, and sum of all the values in the
array. We could have done so with three separate loops, but this
approach is more efficient. Setting <literal>max</literal> and <literal>min</literal> to <literal>scores[0]</literal>
follows the pattern we have used before, but setting <literal>sum</literal> to the same
value is also necessary in this case. Because the loop iterates from <literal>1</literal>
up to <literal>scores.length - 1</literal>, we must include the value at index <literal>0</literal> in
<literal>sum</literal>. Alternatively, we could have set <literal>sum</literal> to <literal>0</literal> and started the
<literal>for</literal> loop at <literal>i = 0</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		double mean = ((double)sum)/n;
		System.out.println("Maximum:\t\t" + max);
		System.out.println("Minimum:\t\t" + min);
		System.out.println("Mean:\t\t\t" + mean);</programlisting>
<simpara>In this short snippet of code, we compute the mean, being careful to
store it into a variable of type <literal>double</literal>, and then print out the three
statistics we have already computed.</simpara>
<programlisting language="java" linenumbering="numbered">		double variance = 0;
		for( int i = 0; i &lt; n; i++ )
			variance += (scores[i] - mean)*(scores[i] - mean);
		variance /= (n - 1);
		System.out.println("Standard Deviation:\t" + Math.sqrt(variance));</programlisting>
<simpara>At this point, we use the mean we have already computed to find the
sample standard deviation. Following the formula for sample standard
deviation, we subtract the mean from each score, square the result, and
add it to a running total. Although the formula for sample standard
deviation uses the bounds <inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation> to <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, we
translate them to 0 to <literal>n - 1</literal> because of zero-based array numbering.
Dividing the total by <literal>n - 1</literal> gives the sample variance. Then, the
square root of the variance is the standard deviation.</simpara>
<programlisting language="java" linenumbering="numbered">		int temp;
		for( int i = 0; i &lt; n - 1; i++ ) {
			min = i;
			for( int j = i + 1; j &lt; n; j++ )
				if( scores[j] &lt; scores[min] )
					min = j;
			temp = scores[min];
			scores[min] = scores[i];
			scores[i] = temp;
		}
		double median;
		if( n % 2 == 0 )
			median = (scores[n/2] + scores[n/2 + 1])/2.0;
		else
			median = scores[n/2];
		System.out.println("Median:\t\t\t" + median);
	}
}</programlisting>
<simpara>To find the median, we use our selection sort code. Note that we have
reused the variable <literal>min</literal> to hold the smallest value found so far,
instead of declaring a new variable such as <literal>smallest</literal>. Some programmers
might object to doing so, since we run the risk of interpreting the
variable as the minimum value in the entire array, as it was before.
Either approach is fine. If you worry about confusing people reading
your code, add a comment.</simpara>
<simpara>After the array has been sorted, we need to do a quick check to see if
its length is odd or even. If its length is even, we need to find the
average of the two middle elements. If its length is odd, we can report
the value of the single middle element.</simpara>
<simpara>Note that some of the statistics we found, such as the maximum, minimum,
or mean, could be computed using loops without an array for storage.
However, the last two tasks need to store all of the values at once in
order to work. Finding the sample standard deviation of a list of values
requires its mean. At least two passes over the data are needed to
compute the sample standard deviation: one to find the mean and another
to apply the equation for sample standard deviation.</simpara>
</example>
</section>
<section xml:id="_concepts_multidimensional_lists">
<title>Concepts: Multidimensional lists</title>
<simpara>In the previous half of the chapter, we focused on lists of data and how
to store them in Java in arrays. The arrays we have discussed already
are <emphasis>one-dimensional</emphasis> arrays. That is, each element in the array has a
single index that refers to it. Given a specific index, an element will
have that index, come before it, or come after it. These kinds of arrays
can be used to solve a huge number of problems involving lists or
collections of data.</simpara>
<simpara>Sometimes, the data needs to be represented with more structure. One way
to provide this structure is with a <emphasis>two-dimensional</emphasis> array. You can
think of a two-dimensional array as a table of data. Instead of using a
single index, a two-dimensional array has two indexes. Usually, we think
about these dimensions as rows and columns. Below is a table of
information that gives the distances in miles between the five largest
cities in the United States.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6666*"/>
<colspec colname="col_6" colwidth="16.667*"/>
<thead>
<row>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle">New York</entry>
<entry align="center" valign="middle">Los Angeles</entry>
<entry align="center" valign="middle">Chicago</entry>
<entry align="center" valign="middle">Houston</entry>
<entry align="center" valign="middle">Phoenix</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">New York</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle"><simpara>2,791</simpara></entry>
<entry align="center" valign="middle"><simpara>791</simpara></entry>
<entry align="center" valign="middle"><simpara>1,632</simpara></entry>
<entry align="center" valign="middle"><simpara>2,457</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Los Angeles</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>2,791</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle"><simpara>2,015</simpara></entry>
<entry align="center" valign="middle"><simpara>1,546</simpara></entry>
<entry align="center" valign="middle"><simpara>373</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Chicago</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>791</simpara></entry>
<entry align="center" valign="middle"><simpara>2,015</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle"><simpara>1,801</simpara></entry>
<entry align="center" valign="middle"><simpara>1,181</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Houston</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>1,632</simpara></entry>
<entry align="center" valign="middle"><simpara>1,546</simpara></entry>
<entry align="center" valign="middle"><simpara>1,801</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle"><simpara>1,176</simpara></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Phoenix</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>2,457</simpara></entry>
<entry align="center" valign="middle"><simpara>373</simpara></entry>
<entry align="center" valign="middle"><simpara>1,181</simpara></entry>
<entry align="center" valign="middle"><simpara>1,176</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The position of each number in the table is a fundamental part of its
usefulness. We know that the distance from Chicago to Houston is 1,801
miles because that number is in the Chicago row and the Houston column.
A two-dimensional array shares almost all of its properties with a
one-dimensional array. It is still a homogeneous, static data structure
with random access. If the example above were made into a Java array,
the numbers themselves would be the elements of the array. The names of
the cities would need to be stored separately, perhaps in an array of
type <literal>String</literal>.</simpara>
<simpara>There is no reason to confine the idea of a two-dimensional list to a
table of values. Many games are played on a two-dimensional grid. One of
the most famous such games is chess. As with so many other things in
computer science, we must come up with an abstraction that mirrors
reality and allows us to store the information inside of a computer. For
chess, we will need an 8 Ã 8 two-dimensional array. We can represent
each piece in the board with a <literal>char</literal>, using the encoding given below.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Piece</entry>
<entry align="center" valign="top">Encoding</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>Pawn</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'P'</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Knight</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'N'</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Bishop</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'B'</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Rook</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'R'</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Queen</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'Q'</literallayout></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>King</simpara></entry>
<entry align="center" valign="top"><literallayout class="monospaced">'K'</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Using upper case characters for black pieces and lower case characters
for white pieces, we could represent a game of chess after a classic
king&#8217;s pawn open by white as shown.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="9">
<colspec colname="col_1" colwidth="11.1111*"/>
<colspec colname="col_2" colwidth="11.1111*"/>
<colspec colname="col_3" colwidth="11.1111*"/>
<colspec colname="col_4" colwidth="11.1111*"/>
<colspec colname="col_5" colwidth="11.1111*"/>
<colspec colname="col_6" colwidth="11.1111*"/>
<colspec colname="col_7" colwidth="11.1111*"/>
<colspec colname="col_8" colwidth="11.1111*"/>
<colspec colname="col_9" colwidth="11.1112*"/>
<thead>
<row>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle">0</entry>
<entry align="center" valign="middle">1</entry>
<entry align="center" valign="middle">2</entry>
<entry align="center" valign="middle">3</entry>
<entry align="center" valign="middle">4</entry>
<entry align="center" valign="middle">5</entry>
<entry align="center" valign="middle">6</entry>
<entry align="center" valign="middle">7</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">0</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'R'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'N'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'B'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'Q'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'K'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'B'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'N'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'R'</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">1</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'P'</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">2</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">3</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">4</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">5</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">6</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced"></literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'p'</literallayout></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">7</emphasis></simpara></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'r'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'n'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'b'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'q'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'k'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'b'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'n'</literallayout></entry>
<entry align="center" valign="middle"><literallayout class="monospaced">'r'</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Observe that, just as with one-dimensional arrays, the indexes for rows
and columns in two-dimensional arrays also use zero-based counting.</simpara>
<simpara>After the step from one-dimensional arrays to two-dimensional arrays, it
is natural to wonder if there can be arrays of even higher dimension. We
can visualize a two-dimensional array as a table, but a
three-dimensional array is harder to visualize. Nevertheless, there are
uses for three-dimensional arrays.</simpara>
<simpara>Consider a professor who is taking a survey of students in her course.
She wants to know how many students there are in each of three
categories: gender, class level, and major. If she treats each of these
as a dimension and assigns an index to each possible value, she could
store the results in a three-dimensional array. For gender she could
pick male = 0 and female = 1. For class level she could pick freshman =
0, sophomore = 1, junior = 2, senior = 3, and other = 4. Assuming it is
a computer science class, for major she could pick computer science = 0,
math = 1, other science = 2, engineering = 3, humanities = 4. Using this
system she could compactly store the number of students in any
combination of categories she was interested in. For example, the total
number of female sophomore engineering students would be stored in the
cell with gender index 1, class level index 1, and major index 3.</simpara>
<simpara>Three dimensions is usually the practical limit when programming in
Java. If you find an especially good reason to use four or higher
dimensions, feel free to do so, but it should happen infrequently. The
Java language has no set limit on array dimensions, but most virtual
machines have the absurdly high limitation of 255 different dimensions.</simpara>
</section>
<section xml:id="_syntax_advanced_arrays_in_java">
<title>Syntax: Advanced arrays in Java</title>
<simpara>Now that we have discussed the value of storing data in multidimensional
lists, we will describe the Java language features that allow you to do
so. The changes needed to go from one-dimensional arrays to
two-dimensional and higher arrays are quite simple. First, we will
describe how to declare, instantiate, and index into two-dimensional
arrays. Then, we will discuss some of the ways in which arrays (both
one-dimensional and higher) are different from primitive data types.
Next, we will explain how it is possible make make two-dimensional
arrays in Java where the rows are not all the same length. Finally, we
will cover some of the most common mistakes programmers make with
arrays.</simpara>
<section xml:id="_multidimensional_arrays">
<title>Multidimensional arrays</title>
<simpara>When declaring a two-dimensional array, the main difference from a
one-dimensional array is an extra pair of brackets. If we wish to
declare a two-dimensional array of type <literal>int</literal> in which we could store
values like the table of distances above, we would do so as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] distances;</programlisting>
<simpara>As with one-dimensional arrays, it is legal to put the brackets on the
other side of the variable identifier or, even more bizarrely, have a
pair on each side.</simpara>
<simpara>Once the array is declared, it must still be instantiated using the
<literal>new</literal> keyword before it can be used. This time we will use two pairs of
brackets, with the number in the first pair specifying the number of
rows and the number in the second pair specifying the number of columns.</simpara>
<programlisting language="java" linenumbering="unnumbered">distances = new int[5][5];</programlisting>
<simpara>After the instantiation, we will have 5 rows and 5 columns, giving a
total of 25 locations where <literal>int</literal> values can be stored. Indexing these
locations is done by specifying row and column values in the brackets.
So, to fill up the table with the distances between cities given above
we can use the following tedious code.</simpara>
<programlisting language="java" linenumbering="unnumbered">//New York
distances[0][1] = 2791;
distances[0][2] = 791;
distances[0][3] = 1632;
distances[0][4] = 2457;
//Los Angeles
distances[1][0] = 2791;
distances[1][2] = 2015;
distances[1][3] = 1546;
distances[1][4] = 373;
//Chicago
distances[2][0] = 791;
distances[2][1] = 2015;
distances[2][3] = 1801;
distances[1][4] = 1181;
//Houston
distances[3][0] = 1632;
distances[3][1] = 1546;
distances[3][2] = 1801;
distances[3][4] = 1176;
//Phoenix
distances[4][0] = 2457;
distances[4][1] = 373;
distances[4][2] = 1181;
distances[4][3] = 1176;</programlisting>
<simpara>You will notice that we did not specify values for <literal>distances[0][0]</literal>,
<literal>distances[1][1]</literal>, <literal>distances[2][2]</literal>, <literal>distances[3][3]</literal>, or
<literal>distances[4][4]</literal>, since each of these already has the default value of
<literal>0</literal>.</simpara>
<simpara>Much more often, multidimensional array manipulation will use nested
<literal>for</literal> loops. For example, we could create an array with 3 rows and 4
columns, and then assign values to those locations such that they were
numbered increasing across each row.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] values = new int[3][4];
int number = 1;
for( int i = 0; i &lt; values.length; i++ )
    for( int j = 0; j &lt; values[0].length; j++ ) {
        values[i][j] = number;
        number++;
    }</programlisting>
<simpara>This code would result in an array filled up like the following table.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>9</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The bounds for the outer <literal>for</literal> loop in this example uses
<literal>values.length</literal>, giving the total number of rows. Then, the inner <literal>for</literal>
loops uses <literal>values[0].length</literal>, which is the length (number of columns)
of the first row. In this case, all the rows of the array have the same
number of columns, but this is not always true, as we will discuss
later.</simpara>
</section>
<section xml:id="_reference_types_2">
<title>Reference types</title>
<simpara>All array variables are <emphasis>reference</emphasis> type variables, not simple values
like most of the types we have discussed so far. A reference variable is
a name for an object. You might recall that we described the difference
between reference types and primitive types in
SectionÂ <xref linkend="concepts:Types"/>, but the only reference type we have
considered in detail is <literal>String</literal>.</simpara>
<simpara>More than one reference variable can point at the same object. When one
object has more than one name, this is called <emphasis>aliasing</emphasis>. The <literal>String</literal>
type is immutable, meaning that an object of type <literal>String</literal> cannot change
its contents. Arrays, however, are mutable, which means that aliasing
can cause unexpected results. Here is a simple example with
one-dimensional array aliasing.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] array1 = new int[10];
for( int i = 0; i &lt; array1.length; i++ )
    array1[i] = i;
int[] array2 = array1;
array2[3] = 17;
System.out.println(array1[3]);</programlisting>
<simpara>Surprisingly, the value printed out will be <literal>17</literal>. The variables <literal>array1</literal>
and <literal>array2</literal> are references to the same fundamental array. Unlike
primitive values, the complete contents of <literal>array1</literal> are not copied to
<literal>array2</literal>. Only one array exists because only one array has been created
by the <literal>new</literal> keyword. So, when index 3 of <literal>array2</literal> is updated, index 3
of <literal>array1</literal> changes as well, because the two variables are simply two
names for one array.</simpara>
<figure>
<title>Two array references pointing to a single array object.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/array3.png"/>
</imageobject>
<textobject><phrase>array3</phrase></textobject>
</mediaobject>
</figure>
<simpara>Sometimes this reference feature of Java allows us to write code that is
confusing or has unexpected consequences. However, the benefit is that
we can assign one array to another without incurring the expense of
copying the entire array. If you had created an array with 1,000,000
elements, copying that array several times could get very expensive in
terms of program running time.</simpara>
<simpara>The best rule of thumb for understanding reference types is that there
is only one actual object for every call to <literal>new</literal>. The primary exception
to this rule is that uses of <literal>new</literal> can be hidden from the user when they
are in method calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">String greeting = new String("Hello");
String pronoun = greeting.substring(0,2);</programlisting>
<simpara>At the end of this code, the reference <literal>pronoun</literal> will point to an object
containing the <literal>String "He"</literal>. The <literal>substring()</literal> method invokes <literal>new</literal>
internally, generating a new <literal>String</literal> object completely separate from
the <literal>String</literal> referenced by <literal>greeting</literal>. This code may look unusual
because we are explicitly using <literal>new</literal> to make a <literal>String</literal> object
containing <literal>"Hello"</literal>. The <literal>String</literal> class is different from every other
class because it can be instantiated without using the <literal>new</literal> keyword.
The line<?asciidoc-br?>
<literal>String greeting = "Hello";</literal> implicitly calls <literal>new</literal> to create an object
containing the <literal>String "Hello"</literal> and functions nearly the same as the
similar line above.</simpara>
</section>
<section xml:id="_ragged_arrays">
<title>Ragged arrays</title>
<simpara>We are ashamed to say that we have lied to you. In Java, there is no
such thing as a multidimensional array. Instead, the examples of
two-dimensional and three-dimensional arrays we have given above are
actually arrays of arrays (of arrays). Thinking about multidimensional
arrays in this way can give the programmer more flexibility.</simpara>
<simpara>If we return to the definition of the two-dimensional array with 3 rows
and 4 columns, we can instantiate each row separately instead of as a
block.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] values = new int[3][];
int number = 1;
for( int i = 0; i &lt; values.length; i++ ) {
    values[i] = new int[4];
    for( int j = 0; j &lt; values[i].length; j++ ) {
        values[i][j] = number;
            number++;
    }
}</programlisting>
<simpara>This code is functionally equivalent to the earlier code that
instantiated all 12 locations at once. The same could be done with a
three-dimensional array or higher. We can specify the length of each row
independently, and, more bizarrely, we can give each row a different
length. A multidimensional array whose rows have different lengths is
called a <emphasis>ragged array</emphasis>.</simpara>
<simpara>A ragged array is usually unnecessary. The main reason to use a ragged
array is to save space, when you have tabular data in which the lengths
of each row varies a great deal. If the lengths of the rows vary only a
little, it is probably not worth the extra hassle. However, if some rows
have 10 elements and others have 1,000,000, the space saved can be
significant.</simpara>
<simpara>We can apply the idea of ragged arrays to the table of distances between
cities. If you examine this table, you will notice that about half the
data in it is repeated, because the distance from Chicago to Los Angeles
is the same as the distance from Los Angeles to Chicago, and so on. We
can store the data in a triangular shape to keep only the unique
distance information.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6666*"/>
<colspec colname="col_6" colwidth="16.667*"/>
<thead>
<row>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle">New York</entry>
<entry align="center" valign="middle">Los Angeles</entry>
<entry align="center" valign="middle">Chicago</entry>
<entry align="center" valign="middle">Houston</entry>
<entry align="center" valign="middle">Phoenix</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">New York</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle" namest="col_3" nameend="col_6"></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Los Angeles</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>2,791</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle" namest="col_4" nameend="col_6"></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Chicago</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>791</simpara></entry>
<entry align="center" valign="middle"><simpara>2,015</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle" namest="col_5" nameend="col_6"></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Houston</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>1,632</simpara></entry>
<entry align="center" valign="middle"><simpara>1,546</simpara></entry>
<entry align="center" valign="middle"><simpara>1,801</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="center" valign="middle"><simpara><emphasis role="strong">Phoenix</emphasis></simpara></entry>
<entry align="center" valign="middle"><simpara>2,457</simpara></entry>
<entry align="center" valign="middle"><simpara>373</simpara></entry>
<entry align="center" valign="middle"><simpara>1,181</simpara></entry>
<entry align="center" valign="middle"><simpara>1,176</simpara></entry>
<entry align="center" valign="middle"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>We could create this table in code by doing the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">distances = new int[5][];
//New York
distances[0] = new int[1];
//Los Angeles
distances[1] = new int[2];
distances[1][0] = 2791;
//Chicago
distances[2] = new int[3];
distances[2][0] = 791;
distances[2][1] = 2015;
//Houston
distances[3] = new int[4];
distances[3][0] = 1632;
distances[3][1] = 1546;
distances[3][2] = 1801;
//Phoenix
distances[4] = new int[5];
distances[4][0] = 2457;
distances[4][1] = 373;
distances[4][2] = 1181;
distances[4][3] = 1176;</programlisting>
<simpara>With this table a user cannot simply type in <literal>distances[0][4]</literal> and hope
to get the distance from New York to Phoenix. Instead, we have to be
careful to make sure that the index of the first city is never larger
than the index of the second city. If we are reading in the indexes of
the cities from a user, we can write some code to do this check. Let
<literal>city1</literal> and <literal>city2</literal>, respectively, contain the indexes of the cities the
user wants to use to find the distances between.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( city1 &gt; city2 ) {
    int temp = city1;
    city1 = city2;
    city2 = temp;
}
System.out.println("The distance is: " + distances[city1][city2] +
    " miles");</programlisting>
<simpara>If we wanted to be even cleverer, we could eliminate the zero entries
from the table, but then the ragged array would have one fewer row than
the original two-dimensional array.</simpara>
</section>
<section xml:id="_common_pitfalls">
<title>Common pitfalls</title>
<simpara>Even one-dimensional arrays make many new errors possible. Below we list
two of the most common mistakes made with both one-dimensional and
multidimensional arrays.</simpara>
<warning>
<title>Pitfall: Array out of bounds</title>
<simpara>The length of an array is determined at runtime. Sometimes the number is
specified in the source code, but it is always possible for an array to
be instantiated based on user input. The Java compiler does not do any
checking to see if you are in the right range. If your program tries to
access an illegal element, it will crash with an
<literal>ArrayIndexOutOfBoundsException</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] array = new int[100];
for( int i = 0; i &lt;= array.length; i++ )
    array[i] = i;</programlisting>
<simpara>Here is a classic example. By iterating through the loop one too many
times, the program will try to store <literal>100</literal> into <literal>array[100]</literal>, when the
last index of the array is <literal>99</literal>. In C and C++, pointer arithmetic
allowed a negative index to be valid for an array in some cases. In
Java, a negative index will always throw an
<literal>ArrayIndexOutOfBoundsException</literal>.</simpara>
<simpara>There are other less common causes for going outside of array bounds.
Imagine that you are scanning through a file that has been redirected to
input, keeping a count of the occurrences of each letter of the alphabet
in the file.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner(System.in);
int[] counts = new int[26];
String word;
while( in.hasNext() ) {
    word = in.next().toLowerCase();
    for( int i = 0; i &lt; word.length(); i++ )
        counts[word.charAt(i) - 'a']++;
}</programlisting>
<simpara>This segment of code does a decent job of counting the occurrences of
each letter. The <literal>while</literal> loop continues to execute as long as there is
another <literal>String</literal> worth of data to read in the file. The inner <literal>for</literal> loop
iterates through each <literal>char</literal> in the <literal>String</literal> and increments the
appropriate element of the <literal>counts</literal> array. By subtracting the value
<literal>'a'</literal>, we normalize the <literal>char</literal> values <literal>'a'</literal> through <literal>'z'</literal> to <literal>0</literal> through
<literal>25</literal>. However, if there is any punctuation in the file, simply
subtracting <literal>'a'</literal> will not work. The Unicode value of <literal>'.'</literal>, for
example, is 46. The Unicode value of <literal>'a'</literal> is 97. Subtracting 97 from 46
will make this code try to increment index <literal>-51</literal> of the array. An
additional check should be put into this code to make sure that the
<literal>char</literal> value being examined is a letter.</simpara>
</warning>
<warning>
<title>Pitfall: Uninitialized reference arrays</title>
<simpara>Another problem only comes up with arrays of reference types. Whenever
the elements of an array are primitive data types, memory for that type
is allocated. Whenever the elements of the array are reference types,
only references to objects, initialized to <literal>null</literal> are allocated. Because
it&#8217;s an array of primitive values, the following code works fine.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] primitives = new int[100];
primitives[67]++;</programlisting>
<simpara>The following code, however, will cause a <literal>NullPointerException</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">String[] references = new String[100];
int x = references[67].length();</programlisting>
<simpara>Arrays of reference types must initialize each element before using it.
The<?asciidoc-br?>
<literal>NullPointerException</literal> could be avoided as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">String[] references = new String[100];
for( int i = 0; i &lt; references.length; i++ )
    references[i] = new String();
int x = references[67].length();</programlisting>
<simpara>In this case, there would be no error, although
<literal>references[67].length()</literal> would still be <literal>0</literal>, and that is probably not
what the programmer intended.</simpara>
<simpara>A similar error can happen with multidimensional arrays.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][] table = new int[10][];
for( int i = 0; i &lt; table.length; i++ )
    table[i][i] = i;</programlisting>
<simpara>Because an array is itself a reference type, the <literal>table</literal> array contains
<literal>10</literal> references to <literal>null</literal> for each of its <literal>10</literal> rows. Unless those rows
are instantiated, the JVM will again throw a <literal>NullPointerException</literal> when
attempting to access an <literal>int</literal> value in the table. This error confuses
many beginner programmers because no reference types appear to be
involved.</simpara>
</warning>
</section>
</section>
<section xml:id="_examples_two_dimensional_arrays">
<title>Examples: Two-dimensional arrays</title>
<simpara>Below we give some examples where two-dimensional arrays can be helpful.
We start with a very simple calendar example, move on to matrix and
vector multiplication useful in math, and finish with a game.</simpara>
<example>
<title>Calendar</title>
<simpara>We are going to create a calendar that can be printed to the console to
show which day of the week each day lands on. Our program will prompt
the user for the day of the week the month starts on and for the total
number of days in the month. Our program will print out labels for the
seven days of the week, followed by numbering starting at the
appropriate place, and wrapping such that each numbered day of the month
falls under the appropriate day of the week.</simpara>
<formalpara xml:id="program:Calendar" xreflabel="Calendar">
<title>This program prints a calendar for a given month, formatted week by week.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class Calendar {
	public static void main(String[] args) {
		String[][] squares = new String[7][7];
		squares[0][0] = "Sun";
		squares[0][1] = "Mon";
		squares[0][2] = "Tue";
		squares[0][3] = "Wed";
		squares[0][4] = "Thu";
		squares[0][5] = "Fri";
		squares[0][6] = "Sat";
		for( int i = 1; i &lt; squares.length; i++ )
			for( int j = 0; j &lt; squares[i].length; j++ )
				squares[i][j] = " ";
		Scanner in = new Scanner( System.in );
		System.out.print("Which day does your month start on?"
				+ " (0 - 6) ");
		int start = in.nextInt(); //read starting day
		System.out.print("How many days does your month have?"
				+ " (28 - 31) ");
		int days = in.nextInt();  //read days in month
		int day = 1;
		int row = 1;
		int column = start;
		while( day &lt;= days ) { //fill calendar
			squares[row][column] = "" + day;
			day++;
			column++;
			if( column &gt;= squares[row].length ) {
				column = 0;
				row++;
			}
		}
		for( int i = 0; i &lt; squares.length; i++ ) {
			for( int j = 0; j &lt; squares[i].length; j++ )
				System.out.print( squares[i][j] + "\t" );
			System.out.println();
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>First, our code creates a 7 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 7 array of type
<literal>String</literal> called <literal>squares</literal>. The array needs 7 rows so that it can start
with a row to label the days and then output up to 6 rows to cover the
weeks. (Months with 31 days span parts of 6 different weeks if they
start on a Friday or a Saturday.) The number of columns corresponds to
the seven days of the week. Next, we initialize the first row of the
array to abbreviations for each day of the week. Then, we initialize the
rest of the array to be a single space.</simpara>
<simpara>Our program then prompts the user for the day the month starts on, using
a <literal>for</literal> loop to print out the choices that have already been saved in
<literal>squares</literal>. The program also prompts the user for the total number of
days in the month.</simpara>
<simpara>The main work of the program is done by the <literal>while</literal> loop, which fills
each square with a steadily increasing day number for each column,
moving on to the next row when a row is filled. Finally, the two nested
<literal>for</literal> loops at the end print out the contents of <literal>squares</literal>, putting a
tab (<literal>'\\t'</literal>) between each column and starting a new line for each row.</simpara>
</example>
<example>
<title>Matrix-vector multiplication</title>
<simpara>Arrays give a natural way to represent vectors and matrices. In 3D
graphics and video game design, we can represent a point in 3D space as
a vector with three elements: <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and
<inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation>. If we want to rotate the three-dimensional point
represented by this vector, we can multiply it by a matrix. For example,
to rotate a point around the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>-axis by
<inlineequation><alt><![CDATA[\theta]]></alt><mathphrase><![CDATA[\theta]]></mathphrase></inlineequation> degrees, we could use the following matrix.</simpara>
<simpara><inlineequation><alt><![CDATA[\begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos \theta & -\sin \theta \\[3pt]]></alt><mathphrase><![CDATA[\begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos \theta & -\sin \theta \\[3pt]]></mathphrase></inlineequation> 0 &amp; \sin
\theta  &amp; \cos \theta \\[3pt] \end{bmatrix}]</simpara>
<simpara>Given an <inlineequation><alt><![CDATA[m\times n]]></alt><mathphrase><![CDATA[m\times n]]></mathphrase></inlineequation> matrix <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation>, let
<inlineequation><alt><![CDATA[A_{ij}]]></alt><mathphrase><![CDATA[A_{ij}]]></mathphrase></inlineequation> be the element in the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript> row,
<inlineequation><alt><![CDATA[j]]></alt><mathphrase><![CDATA[j]]></mathphrase></inlineequation><superscript>th</superscript> column. Given a vector <inlineequation><alt><![CDATA[v]]></alt><mathphrase><![CDATA[v]]></mathphrase></inlineequation> of length
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, let <inlineequation><alt><![CDATA[v_i]]></alt><mathphrase><![CDATA[v_i]]></mathphrase></inlineequation> be the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript>
element in the vector. To multiply <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> by <inlineequation><alt><![CDATA[v]]></alt><mathphrase><![CDATA[v]]></mathphrase></inlineequation>,
we use the following equation to find the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript> element of
the resulting vector <inlineequation><alt><![CDATA[v']]></alt><mathphrase><![CDATA[v']]></mathphrase></inlineequation>.</simpara>
<simpara><inlineequation><alt><![CDATA[v'_i = \sum_{j = 1}^n A_{ij}\cdot v_j]]></alt><mathphrase><![CDATA[v'_i = \sum_{j = 1}^n A_{ij}\cdot v_j]]></mathphrase></inlineequation></simpara>
<simpara>By transforming this equation to Java code, we can write a program that
can read in a three-dimensional point and rotate it around the
<inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>-axis by the amount specified by the user.</simpara>
<formalpara xml:id="program:MatrixRotate" xreflabel="MatrixRotate">
<title>This program uses matrix multiplication to rotate a point in three-dimensional space.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class MatrixRotate {
	public static void main(String[] args) {
		double[] point = new double[3];
		System.out.println("What point do you want to rotate?");
		Scanner in = new Scanner( System.in );
		System.out.print("x: ");
		point[0] = in.nextDouble();
		System.out.print("y: ");
		point[1] = in.nextDouble();
		System.out.print("z: ");
		point[2] = in.nextDouble();
		System.out.print("What angle around the x-axis? ");
		double theta = Math.toRadians(in.nextDouble());
		double[][] rotation = new double[3][3];
		rotation[0][0] = 1;
		rotation[1][1] = Math.cos(theta);
		rotation[1][2] = -Math.sin(theta);
		rotation[2][1] = Math.sin(theta);
		rotation[2][2] = Math.cos(theta);
		double[] rotatedPoint = new double[3];
		for( int i = 0; i &lt; rotatedPoint.length; i++ )
			for( int j = 0; j &lt; point.length; j++ )
				rotatedPoint[i] += rotation[i][j]*point[j];
		System.out.println("Rotated point: [" + rotatedPoint[0] +
			"," + rotatedPoint[1] + "," + rotatedPoint[2] + "]");
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program begins by declaring a array of type <literal>double</literal> to hold the
vector and then reading three values from the user into it. Then, the
program reads in the angle of rotation in degrees and converts it to
radians. Next, we use the <literal>Math</literal> class to calculate the values in the
rotation matrix. Note that we do not change the values that need to be
zero. Finally, we use a <literal>for</literal> loop to perform the matrix-vector
multiplication and then print out the answer. Again, the summing done by
our calculations uses the fact that all elements of <literal>rotatedPoint</literal> are
initialized to <literal>0.0</literal>.</simpara>
</example>
<example>
<title>Tic Tac Toe</title>
<simpara>Almost every child knows the game of Tic Tac Toe. Its playing area is a
3 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 3 grid. Players take turns placing X&#8217;s and O&#8217;s,
trying to get three in a row. Strategically, it is not the most
interesting game since two players who make no mistakes will always tie.
Still, we present a program that allows two human players to play the
game because the manipulations of a two-dimensional array in the program
are similar to those for more complicated games such as Connect Four,
checkers, chess, or Go. Our program will catch any attempt to play on a
location that has already been played and will determine the winner, if
there is one.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class TicTacToe {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		char[][] board = new char[3][3];
		for( int i = 0; i &lt; board.length; i++ )
			for( int j = 0; j &lt; board[0].length; j++ )
				board[i][j] = ' ';
		boolean turn = true;
		boolean gameOver = false;
		int row, column, moves = 0;
		char shape;</programlisting>
<simpara>Games often give rise to complex programs, since rules that are
intuitively obvious to humans may be difficult to state explicitly in
Java. Our program begins by setting up quite a few variables and
objects. First, we create a <literal>Scanner</literal> to read in data. Then, we declare
and instantiate our 3 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 3 playing board as a
two-dimensional array of type <literal>char</literal>. We want any unplayed space on the
grid to be the <literal>char</literal> for a space, so we fill the array with <literal>' '</literal>.
Next, we declare a <literal>boolean</literal> value to keep track of whose turn it is and
another to keep track of whether the game is over or not. Finally, we
declare variables to hold the row, the column, the number of moves that
have been made so far and the current shape (<literal>'X'</literal> or <literal>'O'</literal>).</simpara>
<programlisting language="java" linenumbering="numbered">		while( !gameOver ) {
			shape = turn ? 'X' : 'O';
			System.out.print(shape + "'s turn.  Enter row(0-2): ");
			row = in.nextInt();
			System.out.print("Enter column(0-2): ");
			column = in.nextInt();
			if( board[row][column] != ' ' )
				System.out.println("Illegal move");
			else {
				board[row][column] = shape;
				moves++;
				turn = !turn;
				//print board
				System.out.println(board[0][0] + "|"
						 + board[0][1] + "|" + board[0][2]);
				System.out.println("-----");
				System.out.println(board[1][0] + "|"
						 + board[1][1] + "|" + board[1][2]);
				System.out.println("-----");
				System.out.println(board[2][0] + "|"
						 + board[2][1] + "|" + board[2][2] + "\n");</programlisting>
<simpara>The core of the game is a <literal>while</literal> loop that runs until <literal>gameOver</literal>
becomes <literal>true</literal>. The first line of the body of this loop is an obscure
Java shortcut often referred to as the <emphasis>ternary operator</emphasis>. This line is
really shorthand for the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( turn )
    shape = 'X';
else
    shape = '0';</programlisting>
<simpara>The ternary operator works with a condition followed by a question mark
and then two values separated by a colon. If the condition is <literal>true</literal>,
the first value is assigned, otherwise the second value is assigned. It
is perfect for situations like this where one value is needed when
<literal>turn</literal> is <literal>true</literal> and another is needed when <literal>turn</literal> is <literal>false</literal>. The
ternary operator is a useful trick, but it should not be overused.</simpara>
<simpara>After assigning the appropriate value to <literal>shape</literal>, our code reads in the
row and column values for the current player&#8217;s next move. If the row and
column selected correspond to a spot that has already been taken, the
program gives an error message. Otherwise, the program sets
<literal>board[row][column]</literal> to the appropriate symbol, increments <literal>moves</literal>, and
changes the value of <literal>turn</literal>. Then, it prints out the board. We point out
that our program does not do any bounds checking on <literal>row</literal> and <literal>column</literal>.
If a user tries to place a move at row 5 column 3, our program will try
to do so and crash. Four additional clauses in the <literal>if</literal> statement could
be used to add bounds checking.</simpara>
<programlisting language="java" linenumbering="numbered">				//check rows
				for( int i = 0; i &lt; board.length; i++ )
					if( board[i][0] == shape &amp;&amp; board[i][1] == shape
						&amp;&amp; board[i][2] == shape )
						gameOver = true;
				//check columns
				for( int i = 0; i &lt; board[0].length; i++ )
					if( board[0][i] == shape &amp;&amp; board[1][i] == shape
						&amp;&amp; board[2][i] == shape )
						gameOver = true;
				//check diagonals
				if( board[0][0] == shape &amp;&amp; board[1][1] == shape
					&amp;&amp; board[2][2] == shape )
					gameOver = true;
				if( board[0][2] == shape &amp;&amp; board[1][1] == shape
					&amp;&amp; board[2][0] == shape )
					gameOver = true;
				if( gameOver )
					System.out.println(shape + " wins!");
				else if( moves == 9 ){
					gameOver = true;
					System.out.println("Tie game!");
				}
			}
		}
	}
}</programlisting>
<simpara>listing (lines 36-62) not available.*</simpara>
<simpara>Perhaps the trickiest part of our Tic Tac Toe program is checking for a
win. First we check each row to see if it contains three in a row. Then,
we check each column. Finally, we check the two diagonals. If any of
those checks ended the game, we announce a winner. Otherwise, if the
number of moves has reached 9 with no winner, it must be a tie game. In
a larger game (such as Connect Four, we would want to find better ways
to automate checking rows, columns, and diagonals. For one thing, a very
large board we mean that we would not want to check the entire thing
each move. Instead, we could focus only on rows, columns, and diagonals
affected by the last move.</simpara>
</example>
</section>
<section xml:id="_advanced_special_array_tools_in_java">
<title>Advanced: Special array tools in Java</title>
<simpara>Arrays are fundamental data structures in many programming languages.
There are often special syntactical tools or libraries designed to make
them easier to use. In this section, we explore two advanced tools, the
for-each loop and the <literal>Arrays</literal> utility class.</simpara>
<section xml:id="subsection:The_for-each_loop">
<title>The for-each loop</title>
<simpara>In ChapterÂ <xref linkend="chapter:Repetition"/> we describe three loops: <literal>while</literal>
loops, <literal>for</literal> loops, and <literal>do-while</literal> loops. Although these are the only
three loops in Java, there is a special form of the <literal>for</literal> loop designed
for use with arrays (and some other data structures). This construct is
usually called a <emphasis>for-each loop</emphasis>.</simpara>
<simpara>A for-each loop does not have the three-part header of a regular <literal>for</literal>
loop. Instead, it is designed to iterate over the contents of an array.
Inside its parentheses is a declaration of a variable with the same type
of the elements of the array, then a colon (<literal>:</literal>), then the name of the
array. Consider the following example of a for-each loop used to sum the
values of an array of <literal>int</literal> values called <literal>array</literal>. As with all loops in
Java, braces are optional if there is only one executable statement in
the loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int sum = 0;
for( int value : array )
    sum += value;</programlisting>
<simpara>This code functions in exactly the same way as the traditional <literal>for</literal>
loop we would use to solve the same problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">int sum = 0;
for( int i = 0; i &lt; array.length; i++ )
    sum += array[i];</programlisting>
<simpara>The advantage of the for-each loop is that it is shorter and clearer.
There is also no worry about being off by one with your indexes. The
for-each loop iterates over every element in the array, no indexes
needed!</simpara>
<simpara>For-each loops can be nested or used inside of other loops. Consider the
following nested for-each loops that print out all of the kinds of chess
pieces, in both black and white colors.</simpara>
<programlisting language="java" linenumbering="unnumbered">String[] colors = {"Black", "White"};
String[] pieces =
    {"King", "Queen", "Rook", "Bishop", "Knight", "Pawn"};
for( String color : colors )
    for( String piece : pieces )
        System.out.println(color + " " + piece);</programlisting>
<simpara>For-each loops do have a few drawbacks. They are designed for iterating
through an entire array. It is ugly to try to make them stop early, and
it is impossible to make them go back to previous values. They are also
only designed for <emphasis role="strong">read</emphasis> access, not write access. The variable in the
header of the for-each loop takes on each value in the array in turn,
but assigning values to that variable have no effect on the underlying
array. Consider the following <literal>for</literal> loop that assigns <literal>5</literal> to every value
in <literal>array</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; array.length; i++ )
    array[i] = 5;</programlisting>
<simpara>This kind of assignment is impossible in a for-each loop. The
&#8220;equivalent&#8221; for-each loop does nothing. It assigns <literal>5</literal> to the local
variable <literal>value</literal> but never changes <literal>array</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int value : array )
    value = 5;</programlisting>
<simpara>Although for-each loops are great for arrays, they can also be used for
any other data structures that implements the <literal>Iterable</literal> interface. We
discuss interfaces in ChapterÂ <xref linkend="chapter:Interfaces"/> and dynamic data
structures in Chapters <xref linkend="chapter:Dynamic_Data_Structures"/> and
<xref linkend="chapter:Recursion"/>.</simpara>
</section>
<section xml:id="_the_literal_arrays_literal_class">
<title>The <literal>Arrays</literal> class</title>
<simpara>The designers of the Java API knew that arrays were important and added
a special <literal>Arrays</literal> class to manipulate them.</simpara>
<simpara>This class has a number of static methods that can be used to search for
values in arrays, make copies of arrays, copy selected ranges of arrays,
test arrays for equality, fill arrays with specific values, sort arrays,
convert an entire array into a <literal>String</literal> representation, and more. The
signatures of the methods below are given for <literal>double</literal> arrays, but most
methods are overloaded to work with all primitive types and reference
types.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191*"/>
<colspec colname="col_2" colwidth="234*"/>
<thead>
<row>
<entry align="left" valign="top">Method</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">binarySearch(double[] array, double value)</literallayout></entry>
<entry align="left" valign="top"><simpara>Returns index of <literal>value</literal>
inside <literal>array</literal> or a negative number if it cannot be found. Adding 1 to
the negative number and then negating it will give the index where the
value would have been.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">copyOf(double[] array, int length)</literallayout></entry>
<entry align="left" valign="top"><simpara>Returns a copy of <literal>array</literal> with
length <literal>length</literal>, either truncated or padded if it doesn&#8217;t match the
length of <literal>array</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">copyOfRange(double[] array, int from, int to)</literallayout></entry>
<entry align="left" valign="top"><simpara>Returns a copy of
<literal>array</literal> from the range starting at <literal>from</literal> and going up to but not
including <literal>to</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">equals(double[] array1, double[] array2)</literallayout></entry>
<entry align="left" valign="top"><simpara>Returns <literal>true</literal> if <literal>array1</literal>
and <literal>array2</literal> have the same number of elements, each pair of which is
equal.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">fill(double[] array, double value)</literallayout></entry>
<entry align="left" valign="top"><simpara>Fills <literal>array</literal> with copies of
<literal>value</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">sort(double[] array)</literallayout></entry>
<entry align="left" valign="top"><simpara>Sorts <literal>array</literal> using natural ordering. This
method can fail for <literal>Object</literal> arrays in which the objects are not
comparable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">toString(double[] a)</literallayout></entry>
<entry align="left" valign="top"><simpara>Returns a <literal>String</literal> containing representations
of each element separated with commas.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Consult the API for more information. Even though tasks like <literal>fill()</literal>
are simple, it is worth using the method from <literal>Arrays</literal> instead of
writing your own. The methods in the Java API have often been tuned for
speed and use special commands that are not accessible to regular Java
programmers.</simpara>
</section>
</section>
<section xml:id="_solution_game_of_life">
<title>Solution: Game of Life</title>
<simpara>Here we present our solution to the Conway&#8217;s Game of Life simulation.
Our program is designed to run the simulation with 24 rows and 80
columns, although it would be easy to change those dimensions.</simpara>
<programlisting language="java" linenumbering="numbered">public class Life {
	public static void main(String[] args) {
		final int ROWS = 24;
		final int COLUMNS = 80;
		final int GENERATIONS = 500;
		boolean[][] board = new boolean[ROWS][COLUMNS];
		boolean[][] temp = new boolean[ROWS][COLUMNS];
		boolean[][] swap;
		for( int row = 0; row &lt; ROWS; row++ )
			for( int column = 0; column &lt; COLUMNS; column++ )
				board[row][column] = (Math.random() &gt; 0.9);</programlisting>
<simpara>The <literal>main()</literal> method of our program starts by defining <literal>ROWS</literal>, <literal>COLUMNS</literal>,
and<?asciidoc-br?>
<literal>GENERATIONS</literal> as named constants using the <literal>final</literal> keyword. Next, we
create <emphasis role="strong">two</emphasis> arrays with <literal>ROWS</literal> rows and <literal>COLUMNS</literal> columns. The <literal>board</literal>
array will hold the current generation. The <literal>temp</literal> array will be used to
fill in the next generation. Then, <literal>temp</literal> will be copied into <literal>board</literal>,
and the process will repeat. The <literal>swap</literal> variable is just a reference we
will use to swap <literal>board</literal> and <literal>temp</literal>. We randomly fill the board, making
10% of the cells living. Again, you may wish to play with this number to
see how the patterns in the simulation are affected.</simpara>
<programlisting language="java" linenumbering="numbered">		int total;
		for( int generation = 0; generation &lt; GENERATIONS;
			generation++ ) {
			for( int row = 0; row &lt; ROWS; row++ )
				for( int column = 0; column &lt; COLUMNS; column++ ) {
					total = 0;
					for( int i = Math.max(row - 1, 0);
						 i &lt; Math.min(row + 2, ROWS); i++ )
						for( int j = Math.max(column-1, 0);
							j &lt; Math.min(column+2, COLUMNS); j++ )
							if( (i != row || j != column )
								&amp;&amp; board[i][j] )
								total++;
					if( board[row][column] )
						temp[row][column] = (total == 2 ||
						total == 3);
					else
						temp[row][column] = (total == 3);
				}
			swap = board;
			board = temp;
			temp = swap;</programlisting>
<simpara>The <literal>for</literal> loop at the beginning of this segment of code runs once for
each generation we simulate. The two nested <literal>for</literal> loops examine each
cell in <literal>board</literal>. The two <literal>for</literal> loops nested inside of those loops do the
calculations to determine if a cell will be living or dead in the next
generation. These inner loops start one row before the current row and
finish one row after the current row. They do the same for columns. The
<literal>Math.max()</literal> and <literal>Math.min()</literal> methods are used to keep the loops from
going out of bounds of the array. When backing up a row or a column, the
<literal>Math.max()</literal> methods make sure that we do not generate an index smaller
than 0. When going forward a row or a column, the <literal>Math.min()</literal> methods
make sure that we do not generate an index greater than <literal>ROWS - 1</literal> or
<literal>COLUMNS - 1</literal>.</simpara>
<simpara>After these two innermost <literal>for</literal> loops have counted the total of living
cells around the cell in question, we decide the fate of the cell for
the next generation. If the cell is living and has exactly 2 or 3 living
neighbors, it will continue to be living. If a cell is dead, it will
come to life only if it has exactly 3 living neighbors. After we have
stored the state of each cell in the next generation into <literal>temp</literal>, we
swap <literal>board</literal> and <literal>temp</literal>, using the <literal>swap</literal> variable. We could have thrown
out the old array stored in <literal>board</literal> instead of swapping it with <literal>temp</literal>,
but then we would have to create a new array for <literal>temp</literal> each time, which
is less efficient.</simpara>
<programlisting language="java" linenumbering="numbered">			for( int i = 0; i &lt; 100; i++ )
				System.out.println();
			for( int row = 0; row &lt; ROWS; row++ ) {
				for( int column = 0; column &lt; COLUMNS; column++ )
					if( board[row][column] )
						System.out.print("*");
					else
						System.out.print(" ");
				System.out.println();
			}
			try { Thread.sleep(100); }
			catch( InterruptedException e ) {}
		}
	}
}</programlisting>
<simpara>The first <literal>for</literal> loop in this segment prints 100 blank lines to clear the
screen, as we explained earlier. The two nested <literal>for</literal> loops print out
the state of the current generation, with a <literal>*</literal> for each living cell and
a blank space for each dead one. After the output, the code sleeps for
100 milliseconds to give the effect of an animation. We will discuss
exceptions in general in ChapterÂ <xref linkend="chapter:Exceptions"/> and give more
information about the <literal>Thread.sleep()</literal> method in Chapter
<xref linkend="chapter:Concurrent_Programming"/>.</simpara>
</section>
<section xml:id="_concurrency_arrays">
<title>Concurrency: Arrays</title>
<simpara>Arrays are critical to concurrent programming in Java. In
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>, we will explain how to
create independent threads of execution, each of which is tied to a
<literal>Thread</literal> object. If you have a dual, quad, or higher core computer, you
might want to use two or four threads to solve a problem, but some
programs can use hundreds. How can you keep track of all those <literal>Thread</literal>
objects? In many cases, you will hold references to them in an array.</simpara>
<simpara>Arrays also hold large lists of data. It is common for threaded programs
to share a single array which each thread reads and writes to. In this
way, memory costs are kept low because there is only one copy of all the
data. In the simplest case, each thread works on some portion of the
array without interacting with the rest. Even then, how do you assign
parts of the array to the different threads?</simpara>
<simpara>We will assume that each element of the array needs to be processed in
some way. For example, we might want to record whether or not each
<literal>long</literal> in an array is prime or not. If you have <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation> threads
and an array of length <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> where <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> happens to
be a multiple of <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation>, then it&#8217;s easy: Each thread gets
exactly <inlineequation><alt><![CDATA[n/k]]></alt><mathphrase><![CDATA[n/k]]></mathphrase></inlineequation> items to work on. For example, the first
thread will work on indexes 0 through <inlineequation><alt><![CDATA[\frac{n}{k} - 1]]></alt><mathphrase><![CDATA[\frac{n}{k} - 1]]></mathphrase></inlineequation>, the
second thread will work on indexes <inlineequation><alt><![CDATA[\frac{n}{k}]]></alt><mathphrase><![CDATA[\frac{n}{k}]]></mathphrase></inlineequation> through
<inlineequation><alt><![CDATA[\frac{2n}{k} - 1]]></alt><mathphrase><![CDATA[\frac{2n}{k} - 1]]></mathphrase></inlineequation>, and so on, with the last thread working
on indexes <inlineequation><alt><![CDATA[\frac{(k
- 1)n}{k}]]></alt><mathphrase><![CDATA[\frac{(k
- 1)n}{k}]]></mathphrase></inlineequation> through <inlineequation><alt><![CDATA[n  - 1]]></alt><mathphrase><![CDATA[n  - 1]]></mathphrase></inlineequation>. Not every element in the array
will require the same amount of computation, but we often assume that
they do because it can be difficult to guess which elements will take
more time to process.</simpara>
<simpara>What if the number of elements in the array is not a multiple of the
number of threads? We still want to assign the work the work as fairly
as possible. New programmers are sometimes tempted to use the same
arithmetic from the case in which the threads evenly divide the length
of the array: Each thread gets <inlineequation><alt><![CDATA[\frac{n}{k}]]></alt><mathphrase><![CDATA[\frac{n}{k}]]></mathphrase></inlineequation> (using integer
division) elements, and we stick the last thread with the leftovers. How
bad can that be?</simpara>
<simpara>This assignment of work can be very poorly balanced. Consider a case
with 10 threads and 28 pieces of data. <inlineequation><alt><![CDATA[\frac{28}{10} = 2]]></alt><mathphrase><![CDATA[\frac{28}{10} = 2]]></mathphrase></inlineequation>,
using integer division. Thus, the first nine threads have 2 units of
work to do, but the last thread is stuck with 10! Not only is this
unfair, it is inefficient. The person writing the program probably wants
to minimize the total amount of time needed to finish the job. In this
case, the time from when the first thread starts to when the last thread
finishes is called the task&#8217;s <emphasis>makespan</emphasis>. With this division of work,
the makespan is 10 units of work.</simpara>
<figure role="text-center">
<title>Units of work per thread using a naive strategy.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/split1.svg" width="60%"/>
</imageobject>
<textobject><phrase>split1</phrase></textobject>
</mediaobject>
</figure>
<example>
<title>Fairly assigning work</title>
<simpara>A simple way to fix this problem is to look at the value
<inlineequation><alt><![CDATA[n \mod k]]></alt><mathphrase><![CDATA[n \mod k]]></mathphrase></inlineequation>, the leftovers when you divide <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> by
<inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation>. We want to spread those out over the first few threads.
We know that any remainder will be smaller than <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation>. If the
index of the thread (starting at 0, of course) is less than the
remainder, we add an extra element to its work. In this way, 28 units of
work spread over 10 threads will give 3 elements to the first 8 threads
and 2 elements to the rest. Using this strategy, the makespan becomes 3
units of work, a huge improvement over 10. Finding a way to spreading
work across multiple threads to improve efficiency is a form of <emphasis>load
balancing</emphasis>, a broad term for dividing work across computing resources.</simpara>
<figure role="text-center">
<title>Units of work per thread using a fair strategy.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/06-arrays/images/split2.svg" width="60%"/>
</imageobject>
<textobject><phrase>split2</phrase></textobject>
</mediaobject>
</figure>
<formalpara xml:id="program:AssigningWork" xreflabel="AssigningWork">
<title>Here is a short program that reads the length of an array and the number of threads from the user and then prints out the amount of work for each one. You should be able to adapt the ideas in it to your own multi-threaded programs in ChapterÂ <xref linkend="chapter:Concurrent Programming"/>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class AssigningWork {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		System.out.print("How long is your array? ");
		int n = in.nextInt();
		System.out.print("How many threads do you have? ");
		int k = in.nextInt();
		int quotient = n / k;
		int remainder = n % k;
		int next = 0;
		for( int i = 0; i &lt; k; i++ ) {
			int work = quotient;
			if( i &lt; remainder )
				work++;
			System.out.println("Thread " + i + " does " + work
				+ " units of work, starting at index " + next
				+ " and ending at index " + (next + work - 1));
			next += work;
		}
	}
}</programlisting>
</para>
</formalpara>
</example>
</section>
<section xml:id="_exercises_5">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Why can&#8217;t an array be used to hold an arbitrarily long list of
numbers entered by a user? What are strategies that can be used to
overcome this problem?</simpara>
</listitem>
<listitem>
<simpara>In future chapters, we will introduce a data structure called a
<emphasis>linked list</emphasis>. A linked list is a homogeneous, dynamic data structure,
with sequential access (unlike an array, which has random access). You
can instantly jump to any place in an array, but you have to step
through each element of a linked list to get to the one you want, even
if you know its position in the list exactly. On the other hand,
inserting values into the beginning of a linked list can be done in one
step, while an array would need to be resized and have its contents
copied over. List some tasks for which an array would be better than a
linked list and vice versa.</simpara>
</listitem>
<listitem>
<simpara>Given the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">double[] array1 = new double[50];
double[] array2 = new double[50];
for( int i = 0; i &lt; array1.length; i++ ) {
    array1[i] = i + 1;
    array2[i] = array2.length - i;
}
array2 = array1;
for( int i = 1; i &lt; array1.length; i++ )
    array1[i] = array1[i - 1] + array1[i];</programlisting>
<simpara>What is the value in <literal>array2[array2.length - 1]</literal> after this code is
executed?</simpara>
</listitem>
<listitem>
<simpara>What error will be caused by the following code, and why?</simpara>
<programlisting language="java" linenumbering="unnumbered">String[] array = new String[100];
System.out.println(array[99].charAt(0) +
           " is the first letter of the last String.");</programlisting>
</listitem>
<listitem>
<simpara>An array of length <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> in Java typically takes
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> times the number of bytes for each element plus an
additional 16 bytes of overhead. Since an <literal>int</literal> uses 4 bytes of storage,
an array of 100 <literal>int</literal> elements would take 416 bytes. Consider the
following three-dimensional array declaration and allocation.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[][][] data = new int[10][5][20];</programlisting>
<simpara>How many bytes are allocated for this array? Remember that the 16 byte
overhead will occur repeatedly, since Java creates a three-dimensional
array as an array of arrays of arrays.</simpara>
</listitem>
<listitem>
<simpara>Our original table of city distances allocates
<inlineequation><alt><![CDATA[5 \cdot 5 = 25]]></alt><mathphrase><![CDATA[5 \cdot 5 = 25]]></mathphrase></inlineequation> <literal>int</literal> elements to store all the distances
between the five cities, including repeats. How many <literal>int</literal> elements are
allocated for the triangular, ragged array version of the city distance
table? If we used the normal table style, <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> cities would
require <inlineequation><alt><![CDATA[n^2]]></alt><mathphrase><![CDATA[n^2]]></mathphrase></inlineequation> <literal>int</literal> elements. How many elements would the
triangular, ragged array version allocate for <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> cities?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:naive_array_split"/> Consider the naive method of dividing
an array of length <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> among <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation> threads that
was discussed in SectionÂ <xref linkend="concurrency:Arrays"/>: Each thread gets
<inlineequation><alt><![CDATA[n/k]]></alt><mathphrase><![CDATA[n/k]]></mathphrase></inlineequation> (rounded down because of integer division) elements,
and the last thread gets any extras. What mathematical expression
describes how many extra elements are allocated to the last thread? Can
you come up with an example in which the last element gets <emphasis role="strong">all</emphasis> the
elements? What should have happened in this case using the other, more
fair scheme for assigning the data to threads?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:remove_punctuation"/> In ExampleÂ <xref linkend="example:Word_search"/>,
our code did not count <literal>ship,</literal> as an occurrence of <literal>ship</literal> because of the
comma.</simpara>
<simpara>Rewrite the code from ExampleÂ <xref linkend="example:Word_search"/> to remove
punctuation from the beginning and end of a word. Use a loop that runs
as long as the character at the beginning of a word is not a letter,
replacing the word with a substring of itself that does not include the
first character. Use a second loop to remove non-letters from the end of
a word. Be careful to stop if the length of the <literal>String</literal> becomes 0, as
with text that is entirely composed of non-letters.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:binary_search"/> In ExampleÂ <xref linkend="example:Word_search"/>, we
wrote a program that counts the occurrences of each word from a list
within a text. If the list of words to search within is long, it can
take quite some time to search through the entire list. If the list of
words were sorted, we could do a trick that would allow us to search
much faster. We could play a &#8220;high-low&#8221; game, searching through the
list by checking the middle word in the array. If that word is too late
in the alphabet, repeat the search on the first half of the list. If it
is too early in the alphabet, repeat the search on the second half of
the list. By repeatedly dividing the list in half, until you either find
the word you&#8217;re looking for or narrow your search down to a single
incorrect word, you can search much faster. This kind of searching is
called <emphasis>binary search</emphasis> and uses around <inlineequation><alt><![CDATA[\log n]]></alt><mathphrase><![CDATA[\log n]]></mathphrase></inlineequation> comparisons
to find an element in a list. In contrast, looking through the list one
element at a time takes about <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> comparisons.</simpara>
<simpara>Rewrite the code from ExampleÂ <xref linkend="example:Word_search"/> to use binary
search, after applying selection sort from ExampleÂ <xref linkend="example:Selection
sort"/>. Although selection sort will take some extra time, you should
more than make up the difference with such a fast search. To implement
binary search, keep variables for the start, middle, and end of the
list. Keep adjusting the three variables until the middle index has the
word you are looking for or start and end reach each other. Remember to
use the <literal>compareTo()</literal> method from the <literal>String</literal> class to compare words.</simpara>
</listitem>
<listitem>
<simpara>In ExampleÂ <xref linkend="example:Statistics"/>, we gave a program that finds the
maximum, minimum, mean, standard deviation, and median of a list of
values. Another statistic that is sometimes important is the <emphasis>mode</emphasis>, or
most commonly occurring element. For example, in the list
<inlineequation><alt><![CDATA[\{ 1, 2, 3, 3, 3, 5, 6, 6, 10 \}]]></alt><mathphrase><![CDATA[\{ 1, 2, 3, 3, 3, 5, 6, 6, 10 \}]]></mathphrase></inlineequation>, the mode is 3. Write a
program that can determine the mode of a given list of <literal>int</literal> values. A
list can have multiple modes if more than one element occurs with
maximum frequency. For our purposes, we will consider any list with
multiple modes to have no modes. You may wish to sort the list before
starting the process of counting the frequency of each value.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Connect_Four"/> We used the example of Tic Tac Toe in
Example <xref linkend="example:Tic_Tac_Toe"/> because a more complex game would have
taken too much space to solve. The game of Connect Four (or the
Captain&#8217;s Mistress, as it was originally called) pits two players
against each other on a 6 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 7 vertical board. One
player uses red checkers while the other uses black. The two players
take turns dropping their checkers into columns of the board in which
the checkers will drop to the lowest empty row, due to gravity. The goal
of the game is to be the first to make four in a row of your color.</simpara>
<simpara>Implement a version of Connect Four for two human players, similar to
the version of Tic Tac Toe we created. Many of the ideas are the same,
but the details are more complicated. First, a player will only choose a
particular column. Your program must then find which row a checker
dropped into that column will fall to. Then, the process of counting
four in a row is more difficult than the three in a row of Tic Tac Toe.
You will need more loops to automate the process fully.</simpara>
</listitem>
<listitem>
<simpara>Once you have mastered the material in
ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>, adapt the
solution to Conway&#8217;s Game of Life from SectionÂ <xref linkend="_solution_game_of_life"/>
to display on a graphical user interface. You can use a
<literal>GridLayout</literal> to arrange a large number of <literal>JLabel</literal> objects in a grid and
update their background colors to <literal>Color.BLACK</literal> and <literal>Color.WHITE</literal> as
needed, using the <literal>setBackground()</literal> method. (To make these colors
visible, you will also need to call the <literal>setOpaque()</literal> method once on
each <literal>JLabel</literal> with an argument of <literal>true</literal>.) The Game of Life is much more
compelling with a real GUI instead of an improvised command line
representation.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Creating arrays with longer and longer lengths requires more
processor time, since the all of those elements must be initialize to
some default value. Using an OS <literal>time</literal> command, determine the amount of
time it takes to create an <literal>int</literal> array of length 10, 10,000, and
10,000,000. In all likelihood, the amount of time that instantiation of
the array takes is a small part of the program, and you should see very
little difference in those three times. However, time is not the only
important resource. When you run a JVM, it has a default heap size that
limits the amount of space you can use to create new objects, including
arrays. When you exceed this size, your program will crash with an
<literal>OutOfMemoryError</literal>. Experiment with different sizes of arrays until you
can estimate the size of your heap within 5MB or so.</simpara>
<simpara>This estimate will be very rough, since the JVM uses other memory in the
background. For a more accurate picture, you can use the<?asciidoc-br?>
<literal>Runtime.getRuntime().maxMemory()</literal> method to determine the maximum JVM
memory size and the<?asciidoc-br?>
<literal>Runtime.getRuntime().totalMemory()</literal> method to determine the total JVM
memory being used.</simpara>
</listitem>
<listitem>
<simpara>Run the implementation of the word search program using the binary
search improvement from ExerciseÂ <xref linkend="exercise:binary_search"/>. Use the OS
<literal>time</literal> command to time the difference between the regular and binary
search versions of the program with a long list of words. You may see
very little difference on small input, but you can easily find a list of
the 1,000 most commonly used words in English on the Internet along with
long, copyright free texts from Project Gutenberg
(<link xl:href="http://www.gutenberg.org/">http://www.gutenberg.org/</link>). Combining these two into a single input
should see a significant increase in speed for the binary search version
relative to the regular version.</simpara>
</listitem>
<listitem>
<simpara>Generate input files consisting of <inlineequation><alt><![CDATA[1,000]]></alt><mathphrase><![CDATA[1,000]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[10,000]]></alt><mathphrase><![CDATA[10,000]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[100,000]]></alt><mathphrase><![CDATA[100,000]]></mathphrase></inlineequation> random <literal>int</literal> values.
Time our implementation of selection sort from
ExampleÂ <xref linkend="example:Selection_sort"/> running on each of these input files
and redirecting output to output files. What is the behavior of the
running time as the input length increases by a factor of 10? As a
function of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, how many times does the body of the inner
<literal>for</literal> loop run during selection sort? Does this function closely
parallel the increase in running time?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Simple_Graphical_User_Interfaces">
<title>Simple Graphical User Interfaces</title>
<blockquote>
<attribution>
Mahatma Gandhi
</attribution>
<simpara>To a true artist only that face is beautiful which, quite apart from its exterior, shines with the
truth within the soul.</simpara>
</blockquote>
<section xml:id="_problem_codon_extractor">
<title>Problem: Codon extractor</title>
<simpara>Recall from ChapterÂ <xref linkend="chapter:Repetition"/> that we can record DNA as a
sequence of nucleotide bases A, C, G, and T. Using this idea, we can
represent any sequence of DNA using a <literal>String</literal> made up of those four
letters, such as <literal>"ATGGAAGTATTTAAATAG"</literal>.</simpara>
<simpara>This particular sequence contains 18 bases and six <emphasis>codons</emphasis>. A codon is
a three-base subsequence in DNA. Biologists are interested in dividing
DNA into codons because a single codon usually maps to the production of
a specific amino acid. Amino acids, in turn, are the building blocks of
proteinS. The DNA sequence above contains the six codons ATG, GAA, GTA,
TTT, AAA, and TAG.</simpara>
<simpara>We want to write a program that extracts codons in order from DNA
sequences entered by the user. The program must detect and inform the
user of invalid DNA sequences (those containing letters other than the
four bases). If the user enters a DNA sequence whose length is not a
multiple of three, the final codon should be written with one or two
asterisks (<literal>*</literal>), representing the missing bases.</simpara>
<simpara>With your knowledge of <literal>String</literal> manipulation and loops, this problem
should be easy. However, we want to solve it with a <emphasis>graphical user
interface</emphasis>, not with the command line interaction we have emphasized in
previous chapters. That is, the input step should be done with a window
that looks similar to the following.</simpara>
<informalfigure role="text-center">
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/codoninput.png" width="50%"/>
</imageobject>
<textobject><phrase>codoninput</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>And the corresponding output should look very much like this.</simpara>
<informalfigure role="text-center">
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/codonoutput.png" width="50%"/>
</imageobject>
<textobject><phrase>codonoutput</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="GUIBasicsIntroductionSection">
<title>Concepts: User interaction</title>
<simpara>Many computer programs communicate with a human user. There are at least
two ways in which this communication can happen. One way is to use
command line input and output. In this case, a program prompts the user
for an input and the user responds through the keyboard, usually
completing the response by pressing the <literal>&lt;return&gt;</literal> or <literal>&lt;enter&gt;</literal> key.
Another way to communicate is to use a graphical user interface or GUI.
(Some people pronounce &#8220;GUI&#8221; to sound like &#8220;gooey,&#8221; but others say
&#8220;G-U-I.&#8221;) In this case, the program displays a window consisting of
one or more <emphasis>widgets</emphasis>, such as a button labeled &#8220;OK&#8221; or a text box in
which the user can type some text. Widgets (also known as controls) can
include buttons, labels, text areas, check boxes, menus, and many other
pre-defined objects for user interaction. While the program waits for
the user or does something in the background, the user has the option of
using a combination of the keyboard and the mouse to respond to the
program. While command line interfaces were dominant until the mid-70s,
GUIs have become the prime mode of communication between a program and a
human user. This chapter focuses on the design of simple GUIs using a
few built-in Java classes. ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/> introduces more advanced tools for constructing complex
GUIs.</simpara>
<example>
<title>User interaction</title>
<simpara>FigureÂ <xref linkend="applicationInterfaceFigure"/>(a) shows a Java application
interacting with a user through a command line interface. The
application asks the user for a temperature value in degrees Fahrenheit,
converts it to the equivalent Celsius, displays it, and prompts the user
to enter another value. FigureÂ <xref linkend="applicationInterfaceFigure"/>(b) shows a
similar application interacting with the user through a GUI. In this
case, the application creates a window with five widgets (two text boxes
and three buttons). The user enters a temperature value in the text box
below either the Centigrade label or the Fahrenheit label and presses
the appropriate Convert button. In turn the application displays the
equivalent temperature in the other text box.</simpara>
<figure role="text-center">
<title>User interaction with a Java application (a)Â through a command line interface and (b)Â through a graphical user interface.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/applicationInterface.svg" width="100%"/>
</imageobject>
<textobject><phrase>applicationInterface</phrase></textobject>
</mediaobject>
</figure>
</example>
<simpara>We describe the GUIs we will introduce in this chapter as simple because
several aspects of GUI creation are hidden by the methods we will use.
For example, these GUIs do not require the programmer to handle the
details of events such as a user pressing an &#8220;OK&#8221; button or typing
text into a text box and pressing the <literal>&lt;enter&gt;</literal> key. These events will
be handled automatically by the tools we will introduce in this chapter.
ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/> discusses the
creation of more complex GUIs that require the programmer to program
event handling explicitly.</simpara>
</section>
<section xml:id="syntax:Dialogs_and_the_JOptionPane_class">
<title>Syntax: Dialogs and the <literal>JOptionPane</literal> class</title>
<simpara><literal>JOptionPane</literal> is a utility class for creating GUIs consisting most often
of a single dialog. It offers a variety of ways to create useful dialogs
quickly and easily and is part of the larger Java Swing GUI library. In
this chapter, we will show you how to use the static methods and
constants in <literal>JOptionPane</literal> to construct useful dialogs. Specifically,
you will learn how to construct the following four types of dialogs.</simpara>
<variablelist>
<varlistentry>
<term>Information</term>
<listitem>
<simpara>An information, or message, dialog displays a message to the user.
Static method <literal>showMessageDialog()</literal> creates such a dialog. See
FigureÂ <xref linkend="simpleMessageFigure"/> for an example of a message dialog.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Confirm</term>
<listitem>
<simpara>A confirm dialog asks a user to confirm a statement. Static method<?asciidoc-br?>
<literal>showConfirmDialog()</literal> creates such a dialog. This dialog may return
user input as <literal>YES_OPTION</literal>, <literal>NO_OPTION</literal>, <literal>OK_OPTION</literal>, or
<literal>CANCEL_OPTION</literal>. See FigureÂ <xref linkend="yes-noDialogFigure"/> for an example of
a Yes-No dialog.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Option</term>
<listitem>
<simpara>An option dialog asks the user to select one from an arbitrary set of
options. Static method <literal>showOptionDialog()</literal> creates such a dialog. See
FigureÂ <xref linkend="CapitalDialogFigure"/> for an example.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Input</term>
<listitem>
<simpara>An input dialog is useful for obtaining data provided by the user.
Static method <literal>showInputDialog()</literal> creates such a dialog. The user can
input a <literal>String</literal> that might represent a number, a name, or any
arbitrary piece of text. See FigureÂ <xref linkend="inputDialogFigure"/> for an
example.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The <literal>JOptionPane</literal> class can be used to create both <emphasis>modal</emphasis> and
<emphasis>non-modal</emphasis> dialogs. A modal dialog is one that forces the user to
interact with the dialog before the program can continue. Thus, the
dialog is dismissed and the program execution resumes only after the
user has responded. Modal dialogs are useful in situations where user
input is required for the program to proceed further.</simpara>
<simpara>A non-modal dialog is one that is displayed on the screen and does not
require the user to interact with it for the underlying program to
proceed. It is easy to create a modal dialog using the static methods in
the <literal>JOptionPane</literal> class mentioned earlier. Creation of non-modal dialogs
requires a bit more effort and is not covered in this chapter. In the
remainder of this chapter we show how to use <literal>JOptionPane</literal> to create
various types of modal dialogs.</simpara>
<section xml:id="informationMessageDialog">
<title>Generating an information dialog</title>
<simpara>Often programs need to generate a message for the user and request a
response. The message might be a short piece of information, and the
only response might be &#8220;OK.&#8221; The message might be more complex and
require a more thoughtful response. In this section, we show how the
Java utility class <literal>JOptionPane</literal> can generate a simple dialog whose sole
purpose is to inform the user that a task has been completed. The next
example shows how to generate such a dialog.</simpara>
<example>
<title>Simple dialog</title>
<simpara>ProgramÂ <xref linkend="program:SimpleDialog"/> creates a dialog to inform the user
that the task it was assigned to perform is now complete.
FigureÂ <xref linkend="simpleMessageFigure"/> shows the dialog generated by this
program.</simpara>
<formalpara xml:id="program:SimpleDialog" xreflabel="SimpleDialog">
<title>Program to generate a simple dialog.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;/*@\label{importSwing}@*/

public class SimpleDialog {
    public static void main(String [] args) {
        JOptionPane.showMessageDialog( null,/*@\label{showMessageDialogLine}@*/
        	"Task completed. Click OK to exit",
            "Simple Dialog", JOptionPane.INFORMATION_MESSAGE);
        System.out.println("Done."); /*@\label{displayMessageLine}@*/
    }
}</programlisting>
</para>
</formalpara>
<simpara>Let&#8217;s dissect ProgramÂ <xref linkend="program:SimpleDialog"/>. LineÂ <xref linkend="importSwing"/> is
needed to import classes used in this program. The <literal>swing</literal> package
contains a number of classes needed to create a GUI, and <literal>JOptionPane</literal>
is one such class. If you try to compile the program without
lineÂ <xref linkend="importSwing"/>, it will fail.</simpara>
<figure role="text-center">
<title>A simple dialog generated using <literal>JOptionPane</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/simpleMessageFigure.svg" width="80%"/>
</imageobject>
<textobject><phrase>simpleMessageFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>In FigureÂ <xref linkend="simpleMessageFigure"/> the dialog titled &#8220;Simple Dialog&#8221;
includes an icon, a message and a button labeled &#8220;OK.&#8221; This dialog is
actually a <emphasis>frame</emphasis>, which is what windows are called in Java. We will
discuss frames in greater detail in SectionÂ <xref linkend="syntax:GUIs_in_Java"/>.</simpara>
<simpara>Note that the appearance of the dialog may be different on your
computer. Even though Java is platform independent, GUIs are customized
based on the OS you are running. Each OS has a default <emphasis>look and feel</emphasis>
(L &amp; F) manager that specifies how widgets look and behave in your
program. You can change the L&amp;F manager, but not all managers are
available on all operating systems.</simpara>
<simpara>LineÂ <xref linkend="showMessageDialogLine"/> and the next two lines use a static
method to create a modal dialog. <literal>JOptionPane</literal> is a utility class and
<literal>showMessageDialog()</literal> is a static method in this class. This method,
along with the other three <literal>JOptionPane</literal> methods we discuss in this
chapter is a <emphasis>factory method</emphasis>, meaning that it creates a new object (in
this case some kind of dialog object) on the fly with specific
attributes. In this example, the program is informing the user that a
task has been completed. The method has the following four parameters.</simpara>
<variablelist>
<varlistentry>
<term>Component</term>
<listitem>
<simpara>The parent component in which the dialog is displayed. We use <literal>null</literal>
in this example, which causes a default frame to be used, centering
the dialog in the screen.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Message</term>
<listitem>
<simpara>The message to be displayed. In this example, we have<?asciidoc-br?>
<literal>"Task completed. Click OK to exit."</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Title</term>
<listitem>
<simpara>The title string used to decorate the dialog. In this example, it is
<literal>"A Simple Dialog"</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Message Type</term>
<listitem>
<simpara>The type of the message to be displayed. In this example, we use the
constant <literal>INFORMATION_MESSAGE</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Icon</term>
<listitem>
<simpara>The icon to be displayed in the dialog. If you have an object of type
<literal>Icon</literal>, you can use it to customize your dialog. The
<literal>showMessageDialog()</literal> is an overloaded method that can take several
different sets of parameters. In this example, we used a version of
the method that does not specify an icon.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>LineÂ <xref linkend="displayMessageLine"/> displays a message on the console which is
not needed in this program but illustrates an interesting point. When
you run <literal>SimpleDialog</literal>, you will notice that the <literal>"Done."</literal> message
displays on the console only after you have clicked the &#8220;OK&#8221; button in
the dialog box. This is the modal behavior we mentioned earlier. The
dialog blocks execution of the thread that generated it.</simpara>
</example>
<simpara>In the above example, we have displayed a message of type
<literal>INFORMATION_MESSAGE</literal>. These are additional message types that could be
used.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ERROR_MESSAGE</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PLAIN_MESSAGE</literal></simpara>
</listitem>
<listitem>
<simpara><literal>QUESTION_MESSAGE</literal></simpara>
</listitem>
<listitem>
<simpara><literal>WARNING_MESSAGE</literal></simpara>
</listitem>
</itemizedlist>
<simpara>When used as parameters in <literal>showMessageDialog()</literal>, the constants above
cause different default icons to be displayed in the dialog box.
FigureÂ <xref linkend="iconsInMessageDialogsFigure"/> shows dialogs generated by
<literal>showMessageDialog()</literal> when using <literal>JOptionPane.ERROR_MESSAGE</literal>, (left)
and <literal>JOptionPane.WARNING_MESSAGE</literal> (right). Note the difference in the
icons displayed towards the top left of the two dialogs.</simpara>
<figure role="text-center">
<title>Two dialogs generated using the <literal>showMessageDialog()</literal> method. The left dialog uses <literal>JOptionPane.ERROR_MESSAGE</literal>, and the right uses <literal>JOptionPane.WARNING_MESSAGE</literal>. The only difference is the icon displayed.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/iconsinMessageDialogsFigure.png" width="100%"/>
</imageobject>
<textobject><phrase>iconsinMessageDialogsFigure</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="yes-noDialog">
<title>Generating a Yes-No confirm dialog</title>
<simpara>There are situations when a program needs to obtain a binary answer from
the user, a &#8220;yes&#8221; or a &#8220;no.&#8221; The next example shows how to generate
such a dialog and how to get the user&#8217;s response.</simpara>
<example>
<title>Yes-No dialog</title>
<simpara>Consider a program that checks whether a student understands the
difference between odd and even integers. The program generates a random
integer <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, presents it to the user, and asks the question,
&#8220;Is <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> an odd integer?&#8221; The answer given by the user is
checked for correctness, and the user is informed accordingly.
ProgramÂ <xref linkend="program:OddEvenTest"/> shows how to use the <literal>JOptionPane</literal> class
to generate a dialog for such an interaction.</simpara>
<formalpara xml:id="program:OddEvenTest" xreflabel="OddEvenTest">
<title>Program that tests knowledge of odd and even integers with a Yes-No dialog.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.util.*;

public class OddEvenTest {
    public static void main(String [] args) {
        Random random = new Random();
		String title = "Odd Even Test";
        int x = random.nextInt(10); //Random int from 0 to 9
        String question = "Is " + x + " an odd integer?";
        int response = JOptionPane.showConfirmDialog(null,/*@\label{yes-noDialogLine}@*/
        		question, title, JOptionPane.YES_NO_OPTION);
		String message;
        // Response is YES_OPTION for Yes, NO_OPTION for No.
        if((response==JOptionPane.YES_OPTION &amp;&amp; x%2 != 0) ||
        	(response==JOptionPane.NO_OPTION &amp;&amp; x%2 == 0))
			message = "You're right!"; /*@\label{correctAnswerLine}@*/
        else
			message = "Sorry, that's incorrect."; /*@\label{incorrectAnswerLine}@*/
        JOptionPane.showMessageDialog(null, message, title,
        	JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
<simpara>ProgramÂ <xref linkend="program:OddEvenTest"/> begins by declaring a random number
generator named <literal>random</literal>. It then generates a random number and presents
it to the user in a dialog created at lineÂ <xref linkend="yes-noDialogLine"/>. Note
the use of <literal>JOptionPane.YES_NO_OPTION</literal> as the last parameter in the
<literal>showConfirmDialog()</literal> method at lineÂ <xref linkend="yes-noDialogLine"/>. The generated
dialog is shown in FigureÂ <xref linkend="yes-noDialogFigure"/>(a). A second dialog is
shown with a message dependent on whether the user gives the correct
answer. The two different versions of this dialog are shown in
FigureÂ <xref linkend="yes-noDialogFigure"/>(b) and (c). Note that a call to
<literal>showConfirmDialog()</literal> at lineÂ <xref linkend="yes-noDialogLine"/> returns the
<literal>JOptionPane.YES_OPTION</literal> or the <literal>JOptionPane.NO_OPTION</literal> value
depending on whether the user clicked the &#8220;Yes&#8221; or &#8220;No&#8221; button.</simpara>
<figure role="text-center">
<title>(a)Â A Yes-No dialog generated using <literal>JOptionPane</literal>. (b)Â Dialog in response to correct answer. (c)Â Dialog in response to incorrect answer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/yes-noDialogFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>yes noDialogFigure</phrase></textobject>
</mediaobject>
</figure>
</example>
<simpara>Because we used <literal>YES_NO_OPTION</literal>, the dialog in
ExampleÂ <xref linkend="example:Yes-No_dialog"/> automatically generates two buttons
labeled &#8220;Yes&#8221; and &#8220;No.&#8221; Dialogs can also use the
<literal>YES_NO_CANCEL_OPTION</literal> to generate a dialog with &#8220;Yes,&#8221; &#8220;No,&#8221; and
&#8220;Cancel&#8221; options. The return value from <literal>showConfirmDialog()</literal> is
<literal>CANCEL_OPTION</literal> if the user presses the &#8220;Cancel&#8221; button. .</simpara>
</section>
<section xml:id="_generating_a_dialog_with_a_list_of_options">
<title>Generating a dialog with a list of options</title>
<simpara>The <literal>JOptionPane</literal> class can also be used to generate an arbitrary set of
options as shown in the next example.</simpara>
<example>
<title>Capital dialog</title>
<simpara>Consider a program that asks the user to select the correct capital of a
country from a given list of capitals. It shows three options and asks
the user to select one from among the three. It then checks the user
response for correctness and displays a suitable message.
ProgramÂ <xref linkend="program:CapitalQuiz"/> performs these tasks. In this program,
we call the <literal>showOptionDialog()</literal> method at lineÂ <xref linkend="multipleOptionsLine"/>
to create a dialog with multiple options. In our case, the options are
three names of capitals, and only one of them is correct.
FigureÂ <xref linkend="CapitalDialogFigure"/> shows the dialog created.</simpara>
<formalpara xml:id="program:CapitalQuiz" xreflabel="CapitalQuiz">
<title>Program to generate a dialog with programmer-defined options.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class CapitalQuiz {
	public static void main(String[] args) {
        String title = "Capital Quiz";
        String country = "Azerbaijan";
        String[] capitals = {"Bujumbura","Baku", "Moroni"};
		int correct = 1; //Baku is the correct answer
        String question = "Select the capital of " + country;
        int response = JOptionPane.showOptionDialog(null, /*@\label{multipleOptionsLine}@*/
        	question, title, JOptionPane.PLAIN_MESSAGE,
        	JOptionPane.QUESTION_MESSAGE, null, capitals, null);
        // Response is 0, 1, or 2 for the three options
		String message;
        if(response == correct)
			message = "You're right!";
		else
			message = "Sorry, the capital of " + country +
			" is " + capitals[correct];
        JOptionPane.showMessageDialog(null, message, title,
        	JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>A dialog with programmer-defined options generated by ProgramÂ <xref linkend="program:CapitalQuiz"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/selectCapitalDialogFigure.png" width="50%"/>
</imageobject>
<textobject><phrase>selectCapitalDialogFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>showOptionDialog()</literal> method creates an options dialog, which is the
most complicated (but also the most flexible) of all the dialogs. The
array of <literal>String</literal> values provided as the second to last parameter to
<literal>showOptionDialog()</literal> gives the labels for the buttons.</simpara>
<simpara>There are three <literal>null</literal> values passed into the method on
lineÂ <xref linkend="multipleOptionsLine"/> in ProgramÂ <xref linkend="program:CapitalQuiz"/>. The
first one functions like the <literal>null</literal> used in
ProgramÂ <xref linkend="program:OddEvenTest"/>, specifying that the default frame
should be used. The second specifies that the default icon should be
used. In the next section, we will show how to specify a custom icon.
The last parameter indicates the default button, which will have focus
when the dialog is created. If the user hits <literal>&lt;enter&gt;</literal> instead of
clicking, the button with focus is the button that will be pressed.</simpara>
</example>
</section>
<section xml:id="customIconDialog">
<title>Generating a dialog with a custom icon</title>
<simpara>A custom icon can be included in any dialog. Each of the methods in
<literal>JOptionPane</literal> introduced earlier can take an icon as a parameter. The
next example illustrates how to do so.</simpara>
<example>
<title>Custom icon</title>
<simpara>ProgramÂ <xref linkend="program:CustomIconDialog"/> shows how to use
<literal>showMessageDialog()</literal> to generate a message dialog with a custom icon.
Note the last parameter at lineÂ <xref linkend="customIconLine"/>. This parameter
creates a new <literal>ImageIcon</literal> object from the <literal>file</literal> <literal>String</literal> (<literal>"bat.png"</literal>
in this case). The resulting dialog appears in
FigureÂ <xref linkend="customIconDialogFigure"/>. Dialogs illustrated in earlier
examples can also use an icon parameter to include a custom icon.</simpara>
<figure role="text-center">
<title>A dialog with a custom icon generated by ProgramÂ <xref linkend="program:CustomIconDialog"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/customIconDialogFigure.png" width="50%"/>
</imageobject>
<textobject><phrase>customIconDialogFigure</phrase></textobject>
</mediaobject>
</figure>
<formalpara xml:id="program:CustomIconDialog" xreflabel="CustomIconDialog">
<title>Program to generate a dialog with a custom icon.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class CustomIconDialog{
    public static void main(String [] args){
		String file = "bat.png";
		String title = "Custom Icon";
		String message = "Some bats eat 3,000 mosquitoes a night.";
		JOptionPane.showMessageDialog(null, message, title,
			JOptionPane.INFORMATION_MESSAGE, new ImageIcon(file));/*@\label{customIconLine}@*/
    }
}</programlisting>
</para>
</formalpara>
<simpara>Note that the icon shown above will not appear when you run this code
unless you have a copy of <literal>bat.png</literal> in the same directory.</simpara>
</example>
</section>
<section xml:id="inputDialog">
<title>Generating an input dialog</title>
<simpara>An input dialog can read text data from the user. The
<literal>showInputDialog()</literal> method in the <literal>JOptionPane</literal> class allows us to
create such a dialog. We introduced the <literal>showInputDialog()</literal> method in
SectionÂ <xref linkend="syntax:Java_basics"/>, but we give two more examples here to
emphasize its similarity to the other <literal>JOptionPane</literal> factory methods and
to show off some of its additional features.</simpara>
<example>
<title>Input dialog</title>
<simpara>We want to write a program that asks a question about basic chemistry.
ProgramÂ <xref linkend="program:ChemistryQuizOne"/> shows how to display a question,
obtain an answer from the user, check for the correctness of the answer,
and report back to the user. At lineÂ <xref linkend="chemistryInputDialogLineOne"/>,
the <literal>showInputDialog()</literal> method is used to generate the dialog shown in
FigureÂ <xref linkend="chemistryQuizFigure"/>(a). This method returns a <literal>String</literal> named
<literal>response</literal> containing the text entered by the user in the dialog box. At
lineÂ <xref linkend="chemistryConvertToIntegerLineOne"/>, this <literal>String</literal> is converted to
an <literal>int</literal> and saved into variable <literal>answer</literal>. This value is checked against
the correct answer, and the <literal>showMessageDialog()</literal> method informs the
user whether or not the answer is correct.</simpara>
<simpara>It is important to note that the user could type any sequence of
characters in the dialog box. Try running
ProgramÂ <xref linkend="program:ChemistryQuizOne"/> and see what happens when you type
&#8220;two,&#8221; instead of the number &#8220;2,&#8221; into the dialog box and press the
&#8220;OK&#8221; button. The program will generate an exception indicating that
the input <literal>String</literal> cannot be converted to an integer.
ExerciseÂ <xref linkend="exercise:inputDialogExceptionExercise"/> asks you to modify
ProgramÂ <xref linkend="program:ChemistryQuizOne"/> so it gracefully handles such
exceptions.</simpara>
<formalpara xml:id="program:ChemistryQuizOne" xreflabel="ChemistryQuizOne">
<title>Program to generate a dialog to input data as text.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class ChemistryQuizOne {
    public static void main(String [] args) {
        String title = "Atoms in Water";
        String query = "How many atoms are in a molecule of water?";
        String response = JOptionPane.showInputDialog(null,/*@\label{chemistryInputDialogLineOne}@*/
        	query, title, JOptionPane.QUESTION_MESSAGE);
        int answer = Integer.parseInt(response);/*@\label{chemistryConvertToIntegerLineOne}@*/
		String message;
        if(answer == 3)
			message = "Good! That's correct!";
		else
			message = "Sorry, that's incorrect.";
        JOptionPane.showMessageDialog(null, message, title,
        	JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>(a) A dialog requesting input as text. (b) A dialog requesting a selection from a list of choices. These dialogs are generated by ProgramsÂ <xref linkend="program:ChemistryQuizOne"/> and <xref linkend="program:ChemistryQuizTwo"/>, respectively.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/inputDialogFigure.svg" width="50%"/>
</imageobject>
<textobject><phrase>inputDialogFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara><anchor xml:id="inputDialogFigure" xreflabel="[inputDialogFigure]"/>[inputDialogFigure]</simpara>
</example>
<example>
<title>Input dialog with a list</title>
<simpara>In ExampleÂ <xref linkend="example:Input_dialog"/> the user is required to enter a
single value. To reduce input errors, we can restrict the user to
picking from a predefined list. We can create this list by generating an
array and supplying it as a parameter to the <literal>showInputDialog()</literal> method.</simpara>
<simpara>ProgramÂ <xref linkend="program:ChemistryQuizTwo"/> displays a list of chemical
elements and asks the user to select the heaviest.
LineÂ <xref linkend="chemistryInputDialogListLineTwo"/> passes an array of four
<literal>String</literal> values to the <literal>showInputDialog()</literal> method. Note that the last
parameter to this method is <literal>null</literal> indicating that no specific item on
the list should be selected by default. (In this case, the first item in
the list is initially selected.) The generated dialog is shown in
FigureÂ <xref linkend="chemistryQuizFigure"/>(b). The four elements are contained in a
drop down list.</simpara>
<formalpara xml:id="program:ChemistryQuizTwo" xreflabel="ChemistryQuizTwo">
<title>Program to generate a dialog to input a choice from a list.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class ChemistryQuizTwo {
    public static void main(String [] args) {
		String title = "Heaviest Element";
        String query = "Which is the heaviest element?";
		String[] elements = {"Iron", "Uranium",	"Copernicium",
			"Nitrogen"};
        String response = (String)JOptionPane.showInputDialog(null, /*@\label{chemistryInputDialogListLineTwo}@*/
        	query, title, JOptionPane.QUESTION_MESSAGE, null,
        	elements, null);
		String message;
        if(response.equals("Copernicium"))
			message = "You're right!";
        else
			message = "Sorry, correct answer: Copernicium.";
		JOptionPane.showMessageDialog(null, message, title,
			JOptionPane.INFORMATION_MESSAGE);
    }
}</programlisting>
</para>
</formalpara>
<simpara>Unlike ExampleÂ <xref linkend="example:Input_dialog"/>, the return value from
<literal>showInputDialog()</literal> is now of type <literal>Object</literal>, not of type <literal>String</literal>. The
type of the list required by the method is <literal>Object</literal> array. (You can pass
a <literal>String</literal> array to a method that wants an <literal>Object</literal> array due to
inheritance, which is further discussed in
ChaptersÂ <xref linkend="chapter:Inheritance"/> and <xref linkend="chapter:Polymorphism"/>.) The
return value is the specific object from the array that was passed in.
In our case, it <emphasis role="strong">has</emphasis> to be a <literal>String</literal>, but Java is not smart enough to
figure that out. For this reason, we cast the object to a <literal>String</literal>
before using the <literal>equals()</literal> method.</simpara>
</example>
<example>
<title>Input dialog with a long list</title>
<figure role="text-center">
<title>A dialog requesting user to select one item from a list of 20 data items. Note the use of a scroll down list to display the items.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/07-gui-basics/images/inputDialogListManyItemsFigure.png" width="50%"/>
</imageobject>
<textobject><phrase>inputDialogListManyItemsFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>When the number of elements in the list supplied to the
<literal>showInputDialog()</literal> is 20 or more, a <literal>JList</literal> object is automatically
used to display the items as shown in
FigureÂ <xref linkend="inputDialogListManyItemsFigure"/>.</simpara>
<simpara>Other than a longer list, the code in this example is virtually
identical to the code for ExampleÂ <xref linkend="example:Input_dialog_with_a_list"/>.</simpara>
</example>
</section>
</section>
<section xml:id="_solution_codon_extractor">
<title>Solution: Codon extractor</title>
<simpara>Here we give the solution to the codon extractor problem posed at the
beginning of the chapter. As we have done throughout this chapter, we
start with the import needed for GUIs built on the Swing framework. Next
we begin the <literal>CodonExtractor</literal> class and its <literal>main()</literal> method. For
readability, the solution to this problem is divided into methods that
each do a specific task. We hope that the way a method works is
intuitively clear to you. If not, the next chapter explains them in
detail.</simpara>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class CodonExtractor {
	public static void main(String [] args) {
		int continueProgram;
        do {
        	// Read DNA sequence
            String input = JOptionPane.showInputDialog(
            		"Enter a DNA sequence");/*@\label{DNAInputLine}@*/
            input = input.toUpperCase(); // Make upper case
			String message = "Do you want to continue?";
            if( isValid(input) ) // Check for validity
                displayCodons(input); // Find codons
            else
				message = "Invalid DNA Sequence.\n" + message;
			continueProgram = JOptionPane.showConfirmDialog(
				null, message, "Alert", JOptionPane.YES_NO_OPTION);
        } while(continueProgram == JOptionPane.YES_OPTION);
        JOptionPane.showMessageDialog(null,
        	"Thanks for using the Codon Extractor!");
    }</programlisting>
<simpara>The <literal>main()</literal> method contains a <literal>do-while</literal> loop that allows the user to
enter sequences repeatedly. The <literal>showInputDialog()</literal> method makes an
input dialog and returns the <literal>String</literal> the user enters. The
<literal>toUpperCase()</literal> method converts the <literal>String</literal> to upper case, allowing us
to read input in either case.</simpara>
<simpara>We then call the <literal>isValid()</literal> method to make sure that the user entered a
valid DNA sequence. If it is valid, we use <literal>displayCodons()</literal> to display
the codons in the sequence. Either way, we use a <literal>showConfirmDialog()</literal>
method to creating a confirm dialog, asking the user if he or she wants
to continue entering sequences. The loop will continue as long as the
return value is <literal>JOptionPane.YES_OPTION</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">    public static boolean isValid( String DNA ) {
        String validBases = "ACGT";
        for( int i = 0; i &lt; DNA.length(); i++) {
			char base = DNA.charAt(i);
            if( validBases.indexOf( base ) == -1 )
				return false; //base not in "ACGT"
        }
        return true;
    }</programlisting>
<simpara>The <literal>isValid()</literal> method checks to see if the DNA contains only the
letters representing the four bases. To do this, we use the Java
<literal>String</literal> library cleverly: We loop through the characters in our input,
checking to see where they can be found in <literal>"ACGT"</literal>. If the index
returned is -1, the character was not found, and the DNA is invalid.</simpara>
<programlisting language="java" linenumbering="numbered">    public static void displayCodons(String DNA) {
        String message = "";
		// Get as many complete codons as possible
        for (int i = 0; i &lt; DNA.length() - 2; i += 3)
            message += "\n" + DNA.substring(i, i + 3);
		// 1-2 bases might be left over
        int remaining = DNA.length() % 3;
        if( remaining == 1 )
            message += "\n"+ DNA.substring(DNA.length() - 1,
            	DNA.length()) + "**";
        else if( remaining == 2 )
            message += "\n"+ DNA.substring(DNA.length() - 2,
            	DNA.length()) + "*";
        message = "DNA length: " + DNA.length() +
        	"\n\nCodons: " + message;
        JOptionPane.showMessageDialog(null, message,
        	"Codons in DNA", JOptionPane.INFORMATION_MESSAGE);/*@\label{codonDisplayLine2}@*/
    }
}</programlisting>
<simpara>In the <literal>displayCodons()</literal> method, we display the individual codons to the
user. We build a large <literal>String</literal> with newlines separating each codon. To
do so, we loop through the input, jumping ahead three characters each
time. If the input length is not a multiple of three, we pad with
asterisks. Finally, we use the <literal>showMessageDialog()</literal> method to display
an information dialog with the list of codons.</simpara>
</section>
<section xml:id="_concurrency_simple_guis">
<title>Concurrency: Simple GUIs</title>
<simpara>Many GUI frameworks (including Swing) are built on a multi-threaded
model. Swing uses threads to redraw widgets and listen for user input
while the main thread can continue processing other data.</simpara>
<simpara>In this chapter, the impact of these threads is minimal because we used
only <emphasis role="strong">modal</emphasis> dialogs. Every time we called a <literal>JOptionPane</literal> method, the
execution of the program&#8217;s main thread had to wait until the method
returned. As it turns out, several threads are created when
<literal>showInputDialog()</literal> or any of the others dialog methods are called, but
they do not interact with the main thread since it has been blocked.</simpara>
<simpara>The situation is more complicated with a non-modal dialog, which is one
of the reasons we did not go into them. In a non-modal dialog, the
threads that redraw the dialog and handle its events (like a user
clicking on a button) are running at the same time as the thread that
created the dialog. Since many threads are running, it is possible for
them to write to the same data at the same time. Doing so can lead to
inconsistencies such as the ones we will describe in
ChapterÂ <xref linkend="chapter:Synchronization"/>.</simpara>
<simpara>The GUIs we will create in ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>, however, will be more than dialogs. They will be fully
functional windows, known as frames in Java. Like a non-modal dialog,
the creation of a frame does not block the thread that created it.</simpara>
<simpara>Many applications launch a frame and then end their main thread. If no
other threads are created, life is relatively easy. However, complex
applications may create multiple frames or launch threads to work on
tasks in the background. Another common problem is caused by performing
complicated tasks in the event handler for a GUI. If a task takes too
long, the GUI can freeze or become unresponsive, as you have probably
experienced. The fact that this problem happens so frequently even in
the latest operating systems should hint at the difficulty of managing
GUI threads.</simpara>
<simpara>When we describe how to create fully featured GUIs in
ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>, we will also
give some techniques to help with avoiding unresponsive GUIs in a
multi-threaded environment.</simpara>
</section>
<section xml:id="_summary_4">
<title>Summary</title>
<simpara>In this chapter we have introduced a way to create simple GUIs. These
GUIs are created using various methods available in the <literal>JOptionPane</literal>
class. While the interfaces created this way are simple in nature, they
are often adequate for input and output in short Java programs.
Construction of more complex GUIs is the subject of
ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>.</simpara>
</section>
<section xml:id="_exercises_6">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>In which situations would it be better to use a command-line
interface instead of a GUI? When is it better to use a GUI over a
command-line interface?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:modalNonmodalDialogExercise"/> Explain the difference
between a modal and a non-modal dialog. Give an example of when you
would prefer a modal over non-modal dialog, and another example of when
you would prefer a non-modal to a modal dialog.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:messageTypeConstantsExercise"/> Give one example each when
you would use the five different message type constants in
<literal>showMessageDialog()</literal> method (see pageÂ  for a listing of the five
constants).</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:yesNoDialogExercise"/> In ProgramÂ <xref linkend="program:OddEvenTest"/>,
we could have coded lineÂ <xref linkend="yes-noDialogLine"/> as follows without
changing the program behavior.</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">if( (response == 0 &amp;&amp; x % 2 != 0) ||
    (response == 1 &amp;&amp; x % 2 == 0) )</programlisting>
<simpara>Yet another option is below.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( response != x % 2 )</programlisting>
<simpara>Which of these three implementations is best? Why?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis>
5.  Modify the program in ExampleÂ <xref linkend="example:Yes-No_dialog"/> such that it
tests the user several times, say 25 times, whether a randomly generated
integer is odd or even. The program should keep a score indicating the
number of correct answers. At the end of the test the score is displayed
using a suitable dialog.
6.  Modify the program in ExampleÂ <xref linkend="example:Yes-No_dialog"/> such that it
displays a dialog that asks the user &#8220;Do you wish to continue?&#8221; and
offers options &#8220;Yes&#8221; and &#8220;No.&#8221; The program exits the loop when the
&#8220;No&#8221; option is selected and displays the score using a suitable
dialog.
7.  <xref linkend="exercise:cancelButtonExercise"/> Rewrite
ProgramÂ <xref linkend="program:OddEvenTest"/> so that the confirmatory dialog
generated offers the &#8220;Yes,&#8221; &#8220;No,&#8221; and &#8220;Cancel&#8221; options to the
user. The program exits with a message dialog saying &#8220;Thank You&#8221; when
the user selects the &#8220;Cancel&#8221; option.
8.  <xref linkend="exercise:CapitolDialogExercise"/> Modify
ProgramÂ <xref linkend="program:CapitalQuiz"/> to create and administer a test wherein
the user is asked capitals of 10 countries in a sequence. The program
must keep count of the score, i.e., the number of correct answers.
Inform the user of the score at the end of the test using a suitable
dialog.
9.  <xref linkend="exercise:focusOptionExercise"/> Modify lineÂ <xref linkend="multipleOptionsLine"/>
in ProgramÂ <xref linkend="program:CapitalQuiz"/> so that the button labeled &#8220;Baku&#8221;
has focus.
10. <xref linkend="exercise:randomizeCapitalsExercise"/> SectionÂ <xref linkend="solution:Three card
poker"/> gives a method called <literal>shuffle()</literal> that is used to randomize an
array representing a deck of cards. Adapt this code and modify
ProgramÂ <xref linkend="program:CapitalQuiz"/> so that the order of the capitals is
randomized. Note that you will have to record which index contains the
correct answer.
11. Re-implement the solution to the college cost calculator problem
given in SectionÂ <xref linkend="solution:College_cost_calculator"/> so that it uses
GUIs constructed with <literal>JOptionPane</literal> for input and output.
12. Re-implement the solution to the Monty Hall problem given in
SectionÂ <xref linkend="solution:Monty_Hall"/> so that it uses GUIs constructed with
<literal>JOptionPane</literal> for input and output.
13. Re-implement the solution to the DNA searching problem given in
SectionÂ <xref linkend="solution:DNA_searching"/> so that it uses GUIs constructed with
<literal>JOptionPane</literal> for input and output.
14. Write a program that creates an input dialog that prompts and reads
a file name of an image from the user. Then, create an information
dialog that displays the file as a custom icon. In this way, you can
construct a simple image viewer.
15. <xref linkend="exercise:inputDialogExceptionExercise"/> <emphasis role="strong">Note: You should attempt
this exercise only if you are familiar with exceptions in Java.
Exceptions are covered in ChapterÂ <xref linkend="chapter:Exceptions"/>.</emphasis><?asciidoc-br?>
Use the <literal>try-catch</literal> block and modify
ProgramÂ <xref linkend="program:ChemistryQuizOne"/> so that it handles an exception
generated when the user enters a string that cannot be converted to an
integer. In the event such an exception is raised, pop up a message
dialog box informing the user to try again and type an integer value.
When the user responds by clicking the &#8220;OK&#8221; button on this message
box, the input dialog box should appear once again and offer the user
another chance at the answer. Write two versions of the modified
program. In one version, your program should give only one chance for
input after an incorrect string has been typed. In another version, your
program should remain in a loop until the user enters a valid integer
(note that a valid integer might not be the correct answer to the
question asked).</simpara>
</section>
</chapter>
<chapter xml:id="chapter:Methods">
<title>Methods</title>
<blockquote>
<attribution>
William Shakespeare
</attribution>
<simpara>Polonius (Aside): Though this be madness, yet there is method in &#8217;t.</simpara>
</blockquote>
<section xml:id="_problem_three_card_poker">
<title>Problem: Three card poker</title>
<simpara>Gambling has held a fascination for humankind since its invention. As
long as there have been mathematicians, they have studied the underlying
mechanisms of probability and statistics that drive games of chance. A
classic game of both statistics and strategy is poker. The problem we
want to solve is programming one of the many variations of poker, called
three card poker. Instead of bluffing, a player competes only with the
house according to fixed rules without any room for psychology. A player
is dealt three cards. If the playerâs hand contains a pair or better, he
or she wins a payoff greater than or equal to the money bet. If the
player does not have a pair or better, he or she loses the money bet.
Below is a table giving one possible set of payoffs for each possible
hand.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Hand</entry>
<entry align="center" valign="top">Payoff</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>Straight Flush</simpara></entry>
<entry align="center" valign="top"><simpara>40</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Three of a Kind</simpara></entry>
<entry align="center" valign="top"><simpara>30</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Straight</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Flush</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Pair</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Nothing</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If you are unfamiliar with poker rules or card games in general, here is
a quick explanation of the various hands. A traditional English or
American deck of cards is made up of 52 cards, organized into four
suits: spades, hearts, diamonds, and clubs. In each suit, there are 13
ranks: two, three, four, five, six, seven, eight, nine, ten, jack,
queen, king, and ace.</simpara>
<simpara>In three card poker, a straight is when the three cards can be arranged
so that their ranks (ignoring suit) are in order. For example, a hand
consisting of a Four of Diamonds, a Five of Spades, and a Six of Clubs
would constitute a straight. An ace can serve as either the highest rank
card (coming after a king) or the lowest rank card (coming before a two)
and can help form a straight in either role (but not both at the same
time). A flush is when all three cards have the same suit. For example,
a Three of Hearts, a Seven of Hearts, and a Jack of Hearts would
constitute a flush in three card poker. A straight flush, the highest
hand, is made up of cards that form both a straight (by rank ordering)
and a flush (by uniformity of suit). A three of a kind occurs when all
three cards have the same rank, and a pair occurs when two of the cards
have the same rank. When none of these conditions hold, the hand has no
special designation in three card poker, and the bet is lost.</simpara>
<simpara>Your task is to write a program that serves as a computerized version of
the game. You must create a deck of 52 cards, thoroughly randomize them
to simulate shuffling, and select the first three cards as a hand. You
must then determine the highest designation that applies to the hand of
cards and the corresponding winnings (if any).</simpara>
<simpara>Any reasonable solution to this problem uses arrays, discussed in the
previous chapter. Using only that knowledge, you should be able to
create a three card poker game. However, the focus of this chapter is
<emphasis>methods</emphasis>, which can be used to break the solution to a problem into
logical pieces. By dividing the solution in this way, we will be able to
solve the three card poker problem in a relatively short, elegant, and
easy to read way.</simpara>
</section>
<section xml:id="_concepts_dividing_work_into_segments">
<title>Concepts: Dividing work into segments</title>
<simpara>You should notice that the solutions to problems we have been working on
have become increasingly complex as the book progresses. Partly, this
tendency is due to the fact that interesting problems tend to have
complex solutions. Partly, it is due to the fact that more advanced
features in Java are generally designed to tackle more complicated
problems.</simpara>
<simpara>The tools we introduce in this chapter do not allow you to solve a
problem you could not solve before. Instead, the tools in this chapter
and in the next one make solving a problem easier and less susceptible
to errors. A relatively long, complicated list of Java statements was
necessary to solve problems like the statistics program or Conwayâs Game
of Life. Instead of solving those problems as a single monolithic
segment of code, we can break our solutions into units called <emphasis>static
methods</emphasis>.</simpara>
<section xml:id="_reasons_for_literal_static_literal_methods">
<title>Reasons for <literal>static</literal> methods</title>
<simpara>A static method is a short, named segment of code that has been packaged
up so that it can be <emphasis>called</emphasis> from other parts of the program. Whenever
the task performed by this method is needed, the execution of the
program jumps to the code in the method, does the work it is supposed
to, and then returns to whatever it was doing before.</simpara>
<simpara>The reasons for using static methods can be boiled down to three
essentials:</simpara>
<variablelist>
<varlistentry>
<term>Modularity</term>
<listitem>
<simpara>Very little software development is done by individuals. Commercial
software can have tens or even hundreds of programmers involved in
designing, implementing, testing, and maintaining code. When the code
is divided into individual methods, those methods can be written and
tested by different people with minimal interference. It is much
harder to work together on one giant block of code.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Readability</term>
<listitem>
<simpara>Methods are <emphasis role="strong">named</emphasis> segments of code. When a method is called, its
name is used. If a meaningful name is chosen, the line in the code
that calls the method helps document the code by explaining what is
happening. For example, if a method called <literal>sort()</literal> is used, a reader
instantly understands that something is being sorted. If, instead of a
separate <literal>sort()</literal> method, the code for selection sort were pasted into
the same location, a reader might have to devote a few moments to
understanding the meaning of those lines of code, particularly without
comments.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Reusability</term>
<listitem>
<simpara>The fact that a method can be called from anywhere in the code makes
it reusable. To use the <literal>sort()</literal> example again, we might have to sort
several different arrays in one program. Without methods, we would
have to keep copying and pasting code over and over again. With
methods, the total amount of source code can be smaller. In fact, if
you find yourself copying and pasting code, it is often an indication
that a method would be useful.
+
This idea of reusability stretches beyond individual programs. A
static method can be called from a different program entirely. If you
create a method that is really useful, you are free to use it in other
programs you may write. By doing so, you only have to makes changes in
one place if you discover errors or want to increase its
functionality.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_parallel_to_mathematical_functions">
<title>Parallel to mathematical functions</title>
<simpara>We have been discussing the usefulness of static methods without saying
exactly what they are. One way to get insight into methods is by
acknowledging their similarity to functions from mathematics. In
procedural (non-object oriented) languages like C, the equivalent of
static methods are usually referred to as functions, in fact. Like
functions in mathematics, a static method takes some number of inputs
(though, as few as zero) and usually produces some output.</simpara>
<simpara>You have already used several static methods from the <literal>Math</literal> class, such
as <literal>Math.sqrt()</literal>. The expression <inlineequation><alt><![CDATA[f(x) = \sqrt{x}]]></alt><mathphrase><![CDATA[f(x) = \sqrt{x}]]></mathphrase></inlineequation> defines
what <inlineequation><alt><![CDATA[f(x)]]></alt><mathphrase><![CDATA[f(x)]]></mathphrase></inlineequation> does in the same way that the code inside of
<literal>Math.sqrt()</literal> does. When you want to use <inlineequation><alt><![CDATA[f(x)]]></alt><mathphrase><![CDATA[f(x)]]></mathphrase></inlineequation> for a
specific value, you can set <inlineequation><alt><![CDATA[y = f(5)]]></alt><mathphrase><![CDATA[y = f(5)]]></mathphrase></inlineequation> in the same way that
you might type the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">double y = Math.sqrt(5);</programlisting>
<simpara>In the statement <inlineequation><alt><![CDATA[f(5)]]></alt><mathphrase><![CDATA[f(5)]]></mathphrase></inlineequation>, the value of <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> is
replaced by <inlineequation><alt><![CDATA[5]]></alt><mathphrase><![CDATA[5]]></mathphrase></inlineequation>. In the same way, some variable inside of
<literal>Math.sqrt()</literal> takes on the value <literal>5</literal> when the method is called.</simpara>
<simpara>It is important to understand this similarity between methods and
mathematical functions because the designers of many programming
languages have been directly influenced by the older notation. However,
there are many differences between the two concepts as well.
Mathematical functions can take more than one input, and so can Java
methods. Methods can also take no input, while the whole point of a
mathematical function is to map some input value(s) to some output
value. Java methods do not necessarily even have output values. They may
just <emphasis role="strong">do</emphasis> something.</simpara>
</section>
<section xml:id="_control_flow">
<title>Control flow</title>
<simpara>We have discussed selection statements such as <literal>if</literal> and <literal>switch</literal> as well
as three different looping structures, <literal>for</literal>, <literal>while</literal>, and <literal>do-while</literal>.
Each of these Java language features is used for control flow. The
selection statements allow your program to choose which code to execute.
The loops allow your code to repeatedly execute certain code. Methods
also affect control flow. When a method is called, the execution of the
program jumps into the method, does all the work it needs to there, and
then returns to the code that called it. Recall the very simple example
from above.</simpara>
<programlisting language="java" linenumbering="unnumbered">double y = Math.sqrt(5);</programlisting>
<simpara>The JVM has allocated a variable of type <literal>double</literal> and is preparing to
assign a value to it. Suddenly, the execution of the JVM jumps into the
code inside of the <literal>Math.sqrt()</literal> method. It takes some non-trivial
amount of work to compute the square root of a number. After that
computation is finished, the flow of execution returns to the assignment
that has been waiting all that time. Just like a mathematical function,
we can treat the method call <literal>Math.sqrt(5)</literal> as if it were &#8220;magically&#8221;
replaced by a <literal>double</literal> approximating the square root of 5.</simpara>
</section>
</section>
<section xml:id="_syntax_methods">
<title>Syntax: Methods</title>
<simpara>By now, you should have a good feel for the concepts behind calling and
even creating static methods and are probably getting impatient to use
them. There are a number of issues of method syntax in Java you should
be aware of. First, we describe how you can create your own static
methods, then discuss the finer points of calling static methods, and
finally explain how <emphasis>class variables</emphasis> can be used from many different
methods.</simpara>
<section xml:id="_defining_methods">
<title>Defining methods</title>
<simpara>A very simple method that the <literal>Math</literal> class provides is the <literal>Math.max()</literal>
method. This method selects the larger of two values that you give it as
input.</simpara>
<programlisting language="java" linenumbering="unnumbered">int maximum = Math.max(5, 10);</programlisting>
<simpara>In this case, the value stored into <literal>maximum</literal> is <literal>10</literal>. Despite its
simplicity, we demonstrated how useful this method could be in our
solution to Conwayâs Game of Life from ChapterÂ <xref linkend="chapter:Arrays"/>. If we
wanted to write this method ourselves, the code would be as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int max( int a, int b ) {
    if( a &gt;= b )
        return a;
    else
        return b;
}</programlisting>
<simpara>Even in such a small method, there are a lot of pieces of syntax to
worry about. The first line of this method is called the <emphasis>method
header</emphasis>. The <literal>public</literal> keyword in this header is used to denote that any
code, even code from a different class, can call this method. We discuss
restricting access to methods and variables more in the later part of
this chapter. For now, assume that every method is <literal>public</literal>.</simpara>
<simpara>The keyword <literal>static</literal> indicates that this method is static. Although we
have used the term <emphasis>static method</emphasis> many times, we have not yet defined
it. A static method is linked to a whole class, not to a specific object
of that classâthat is, a static method can be called without referencing
an object of the class. Again, we discuss the finer points of objects
and classes in the next chapter. For now, all methods are <literal>static</literal>.</simpara>
<simpara>The third keyword in the method header is the familiar <literal>int</literal>, giving the
return type of the method. Wherever this method is called, it can be
treated like an <literal>int</literal> value, because that is what it gives back. In this
case, the return type is obvious: The maximum of two <literal>int</literal> values must
also be an <literal>int</literal> value. Any type can be used as a return value including
all the primitive types and any reference or array types. The only
limitation is that a method can only return a single item, but, since
that item can be an array, this limitation is usually not important. It
is also possible for a method to return nothing. In that case, the
keyword <literal>void</literal> is used for the return type.</simpara>
<simpara>Next in the method header is the identifier <literal>max</literal>, which is the name of
the method. Any legal identifier that you can use for a variable name is
valid for a method name as well. It is important to pick a name that is
readable and gives a reader a clear idea about what the method does. A
common convention is to name a method using a verb phrase, indicating
the operation that is being done by that method (e.g., <literal>computeTax</literal>).
Like variable names, the Java standard is to use camel notation,
starting with a lowercase letter and capitalizing the first letter of
each new word in the name.</simpara>
<simpara>After the name of the method is the list of the <emphasis>parameters</emphasis>, separated
by commas. In this case, each parameter has the <literal>int</literal> type. You are free
to name your parameters whatever you want, though they should be
meaningful. You can have as few as zero parameters, but there is an
upper limit imposed by the JVM, usually 255. The body of the method
follows the header of the method, surrounded by braces (<literal>\{\}</literal>). Unlike
<literal>if</literal> statements and loops, the braces for methods are required.</simpara>
<simpara>Inside the body of a method, the usual rules for Java control flow
apply. Each line is executed line by line unless there are selection
statements or loops. Calling methods inside of methods is allowed as
well. In the <literal>max()</literal> method, we use an <literal>if-else</literal> construction to find
the larger of <literal>a</literal> and <literal>b</literal>. A <literal>return</literal> statement immediately stops
execution of the method, transfers execution back to the calling code,
and gives back the value that comes after it. In this case, the value of
<literal>a</literal> is returned if it is equal or larger, and the value of <literal>b</literal> is
returned otherwise. Because a <literal>return</literal> statement immediately jumps out
of a method, we could have written the method with one fewer line of
code.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int max( int a, int b ) {
    if( a &gt;= b )
        return a;
    return b;
}</programlisting>
<simpara>The only way that the line <literal>return b;</literal> can be reached is if <literal>a</literal> had not
already been returned.</simpara>
<section xml:id="_the_literal_main_literal_method">
<title>The <literal>main()</literal> method</title>
<simpara>If some of this syntax seems eerily familiar, remember that you have
been coding static methods since your very first Java program. The
<literal>main()</literal> method is just another static method, special only because the
JVM chooses to start execution there. Letâs look at the <literal>main()</literal> method
from a standard Hello, World! program.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void main( String[] args ) {
    System.out.println("Hello, world!");
    return;
}</programlisting>
<simpara>Just like the <literal>max()</literal> method, the header for <literal>main()</literal> starts with
<literal>public static</literal>. Then, the return type for <literal>main()</literal> is <literal>void</literal> because
the JVM is not expecting to get any answer back. The <literal>main()</literal> method has
a single parameter, an array of type <literal>String</literal>. In this program, we do
not use the <literal>args</literal> parameter, but it is available. For the <literal>main()</literal>
method, this declaration is fine, because <literal>main()</literal> has to be uniform
across all programs. However, when designing your own methods, you
should not include unnecessary parameters.</simpara>
<simpara>The final executable line in this <literal>main()</literal> method is a <literal>return</literal>
statement. Because <literal>main()</literal> has a <literal>void</literal> return type, the <literal>return</literal>
statement has no value to return. For <literal>void</literal> methods, a <literal>return</literal>
statement is optional. You can use it to leave a method early, if
desired. For a value-returning method, execution must reach a <literal>return</literal>
statement with a valid value no matter what the input of the method is.
If Java finds a way that execution could reach the end of a value
returning method without reaching a <literal>return</literal> statement, it causes a
compiler error.</simpara>
</section>
<section xml:id="subsubsection:Overloaded_methods">
<title>Overloaded methods</title>
<simpara>Since this declaration is in another class, it is OK to create a <literal>max()</literal>
method even though there is already one in the <literal>Math</literal> class. However, it
is possible to create more than one method with the same name in the
same class, provided that their <emphasis>signatures</emphasis> are not the same. Two
methods have the same <emphasis>signature</emphasis> if they have the same name and
parameter types.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int max( int a, int b, int c ) {
    return max(max(a, b), c);
}</programlisting>
<simpara>In this example, we have created yet another <literal>max()</literal> method, but this
one takes three parameters instead of two. This method even calls the
two parameter version of <literal>max()</literal>. Creating more than one method with the
same name is called <emphasis>overloading</emphasis> those methods. Overloading methods is
useful because it allows you to use the same method name for similar
functionality, even when there are some underlying differences in the
implementation. For example, the <literal>Math</literal> class provides four different,
overloaded versions of the <literal>max()</literal> method, specialized for <literal>int</literal>,
<literal>long</literal>, <literal>float</literal>, and <literal>double</literal> values, respectively.</simpara>
<simpara>There are limitations on creating overloaded methods, of course. The
compiler must be able to determine which method you intend to use. Thus,
the signatures have to vary by type or number of parameters. A different
return type is not enough.</simpara>
</section>
</section>
<section xml:id="_calling_methods">
<title>Calling methods</title>
<simpara>After a method has been defined, it must be called before it does
anything. You have plenty of experience calling static methods like
<literal>Math.sqrt()</literal> and <literal>Math.max()</literal>. An example of the appropriate syntax was
given earlier.</simpara>
<programlisting language="java" linenumbering="unnumbered">int maximum = Math.max(5, 10);</programlisting>
<simpara>Formally, the call starts with the name of the class (<literal>Math</literal>), followed
by a dot, followed by the name of the method (<literal>max</literal>), followed by the
list of <emphasis>arguments</emphasis> inside parentheses. These arguments are the values
you want to <emphasis>pass</emphasis> into the method. Some books use the term <emphasis>formal
parameters</emphasis> to describe the variables defined in the method signature
and <emphasis>actual parameters</emphasis> to describe the values passed into the methods,
but we stick with the simpler terms parameters and arguments.</simpara>
<simpara>Of course, the number of arguments must match the number of parameters
defined by the method, and the types must match as well. Java performs
automatic casting when no precision is lost. Thus, you can always supply
an <literal>int</literal> argument for a <literal>double</literal> parameter, but not the reverse.
Arguments can be literal values, variables, or even other method calls
that return the appropriate type.</simpara>
<simpara>Using the <literal>max()</literal> method defined before, we could rewrite our simple
example without a class name.</simpara>
<programlisting language="java" linenumbering="unnumbered">int maximum = max(5, 10);</programlisting>
<simpara>Whenever you call a static method from code that is inside the same
class, you can leave out the class name.</simpara>
<section xml:id="_binding">
<title>Binding</title>
<simpara>Many new programmers are confused about the relationship between
arguments and parameters. The process of supplying an argument to be
used as a parameter is called <emphasis>binding</emphasis>. Through binding, a value or
variable from the calling code is given a new name inside of a method.
Consider the following method.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int add( int a, int b ) {
    return a + b;
}</programlisting>
<simpara>This absurdly short method adds two numbers together and returns the
result, approximating the functionality of the <literal>+</literal> operator. We could
call the method in the following context.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 3;
int y = 5;
int z = add( x, y );</programlisting>
<simpara>Inside the method, the value of <literal>x</literal> is bound to the variable <literal>a</literal>, and
the value of <literal>y</literal> is bound to the variable <literal>b</literal>. The <literal>add()</literal> method has
its own <emphasis>scope</emphasis>. Scope means the area where a variable name is visible
(or meaningful). Thus, <literal>x</literal> and <literal>y</literal> do not exist inside of the <literal>add()</literal>
method, only the variables <literal>a</literal> and <literal>b</literal> do. Since methods have their own
scope, variables in one method can have the same names as variables in
another method without the compiler (or the programmer!) becoming
confused. Consider the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">int a = 3;
int b = 5;
int c = add( b, a );</programlisting>
<simpara>Here the variables <literal>a</literal> and <literal>b</literal> exist in both the calling code and inside
the method, but the names are independent. The value of <literal>a</literal> in the
calling code happens to be bound to a variable called <literal>b</literal> inside the
method, but the JVM has no confusion about which <literal>a</literal> is which. Herein
lies the value of methods: They are largely independent of whatever else
is going on in the code, allowing the programmer to focus on a small,
manageable task.</simpara>
<simpara>Another important feature of Java is that the process of binding
variables is <emphasis>pass by value</emphasis>, meaning that only the <emphasis role="strong">value</emphasis> of the
argument is bound to the parameter. Whenever a method is called, the
method creates a new variable for each parameter and copies the value of
its argument into it. In practice, this approach means that a method
cannot directly change the value of an argument. Consider the following
method:</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void increment( int counter ) {
    counter++;
}</programlisting>
<simpara>This method takes the value of its argument and copies it into the new
variable <literal>counter</literal>. Then, it increments <literal>counter</literal>, but the original
argument is unchanged. Thus, the following fragment is an infinite loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 0;
while( i &lt; 100 )
    increment( i );</programlisting>
<simpara>The value of <literal>i</literal> remains fixed at <literal>0</literal> for the entire program. The copy
of <literal>i</literal> bound to <literal>counter</literal> increases to <literal>1</literal> every time <literal>increment()</literal> is
called, but <literal>i</literal> remains unaffected.</simpara>
<simpara>This is not to say that a method cannot affect the variables outside of
itself. The primary way that it can do so is by using <literal>return</literal>
statements. We can rewrite <literal>increment()</literal> to achieve this effect.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int increment( int counter ) {
    counter++;
    return counter;
}</programlisting>
<simpara>Then, we need to adjust the loop so that it stores the returned value
instead of dropping it on the floor.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 0;
while( i &lt; 100 )
    i = increment( i );</programlisting>
<simpara>A second way that methods can affect the values of outside variables is
more indirect. In Java, every argument is passed by value, even arrays
and objects. Practically, this means that, if a reference to an array is
passed into a method, you cannot change which array it is pointing at.
Since references are not values but names pointing at a particular
location in memory, you can directly change the contents of that memory
with a method, even if you canât change which locations are being
referenced. For example, the following method does <emphasis role="strong">not</emphasis> reverse the
order of an array.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void badReverseArray( int[] array ) {
    int[] temp = new int[array.length];
    for( int i = 0; i &lt; array.length; i++ )
        temp[i] = array[array.length - i - 1];
    array = temp;
}</programlisting>
<simpara>Although this code does store a reversed version of <literal>array</literal> in <literal>temp</literal>,
the last line of the method is meaningless: The array passed into the
method still points to the original location in memory. We can rewrite
the method to do the reversal <emphasis>in place</emphasis>, meaning that the values of the
array are shuffled around, but the array still occupies the same memory
locations.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void goodReverseArray( int[] array ) {
    int temp;
    for( int i = 0; i &lt; array.length / 2; i++ ) {
        temp = array[i];
        array[i] = array[array.length - i - 1];
        array[array.length - i - 1] = temp;
    }
}</programlisting>
<simpara>In this version of the method, we swap the first element of the array
with the last, the second with the second to last, and so on. We only go
up to the halfway point of the array, otherwise we undo the reversal
process. The values of the array are reversed, but they still occupy the
same chunk of memory. It is possible to write a correct method more in
the style of <literal>badReverseArray()</literal> which creates a temporary array, copies
the original values into it, and then copies them back to the original
array in reverse order, but it is less efficient to create the extra
array and perform two copies.</simpara>
</section>
</section>
<section xml:id="subsection:class_variables">
<title>Class variables</title>
<simpara>According to the rules we have given so far, the only legal variables in
the scope of a static method are the parameters and any other <emphasis>local</emphasis>
variables declared inside the method. However, it is possible to create
a variable that exists outside of static methods yet is visible inside
all of them. These kinds of variables are called <emphasis>class variables</emphasis> (or
sometimes <emphasis>static fields</emphasis> or <emphasis>global variables</emphasis>). These variables
persist <emphasis role="strong">between</emphasis> method calls. The syntax for creating such a variable
is to declare it outside of all methods (but inside the class) with an
access modifier such as <literal>public</literal> or <literal>private</literal>, and the keyword <literal>static</literal>.
For example, the following class includes a method called <literal>record()</literal>
that increases the class variable <literal>counter</literal> every time it is called.</simpara>
<formalpara xml:id="program:Bookkeeper" xreflabel="Bookkeeper">
<title>A program that keeps track of the number of times the <literal>record()</literal> method is called.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Bookkeeper {
	public static int counter = 0;

	public static void main(String[] args ) {
		while( Math.random() &gt; 0.001 )
			record();

		System.out.println("Record was called " + counter +
			" times.");
	}

	public static void record() {
		counter++;
	}
}</programlisting>
</para>
</formalpara>
<simpara>When run, this program calls the <literal>record()</literal> method some random number of
times, and the variable <literal>counter</literal> keeps track of the number. Because
both <literal>main()</literal> and <literal>record()</literal> are static methods, the value of <literal>counter</literal>
is accessible to each of them. Many programmers frown on the use of
class variables precisely because they are visible to many different
methods. The idea of a method is to isolate pieces of code so that the
complexity of a program can be divided into simple units. In the case of
a public class variable, even code in other classes can modify its
value. So many different pieces of code can modify the value that it may
be difficult to keep the variable from being changed in an unexpected
way. If another method used the <literal>counter</literal> variable to record the number
of times it was called, the final value of <literal>counter</literal> would be the sum of
the number of times the two methods were called. There might be some
reason to keep track of such information, but it would be impossible to
reconstruct what fraction of the value in <literal>counter</literal> came from one method
and what fraction came from the other.</simpara>
<simpara>Class variables have their uses, but they should generally be avoided.
One exception to this rule is constants. Since a constant never changes,
a class variable is a great place to store it, making the value
available to any code that uses it. An example you have already used is
<literal>Math.PI</literal>. As with static methods, a static field from another class can
be accessed by using the class name, then a dot, then the name of the
static field. Again, when the code using the field is in the same class,
the class name can be dropped. A class constant is declared like a class
variable, but with the addition of the <literal>final</literal> keyword. The following
class allows a user to compute the one-dimensional force due to gravity,
given by the equation <inlineequation><alt><![CDATA[F =
\frac{Gm_1m_2}{r^2}]]></alt><mathphrase><![CDATA[F =
\frac{Gm_1m_2}{r^2}]]></mathphrase></inlineequation>, where <inlineequation><alt><![CDATA[m_1]]></alt><mathphrase><![CDATA[m_1]]></mathphrase></inlineequation> is the mass of one
object, <inlineequation><alt><![CDATA[m_2]]></alt><mathphrase><![CDATA[m_2]]></mathphrase></inlineequation> is the mass of another, <inlineequation><alt><![CDATA[r]]></alt><mathphrase><![CDATA[r]]></mathphrase></inlineequation> is the
distance between their centers, and <inlineequation><alt><![CDATA[G]]></alt><mathphrase><![CDATA[G]]></mathphrase></inlineequation> is the gravitational
constant,
<inlineequation><alt><![CDATA[6.673 \times 10^{-11}\mbox{ N}\cdot\mbox{m}^2\cdot\mbox{kg}^{-2}]]></alt><mathphrase><![CDATA[6.673 \times 10^{-11}\mbox{ N}\cdot\mbox{m}^2\cdot\mbox{kg}^{-2}]]></mathphrase></inlineequation>.</simpara>
<formalpara xml:id="program:Gravity" xreflabel="Gravity">
<title>A program that calculates the attraction due to gravity between two masses.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Gravity {
	public static final double G = 6.673e-11;

	public static void main(String[] args ) {
		double m1, m2, r;
		Scanner in = new Scanner( System.in );
		System.out.println("What is the first mass?");
		m1 = in.nextDouble();
		System.out.println("What is the second mass?");
		m2 = in.nextDouble();
		System.out.println("What is the distance between them?");
		r = in.nextDouble();
		System.out.println("The force of gravity is " +
			force( m1, m2, r ) + " N");
	}

	public static double force(double m1, double m2, double r) {
		return G*m1*m2/(r*r);
	}
}</programlisting>
</para>
</formalpara>
<simpara>Use named constants this way whenever you can. You can use the <literal>public</literal>
modifier if you want all classes to have access to your constant
(<literal>Gravity.G</literal> is a good example). You can use the <literal>private</literal> modifier if
you want the constant to be accessible only inside your class, if it has
no use outside, or if it contains secret information.</simpara>
</section>
</section>
<section xml:id="_examples_defining_methods">
<title>Examples: Defining methods</title>
<simpara>Any large problem should be broken down into methods. Because the
technique is useful in so many circumstances, it is difficult to give a
set of examples that covers all the bases. Instead, our examples are
short, easy to understand methods, focusing on Euclidean distance,
testing for palindromes, and converting a <literal>String</literal> representation of an
<literal>int</literal> to an <literal>int</literal>.</simpara>
<example>
<title>Euclidean distance</title>
<simpara>The Euclidean distance between two points is the length of a straight
line connecting them. It plays an important role in 3D graphics and
games and is the basis for many other practical applications involving
spatial relationships. Unfortunately, the real world is complicated
enough that, even if the shortest distance between two points is a
straight line, we can seldom travel along it.</simpara>
<simpara>Given a two points in 3D space <inlineequation><alt><![CDATA[(x_1, y_1, z_1)]]></alt><mathphrase><![CDATA[(x_1, y_1, z_1)]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[(x_2,
y_2, z_2)]]></alt><mathphrase><![CDATA[(x_2,
y_2, z_2)]]></mathphrase></inlineequation>, we can compute the Euclidean distance between them with the
equation: <inlineequation><alt><![CDATA[d = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1
- z_2)^2}]]></alt><mathphrase><![CDATA[d = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1
- z_2)^2}]]></mathphrase></inlineequation> The following method applies this equation directly.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double distance(double x1, double y1, double z1,
                  double x2, double y2, double z2 ) {
    double x = x1 - x2;
    double y = y1 - y2;
    double z = z1 - z2;
    return Math.sqrt( x*x + y*y + z*z );
}</programlisting>
<simpara>This calculation is a good choice for a static method since it might be
necessary to do this calculation many times and it does not depend on
any other variables or program state.</simpara>
</example>
<example>
<title>Palindrome testing</title>
<simpara>A palindrome is a word or phrase (or even a number) that is the same
spelled forwards and backwards. &#8220;Racecar,&#8221; &#8220;Madam, Iâm Adam,&#8221; and
&#8220;Satan, oscillate my metallic sonatas&#8221; are examples in English.
Typically, spaces and punctuation are ignored. We are going to write a
function that, given a <literal>String</literal>, returns <literal>true</literal> if it is a palindrome
and <literal>false</literal> otherwise. To simplify the problem, we are <emphasis role="strong">not</emphasis> going to
ignore spaces and punctuation. Thus, with our method, &#8220;racecar&#8221; counts
as a palindrome, but neither of the other two examples would.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static boolean isPalindrome(String text) {
    text = text.toLowerCase();
    for( int i = 0; i &lt; text.length() / 2; i++ )
        if( text.charAt(i) != text.charAt(text.length() - i - 1))
            return false;
    return true;
}</programlisting>
<simpara>Because our method returns <literal>true</literal> or <literal>false</literal>, its return type must be
<literal>boolean</literal>. Many methods that return a <literal>boolean</literal> value have a name
starting with <literal>is</literal>, like our method. The first line of the body of our
method changes <literal>text</literal> to lower case. The <literal>String</literal> method <literal>toLowerCase()</literal>
creates a lower case copy of the <literal>String</literal> it is called on, in this case
<literal>text</literal>. Then, we point the reference variable <literal>text</literal> at that new, lower
case <literal>String</literal>. On the outside of this function, the <literal>String</literal> passed in
does not change because the name <literal>text</literal> is passed by value.</simpara>
<simpara>The loop iterates through the first half of <literal>text</literal>, comparing it to the
second half. This loop reflects the asymmetry of these kinds of tests:
You canât be sure that <literal>text</literal> is a palindrome until you have checked the
entire thing, but you immediately know that it is not if even a single
pair of characters does not match. If the test in that <literal>if</literal> statement
ever shows that the two <literal>char</literal> values are not equal, the <literal>return false</literal>
statement jumps out of the method without completing the loop.</simpara>
</example>
<example>
<title>Parsing a number</title>
<simpara>When you read in a number using an object of the <literal>Scanner</literal> class, it
converts (or <emphasis>parses</emphasis>) the text entered by the user into the appropriate
type. For example, the <literal>nextDouble()</literal> method reads in some text and
convert it into a <literal>double</literal>. When you use a <literal>JOptionPane</literal> method to read
in input, it comes in as a <literal>String</literal>. If you want to use that data as a
<literal>double</literal>, you must convert it using the <literal>Double.parseDouble()</literal> static
method. Some Java programmer had to write this method. We are going to
recreate a similar method to convert the <literal>String</literal> representation of a
floating point number into a <literal>double</literal>. Our simple method ignores
scientific notation.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double parseDouble(String value) {
    int i = 0;
    boolean negative = false;
    double temp = 0.0;
    double fraction = 10;
    if( value.charAt(i) == '-' ) {
        negative = true;
        i++;
    }
    else if( value.charAt(i) == '+' )
        i++;
    while( i &lt; value.length() &amp;&amp; value.charAt(i) != '.' ) {
        temp *= 10;
        temp += value.charAt(i) - '0';
        i++;
    }
    i++; //move past decimal point (if there)
    while( i &lt; value.length() ) {
        temp += (value.charAt(i) - '0') / fraction;
        fraction *= 10;
        i++;
    }
    if( negative )
        temp = -temp;
    return temp;
}</programlisting>
<simpara>After declaring a few variables, this method first checks index <literal>0</literal> in
the input <literal>String</literal> <literal>value</literal> to see if it is a <literal>'-'</literal> or a <literal>'+'</literal>. If it is
a <literal>'-'</literal>, it sets <literal>negative</literal> to <literal>true</literal> and moves on. If it is a <literal>'+'</literal>, it
simply moves on. Then, the method loops through <literal>value</literal> until it reaches
the end or reaches a decimal point. As it iterates, it multiplies the
current value of <literal>temp</literal> by 10 and adds in the next digit from <literal>value</literal>
(after subtracting <literal>'0'</literal> so that the range is is from 0 to 9). This
repetitive multiplication by 10 accounts for the increasing powers of 10
in the base 10 number system. Since <literal>temp</literal> starts with a value of <literal>0.0</literal>,
the first multiplication has no effect, as intended.</simpara>
<simpara>After the first <literal>while</literal> loop, the index <literal>i</literal> is incremented once, to skip
the decimal point, if there is one. If there is no decimal point, the
loop must have exited because the end of <literal>value</literal> had been reached. The
second <literal>while</literal> loop runs to the end of <literal>value</literal>, this time adding in each
digit value divided by <literal>fraction</literal>, which is increased by a factor of 10
each time. Doing so allows us to add smaller and smaller fractional
digits to the total. We set <literal>temp</literal> to its opposite if the flag
<literal>negative</literal> was set earlier and finally return <literal>temp</literal>.</simpara>
<simpara>You should note that the real <literal>Double.parseDouble()</literal> method not only
accepts <literal>String</literal> values in scientific notation but also does a great
deal of error checking. Our code either crashes or gives inaccurate
results on an empty <literal>String</literal>, a <literal>String</literal> containing non-numerical
characters, or a <literal>String</literal> with more than one decimal point. Furthermore,
this code does not use the best approach for minimizing floating-point
precision errors.</simpara>
</example>
</section>
<section xml:id="_solution_three_card_poker">
<title>Solution: Three card poker</title>
<simpara>Here we present our solution to the three card poker problem. We explain
each method individually.</simpara>
<programlisting language="java" linenumbering="numbered">public class ThreeCardPoker {
	public static final String[] SUITS = {"Spades", "Hearts",
		"Diamonds", "Clubs"};
	public static final String[] RANKS = {"2", "3", "4", "5", "6",
		"7", "8", "9", "10", "Jack", "Queen", "King", "Ace"};
	public static final int STRAIGHT_FLUSH = 40;
	public static final int THREE_OF_A_KIND = 30;
	public static final int STRAIGHT = 6;
	public static final int FLUSH = 2;
	public static final int PAIR = 1;
	public static final int NOTHING = 0;</programlisting>
<simpara>Before our <literal>main()</literal> method even begins, we have declared a number of
class constants. Two constant arrays of <literal>String</literal> values provide us with
an easy way to represent suits and ranks. The remaining six <literal>int</literal>
constants are used to allocate a winning payoff to each possible
outcome. Note that these constants can be declared anywhere inside the
class, provided that they are outside of all methods. However, it is
typical (and good style) to declare them at the top of the class.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void main(String[] args) {
		int[] deck = new int[52];
		int[] hand = new int[3];
		for( int i = 0; i &lt; deck.length; i++ )
			deck[i] = i;
		shuffle( deck );
		for( int i = 0; i &lt; hand.length; i++ )
			hand[i] = deck[i];
		int winnings = score(hand);
		System.out.println("Hand: ");
		print(hand);
		if( winnings == 0 )
			System.out.println("You win nothing.");
		else
			System.out.println("You win " + winnings +
			" times your bet.");
	}</programlisting>
<simpara>In the <literal>main()</literal> method, an array representing a deck of 52 cards is
created first, followed by an array representing the 3 cards to be
dealt. The deck is filled sequentially and then shuffled with a method.
Next, the first 3 cards of the deck are copied into the array
representing the hand of cards. The score of the hand is determined, and
then the hand is printed out. We print the hand after determining the
score because the hand is sorted in the process of determining the
score, making the output easier to read. Finally, we print the
appropriate output, depending on the score.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void shuffle(int[] deck) {
		int index, temp;
		for( int i = 0; i &lt; deck.length; i++ ) {
			index = i + (int)((deck.length - i)*Math.random());
			temp = deck[index];
			deck[index] = deck[i];
			deck[i] = temp;
		}
	}</programlisting>
<simpara>This method shuffles the deck. Its approach is to swap the first element
in the array of cards with one of the elements that follow, chosen
randomly. Then, it swaps the second element in the array with any of the
elements that follow it, and so on. If <literal>Math.random()</literal> truly gives us a
uniformly generated random number in the range <inlineequation><alt><![CDATA[[0,1)]]></alt><mathphrase><![CDATA[[0,1)]]></mathphrase></inlineequation>, the
final shuffled deck should be any one of the <inlineequation><alt><![CDATA[52!]]></alt><mathphrase><![CDATA[52!]]></mathphrase></inlineequation> possible
decks with equal probability.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void print(int[] hand) {
		for( int i = 0; i &lt; hand.length; i++ )
			System.out.println(RANKS[getRank(hand[i])] + " of "
			+ SUITS[getSuit(hand[i])]);
	}

	public static int getRank(int value) { return value % 13; }
	public static int getSuit(int value) { return value / 13; }</programlisting>
<simpara>The first of these methods prints out a human readable version of each
card in an array (instead of 0 - 51). It does so using the second and
third methods as helper methods. Method <literal>getRank()</literal> computes the rankÂ of
a card from its number, and method <literal>getSuit()</literal> computes the suit of a
card from its number. The indexes obtained from these methods are used
to index into the <literal>RANKS</literal> and <literal>SUITS</literal> arrays.</simpara>
<simpara>In the C language, calling a method from a method defined earlier
required a special declaration step called <emphasis>prototyping</emphasis> before both
methods. Java does not have this complication, and the <literal>getRank()</literal> and
<literal>getSuit()</literal> methods compile and function perfectly if they are written
above <literal>print()</literal> or below it inside the class definition.</simpara>
<programlisting language="java" linenumbering="numbered">	private static int score(int[] hand) {
		sortByRank( hand );
		if( hasStraight( hand ) &amp;&amp; hasFlush( hand ) )
			return STRAIGHT_FLUSH;
		if( hasThree( hand ) )
			return THREE_OF_A_KIND;
		if( hasStraight( hand ) )
			return STRAIGHT;
		if( hasFlush( hand ) )
			return FLUSH;
		if( hasPair( hand ) )
			return PAIR;
		return NOTHING;
	}</programlisting>
<simpara>This method computes the score by first sorting the hand and then
testing progressively worse outcomes, starting with the best, a straight
flush. As it moves down the list of outcomes, it calls appropriate
methods to determine if a hand has a certain characteristic.</simpara>
<programlisting language="java" linenumbering="numbered">	private static void sortByRank( int[] hand ) {
		int smallest, temp;
		for( int i = 0; i &lt; hand.length - 1; i++ ) {
			smallest = i;
			for( int j = i + 1; j &lt; hand.length; j++ ) {
				if( getRank(hand[j]) &lt; getRank(hand[smallest]) )
					smallest = j;
			}
			temp = hand[smallest];
			hand[smallest] = hand[i];
			hand[i] = temp;
		}
	}</programlisting>
<simpara>This code is an implementation of selection sort packaged into a method.
Note that this method does actually change the values inside of the
array <literal>hand</literal> even though it cannot change the array that <literal>hand</literal> points
to. The array itself is passed by value, but its contents are
effectively passed by reference.</simpara>
<programlisting language="java" linenumbering="numbered">	private static boolean hasPair( int[] hand ) {
		return getRank(hand[0]) == getRank(hand[1]) ||
		       getRank(hand[1]) == getRank(hand[2]);
	}

	private static boolean hasThree( int[] hand ) {
		return getRank(hand[0]) == getRank(hand[1]) &amp;&amp;
		       getRank(hand[1]) == getRank(hand[2]);
	}

	private static boolean hasFlush( int[] hand ) {
		return getSuit(hand[0]) == getSuit(hand[1]) &amp;&amp;
		       getSuit(hand[1]) == getSuit(hand[2]);
	}

	private static boolean hasStraight( int[] hand ) {
		return (getRank(hand[0]) == 0 &amp;&amp; getRank(hand[1]) == 1
				&amp;&amp; getRank(hand[2]) == 12) || //ace low
		       (getRank(hand[1]) == getRank(hand[0]) + 1 &amp;&amp;
		        getRank(hand[2]) == getRank(hand[1]) + 1);
	}
}</programlisting>
<simpara>These four methods do the actual work of determining the attributes of a
hand. They are all similar and would be more complex for five- or
seven-card poker hands. Methods <literal>hasPair()</literal> and <literal>hasStraight()</literal> depend
on the array being sorted previously. The code in <literal>hasPair()</literal> works by
checking to see if the first and second or second and third cards have
the same rank. The code in <literal>hasThree()</literal> checks to see if all the ranks
are the same. The code in <literal>hasFlush()</literal> is the same as <literal>hasThree()</literal>
except that it checks for suit instead of rank. Finally, <literal>hasStraight()</literal>
checks to see if the ranks are all in ascending order, with an extra
case to deal with the possibility of the ace counting as low.</simpara>
</section>
<section xml:id="_concurrency_methods">
<title>Concurrency: Methods</title>
<simpara>In Java, it is impossible to have concurrency without methods. Methods
are the way we break a large program into manageable pieces but are also
part of the syntax that Java uses to create threads of execution. Each
thread of execution is associated with a <literal>Thread</literal> object, but creating
the object is not enough to start a new thread of execution running.
Only when the <literal>start()</literal> method is called on the <literal>Thread</literal> object does the
new thread start running.</simpara>
<simpara>Hopefully, you have begun to visualize the execution of Java programs as
an arrow that sits next to each line of code as it is executed. This
arrow can jump to a choice and skip over other code using <literal>if</literal> and
<literal>switch</literal> statements. Using loops, the arrow can jump backwards and
repeatedly execute code it has just executed. As we have discussed in
this chapter, it can jump into a method, execute the code in that
method, and then return to its caller, going back right to where it left
off before the call.</simpara>
<simpara>When the <literal>start()</literal> method is called on a <literal>Thread</literal> object, however, the
arrow returns to the caller, but it also splits itself into a second
arrow that then executes the corresponding <literal>run()</literal> method and any
methods it calls. Note that we are talking about a method called on a
<literal>Thread</literal> object, not a static method called on the class as a whole.
Calling <literal>start()</literal> is an instance method, which we discuss in
ChapterÂ <xref linkend="chapter:Classes"/>. Unlike the static methods we have discussed
in this chapter, an instance method is tied to a particular object, but
most of what you have learned about methods still applies.</simpara>
<simpara>Methods are supposed to make programming easier by breaking programs
into chunks small enough to think about. One of the only real dangers of
methods is using class variables, as discussed in
SectionÂ <xref linkend="subsection:class_variables"/>. This problem becomes worse with
multiple threads. With a single thread, two or more different methods
can all affect the same class variable, perhaps in conflicting ways.
With multiple threads, even the <emphasis role="strong">same</emphasis> method can interfere with itself.</simpara>
<example>
<title>LCG without thread safety</title>
<simpara>A linear congruential generator (LCG) allows you to create a sequence of
pseudorandom numbers using the equation
<inlineequation><alt><![CDATA[x_i=(ax_{i-1}+b)\mod m]]></alt><mathphrase><![CDATA[x_i=(ax_{i-1}+b)\mod m]]></mathphrase></inlineequation>, deriving the next number from the
previous one, and so on.</simpara>
<formalpara xml:id="program:UnsafeRandom" xreflabel="UnsafeRandom">
<title>This program implements an LCG similar to one sometimes used in the function <literal>rand()</literal> used in the C language.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class UnsafeRandom {
	private static int next = 1;
	private final static int A = 1103515245;
	private final static int B = 12345;
	private final static int M = 32768;

	public static int nextInt() {
		return next = (A*next + B) % M;
	}
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>UnsafeRandom</literal> program listed above always generates the same
sequence of pseudorandom numbers, which can be very useful for debugging
a program. However, if two or more threads are calling <literal>nextInt()</literal>, they
probably are getting different sequences. One thread picks up some of
the numbers, and the other picks up the missing numbers in between. If
each thread wants to generate the same sequence of numbers, the method
should be rewritten so that it takes in the previous number in the
sequence. In that way, there is no shared state. Remember that using a
(non-final) static field (class variable) should be avoided whenever
possible.</simpara>
<formalpara xml:id="program:SafeRandom" xreflabel="SafeRandom">
<title>This program implements the same LCG safely by requiring the caller to supply the previous random number.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class SafeRandom {
	private final static int A = 1103515245;
	private final static int B = 12345;
	private final static int M = 32768;

	public static int nextInt( int previous ) {
		return (A*previous + B) % M;
	}
}</programlisting>
</para>
</formalpara>
</example>
<example>
<title>Unpredictable methods</title>
<simpara>By forcing each thread to carry its own state, we fixed the previous
problem. In ChapterÂ <xref linkend="chapter:Synchronization"/> we talk about the much
nastier problem of two threads executing a method at exactly the same
time. When that happens, very curious effects are possible. Consider the
following program:</simpara>
<formalpara xml:id="program:AlwaysEven" xreflabel="AlwaysEven">
<title>The <literal>print()</literal> method always prints <literal>"Even"</literal> when run with a single thread but can sometimes print <literal>"Odd"</literal> if called repeatedly with multiple threads.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class AlwaysEven {
	private static int value = 1;

	public static void print() {
		value++;
		if( value % 2 == 0 )
			System.out.println("Even");
		else
			System.out.println("Odd");
		value++;
	}
}</programlisting>
</para>
</formalpara>
<simpara>With a single thread running, <literal>value</literal> always goes up to an even number
before printing and then increments to the next odd number afterwards.
If two or more threads are calling the <literal>print()</literal> method, <literal>value</literal> could
be changed by one right before the other executes the <literal>if</literal> statements.</simpara>
</example>
</section>
<section xml:id="_exercises_7">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Describe three advantages of dividing long segments of code into
static methods.</simpara>
</listitem>
<listitem>
<simpara>Can you think of any disadvantages of dividing code into methods?
Are there situations where using a method is unwise?</simpara>
</listitem>
<listitem>
<simpara>If you wanted to declare a static method that would compute the
mean, median, and standard deviation of an input array of <literal>double</literal>
values, how would you return those three answers?</simpara>
</listitem>
<listitem>
<simpara>Consider the following method definition.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void twice( int i ) {
    i = 2 * i;
}</programlisting>
<simpara>How many times does the following loop run, and why?</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 2;
while( x &lt; 128 )
    twice(x);</programlisting>
</listitem>
<listitem>
<simpara>Consider the following signatures of two overloaded methods.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int magic( int rabbit, double hat )
public static int magic( double wand, int spell )</programlisting>
<simpara>Which method would be invoked by the following call?</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = magic( 3, 16 );</programlisting>
<simpara>What about the following?</simpara>
<programlisting language="java" linenumbering="unnumbered">int y = magic( 3.2, 16.4 );</programlisting>
<simpara>Use a compiler to check your answers.</simpara>
</listitem>
<listitem>
<simpara>The following class generates a sequence of even numbers. Each time
the <literal>next()</literal> method is called, the next even number in the sequence is
returned. What is the design problem with using a static field to keep
track of the next value in the sequence?</simpara>
<programlisting language="java" linenumbering="unnumbered">public class EvenNumbers {
    private static int counter = 0;

    public static int next() {
        counter += 2;
        return counter;
    }
}</programlisting>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Write a static method called <literal>cube()</literal> that takes a single <literal>double</literal>
value as a parameter and returns its value cubed. Do not use the
<literal>Math.pow()</literal> method.</simpara>
</listitem>
<listitem>
<simpara>Implement a static method that takes a single <literal>int</literal> value as a
parameter and prints its digits in reverse. For example, if <literal>103</literal> was
passed into this method, it would print <literal>301</literal> to the screen.</simpara>
<simpara>You can find out what digit is in the ones place of a number by taking
its remainder modulus 10. Then, you can remove the digit in the ones
place by dividing by 10. Do not convert the <literal>int</literal> value into a <literal>String</literal>.</simpara>
</listitem>
<listitem>
<simpara>Write a static method that takes an array of <literal>int</literal> values as a
parameter and returns <literal>true</literal> if the array is in ascending order and
<literal>false</literal> otherwise. Compare each element of the array to the next element
of the array. If the current element is ever larger than the next
element, the array is not sorted in ascending order. Note that you can
only be sure that the array is in ascending order after you have checked
all neighboring pairs.</simpara>
</listitem>
<listitem>
<simpara>Write a static method that finds the
<inlineequation><alt><![CDATA[\lfloor\log_2(n)\rfloor]]></alt><mathphrase><![CDATA[\lfloor\log_2(n)\rfloor]]></mathphrase></inlineequation> of an integer <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>.
Note that if <inlineequation><alt><![CDATA[\log_2 n = x]]></alt><mathphrase><![CDATA[\log_2 n = x]]></mathphrase></inlineequation>, it is also true that
<inlineequation><alt><![CDATA[n = 2^x]]></alt><mathphrase><![CDATA[n = 2^x]]></mathphrase></inlineequation>. In other words, the <inlineequation><alt><![CDATA[\log_2]]></alt><mathphrase><![CDATA[\log_2]]></mathphrase></inlineequation> operator
tells you what power of <inlineequation><alt><![CDATA[2]]></alt><mathphrase><![CDATA[2]]></mathphrase></inlineequation> a number is. One way to define
the <inlineequation><alt><![CDATA[\log_2 n]]></alt><mathphrase><![CDATA[\log_2 n]]></mathphrase></inlineequation> is the number of times you have to divide
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> by <inlineequation><alt><![CDATA[2]]></alt><mathphrase><![CDATA[2]]></mathphrase></inlineequation> to get <inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation>. Use this
definition to make a loop that finds the value without using any calls
to the <literal>Math</literal> library.</simpara>
<simpara>Here are some examples of the return values your method should give for
various input values of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top">Return Value</entry>
<entry align="center" valign="top"><inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation></entry>
<entry align="center" valign="top">Return Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>100</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>512</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"><simpara>1000</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"><simpara>1024</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara><xref linkend="exercise:palindromes"/> Write a method that tests palindromes like
the method from ExampleÂ <xref linkend="example:Palindrome_testing"/> but also ignores
punctuation and spaces. Thus, <literal>"A man, a plan, a canal: Panama"</literal> should
be counted as a palindrome by this new method.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the solution from SectionÂ <xref linkend="solution:Three_card_poker"/>
so that it uses a GUI constructed with <literal>JOptionPane</literal> to display the hand
and the winnings.</simpara>
</listitem>
<listitem>
<simpara>Five card poker is a much more common version of poker than the
three card version we discussed in SectionÂ <xref linkend="problem:Three_card_poker"/>.
Using static methods, implement a two-player game of poker in which the
deck is shuffled and then dealt into two hands of five cards each. Then,
state which playerâs hand wins. With five cards, determining which hand
wins is a more complicated process. The rankings of the various possible
hands from best to worst are as follows.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>All five cards belong to the same suit and have ranks in sequential
order (with either ace high or low). If two people both have straight
flushes, the higher ranked one wins. If they both have the same ranks,
it is a tie.</simpara>
</listitem>
<listitem>
<simpara>Four of the five cards have the same rank. If two people have four
of a kind, the higher rank set of four wins.</simpara>
</listitem>
<listitem>
<simpara>Three of the five cards have the same rank and the other two share
another rank. If two people have a full house, the higher ranked set of
three wins.</simpara>
</listitem>
<listitem>
<simpara>All five cards have the same suit. If two people have flushes, the
one with the highest card wins. If the highest card is a tie, the next
highest is the tie breaker, and so on. If the two flushes have exactly
the same ranks, the two flushes tie.</simpara>
</listitem>
<listitem>
<simpara>All five cards have ranks in sequential order (with either ace high
or low). If two people both have straight flushes, the higher ranked one
wins. If they both have the same ranks, it is a tie.</simpara>
</listitem>
<listitem>
<simpara>Three of the cards have the same rank. If two people have three of a
kind, the higher ranked set of three wins.</simpara>
</listitem>
<listitem>
<simpara>A pair of cards have the same rank and another pair of cards share
another rank. If two people both have two pairs, the higher ranked pair
is a tiebreaker. If the higher ranked pair is the same, the lower ranked
pair is a tiebreaker. If the lower ranked pair is the same, the final
unpaired card is the tiebreaker. If all the ranks of both hands match,
it is a tie.</simpara>
</listitem>
<listitem>
<simpara>A pair of cards has the same rank. If two people have pairs, the
rank of the pair is a tiebreaker. If the pairs have the same rank, the
remaining cards in each hand are tiebreakers, in descending rank order.</simpara>
</listitem>
<listitem>
<simpara>If none of the other cases hold, the high card determines the value
of the hand. If two people have the same highest card, the remaining
cards in each hand are used as tiebreakers, in descending rank order.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In terms of time, there is a small overhead associated with calling
a method and returning a value, but it is very hard to measure. Write a
program with two <literal>int</literal> variables, <literal>a</literal> and <literal>b</literal>, where <literal>a</literal> starts with a
value of <literal>1</literal> and <literal>b</literal> starts with a value of <literal>2</literal>. Run a <literal>for</literal> loop
100,000,000 times. On each iteration first increase the value of <literal>a</literal> by
the value of <literal>b</literal> and then increase the value of <literal>b</literal> by <literal>a</literal>. Time this
loop with <literal>System.nanoTime()</literal> and then print out the time taken and the
value of <literal>a</literal>. The value of <literal>a</literal> is not important, but the compiler will
optimize away the math done with <literal>a</literal> and <literal>b</literal> unless we output the value.
We recommend that you run this program repeatedly to get a sense of the
average running time.</simpara>
<simpara>Now, instead of using the <literal>+</literal> operator to add <literal>a</literal> and <literal>b</literal>, use the
following method.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int add( int a, int b ) {
    return a + b;
}</programlisting>
<simpara>Again, run your program repeatedly with this modification. What is the
difference in running time between the version that uses a method and
the version that does addition directly?</simpara>
<simpara>Depending on your JVM, itâs quite possible that thereâs almost no
difference. The JVM does a lot of optimizations including <emphasis>inlining</emphasis>,
which replaces a call to a method with the actual code inside the
method.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Classes">
<title>Classes</title>
<blockquote>
<attribution>
Yoda
</attribution>
<simpara>Luminous beings are we, not this crude matter.</simpara>
</blockquote>
<section xml:id="_problem_nested_expressions">
<title>Problem: Nested expressions</title>
<simpara>How does the compiler check the Java code that you write and find
errors? Syntax checking and type checking are involved processes that
are key parts of compiler design. Compilers are some of the most complex
programs of any kind, and building one is beyond the scope of the
material covered in this book. However, we can get insight into some
problems faced by compiler designers by considering the problem of
correctly nested expressions.</simpara>
<simpara>There are many rules for forming correct Java code, but it is always the
case that grouping symbols (<literal>(</literal>, <literal>)</literal>, <literal>[</literal>, <literal>]</literal>, <literal>{</literal>, <literal>}</literal>) are correctly
nested. Ignoring other symbols, we may find a section of code that
contains the sequence <literal>"( ) [ ]"</literal>, but correctly written code never
contains <literal>"( [ ) ]"</literal>.</simpara>
<simpara>To be correctly nested, left and right parentheses must be balanced,
left and right square brackets must be balanced, and left and right
curly braces must be balanced. Furthermore, a correctly balanced set of
parentheses can be nested inside of a correctly balanced set of square
brackets or curly braces (and vice versa), but they cannot intersect as
they do at the end of the previous paragraph. TableÂ <xref linkend="table:nested
expressions"/> shows more examples of correctly and incorrectly nested
expressions.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Correctly Nested</entry>
<entry align="left" valign="top">Incorrectly Nested</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">""</literallayout></entry>
<entry align="left" valign="top"><literallayout class="monospaced">"("</literallayout></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">"(){}"</literallayout></entry>
<entry align="left" valign="top"><literallayout class="monospaced">"}{"</literallayout></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">"((abc)){x}"</literallayout></entry>
<entry align="left" valign="top"><literallayout class="monospaced">"( a { b ) c }"</literallayout></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">"({[z]})"</literallayout></entry>
<entry align="left" valign="top"><literallayout class="monospaced">"{abc("</literallayout></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">"({xyz})({ijk}[123])"</literallayout></entry>
<entry align="left" valign="top"><literallayout class="monospaced">"{(333)888(})"</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>But how can we examine an expression to see if it is correctly nested?
The key to solving this problem is the idea of a <emphasis>stack</emphasis>. A stack is a
simple data structure with three operations: <emphasis>push</emphasis>, <emphasis>pop</emphasis>, and <emphasis>top</emphasis>.
The data structure is meant to behave like a stack of books or cups or
any other physical objects. When you use the push operation, you are
moving something to the top of the stack. When you use the pop
operation, you are taking something off the top of the stack. The top
operation is used to read what is at the top of the stack. In a stack,
you can only read that very topmost item, as if all the other items were
buried underneath it. A stack is known as a FILO (first in, last out) or
a LIFO (last in, first out) data structure because, if you push a series
of items onto the stack and then pop them all off the stack, they come
off the stack in the reverse order from how they were added.</simpara>
<simpara>Armed with an understanding of the stack, it is straightforward to see
if an expression is nested correctly. Scan through each character in the
input and follow these steps.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If it is a left parenthesis, left square bracket, or left curly
brace, put it on the stack.</simpara>
</listitem>
<listitem>
<simpara>If it is a right parenthesis, right square bracket, or right curly
brace, check that the top of the stack is its matching left half. If it
is, pop the left half off the stack. If it isnât (or if the stack is
empty), the grouping symbols are either unbalanced or intersecting.
Print an error and quit.</simpara>
</listitem>
<listitem>
<simpara>For any character that isnât a grouping symbol, ignore it and move
on.</simpara>
</listitem>
</orderedlist>
<simpara>If you reach the end of input without an error, check to see if the
stack is empty. If it is, then all of the left grouping symbols have
been matched up with right grouping symbols. If not, there are left
symbols left on the stack, and the expression isnât correctly nested.</simpara>
</section>
<section xml:id="_concepts_object_oriented_programming">
<title>Concepts: Object-oriented programming</title>
<simpara>To solve the nested expressions problem, we need to create a stack data
structure. Each element of the stack should be able to hold a <literal>char</literal>
value term from an expression, where a term is an operator, operand, or
a parenthesis (bracket or curly brace). Although we could get by using
only the static methods we introduced in the previous chapter, a better
tool can make programming easier.</simpara>
<simpara>We are introducing these topics in a progression: First, all of our
programs were a series of sequential instructions inside of a <literal>main()</literal>
method. We added in selection statements and loops to solve more
difficult problems. As our programs became more complicated, we started
using additional static methods to divide the program into logical
segments. Now, we are moving to fully object-oriented programming (OOP)
in which data as well as code can be packaged into objects that interact
with each other.</simpara>
<simpara>OOP has been a controversial topic, particularly in the computer science
education community. The most important thing to remember is that we are
not throwing away any of the ideas we used before. We are continuing on
a path toward making code safer and more reusable. Several other
chapters in this book touch on important ideas in OOP such as
inheritance and polymorphism. Below, we are going to focus on the
basics, including the fundamentals of objects, encapsulation of data,
and instance (non-static) methods.</simpara>
<section xml:id="_objects">
<title>Objects</title>
<simpara>You have already used objects, perhaps without realizing it. Every time
you use a <literal>String</literal>, you are using an object. So far, we have created a
class every time we have written a program. A class is a way to organize
static methods, but a class is something more: a template for objects.
Whenever you write a class, the potential to create specific objects
exists.</simpara>
<simpara>For a conceptual example, you can think of Human as a class and Albert
Einstein as an object (or an <emphasis>instance</emphasis>) of that class. The class
defines certain characteristics that all human beings have: name, date
of birth, height, and so on. Then, the object has specific values for
each one of those characteristics, such as Albert Einstein, March 14,
1879, 175, and so on.</simpara>
<figure>
<title>Example of a class serving as a template for an object.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/09-classes/images/class.svg" width="100%"/>
</imageobject>
<textobject><phrase>class</phrase></textobject>
</mediaobject>
</figure>
<simpara>This idea of a class as a template is key because it means that an
object of a given type (from a given class) can be used anywhere that is
appropriate for another object of that type. Later in the chapter, we
create an object that performs the work of a stack, storing a number of
other objects. If we design a library of code that can manipulate or use
stack objects, we should be able to use this library countless times for
countless different stack objects without changing the code. This kind
of code reuse is one of the main goals of OOP.</simpara>
</section>
<section xml:id="_encapsulation">
<title>Encapsulation</title>
<simpara>In order to guarantee that objects can be used in many different
contexts safely, the data inside of the object must be protected. Java
provides access modifiers so that code without appropriate permission
cannot change or even read the data inside of an object.</simpara>
<simpara>This feature is called <emphasis>encapsulation</emphasis>. One programmer may write the
class file defining a type of object while another or many others write
code that uses those objects. The programmers who use objects written by
others do not need to understand the inner workings of those objects.
Instead, they can treat each object as a &#8220;black box&#8221; with a list of
actions that the object can do. Each action has a certain specified
input and a certain specified output, but the internal functioning of
the object is hidden.</simpara>
</section>
<section xml:id="_instance_methods">
<title>Instance methods</title>
<simpara>These &#8220;actions&#8221; are methods, but not static ones. Static methods did
not need an object in order to be called. Regular (instance) methods
should be thought of as an action performed on (or by) a specific
object. This action could be asking a question, such as inquiring what
the name of an object of type Human is. This action could be telling the
object to change itself, such as the case of pushing something onto a
stack.</simpara>
<simpara>One of the broadest definitions of an object is a collection of data and
methods to access that data. We call the data inside of an object its
<emphasis>fields</emphasis> or instance data and the methods to access them <emphasis>instance
methods</emphasis>. Static methods are used primarily to modularize large blocks
of code into smaller functional units. However, instance methods are
tightly coupled to the fields of an object and perform tasks that change
the object or get information from it.</simpara>
</section>
</section>
<section xml:id="_syntax_classes_in_java">
<title>Syntax: Classes in Java</title>
<simpara>OOP concepts such as encapsulation may seem esoteric until you see them
in practice. Remember, we just want to create some private data and then
define a few carefully controlled ways that the data can be manipulated.
First, weâll describe how to declare fields, then explain how to write
instance methods to manipulate that data, and finally give more details
about protecting its privacy.</simpara>
<section xml:id="_fields">
<title>Fields</title>
<simpara>Fields in an object must be declared like any other data in Java. The
type of a piece of data can be a primitive or reference type. Fields are
also sometimes called member variables. You declare fields just like you
would class variables, except without the <literal>static</literal> keyword. Hereâs an
example with the <literal>Human</literal> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Human {
    private String name;
    private String DOB;
    private int height; //in cm
}</programlisting>
<simpara>With this definition, a <literal>Human</literal> object has three attributes: <literal>name</literal>,
<literal>DOB</literal>, and <literal>height</literal>. Because the access modifier for each field is
<literal>private</literal>, code outside of this class cannot change or even read the
values. Note that this class cannot do anything yet. Also, note that
this class does not contain a <literal>main()</literal> method. There is no way to run
this class, but thatâs fine. We can add a <literal>main()</literal> method, of course.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Human {
    private String name;
    private String DOB;
    private int height; //in cm

    public static void main(String[] args) {
        name = "Albert Einstein";
        DOB = "March 14, 1879";
        height = 175;
    }
}</programlisting>
<simpara>Now we have added a <literal>main()</literal> method, but our code does not compile.
Since the <literal>main()</literal> method is a static method, it is not associated with
any particular object. When we tell the <literal>main()</literal> method to change the
fields, it does not know what object we are talking about. If we
actually want to use an object, weâll have to create one.</simpara>
<formalpara xml:id="program:Human" xreflabel="Human">
<title>Example of a class encapsulating the attributes of a human being.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Human {
	private String name;
	private String DOB;
	private int height; //in cm

	public static void main(String[] args) {
		Human einstein = new Human();
		einstein.name = "Albert Einstein";
		einstein.DOB = "March 14, 1879";
		einstein.height = 175;
	}
}</programlisting>
</para>
</formalpara>
<simpara>The above code compiles because we have used the <literal>new</literal> keyword to create
an object of type <literal>Human</literal> saved in a reference variable called
<literal>einstein</literal>. With a <literal>Human</literal> object, we can set its fields using
dotÂ notation. With static methods and static variables, we used the name
of the <emphasis role="strong">class</emphasis> followed by a dot, for instance methods and instance
variables, we use the name of the <emphasis role="strong">object</emphasis> followed by a dot. Even
though each of these fields is private, we can access them from <literal>main()</literal>
because <literal>main()</literal> is inside the <literal>Human</literal> class. Code inside of another
class could create a new <literal>Human</literal> object, but it could not change its
fields.</simpara>
<simpara>This juxtaposition of static and non-static fields and methods inside of
a single class is confusing to many new Java programmers. The confusion
seems to stem from the fact that the class (such as <literal>Human</literal>) is a
template for objects but it is also a place to house other related code,
such as static methods, including <literal>main()</literal>.</simpara>
<simpara>Although the practice is discouraged, we mentioned in
SectionÂ <xref linkend="subsection:class_variables"/> that class variables can be
stored in the class itself. Every object has a distinct copy of each
field, but there is only a single copy of each class variable that they
all share. By using the keyword <literal>static</literal>, we could add a class variable
called <literal>population</literal> to our <literal>Human</literal> class, since that is information
connected to humans as a whole, not to any individual human being.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Human {
    private String name;
    private String DOB;
    private int height; //in cm
    private static double population = 7.023E9;
}</programlisting>
<simpara>We are using a <literal>double</literal> to represent the worldâs population since the
value is too big to fit in an <literal>int</literal> and is easily expressed in
scientific notation. If several <literal>Human</literal> objects were created, they would
have their own <literal>name</literal>, <literal>DOB</literal>, and <literal>height</literal> values, but the value for
<literal>population</literal> would only be stored in the class.</simpara>
<figure>
<title>Class variables (static fields) are stored with the class, not with individual objects.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/09-classes/images/staticvalue.svg" width="100%"/>
</imageobject>
<textobject><phrase>staticvalue</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_constructors">
<title>Constructors</title>
<simpara>To create a new object, you have to invoke a <emphasis>constructor</emphasis>, a special
kind of method that can initialize the object. A constructor allows sets
up the values inside an object when it is first created. Letâs consider
a simple <literal>Rectangle</literal> class with only two fields: <literal>length</literal> and <literal>width</literal>,
both of type <literal>int</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Rectangle {
    private int length;
    private int width;</programlisting>
<simpara>One possible constructor for the class is given below.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public Rectangle( int l, int w ) {
        length = l;
        width = w;
    }</programlisting>
<simpara>This constructor lets us set the width and length when the object is
created. To do so, code could invoke the constructor using the <literal>new</literal>
keyword.</simpara>
<programlisting language="java" linenumbering="unnumbered">Rectangle rectangle = new Rectangle(50, 20);</programlisting>
<simpara>This code creates a new <literal>Rectangle</literal> object, with length 50 and width 20.
Constructors are almost always <literal>public</literal>, otherwise it would be
impossible for code outside of the <literal>Rectangle</literal> class to create a
<literal>Rectangle</literal> object. Notice that the definition of the <literal>Rectangle</literal>
constructor does not have a return type. A constructors is the only kind
of method that does not have a return type. It is possible to have more
than one constructor as well, just as other methods can be overloaded.
For more information about overloaded methods, refer back to
SectionÂ <xref linkend="subsubsection:Overloaded_methods"/>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public Rectangle( int value ) {
        length = value;
        width = value;
    }</programlisting>
<simpara>In the very same class, we could have this second constructor, allowing
us to quickly and easily create a square. All classes have constructors,
but some are not written explicitly. If you donât type out a constructor
for a class, a default one is automatically created. The default
constructor takes no parameters and sets all the values inside the new
object to defaults such as <literal>null</literal> and <literal>0</literal>. Once you do create a
constructor, the default one is no longer provided. Thus, since our
definition of the <literal>Rectangle</literal> class already contains two constructors,
the following line would cause a compiler error if someone tries to use
it in their code.</simpara>
<programlisting language="java" linenumbering="unnumbered">Rectangle defaultRectangle = new Rectangle();</programlisting>
<simpara>Another important thing to consider with all instance methods is scope.
Fields are visible inside of instance methods, but they can be hidden by
parameters.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public Rectangle( int length, int width ) {
        length = length;
        width = width;
    }</programlisting>
<simpara>This version of the two parameter <literal>Rectangle</literal> constructor compiles, but
it does not properly initialize the values of the fields <literal>length</literal> and
<literal>width</literal>. Instead, the parameters <literal>length</literal> and <literal>width</literal> are copied back
into themselves for no reason. The designers of Java anticipated that it
would be useful to refer to fields even in the presence of other
variables with the same name. To do so, the <literal>this</literal> keyword can be used.
Any field (or method) can be referred to by its object name, followed by
a dot, followed by the name of that field or method. Since you donât
have a variable name to reference the object when youâre inside of it,
the <literal>this</literal> keyword acts as a reference to the object.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public Rectangle( int length, int width ) {
        this.length = length;
        this.width = width;
    }</programlisting>
<simpara>This version of the code functions correctly, since we have explicitly
told Java to store the argument <literal>length</literal> into the field <literal>length</literal> inside
the object pointed at by <literal>this</literal> and to do similarly for <literal>width</literal>.</simpara>
</section>
<section xml:id="_methods">
<title>Methods</title>
<simpara>Objects do not really come to life until you add instance methods. With
the <literal>Rectangle</literal> class described above, any <literal>Rectangle</literal> objects created
are not useful in other classes because it is impossible to access their
data. Instead, we want to create a clear and usable relationship between
the fields and the methods.</simpara>
<simpara>There are many different kinds of methods, but two of the most important
are accessors and mutators.</simpara>
<section xml:id="_accessors">
<title>Accessors</title>
<simpara>We often want to read the data inside of various the objects. With our
current definition of <literal>Rectangle</literal>, no code from an outside class can
find out the length or width of the rectangle we are representing.</simpara>
<simpara><emphasis>Accessor methods</emphasis> (or simply <emphasis>accessors</emphasis>) are designed for this task.
By definition, an accessor allows us to read some data or get some
information out of an object without making any changes to its fields.
Accessors can be thought of as asking the object a question. The names
of accessors often start with the word <literal>get</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public int getLength() {
        return length;
    }

    public int getWidth() {
        return width;
    }</programlisting>
<simpara>Here are two accessors methods that we would expect in the <literal>Rectangle</literal>
class. The first returns the value of <literal>length</literal>, and the second returns
the value of <literal>width</literal>. These methods only report information. They do not
change the value of either variable. Their syntax should be
self-explanatory. Each is declared to be <literal>public</literal> so that anyone can
read the length and width of a rectangle. Both methods have a return
type of <literal>int</literal> because that is the type used to store <literal>length</literal> and
<literal>width</literal> inside a <literal>Rectangle</literal> object. Neither method has any parameters.
An accessor does not have to be so simple. An accessor could return a
value that needs to be computed from the underlying field data.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public int getArea() {
        return length*width;
    }

    public int getPerimeter() {
        return 2*length + 2*width;
    }</programlisting>
<simpara>These accessors compute the area and perimeter, respectively, of the
rectangle in question, even though that data is not stored directly in
the <literal>Rectangle</literal> object.</simpara>
</section>
<section xml:id="_mutators">
<title>Mutators</title>
<simpara>Some objects, such as <literal>String</literal> values, are <emphasis>immutable</emphasis> objects, meaning
that the data stored inside them cannot be changed after they have been
created with a constructor. If you have ever thought that you were
changing a <literal>String</literal>, you were actually creating a new <literal>String</literal> with the
appropriate modifications. Most objects are mutable, however, and we use
methods called <emphasis>mutator methods</emphasis> (or simply <emphasis>mutators</emphasis>) to change their
fields.</simpara>
<simpara>Like accessors, mutators have no special syntax. The term is used to
describe any methods that change the data inside of an object. For the
<literal>Rectangle</literal> class, the only internal data we have is the <literal>length</literal> and
<literal>width</literal> variables. Mutators for these might look as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public void setLength( int length ) {
        this.length = length;
    }

    public void setWidth( int width ) {
        this.width = width;
    }</programlisting>
<simpara>Just as the names for many accessors begin with <literal>get</literal>, the names for
many mutators begin with <literal>set</literal>. Mutators often have a <literal>void</literal> return type
because they are changing the object, not getting information back. Some
mutators might have a return type that gives information about an error
that occurred while trying to make a change. Note that we used the
<literal>this</literal> keyword once again to distinguish each field from the method
argument with the same name.</simpara>
<simpara>You may have noticed that we use the machinery of a method to both get
and set the <literal>length</literal> field, for example. Perhaps doing so seems
needlessly complex. After all, if the <literal>length</literal> variable had been
declared with the <literal>public</literal> modifier instead of the <literal>private</literal> modifier,
we could get and set its value directly, without using methods. In
response, letâs improve the mutators that set <literal>length</literal> and <literal>width</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public void setLength( int length ) {
        if( length &gt; 0 )
            this.length = length;
    }

    public void setWidth( int width ) {
        if( width &gt; 0 )
            this.width = width;
    }</programlisting>
<simpara>With these better mutators, we can prevent a user from setting the
values of <literal>length</literal> and <literal>width</literal> to negative numbers or zero, values that
donât make sense for dimensions of a rectangle. For more complicated
objects, it becomes even more important to protect the values of the
fields from malicious or mistaken users.</simpara>
</section>
</section>
<section xml:id="subsection:Access_modifiers">
<title>Access modifiers</title>
<simpara>Hiding data is at the heart of the Java OOP model. There are four
different levels of access that can be applied to fields and methods,
whether static or not. They are <literal>public</literal>, <literal>private</literal>, <literal>protected</literal>, and
package-private.</simpara>
<variablelist>
<varlistentry>
<term><literal>public</literal> modifier</term>
<listitem>
<simpara>The <literal>public</literal> access modifier states that a variable or method can be
accessed by any code, no matter what class contains it. Most methods
should be <literal>public</literal> so that they can be used freely to interact with
their object. Virtually no fields should be <literal>public</literal>. Constants (static
or otherwise) are the most significant exception to this rule. Making
constants <literal>public</literal> is usually not a problem since they cannot be changed
by outside code anyway. In the <literal>Rectangle</literal> class, variables <literal>length</literal> and
<literal>width</literal> are so simple that making them <literal>public</literal> is not unreasonable. If
you have a field that can be changed at any time by any code to any
value, you can leave that field <literal>public</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>private</literal> modifier</term>
<listitem>
<simpara>This modifier states that a variable or method cannot be accessed by any
code unless the code is contained in the same class. It is important to
realize that the restriction is based on the <emphasis role="strong">class</emphasis>, not on the
<emphasis role="strong">object</emphasis>. Code inside any <literal>Rectangle</literal> object can modify <literal>private</literal> values
inside of any other <literal>Rectangle</literal> object or class. Most fields should be
<literal>private</literal> so that outside code cannot modify them. Methods can be
<literal>private</literal>, but these methods should be helper or utility methods used
inside the class or object to divide up work.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>protected</literal> modifier</term>
<listitem>
<simpara>This modifier states that a variable or method cannot be accessed by any
code unless the code is contained in the same class, a subclass, or is
in the same package. This level of access is more restrictive than
<literal>public</literal> but less restrictive than <literal>private</literal> or default access. We
discuss it further in the context of subclasses and inheritance in
ChapterÂ <xref linkend="chapter:Inheritance"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Package-private (no explicit modifier)</term>
<listitem>
<simpara>If you do not type an access modifier when you declare a field or
method, that field or method is not <literal>public</literal>. Instead, it has the
default or package-private access modifier applied to it. Fields or
methods with this modifier can be accessed by any code that is in the
same <emphasis>package</emphasis> or directory. A package is yet another layer of
organization that Java provides to group classes together. When you use
an <literal>import</literal> statement, you can import an entire package of classes.
There is no keyword for this access modifier. It is useful if you are
designing a package containing classes that must be able to access each
otherâs fields or methods. For now, you should always give your fields
and methods an explicit <literal>public</literal> or <literal>private</literal> (or sometimes <literal>protected</literal>)
modifier.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>From least restrictive to most restrictive, the modifiers are <literal>public</literal>,
<literal>protected</literal>, package-private, and <literal>private</literal>. Each additional level of
restriction removes a single category of access. All fields and methods
can be accessed by code from the same class. The following table gives
the contexts outside the class that can access a field or method marked
with each modifier.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="right" valign="bottom">Modifier</entry>
<entry align="center" valign="bottom">Package</entry>
<entry align="center" valign="bottom">Subclass</entry>
<entry align="center" valign="bottom">Unrelated<?asciidoc-br?>
Classes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="bottom"><simpara><literal>public</literal></simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="right" valign="bottom"><simpara><literal>protected</literal></simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
</row>
<row>
<entry align="right" valign="bottom"><simpara>Package-private</simpara></entry>
<entry align="center" valign="bottom"><simpara>Yes</simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
</row>
<row>
<entry align="right" valign="bottom"><simpara><literal>private</literal></simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
<entry align="center" valign="bottom"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_examples_classes">
<title>Examples: Classes</title>
<simpara>Although large and complex programs are needed to see the real benefits
of OOP in Java, here are two short examples showing, respectively, how
objects can be used to make a roster of students and compute the value
of an expression in postfix notation.</simpara>
<example>
<title>Student roster</title>
<simpara>We are going to create a <literal>Student</literal> class so that we can store objects
containing student roster information. Then, weâre going to create a
client program that reads data from a user to create <literal>Student</literal> objects,
sort them by GPA, and then print them out.</simpara>
<programlisting language="java" linenumbering="numbered">public class Student {
	public static final String[] YEARS =
	{"Freshman", "Sophomore", "Junior", "Senior"};
	private String name;
	private int year;
	private double GPA;</programlisting>
<simpara>We start by defining the <literal>Student</literal> class. First, there is a constant
array of type <literal>String</literal>, giving the names of each of the four years.
Next, the fields in the <literal>Student</literal> class store the name, year, and GPA of
the student.</simpara>
<programlisting language="java" linenumbering="numbered">	public Student(String name, int year, double GPA) {
		setName( name );
		setYear( year );
		setGPA( GPA );
	}</programlisting>
<simpara>We have one constructor for this class, which takes in a <literal>String</literal>, an
<literal>int</literal>, and a <literal>double</literal> corresponding to the name, year, and GPA of the
student. The constructor then internally uses mutator methods to store
the values into the fields. By doing so, we automatically take advantage
of the error checking in the GPA mutator.</simpara>
<programlisting language="java" linenumbering="numbered">	public void setName(String name) { this.name = name; }
	public void setYear(int year) { this.year = year; }

	public void setGPA(double GPA) {
		if( GPA &gt;= 0 &amp;&amp; GPA &lt;= 4.0 )
			this.GPA = GPA;
		else
			System.out.println("Invalid GPA: " + GPA);
	}</programlisting>
<simpara>These are the mutators corresponding to each of the three fields. The
input for the name and year mutators are not checked, but the GPA
mutator checks to make sure that the GPA value is in the proper range.</simpara>
<programlisting language="java" linenumbering="numbered">	public String getName() { return name; };
	public int getYear() { return year; };
	public double getGPA() { return GPA; };

	public String toString() {
		return name + "\t" + YEARS[year] +
			"\t" + GPA;
	}
}</programlisting>
<simpara>Finally, these accessors allow the user to find out the name, year, or
GPA of a given student. Every class in Java automatically has a
<literal>toString()</literal> method that is called whenever an object is being printed
out directly. We have changed this method to return the information in
<literal>Student</literal> formatted as a <literal>String</literal>.</simpara>
<simpara>Creating the <literal>Student</literal> class is only half the battle. We also must
create client code to use it.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class StudentRoster {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		Student[] roster = new Student[in.nextInt()];
		for( int i = 0; i &lt; roster.length; i++ ) {
			in.nextLine();
			roster[i] = new Student( in.nextLine(),
				in.nextInt(), in.nextDouble() );
		}
		sort(roster);
		for( int i = 0; i &lt; roster.length; i++ )
			System.out.println(roster[i]);
	}</programlisting>
<simpara>The <literal>main()</literal> method in the <literal>StudentRoster</literal> class begins by reading in
the total number of students. Next, it makes an array of type <literal>Student</literal>
of that length. Then, it repeatedly reads in a name, year, and GPA,
creates a new <literal>Student</literal> object with those values, and stores it into the
array. After creating all the <literal>Student</literal> objects, it sorts them with a
method call and prints them out.</simpara>
<simpara>One oddity in this code is the seemingly superfluous <literal>in.nextLine()</literal> in
the first <literal>for</literal> loop. This line of code consumes a trailing newline
character from previous input. Take it out and see how quickly the
program malfunctions.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void sort(Student[] roster) {
		for( int i = 0; i &lt; roster.length - 1; i++ ) {
			int smallest = i;
			for( int j = i + 1; j &lt; roster.length; j++ )
				if(roster[j].getGPA() &lt; roster[smallest].getGPA())
					smallest = j;
			Student temp = roster[smallest];
			roster[smallest] = roster[i];
			roster[i] = temp;
		}
	}
}</programlisting>
<simpara>This <literal>sort()</literal> method is similar to others that you have seen. It
implements selection sort in ascending order based on GPA.</simpara>
<simpara>If you run this program, you will notice that it does not prompt the
user for any input. This version of the code is designed for redirected
input from a file. A more user friendly, interactive version should
prompt the user clearly.</simpara>
<simpara>Using OOP is not necessary to solve this problem. Instead of objects, we
could have used three separate arrays holding the name, year, and GPA of
each student, respectively. However, coordinating these arrays together
would become tedious, particularly when sorting.</simpara>
</example>
</section>
<section xml:id="_advanced_nested_classes">
<title>Advanced: Nested classes</title>
<simpara>Inside of a class, you can define fields and methods, but what about
other classes? Yes! Doing so creates a <emphasis>nested class</emphasis>. When you define a
class inside of an outer class, it can access fields and methods in the
outer class, even if they are marked <literal>private</literal>. Java allows a number of
different ways to define a nested class. They are all useful, but each
is subtly different. Some nested classes are tied to a specific object
of the outer class while others are not.</simpara>
<section xml:id="_static_nested_classes">
<title>Static nested classes</title>
<simpara>If you mark a nested class with the <literal>static</literal> keyword, you are creating a
class whose objects are independent of any particular outer class
object. Such a class is called a <emphasis>static nested class</emphasis>. Consider the
following class definition.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Outer {
    private int x;
    private int y;

    public static class Nested {
        private int z;
    }
}</programlisting>
<simpara>A static nested class is similar to a normal, top-level class with two
differences. First, the full name of a nested class is the name of the
outer class followed by a dot followed by the nested class name. Second,
when given an outer class object, code in a static nested class can
access and modify <literal>private</literal> (and <literal>protected)</literal>) data in the outer class
object.</simpara>
<figure role="text-center">
<title>A static nested class object is allowed to access data from outer class objects even though there is no direct relationship between them.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/09-classes/images/nested.svg" width="80%"/>
</imageobject>
<textobject><phrase>nested</phrase></textobject>
</mediaobject>
</figure>
<simpara>Static nested classes can be used when the class you need is only useful
in connection with the outer class. Thus, nesting the class groups it
with its outer class. We can create an instance of the nested class
above as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Outer.Nested nested = new Outer.Nested();</programlisting>
<simpara>Because it is a static nested class, we do not need an instance of type
<literal>Outer</literal> to create an instance of type <literal>Outer.Nested</literal>. If you compile
<literal>Outer.java</literal>, it will create two files, <literal>Outer.class</literal> and
<literal>Outer$Nested.class</literal>. The dollar sign (<literal>$</literal>) separates the names of each
level of nested class in the file name. It is possible to nest classes
inside of nested classes, producing another <literal>.class</literal> file with another
dollar sign and the new class name appended.</simpara>
<simpara>Note that static nested classes can be marked <literal>public</literal>, <literal>private</literal>,
<literal>protected</literal>, or package-private (no explicit modifier). These access
modifiers control which code can access or instantiate static nested
classes using the sames access rules for fields and methods.</simpara>
<example>
<title>Static nested class for testing</title>
<simpara>One application for static nested classes is testing. You can write code
that tests the functionality of your outer class, fiddling with its
fields if needed. Then, because a separate <literal>.class</literal> file is created, you
can deliver only the <literal>.class</literal> file for the outer class to your customer.</simpara>
<simpara>Consider the <literal>Square</literal> class, similar to the <literal>Rectangle</literal> class given
earlier.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Square {
    private int side;

    public Square( int side ) {
        this.side = side;
    }

    public int getArea() {
        return side*side;
    }
}</programlisting>
<simpara>We could add a static nested class called <literal>Test</literal> to <literal>Square</literal> to test
that its <literal>getArea()</literal> and <literal>getPerimeter()</literal> methods are working properly.
The final code might be as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Square {
    private int side;

    public Square( int side ) {
        this.side = side;
    }

    public int getArea() {
        return side*side;
    }

    public static class Test {
        public static void main(String[] args) {
            Square square = new Square(5);
            System.out.print("Test 1: ");
            if( square.getArea() == 25 )
                System.out.println("Passed");
            else
                System.out.println("Failed");

            square.side = 7;
            System.out.print("Test 2: ");
            if( square.getArea() == 49 )
                System.out.println("Passed");
            else
                System.out.println("Failed");
        }
    }
}</programlisting>
<simpara>To run the tests, you would compile <literal>Square.java</literal> and then run the
nested class by invoking <literal>java Square$Test</literal>. It is unwise to use the
nested class to change the private fields in <literal>square</literal>, but we did so to
show that it is allowed by Java. A better test would create a second
<literal>Square</literal> object with a side of length 7.</simpara>
</example>
</section>
<section xml:id="_inner_classes">
<title>Inner classes</title>
<simpara>Another kind of nested class is an <emphasis>inner class</emphasis>. Unlike static nested
classes, the objects of inner classes are associated with a particular
object of the outer class. You can think of an inner class object living
<emphasis role="strong">inside</emphasis> an outer class object. It is impossible to instantiate an inner
class object without having an outer class object first. Consider the
following class definition.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Outer {
    private int a;

    public class Inner {
        private int b;
        private int c;
    }
}</programlisting>
<simpara>Every instance of <literal>Inner</literal> must be associated with an instance of
<literal>Outer</literal>. To instantiate an inner class, you use the name of an outer
class object, followed by a dot, followed by the <literal>new</literal> keyword, and then
the name of the inner class. We can create an instance of the inner
class above as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();</programlisting>
<simpara>This syntax looks confusing, but it makes <literal>inner</literal> an object that exists
inside of <literal>outer</literal>. Thus, if there were methods defined in <literal>Inner</literal>, they
could refer to field <literal>a</literal>, because every instance of <literal>Inner</literal> would be
inside of an instance of <literal>Outer</literal> with a copy of <literal>a</literal>.</simpara>
<simpara>The relationship between outer and inner objects is one to many. We can
instantiate any number of inner class objects that all live inside of
the same outer class object.</simpara>
<figure role="text-center">
<title>An inner class object is always associated with a specific outer class object.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/09-classes/images/inner.svg" width="80%"/>
</imageobject>
<textobject><phrase>inner</phrase></textobject>
</mediaobject>
</figure>
<simpara>Another issue with inner classes (as opposed to static nested classes)
is that they cannot contain static fields (except for constants) or
methods. Since each instance of an inner class is tied to an instance of
an outer class, the designers of Java thought that static fields and
methods for an inner class really belong in the outer class.</simpara>
<simpara>It is even possible to define a class <emphasis role="strong">inside</emphasis> a method, if that class
is only referred to in the method. Such a class is called a <emphasis>local
class</emphasis>. It is possible to create an unnamed local class on the fly as
well. Such a class is called an <emphasis>anonymous class</emphasis>. Both local and
anonymous classes are special kinds of inner classes. Because of the way
they are created and used, we discuss them in SectionÂ <xref linkend="advanced:Local
and anonymous classes"/></simpara>
<example>
<title>Inner class objects as iterators</title>
<simpara>If you create a data structure for other programmers to use, a useful
feature is the ability to retrieve each item from the data structure in
order. Different threads or methods might need to process these elements
independently from each other. Each piece of code can be given an inner
class object called an <emphasis>iterator</emphasis> that can repeatedly get the next item
in the data structure. Since instances of an inner class can read
private data of the outer class, iterators can keep track of where they
are inside the data structure. If outside code were allowed access to
the data structureâs internals, it would violate encapsulation.
Iterators are a very common application of inner classes.</simpara>
<simpara>We can create a <literal>SafeArray</literal> class that only allows data to be written to
its internal array if it falls in the legal range of indexes.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SafeArray {
    private double[] data;

    public SafeArray( int size ) {
        data = new double[size];
    }

    public int set(int index, double value) {
        if( index &gt;= 0 &amp;&amp; index &lt; data.length )
            data[index] = value;
    }
}</programlisting>
<simpara>We could add an inner class called <literal>Iterator</literal> to <literal>SafeArray</literal> that allows
us to process all the array values without knowing how many there are.
This kind of behavior is useful for many dynamic data structures, as
discussed in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SafeArray {
    private double[] data;

    public SafeArray( int size ) {
        data = new double[size];
    }

    public void set(int index, double value) {
        if( index &gt;= 0 &amp;&amp; index &lt; data.length )
            data[index] = value;
    }

    public class Iterator {
        private int index = 0;

        public boolean hasNext() {
            return ( index &lt; data.length );
        }

        public double getNext() {
            if( index &gt;= 0 &amp;&amp; index &lt; data.length )
                return data[index++];
            else
                return Double.NaN;
        }
    }
}</programlisting>
<simpara>The following method uses the iterator we have defined to find the sum
of the values in a <literal>SafeArray</literal> object.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static findSum( SafeArray array ) {
    double sum = 0;
    SafeArray.Iterator iterator = array.new Iterator();

    while( iterator.hasNext() )
        sum += iterator.getNext();

    return sum;
}</programlisting>
</example>
</section>
</section>
<section xml:id="_solution_nested_expressions">
<title>Solution: Nested expressions</title>
<simpara>We now have enough knowledge to solve the nested expressions problem
from the beginning of the chapter. Classes help us divide up the work of
solving the problem. First, we need a stack class that can hold <literal>char</literal>
values.</simpara>
<formalpara xml:id="program:SymbolStack" xreflabel="SymbolStack">
<title>Simple stack class to hold symbols from an input expression.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class SymbolStack {
	private char[] symbols;
	private int size;

	public SymbolStack( int maxSize ) {
		symbols = new char[maxSize];
		size = 0;
	}

	public void push( char symbol ) { symbols[size++] = symbol; }
	public void pop() { size--; }
	public char top() { return symbols[size - 1]; }
	public boolean isEmpty() { return size == 0; }
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>SymbolStack</literal> class allows us to perform the push, pop, and top
stack operations with methods of the same names. Its constructor takes a
maximize size for the stack and allocates an array of that size. It also
sets the <literal>size</literal> field to <literal>0</literal> so that we can keep track of how many
things are in the stack (and consequently where the top is).</simpara>
<simpara>The <literal>push()</literal> method stores an input <literal>char</literal> into the stack at location
<literal>size</literal> and then increments <literal>size</literal>. The <literal>pop()</literal> method simply decrements
<literal>size</literal>. It has no error checking to prevent a user from popping the
stack once it is already empty. Finally, the <literal>top()</literal> method returns the
value at the top of the stack, whose location is <literal>size - 1</literal>.
<literal>SymbolStack</literal> also defines an <literal>isEmpty()</literal> method so that we can see if
the stack is empty.</simpara>
<simpara>Now we need the client code that read the input and interacts with the
stack.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class NestedExpressions {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		String input = in.nextLine();
		SymbolStack stack = new SymbolStack(input.length());
		char symbol;
		boolean correct = true;</programlisting>
<simpara>The <literal>main()</literal> method of this class reads in the input and creates a
<literal>SymbolStack</literal> called <literal>stack</literal> with a maximum size of the input length. We
know that the stack never needs to hold more than the total input. It
also creates a <literal>boolean</literal> named <literal>correct</literal> to keep track of whether or not
the input is correctly nested. We start by assuming that it is.</simpara>
<programlisting language="java" linenumbering="numbered">		for( int i = 0; i &lt; input.length() &amp;&amp; correct; i++ ) {
			symbol = input.charAt(i);
			switch( symbol ) {
				case '(':
				case '[':
				case '{':
					stack.push(symbol);
					break;
				case ')':
					if(stack.isEmpty() || stack.top() != '(')
						correct = false;
					else
						stack.pop();
					break;
				case ']':
					if(stack.isEmpty() || stack.top() != '[')
						correct = false;
					else
						stack.pop();
					break;
				case '}':
					if(stack.isEmpty() || stack.top() != '{')
						correct = false;
					else
						stack.pop();
					break;
			}
		}</programlisting>
<simpara>This <literal>for</literal> loop runs through each <literal>char</literal> in the input. If it is a left
parenthesis, left square bracket, or left curly brace, it pushes the
symbol onto the stack. If it is a right parenthesis, right square
bracket, or right curly brace, it checks to see if the stack is empty.
Because of short-circuit evaluation, the code does not even look at the
top of the stack if it is empty. However, if the stack is not empty, it
checks to see if the top matches the current symbol. If the stack is
empty or its top does not match, <literal>correct</literal> is set to <literal>false</literal>. For
efficiency, the loop stops early if <literal>correct</literal> is no longer <literal>true</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		if( !stack.isEmpty() ) //unmatched left symbols
			correct = false;

		if( correct )
			System.out.println("The input is correctly nested!");
		else
			System.out.println("The input is incorrectly nested!");
	}
}</programlisting>
<simpara>After the input has been examined, we check to see if the stack is
empty. If it isnât, there must be some left symbols that were not
matched with right symbols. In that case, we set <literal>correct</literal> to <literal>false</literal>.
Finally, we print out whether the input is correctly or incorrectly
nested based on the value of <literal>correct</literal>.</simpara>
</section>
<section xml:id="_concurrency_objects">
<title>Concurrency: Objects</title>
<simpara>Nearly everything in Java is an object: arrays, lists, <literal>String</literal> values,
colors, and even exceptions, which form Javaâs error-handling system and
is discussed in ChapterÂ <xref linkend="chapter:Exceptions"/>. Some critics of Java
point out that <literal>int</literal>, <literal>double</literal>, and the other primitive types are not
objects, forcing the programmer to adopt two different programming
models. Regardless, threads are stored as objects as well. In
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>, we discuss how to create
threads and the various methods that can be used to interact with them.</simpara>
<simpara>However, objects of type <literal>Thread</literal> are not the only ones you deal with
when writing concurrent programs. As we have just noted, most data in
Java is encapsulated in an object. One of the deep reasons for using OOP
is safety: We want the private data inside of an object to stay in a
consistent state. Due to their inexplicable ability to get out of tight
situations, one tradition holds that cats have nine lives. Because of
their inquisitive nature, another tradition holds that curiosity killed
the cat. Consider the class below that keeps track of the lives a cat
has, losing one every time it becomes curious.</simpara>
<example>
<title>Thread safety</title>
<formalpara xml:id="program:Cat" xreflabel="Cat">
<title>Program to record the number of lives a cat has left. Each <literal>Cat</literal> object starts with 9, but loses one each time it uses its curiosity. If no more lives remain, an error message is output.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Cat {
	private int lives = 9;

	public boolean useCuriosity() {
		if( lives &gt; 1 ) { /*@\label{life check}@*/
			lives--;
			System.out.println("Down to life " + lives);
			return true;
		}
		else {
			System.out.println("No more lives left!");
			return false;
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>If the relationship between curiosity and mortality is the only feature
of a cat you are trying to model, this class appears to function well.
If the <literal>useCuriosity()</literal> method is invoked, it removes a life or prints
an error message if the cat has run out of lives. In a single-threaded
situation, this object would work perfectly. No cat would be able to
lose more than 9 lives.</simpara>
<simpara>In a multi-threaded situation, there is no telling when a thread might
pause in executing the <literal>useCuriosity()</literal> method. If 100 threads all
called <literal>useCuriosity()</literal>, each one might successfully pass the <literal>if</literal>
statement on line <xref linkend="life_check"/> before any had decremented <literal>lives</literal>.
Once past the check, nothing would prevent them from continuing on and
decrementing <literal>lives</literal>, resulting in a cat who lost 100 lives, resulting
in a total of -91 lives. Such a scenario makes no sense.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Synchronization"/>, we discuss how to prevent this
problem, using the <literal>synchronized</literal> keyword to allow only a single thread
at a time to execute the body of a method. The goal is to make
<literal>useCuriosity()</literal> <emphasis>thread-safe</emphasis>, meaning that its behavior is consistent
and correct no matter how many threads try to execute it at the same
time.</simpara>
</example>
<simpara>As you work through this book and begin to write your own concurrent
programs, we discuss ways to make them thread-safe. However, you are
also a consumer of code written by other people. In multi-threaded
environments, you may need to use library classes that are thread-safe.
For example, <literal>AtomicInteger</literal> is a thread-safe class designed to store
and manipulate <literal>int</literal> values. In ChapterÂ <xref linkend="chapter:Dynamic Data
Structures"/>, we talk about the <literal>ArrayList</literal> and <literal>Vector</literal> classes, which
are both used to hold variable length lists of objects. One of the few
differences between them is that <literal>ArrayList</literal> is not thread-safe while
<literal>Vector</literal> is. There is even the <literal>Collections.synchronizedCollection()</literal>
method (and other similar methods), which takes a collection that is not
thread-safe and returns a version of it that is.</simpara>
<simpara>Java was intended to be multi-threaded from the very beginning, but
concurrency was never the most important feature in the language. For
that reason, the documentation does not clearly mark which methods are
thread-safe. Usually, some of the paragraphs of description above the
list of methods say that a class is &#8220;synchronized&#8221; if it is
thread-safe. If it is not, the documentation may not mention anything.
Careful attention is needed to be sure which classes and APIs are
thread-safe.</simpara>
<simpara>You may wonder why all classes are not thread-safe, but everything comes
with a price. If a class is thread-safe, its methods are usually marked
with the <literal>synchronized</literal> keyword. The JVM is relatively efficient about
how it enforces that keyword, but the computational expense is not zero.
Learn the libraries well, and use the right tools for the right job.</simpara>
</section>
<section xml:id="_exercises_8">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Explain the relationship between a class and an object.</simpara>
</listitem>
<listitem>
<simpara>What is the difference between a static method and an instance
method?</simpara>
</listitem>
<listitem>
<simpara>What is the purpose of a constructor? Why is it impossible for a
constructor to return a value? Why is it impossible for a constructor to
be called multiple times on the same object?</simpara>
</listitem>
<listitem>
<simpara>A static method can be called directly from a instance method, but
an instance method cannot be called directly from a static method. Why?</simpara>
</listitem>
<listitem>
<simpara>Describe the uses of accessor and mutator methods. Is it possible to
create a method that is both an accessor and a mutator? Why or why not?</simpara>
</listitem>
<listitem>
<simpara>Why do we usually mark fields with the <literal>private</literal> keyword when it
would be easier to make all fields <literal>public</literal>?</simpara>
</listitem>
<listitem>
<simpara>What is the meaning of the <literal>this</literal> keyword? When is it necessary to
use it? When can it be ignored?</simpara>
</listitem>
<listitem>
<simpara>Consider the following class definitions.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class A {
    private int a;

    public int get() {
        return a;
    }

    public static void increment() {
        a++;
    }
}

public class B {
    private int b;

    public B(int value) {
        b = value;
    }

    public A generate() {
        A object = new A();
        object.a = b;
    }
}</programlisting>
<simpara>The field <literal>a</literal> is used three times in the previous code. Which of these
uses cause a compiler error and why?</simpara>
</listitem>
<listitem>
<simpara>In SectionÂ <xref linkend="solution:Nested_expressions"/>, we gave a definition of
<literal>SymbolStack</literal> that implements a simple stack using two fields, defined
as followed:</simpara>
<programlisting language="java" linenumbering="unnumbered">private char[] symbols;
private int size;</programlisting>
<simpara>By calling the <literal>top()</literal> or <literal>pop()</literal> methods on an empty stack, it is
possible to cause a program to crash. What additional problems could
happen if <literal>symbols</literal> and <literal>size</literal> were declared <literal>public</literal> and malicious or
poorly written code had access to the object?</simpara>
</listitem>
<listitem>
<simpara>Consider the following class definition.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class GroceryItem {
    private String name;
    private double price;

    public GroceryItem( String text, double money ) {
        String name = text;
        double price = money;
    }

    public String getName() { return name; }
    public String getPrice() { return price; }
}</programlisting>
<simpara>This class compiles, but its constructor does not function properly. Why
not?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>OOP is often used when the data inside the object must maintain
special relationships. Consider a clock with hours, minutes, and
seconds. When the number of seconds reaches 60, the number of minutes is
increased by 1, and the number of seconds is reset to 0. When the number
of minutes reaches 60, the numer of hours is increased by 1, and the
number of seconds is reset to 0. When the number of hours reaches 13, it
is reset to 1. AM and PM switch whenever the number of hours reaches 12.</simpara>
<simpara>Define a <literal>Clock</literal> class with private <literal>int</literal> fields <literal>hours</literal>, <literal>minutes</literal>, and
<literal>seconds</literal> and a <literal>boolean</literal> field <literal>PM</literal>. Write a constructor that
initializes <literal>hours</literal> to <literal>12</literal>, <literal>minutes</literal> and <literal>seconds</literal> to <literal>0</literal>, and <literal>PM</literal> to
<literal>false</literal>. Write a mutator <literal>increment()</literal> that adds <literal>1</literal> to <literal>seconds</literal>. This
mutator should correctly handle all the clock behavior described above.
Write an accessor called <literal>toString()</literal> that returns a nicely formatted
version of the time as a <literal>String</literal>. For example, the initial time would
be returned as <literal>"12:00:00 AM"</literal>. Make sure you pad the output for
<literal>seconds</literal> and <literal>minutes</literal> with an extra <literal>"0"</literal> if they are less than <literal>10</literal>.</simpara>
</listitem>
<listitem>
<simpara>Draw on any of your hobbies to come up with a collection of items,
whether those items are books you like to read, athletes you follow,
music you collect, or anything else that is easy to classify. First
create a class that can describe one of these items with three to five
attributes. For example, the important attributes of a book might be
author, title, genre, and page count. Each of these attributes should be
stored as a <literal>private</literal> field and manipulated with <literal>public</literal> accessor and
mutator methods.</simpara>
<simpara>Using an array, create a database of these objects. Write methods that
print out all objects that have a particular value for an attribute.
Using the book example, your database program should let the user input
that he or she is looking for all books whose author is
<literal>Alexandre Dumas</literal>. You may wish to use input redirection so that you do
not have to enter data about your objects repetitively.</simpara>
</listitem>
<listitem>
<simpara>The <literal>java.awt</literal> package defines a class called <literal>Point</literal> that can be
used to manipulate an <inlineequation><alt><![CDATA[(x,y)]]></alt><mathphrase><![CDATA[(x,y)]]></mathphrase></inlineequation> pair in programs involving the
Cartesian coordinate system. Create your own <literal>Point</literal> class with <literal>int</literal>
values <literal>x</literal> and <literal>y</literal> as fields.</simpara>
<simpara>Create one constructor that allows the user to specify values for <literal>x</literal>
and <literal>y</literal> and a default constructor that takes no arguments and sets both
<literal>x</literal> and <literal>y</literal> to <literal>0</literal>. Create accessors and mutators for <literal>x</literal> and <literal>y</literal>.</simpara>
<simpara>Finally, create a method with the signature
<literal>public double distance( Point p )</literal> that uses the distance formula
<inlineequation><alt><![CDATA[\sqrt{(x_1 - x_2)^2+(y_1 - y_2)^2}]]></alt><mathphrase><![CDATA[\sqrt{(x_1 - x_2)^2+(y_1 - y_2)^2}]]></mathphrase></inlineequation> to find the distance
between the current <literal>Point</literal> object and the <literal>Point</literal> object <literal>p</literal> passed in
as an argument.</simpara>
<simpara>Write client code that allows you to create two <literal>Point</literal> objects and test
if the <literal>distance()</literal> method gives the right answer.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the solution from SectionÂ <xref linkend="solution:Nested
expressions"/> so that it performs its input and output with GUIs created
using <literal>JOptionPane</literal>.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Objects are great tools for solving problems, but there is some
additional overhead associated with creating objects and calling
methods.</simpara>
<simpara>Write a piece of code that allocates an array of 10,000,000 <literal>int</literal>
values. Iterate through that array, storing the value <literal>i</literal> into index
<literal>i</literal>, and time the process using an OS <literal>time</literal> command. As you know, the
<literal>Integer</literal> wrapper class allows us to store an <literal>int</literal> value in object
form. Repeat the experiment, but, instead of <literal>int</literal> values, allocate an
array to hold 10,000,000 <literal>Integer</literal> objects. Iterate through the array
again, storing an <literal>Integer</literal> object into each index of the array. For
index <literal>i</literal>, store a new <literal>Integer</literal> objected created by passing value <literal>i</literal>
into its constructor. Compare the time taken to the previous time for
<literal>int</literal> values. Do you think this is a reasonable way to estimate the time
it takes to call a constructor and allocate a new object?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Interfaces">
<title>Interfaces</title>
<blockquote>
<attribution>
Edward Gibbon
</attribution>
<simpara>Our work is the presentation of our capabilities.</simpara>
</blockquote>
<section xml:id="_problem_sort_it_out">
<title>Problem: Sort it out</title>
<simpara>Defining classes as we did in ChapterÂ <xref linkend="chapter:Classes"/> provides us
with useful tools. First, we can group related data together. Then, we
can encapsulate that data so that it can only be changed in carefully
controlled ways. But these ideas are only a fraction of the true power
of object orientation that becomes apparent when we exploit
relationships between different classes. Eventually, in
ChapterÂ <xref linkend="chapter:Inheritance"/>, we will talk about hierarchical
relationships, in which one class can be the parent of many other child
classes. However, there is a simpler relationship that classes can
share, the ability to do some specific action or answer some specific
question. If we know that several different classes can all do the same
things, we want to be able to treat them in a unified way. For example,
imagine that you are writing code to aid laboratory analysis of the free
radical content of a number of creatures and items. For this analysis it
is necessary to sort the test subjects by weight and by age.</simpara>
<simpara>The subjects you are going to sort will be objects of type <literal>Dog</literal>, <literal>Cat</literal>,
<literal>Person</literal>, and <literal>Cheese</literal>. All of these subjects will have some calendar
age. Naturally, the age we are interested for a <literal>Dog</literal> is 7 times its
calendar age. At the same time, because a cat has nine lives, we will
use <inlineequation><alt><![CDATA[\frac{1}{9}]]></alt><mathphrase><![CDATA[\frac{1}{9}]]></mathphrase></inlineequation> of its calendar age. The age we use for
<literal>Person</literal> and <literal>Cheese</literal> objects is simply their calendar age.</simpara>
<simpara>As we discussed in ExampleÂ <xref linkend="example:Selection_sort"/>, sorting is one of
the most fundamental things that computer scientists do. In that
example, we introduced selection sort. Here we are going to use another
sort called bubble sort. We are introducing bubble sort to expose you to
another way to sort data. Although they are easy to understand, neither
bubble sort nor selection sort are the fastest ways known to sort lists.</simpara>
<simpara>Bubble sort works by scanning through a list of items, a pair at a time,
and swapping the elements of the pair if they are out of order. One scan
through the list is called a <emphasis>pass</emphasis>. The algorithm keeps making passes
until no consecutive pair of elements is out of order. Here is an
implementation of bubble sort that sorts an array of <literal>int</literal> values in
ascending order.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean swapped = true;
int temp;
while( swapped ) {
    swapped = false;
    for( int i = 0; i &lt; array.length - 1; i++ )
        if( array[i] &gt; array[i + 1] ) {
            temp = array[i];
            array[i] = array[i + 1];
            array[i + 1] = temp;
            swapped = true;
        }
}</programlisting>
<warning>
<title>Pitfall: Array out of bounds</title>
<simpara>Note that index variable <literal>i</literal> stops before <literal>array.length - 1</literal> since we
donât want to get an<?asciidoc-br?>
<literal>ArrayIndexOutOfBoundsException</literal> when looking at <literal>array[i + 1]</literal>.</simpara>
</warning>
<simpara>The only change needed to make a bubble sort work with lists of
arbitrary objects (instead of just <literal>int</literal> values) is the <literal>if</literal> statement.
Likewise, changing the greater than (<literal>&gt;</literal>) to a less than (<literal>&lt;</literal>) will
change the sort from ascending to descending.</simpara>
</section>
<section xml:id="_concepts_making_a_promise">
<title>Concepts: Making a promise</title>
<simpara>Knowing how to sort a list of items is half of the problem we want to
solve. The other half is designing the classes so that sorting by either
age or weight is easy. And easy sorting is not enough: We want to follow
good object oriented design so that sorting future classes will be easy
as well.</simpara>
<simpara>For these kinds of situations, Java has a feature called <emphasis>interfaces</emphasis>.
An interface is a set of methods that a class must have in order to
<emphasis>implement</emphasis> that interface. If a class implements an interface, it is
making a promise to have a version of each of the methods listed in the
interface. It can choose to do anything it wants inside the body of each
method, but it must have them to compile. Interfaces are also described
as contracts, since a contract is a promise to do certain things. One
reason that interfaces are so useful is because Java allows a class to
implement any number of them.</simpara>
<simpara>The purpose of an interface is to guarantee that a class has the
capability to do something. In the case of this sorting problem, we will
need to sort by age and weight. Consequently, the ability to report age
and weight are the two important capabilities that the objects we are
sorting must have.</simpara>
</section>
<section xml:id="_syntax_interfaces">
<title>Syntax: Interfaces</title>
<simpara>Declaring an interface is similar to declaring a class except that
interfaces can only hold public abstract methods and constants. An
<emphasis>abstract method</emphasis> is one that does not have a body. Its return type,
name, and parameters are given, but this information is concluded with a
semicolon (<literal>;</literal>) instead of a method body. Because the purpose of an
interface is to ensure a class has certain publicly available
capabilities, all abstract methods and constants listed in an interface
are assumed to be <literal>public</literal>. It is legal but needlessly cluttered to mark
each method with <literal>public</literal>, and it is illegal to mark them with <literal>private</literal>
or <literal>protected</literal>.</simpara>
<simpara>Here is an interface for a guitar player that defines two abstract
methods.</simpara>
<programlisting xml:id="program:Guitarist" xreflabel="Guitarist" language="java" linenumbering="numbered">public interface Guitarist {
	void strumChord( Chord chord );
	void playMelody( Melody notes );
}</programlisting>
<simpara>Any class that implements this interface must have both of these
methods, declared with the access modifier <literal>public</literal>, the same return
types, and the same parameters. We could create a <literal>RockGuitarist</literal> class
that implements <literal>Guitarist</literal> as follows.</simpara>
<programlisting xml:id="program:RockGuitarist" xreflabel="RockGuitarist" language="java" linenumbering="numbered">public class RockGuitarist implements Guitarist {
	public void strumChord( Chord chord ) {
		System.out.print("Totally wails on that " + chord.getName()
				+ " chord!");
	}

	public void playMelody( Melody notes ) {
		System.out.print( "Burns through the notes " +
				notes.toString() + " like Jimmy Page!" );
	}
}</programlisting>
<simpara>Or we can create a <literal>ClassicalGuitarist</literal> class. A classical guitarist is
going to approach playing a chord or a melody differently from a rock
guitarist. Java only requires that all the methods in the interface are
implemented.</simpara>
<programlisting xml:id="program:ClassicalGuitarist" xreflabel="ClassicalGuitarist" language="java" linenumbering="numbered">public class ClassicalGuitarist implements Guitarist {
	public void strumChord( Chord chord ) {
		System.out.print( "Delicately voices a " + chord.getName()
				+ " chord." );
	}

	public void playMelody( Melody notes ) {
		System.out.print("Plucks the melodic line "
				+ notes.toString()
				+ " with the skill of John Williams.");
	}
}</programlisting>
<simpara>Interfaces make our code more flexible because we can use a reference
with an interface type to refer to any objects which implement that
interface. In the following snippet of code we do this by creating 100
<literal>Guitarist</literal> references, each of which randomly points to either a
<literal>RockGuitarist</literal> or a <literal>ClassicalGuitarist</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">Guitarist[] guitarists = new Guitarist[100];
Random random = new Random();
for( int i = 0; i &lt; guitarists.length; i++ )
    if( random.nextBoolean() )
        guitarists[i] = new RockGuitarist();
    else
        guitarists[i] = new ClassicalGuitarist();</programlisting>
<simpara>Mistakes in the use of interfaces should generally be caught at compile
time. If you implement an interface with a class you are writing but
forget (or misspell) a required method, the compiler will fail to
compile that class. If you remember all of the required methods but
forget to specify that your class implements a particular interface, the
compiler will fail when you try to use that class in a place where that
interface is required.</simpara>
<simpara>If you have code that takes some arbitrary object as a parameter, you
can determine if that object implements a particular interface by using
the <literal>instanceof</literal> keyword. For example, the following method takes a
<literal>Chord</literal> object and an object of type <literal>Object</literal>. The <literal>Object</literal> type is the
most basic reference type there is. All reference types in Java can be
treated as an <literal>Object</literal> type. Thus, a reference of type <literal>Object</literal> could
point at any object of any type. In this case, if the <literal>Object</literal> turns out
to implement the <literal>Guitarist</literal> interface, we can cast it to a <literal>Guitarist</literal>
and use it to strum a chord.</simpara>
<programlisting language="java" linenumbering="unnumbered">void checkBeforeStrum( Object unknown, Chord chord ) {
    if( unknown instanceof Guitarist ) {
        Guitarist player = (Guitarist)unknown;
        player.strumChord( chord );
    }
    else
        System.out.println("That's not a guitarist!");
}</programlisting>
<warning>
<title>Pitfall: Interfaces cannot be instantiated</title>
<simpara>It is tempting to try to create an object of an interface type. If you
think about this carefully, it should be clear why this is impossible.
An interface is a promise to do things, but it is not a class. It has no
data nor methods to manipulate data. Thus, the following code will fail
to compile.</simpara>
<programlisting language="java" linenumbering="unnumbered">Guitarist guitarist = new Guitarist();</programlisting>
<simpara>We are permitted to make a reference to objects that implement
<literal>Guitarist</literal>. We can make an array that holds such references. The
interface itself, however, can never be instantiated.</simpara>
</warning>
<section xml:id="_interfaces_and_literal_static_literal">
<title>Interfaces and <literal>static</literal></title>
<simpara>When designing an interface, you cannot mark a method as <literal>static</literal>.
Whether or not a method is <literal>static</literal> is considered by Java to be an
implementation detail that is not suitable to specify in an interface.
For example, even with <literal>Chord</literal> and <literal>Melody</literal> defined, the following
interface fails to compile.</simpara>
<programlisting xml:id="program:StaticGuitarist" xreflabel="StaticGuitarist" language="java" linenumbering="numbered">public interface StaticGuitarist {
	void strumChord( Chord chord );
	void playMelody( Melody notes );
	static int getStrings();
}</programlisting>
<simpara>The designers of Java decided that they did not want their language to
function this way. Some languages like PHP allow the equivalent of
static methods in interfaces.</simpara>
<simpara>Neither fields nor class variables are allowed in interfaces either, but
class constants are allowed. Thus, we could define <literal>static</literal> <literal>final</literal>
values that might be useful to any class implementing an interface. With
<literal>Chord</literal> and <literal>Melody</literal> defined, the following interface <emphasis role="strong">will</emphasis> compile.</simpara>
<programlisting xml:id="program:ConstantGuitarist" xreflabel="ConstantGuitarist" language="java" linenumbering="numbered">public interface ConstantGuitarist {
	static final int MAJOR = 1;
	static final int NATURAL_MINOR = 2;
	static final int HARMONIC_MINOR = 3;
	static final int MELODIC_MINOR = 4;
	static final int CHROMATIC = 5;
	static final int PENTATONIC = 6;

	void strumChord( Chord chord );
	void playMelody( Melody notes );
}</programlisting>
<simpara>Many modern Java users object to the use of constants in interfaces,
since the purpose of an interface is to define a list of a requirements
for what a class does rather than dealing with data values.
Nevertheless, constants are allowed in interfaces, and the Java API does
so in many cases.</simpara>
<example>
<title>Supermarket pricing</title>
<simpara>Interface names often include the suffix <emphasis>-able</emphasis>, for example,
<literal>Runnable</literal>, <literal>Callable</literal>, and <literal>Comparable</literal>. This suffix is typical because
it reminds us that a class implementing an interface has some specific
ability. Letâs consider an example in a supermarket in which the items
could have very little in common with each other but they all have a
price. We could define the interface <literal>Priceable</literal> as follows.</simpara>
<programlisting xml:id="program:Priceable" xreflabel="Priceable" language="java" linenumbering="numbered">interface Priceable {
	double getPrice();
}</programlisting>
<simpara>If bananas cost $0.49 a pound, we can define the <literal>Bananas</literal> class as
follows.</simpara>
<programlisting xml:id="program:Bananas" xreflabel="Bananas" language="java" linenumbering="numbered">public class Bananas implements Priceable {
	public static final double PRICE_PER_POUND = 0.49;
	private double weight;

	public Bananas( double weight ) { this.weight = weight; }

	public double getPrice() {
		return weight*PRICE_PER_POUND;
	}
}</programlisting>
<simpara>If eggs are $1.50 for a dozen large eggs and $1.75 for a dozen extra
large eggs, we can define the <literal>Eggs</literal> class as follows.</simpara>
<programlisting xml:id="program:Eggs" xreflabel="Eggs" language="java" linenumbering="numbered">public class Eggs implements Priceable {
	public static final double PRICE_PER_DOZEN_LARGE = 1.5;
	public static final double PRICE_PER_DOZEN_EXTRA_LARGE = 1.75;
	private int dozens;
	private boolean extraLarge;

	public Eggs( int dozens, boolean extraLarge ) {
		this.dozens = dozens;
		this.extraLarge = extraLarge;
	}

	public double getPrice() {
		if( extraLarge )
			return dozens*PRICE_PER_DOZEN_EXTRA_LARGE;
		else
			return dozens*PRICE_PER_DOZEN_LARGE;
	}
}</programlisting>
<simpara>Finally, if water is $0.99 a gallon, we can define the <literal>Water</literal> class as
follows.</simpara>
<programlisting xml:id="program:Water" xreflabel="Water" language="java" linenumbering="numbered">public class Water implements Priceable {
    public static final double PRICE_PER_GALLON = 0.99;
    private int gallons;

    public Water( int gallons ) { this.gallons = gallons; }

    public double getPrice() { return gallons*PRICE_PER_GALLON; }
}</programlisting>
<simpara>Each class could be much more complicated, but the code shown is all
that is needed to implement the <literal>Priceable</literal> interface. Even though there
is no clear relationship between bananas, eggs, and water, a shopping
cart filled with these items (and any others implementing the
<literal>Priceable</literal> interface) could easily be totaled at the register. If we
represent the shopping cart as an array of <literal>Priceable</literal> items, we could
write a simple method to total the values like so.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double getTotal( Priceable[] cart ) {
    double total = 0.0;
    for( int i = 0; i &lt; cart.length; i++ )
        total += cart[i].getPrice();

    return total;
}</programlisting>
<simpara>Note that we can pass in <literal>Bananas</literal>, <literal>Eggs</literal>, <literal>Water</literal>, and many other
kinds of objects in a <literal>Priceable</literal> array as long as they all implement
this interface. Even though it is impossible to create an object with an
interface type, we can make as many references to it as we want.</simpara>
</example>
</section>
</section>
<section xml:id="_advanced_local_and_anonymous_classes">
<title>Advanced: Local and anonymous classes</title>
<simpara>If you have not read SectionÂ <xref linkend="advanced:Nested_classes"/>, you may want
to look over that material to be sure that you understand what nested
classes and inner classes are. Recall that a normal inner class is
declared inside of another class, but it is also legal to declare a
class inside of a method. Such a class is called a <emphasis>local class</emphasis>. Under
some circumstances, it is useful to create another kind of inner class
that has no name. That kind of class is called an <emphasis>anonymous class</emphasis>.</simpara>
<simpara>Both kinds of classes are inner classes. They can access fields and
methods, even if they are marked <literal>private</literal>. Like other inner classes,
they are not allowed to declare <literal>static</literal> variables other than constants.
We bring up these kinds of classes in this chapter because they are
commonly used to create a class with a narrow purpose that implements a
required interface.</simpara>
<section xml:id="_local_classes">
<title>Local classes</title>
<simpara>A local class declaration looks like any other class declaration except
that it occurs within a method. The name of a local class only has
meaning inside the method where it is defined. Because the scope of the
name is only the method, a local class cannot have access modifiers such
as <literal>public</literal>, <literal>private</literal>, or <literal>protected</literal> applied to it.</simpara>
<simpara>Consider the following method in which an <literal>Ellipse</literal> class is defined
locally. Recall that an ellipse (or oval) has a major (long) axis and a
minor (short) axis. The area of an ellipse is half its major axis times
half its minor axis times <inlineequation><alt><![CDATA[\pi]]></alt><mathphrase><![CDATA[\pi]]></mathphrase></inlineequation>. (Because the major and
minor axes of a circle are its diameter, this formula becomes
<inlineequation><alt><![CDATA[\pi
r^2]]></alt><mathphrase><![CDATA[\pi
r^2]]></mathphrase></inlineequation> in that case.)</simpara>
<figure role="text-center">
<title>Area of an ellipse.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/10-interfaces/images/ellipse.svg" width="50%"/>
</imageobject>
<textobject><phrase>ellipse</phrase></textobject>
</mediaobject>
</figure>
<programlisting language="java" linenumbering="unnumbered">public static void createEllipse(double a1, double a2) {
    class Ellipse {
        private double axis1;
        private double axis2;

        public Ellipse( double axis1, double axis2 ) {
            this.axis2 = axis2;
            this.axis1 = axis1;
        }
        public double getArea() {

            return Math.PI*0.5*axis1*0.5*axis2;
    }
        }

    System.out.println("The ellipse has area " + e.getArea());
    Ellipse e = new Ellipse(a1, a2);
}</programlisting>
<simpara>This <literal>Ellipse</literal> class cannot be referred to by any other methods. Since
an <literal>Ellipse</literal> class might be useful in other code, a top-level class
would make more sense than this local class. For this reason, local
classes are not commonly used.</simpara>
<simpara>However, we can make local classes more useful if they implement
interfaces. Consider the following interface which can be implemented by
any shape that returns its area.</simpara>
<programlisting xml:id="program:AreaGettable" xreflabel="AreaGettable" language="java" linenumbering="numbered">public interface AreaGettable {
	double getArea();
}</programlisting>
<simpara>The method below takes an array of <literal>AreaGettable</literal> objects and sums their
areas.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double sumAreas( AreaGettable[] shapes ) {
    double sum  = 0;
    for( int i = 0; i &lt; shapes.length; i++ )
        sum += shapes[i].getArea();

    return sum;
}</programlisting>
<simpara>If we create a local class that implements <literal>AreaGettable</literal>, we can use it</simpara>
<simpara>in conjunction with the <literal>sumAreas()</literal> method. In the following method, we
100 <literal>Ellipse</literal> instances which can then be passed to <literal>sumAreas()</literal>.
will expand the local <literal>Ellipse</literal> class in this way and fill an array with</simpara>
<simpara>public static void createEllipses() {</simpara>
<programlisting language="java" linenumbering="unnumbered">    class Ellipse implements AreaGettable {
        private double axis1;

        private double axis2;
            this.axis1 = axis1;
        public Ellipse( double axis1, double axis2 ) {
            this.axis2 = axis2;

        }
        public double getArea() {
            return Math.PI*0.5*axis1*0.5*axis2;
        }
    }


    AreaGettable[] ellipses = new AreaGettable[100];
    for( int i = 0; i &lt; 100; i++ )
        ellipses[i] = new Ellipse(Math.random() * 25.0,
            Math.random() * 25.0);
    double sum = sumAreas( ellipses );

    System.out.println("The total area is " + sum);
}</programlisting>
<simpara>Even though the <literal>Ellipse</literal> class had the <literal>getArea()</literal> method before, the
compiler would not have allowed us to store <literal>Ellipse</literal> references in an
<literal>AreaGettable</literal> array until we marked the <literal>Ellipse</literal> class as implementing
<literal>AreaGettable</literal>. As in ExampleÂ <xref linkend="example:Supermarket_pricing"/>, we used
an array of the interface type.</simpara>
</section>
<section xml:id="subsection:_Anonymous_classes">
<title>Anonymous classes</title>
<simpara>This second <literal>Ellipse</literal> class is more useful since objects with its type
can be passed to other methods as an <literal>AreaGettable</literal> reference, but
declaring the class locally provides few benefits over a top-level
class. Indeed, local classes are seldom preferable to top-level classes.
Although anonymous classes behave like local classes, they conveniently
can be created at any point.</simpara>
<simpara>An anonymous class has no name. It is created on the fly from some
interface or parent class and can be stored into a reference with that
type. In the following example, we modify the <literal>createEllipses()</literal> method
so that it creates an anonymous class which behaves exactly like the
<literal>Ellipse</literal> class and implements the <literal>AreaGettable</literal> interface.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void createEllipses() {
    AreaGettable[] ellipses = new AreaGettable[100];

    for( int i = 0; i &lt; 100; i++ ) {
        final double value1 = Math.random();
        final double value2 = Math.random();

        ellipses[i] = new AreaGettable() {
            private double axis1 = value1;
            private double axis2 = value2;

            public double getArea() {
                return Math.PI*0.5*axis1*0.5*axis2;
            }
        };
    }

    double sum = sumAreas( ellipses );
    System.out.println("The total area is " + sum);
}</programlisting>
<simpara>The syntax for creating an anonymous class is ugly. First, you use the
<literal>new</literal> keyword followed by the name of the interface or parent class you
want to create the anonymous class from. Next, you put the arguments to
the parent class constructor inside of parentheses or leave empty
parentheses for an interface. Finally, you open a set of braces and fill
in the body for your anonymous class. When defining an anonymous class,
the entire body is crammed into a single statement, and you will often
need to complete that statement with a semicolon (<literal>;</literal>).</simpara>
<simpara>Anonymous classes do not have constructors. If you need a constructor,
you will have to create a local class. Constructors are usually not
necessary since both local and anonymous classes can see local variables
and fields and use those to initialize values. Although any fields can
be used, local variables must be marked <literal>final</literal> (as shown above) if
their values will be used by local or anonymous classes. This
restriction prevents local variables from being changed unpredictably by
methods in the local class.</simpara>
<simpara>It may not be easy to see why anonymous classes are useful. Both the
Java API and libraries written by other programmers have many methods
that require parameters whose type implements a particular interface.
Without anonymous classes, you would have to define a named class and
instantiate it to supply such a method with an object with the required
capabilities.</simpara>
<simpara>Using anonymous classes, you can create such an object in one step,
right where you need it. This practice is commonly used for creating
<emphasis>listeners</emphasis> for GUIs. A listener is an object that does the right action
when a particular event happens. If you need many different listeners in
one program, it can be convenient to create anonymous classes that can
handle each event rather than defining many named classes which each
have a single, narrow purpose. We will use this technique in
ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>.</simpara>
</section>
</section>
<section xml:id="_solution_sort_it_out">
<title>Solution: Sort it out</title>
<simpara>It is not difficult to move from totaling the value of items as we did
in ExampleÂ <xref linkend="example:Supermarket_pricing"/> to sorting them. Refer to the
following class diagram as we explain our solution to the sorting
problem posed at the beginning of the chapter. Dotted lines are used to
show the implements relationship.</simpara>
<figure>
<title>Sorting relationships.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/10-interfaces/images/ageandweight.svg" width="100%"/>
</imageobject>
<textobject><phrase>ageandweight</phrase></textobject>
</mediaobject>
</figure>
<simpara>We will start with the definitions of the two interfaces we will use to
compare objects.</simpara>
<programlisting xml:id="program:Ageable" xreflabel="Ageable" language="java" linenumbering="numbered">public interface Ageable {
	int getAge();
}</programlisting>
<programlisting xml:id="program:Weighable" xreflabel="Weighable" language="java" linenumbering="numbered">public interface Weighable {
	double getWeight();
}</programlisting>
<simpara>Classes implementing these two interfaces will be able to give their age
and weight independently. The next step is to create the <literal>Dog</literal>, <literal>Cat</literal>,
<literal>Person</literal>, and <literal>Cheese</literal> classes which can do so.</simpara>
<simpara>Weâll see in ChapterÂ <xref linkend="chapter:Inheritance"/> that the <literal>Dog</literal>, <literal>Cat</literal>, and
<literal>Person</literal> classes could inherit from a common ancestor (such as
<literal>Creature</literal> or <literal>Mammal</literal>) which implements the <literal>Ageable</literal> and <literal>Weighable</literal>
interfaces. That design could reduce the total amount of code needed.
For now, each class will have to implement both interfaces directly.</simpara>
<programlisting xml:id="program:Dog" xreflabel="Dog" language="java" linenumbering="numbered">public class Dog implements Ageable, Weighable {
	private int age;
	private double weight;

	public Dog( int age, double weight ) {
		this.age = age;
		this.weight = weight;
	}

	public int getAge() { return age*7; }

	public int getWeight() { return weight; }
}</programlisting>
<programlisting language="java" linenumbering="numbered">public class Cat implements Ageable, Weighable {
	private int age;
	private double weight;

	public Cat( int age, double weight ) {
		this.age = age;
		this.weight = weight;
	}

	public int getAge() { return age/9; }

	public int getWeight() { return weight; }
}</programlisting>
<programlisting xml:id="program:Person" xreflabel="Person" language="java" linenumbering="numbered">public class Person implements Ageable, Weighable {
	private int age;
	private double weight;

	public Person( int age, double weight ) {
		this.age = age;
		this.weight = weight;
	}

	public int getAge() { return age; }

	public int getWeight() { return weight; }
}</programlisting>
<programlisting xml:id="program:Cheese" xreflabel="Cheese" language="java" linenumbering="numbered">public class Cheese implements Ageable, Weighable {
	private int age;
	private double weight;
	private String type;

	public Cheese( int age, double weight, String type ) {
		this.age = age;
		this.weight = weight;
		this.type = type;
	}

	public int getAge() { return age; }

	public int getWeight() { return weight; }

	public String getType() { return type; }
}</programlisting>
<simpara>With the classes in place, we can assume that client code will
instantiate some objects and perform operations on them. All that is
necessary is to write the method that will do the sorting. We can wrap
the bubble code given earlier in a method body with only a few changes
to generalize the sort beyond <literal>int</literal> values.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void sort( Object[] array, boolean age ) {
    boolean swapped = true;
    Object temp;
    while( swapped ) {
        swapped = false;
        for( int i = 0; i &lt; array.length - 1; i++ )
            if( outOfOrder( array[i], array[i + 1], age ) {
                temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
                swapped = true;
            }
    }
}</programlisting>
<simpara>In this method, the <literal>boolean</literal> <literal>age</literal> is <literal>true</literal> if we are sorting by age
and <literal>false</literal> if we are sorting by weight. Note that the array and <literal>temp</literal>
have the <literal>Object</literal> type. Recall that any object can be stored in a
reference of type <literal>Object</literal>.</simpara>
<simpara>The only other change we needed was to replace the greater-than
comparison (<literal>&gt;</literal>) with the <literal>outOfOrder()</literal> method, which we define below.</simpara>
<programlisting language="java" linenumbering="unnumbered">public boolean outOfOrder( Object o1, Object o2, boolean age ) {
    if( age ) {
        Ageable age1 = (Ageable)o1;
        Ageable age2 = (Ageable)o2;
        return age1.getAge() &gt; age2.getAge();
    }
    else {
        Weighable weight1 = (Weighable)o1;
        Weighable weight2 = (Weighable)o2;
        return weight1.getWeight() &gt; weight2.getWeight();
    }
}</programlisting>
<simpara>Even though we have designed our program for objects that implement both
the <literal>Ageable</literal> and <literal>Weighable</literal> interfaces, the compiler only sees
<literal>Object</literal> references in the array. Thus, we must cast each object to the
appropriate interface type to do the comparison. There is a danger that
a user will pass in an array with objects which do not implement both
<literal>Ageable</literal> and <literal>Weighable</literal>, causing a <literal>ClassCastException</literal>. To allow for
universal sorting methods, the Java API defines a <literal>Comparable</literal> interface
which can be implemented by any class which requires sorting. With Java
5 and higher, the <literal>Comparable</literal> interface uses generics to be more
type-safe, so we will not discuss how to use this interface until we
cover generics in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>.</simpara>
</section>
<section xml:id="_concurrency_interfaces">
<title>Concurrency: Interfaces</title>
<simpara>As we discussed in SectionÂ <xref linkend="concepts:Making_a_promise"/>, implementing
an interface means making a promise to have public methods with the
signatures specified in the interface definition. Making a promise seems
only tangentially related to having multiple threads of execution.
Indeed, interfaces and concurrency do not overlap a great deal, but
there are two important areas where they affect one another.</simpara>
<simpara>The first is that a special interface called the <literal>Runnable</literal> interface
can be used to create new threads of execution. <literal>Runnable</literal> is a very
simple interface, containing the single signature <literal>void run()</literal>. This
means that any object with a <literal>run()</literal> method that takes no arguments and
returns no values can be used to create a thread of execution. This
makes intuitive sense. A regular program has a single starting place,
the <literal>main()</literal> method. If we want to run additional threads, some method
needs to be marked as a starting place for each one. For more
information about using the <literal>Runnable</literal> interface, refer to
SectionÂ <xref linkend="subsection:runnable"/>.</simpara>
<simpara>The second connection between interfaces and concurrency is more
philosophical. What can you specify in an interface? The rules for
interfaces in Java are relatively limited: You can require a class to
have a public instance method with specific parameters and a specific
return type. Java interfaces do not allow you to require a static
method.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Synchronization"/>, we will discuss a key way to
make classes thread-safe by using the<?asciidoc-br?>
<literal>synchronized</literal> keyword. Like static, Java does not allow an interface to
specify whether a method is synchronized. Thus, it is impossible to use
an interface to guarantee that a method will be thread-safe.</simpara>
<simpara>As with all interface usage, this restriction cuts both ways: If you are
designing an interface, there is no way that you can guarantee that
implementing classes use synchronized methods. On the other hand, if you
are implementing an interface, the designer may hope that your class
uses synchronized (or otherwise thread-safe) methods, but the interface
cannot force you to do so. Whenever thread-safety is an issue, make sure
you read (or write) the documentation carefully. Since there is no way
to force programmers to use the <literal>synchronized</literal> keyword, the
documentation may be the only guide.</simpara>
</section>
<section xml:id="_exercises_9">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>What is the purpose of an interface?</simpara>
</listitem>
<listitem>
<simpara>Why implement an interface when it puts additional requirements on a
class yet adds no functionality?</simpara>
</listitem>
<listitem>
<simpara>Is it legal to have methods marked <literal>private</literal> or <literal>protected</literal> in an
interface? Why did the designers of Java make this choice?</simpara>
</listitem>
<listitem>
<simpara>What is the <literal>instanceof</literal> keyword used for? Why is it useful in the
context of interfaces?</simpara>
</listitem>
<listitem>
<simpara>What kind of programming error causes a <literal>ClassCastException</literal>?</simpara>
</listitem>
<listitem>
<simpara>Create an interface called <literal>ColorWavelengths</literal> that only contains
constants storing the wavelengths in nanometers for each of the seven
colors of light, as given below.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Color</entry>
<entry align="center" valign="top">Wavelength (nm)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>Red</simpara></entry>
<entry align="center" valign="top"><simpara>680</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Orange</simpara></entry>
<entry align="center" valign="top"><simpara>605</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Yellow</simpara></entry>
<entry align="center" valign="top"><simpara>580</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Green</simpara></entry>
<entry align="center" valign="top"><simpara>545</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Blue</simpara></entry>
<entry align="center" valign="top"><simpara>473</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Indigo</simpara></entry>
<entry align="center" valign="top"><simpara>430</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Violet</simpara></entry>
<entry align="center" valign="top"><simpara>415</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Write an interface called <literal>Clock</literal> that specifies the functionality a
clock should have. Remember that the classes that implement the clock
may tell time in different ways (hourglass, water clock, mechanical
movement, atomic clock), but they must share the basic functionality
that you specify.</simpara>
</listitem>
<listitem>
<simpara>There are four compiler errors in the following interface. Name each
one and explain why it is an error.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Singable {
    public int SOPRANO = 1;
    public static int ALTO = 2;

    public void sing();
    private String chant();
    public boolean hasDeepVoice() {
        return false;
    }
    public static boolean hasPerfectPitch();
    public synchronized void tune( int frequency );
}</programlisting>
</listitem>
<listitem>
<simpara>Consider the interface defined below.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Explodable {
    boolean explode( double megatons );
}</programlisting>
<simpara>Which of the following classes properly implement <literal>Explodable</literal>?</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Dynamite implements Explodable {
    public boolean explode() {
        System.out.println("BOOM!");
        return true;
    }
}

public class AtomicBomb implements Explodable {
    public boolean explode( double size ) {
        System.out.println("A huge " + size +
            " megaton blast shakes the earth!");
        return true;
    }
}

public class Grenade {
    public boolean explode( double megatons ) {
        return true;
    }
}

public class Firecracker implements Explodable {
    private boolean explode( double megatons ) {
        return (megatons &lt; 0.0000001);
    }
}</programlisting>
</listitem>
<listitem>
<simpara>Write a single class that correctly implements the following three
interfaces.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Laughable {
    boolean laugh( int times );
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public interface Cryable {
    void cry( int tears, boolean moaning );
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public interface Shoutable {
    void laugh( double volume, String words );
}</programlisting>
</listitem>
<listitem>
<simpara>If you are sorting a list of items <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> elements long
using bubble sort, what is the minimum number of passes you would need
to be sure the list is sorted, assuming the worst possible ordering of
items to start with? (Hint: Imagine the list is in backwards order.)
What is the minimum number of passes if the list is already sorted?
<emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Add client code that randomly creates the objects needing sorting in
the solution from SectionÂ <xref linkend="solution:Sort_it_out"/>. Design and include
additional classes <literal>Wine</literal> and <literal>Tortoise</literal> that both implement <literal>Ageable</literal>
and <literal>Weighable</literal>. Add <literal>toString()</literal> methods to each class so that their
contents can be easily output. Make sure that you print out the list of
objects after sorting to test your implementation.</simpara>
</listitem>
<listitem>
<simpara>Refer to the sort given as a solution in SectionÂ <xref linkend="solution:Sort it
out"/>. Add another <literal>boolean</literal> to the parameters of the sort which
specifies whether the sort is ascending or descending. Make the needed
changes throughout the code to add this functionality.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:parallelBubbleSort"/> After learning about threads in
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>, refer to the simple bubble
sort from SectionÂ <xref linkend="problem:Sort_it_out"/>. The goal is now to
parallelize the sort. Write some code which will generate an array of
random <literal>int</literal> values. Design your code so that you can spawn
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> threads. Partition the single array into <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>
arrays and map one partition to each thread. Use your bubble sort
implementation to sort each partition. Finally, merge the arrays back
together, in sorted order, into one final array. For now, just use one
thread (ideally the main thread) to do the merge.</simpara>
<simpara>The merge operation is a simple idea, but it is easy to make mistakes in
its implementation. The idea is to have three indexes, one for each of
the two arrays you are merging and one for the result array. Always take
the smaller (or larger, if sorting in descending order) index value from
the two arrays and put it in the result. Then increment the index from
the array you took the data from as well as the index of the result
array. Make sure that you are careful not to go beyond the end of the
arrays which are being merged.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Once you have implemented the sort in parallel from
ExerciseÂ <xref linkend="exercise:parallelBubbleSort"/>, time it against the sequential
version. Try two, four, and eight different threads. Be sure to create
one random array and use copies of the same array for both the parallel
and sequential versions. Be careful not to sort an array that is already
sorted! Try array sizes of 1,000, 100,000, and 1,000,000. Did the
performance increase? Was it as much as you expected?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Inheritance">
<title>Inheritance</title>
<blockquote>
<attribution>
Khalil Gibran
</attribution>
<simpara>Your children are not your children.<?asciidoc-br?>
They are the sons and daughters of Life&#8217;s longing for itself.<?asciidoc-br?>
They come through you but not from you,<?asciidoc-br?>
And though they are with you yet they belong not to you.</simpara>
</blockquote>
<section xml:id="_problem_boolean_circuits">
<title>Problem: Boolean circuits</title>
<simpara>In ChapterÂ <xref linkend="chapter:Selection"/>, we talked extensively about Boolean
algebra and how it can be applied to <literal>if</literal> statements in order to control
the flow of execution in your program. The commands that we give in
software must be executed by hardware in order to have an effect. It
should not be surprising that computer hardware is built out of digital
circuits that behave according to the same rules as Boolean logic. Each
component of these circuits is called a <emphasis>logic gate</emphasis>. There are logic
gates corresponding to all the Boolean operations you are used to: AND,
OR, XOR, NOT, and others.</simpara>
<simpara>The output of an AND gate is the result of performing a logical AND on
its inputs. That is, the output is true if and only if both of the
inputs are true. The same correlation exists between each gate and the
Boolean operator with the same name. At the level of circuitry, a 1 (or
&#8220;on&#8221;) is often used to represent true, and a 0 (or &#8220;off&#8221;) is often
used to represent false. Modern computer circuitry is built almost
entirely out of such gates, performing addition, subtraction, and all
other basic operations as complicated combinations of logic gates, where
each digit of every number is a 1 or 0 determined by the circuit.</simpara>
<simpara>Because these circuits can become large and unwieldy, your problem is to
write a Java program that will allow a user to specify the design of
such a circuit and then see what its output is. The input to this
program will be a text file redirected to standard input that gives the
number of gates of the circuit, lists what each gate is, then gives a
list of connections between them.</simpara>
<simpara>The following is an example of input to make a circuit with six
components.</simpara>
<literallayout class="monospaced">6
true
false
AND
XOR
NOT
OUTPUT 1
2 0 1
3 2 1
4 3
5 4</literallayout>
<simpara>The first line specifies the total number of components. The next two
components give either true or false inputs, depending on their name.
The <literal>AND</literal> and the <literal>XOR</literal> correspond to gates of the same name which each
take two inputs. The <literal>NOT</literal> corresponds to a NOT gate with a single
input. Finally, <literal>OUTPUT 1</literal> is the single output of this circuit that we
are interested in. After the list of gates is a list of how they are
connected. The line <literal>2 0 1</literal> specifies that gate at index 2, which
happens to be an AND gate, has an input from the gate at index 0 and an
input from the gate at index 1. In other words, the AND gate has one
true input and one false input. The final circuit produced would look
like the following.</simpara>
<figure>
<title>Final circuit diagram showing the six components.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/11-inheritance/images/circuit.png"/>
</imageobject>
<textobject><phrase>circuit</phrase></textobject>
</mediaobject>
</figure>
<simpara>We are only interested in the value of any OUTPUT gates. Thus, the
program that is simulating this circuit would print the following.</simpara>
<literallayout class="monospaced">OUTPUT 1: true</literallayout>
<simpara>There are many different ways to implement a solution to this problem.
The total number of gates is given as the first input. Thus, you can
make an array of gates. When you go to connect them, the indexes given
in the input will map naturally onto the gates in the array. But, what
type should the array be? You could create a <literal>Gate</literal> class that could do
the work of any conceivable gate, but the implementation would be
awkward. All gates would have to have two inputs even if they don&#8217;t need
any. Adding different kinds of gates later (like a NAND, for example)
would mean rewriting the <literal>Gate</literal> class.</simpara>
<simpara>Instead, a cleaner approach to the solution is to use <emphasis>inheritance</emphasis>. In
object oriented languages like Java, inheritance is a process that
allows you to create a new specialized class from a more general,
preexisting class.</simpara>
<simpara>We recommend the following inheritance hierarchy, in which the arrows
point from each child class to its parent class.</simpara>
<figure>
<title>Recommended inheritance hierarchy.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/11-inheritance/images/gates.png"/>
</imageobject>
<textobject><phrase>gates</phrase></textobject>
</mediaobject>
</figure>
<simpara>As you can see, every class inherits from the <literal>Gate</literal> class. If your
array can be of type <literal>Gate</literal>, it will be able to hold objects of any
child of <literal>Gate</literal>. <literal>UnaryOperator</literal>, <literal>BinaryOperator</literal>, <literal>True</literal>, and <literal>False</literal>
are children of the basic <literal>Gate</literal> class. Then, <literal>Output</literal> and <literal>Not</literal> are
children of <literal>UnaryOperator</literal> since each only has a single input.
Naturally, <literal>And</literal>, <literal>Or</literal>, and <literal>Xor</literal> are children of <literal>BinaryOperator</literal>,
since they all have two inputs.</simpara>
<simpara>If this large collection of classes seems bewildering, do not be
discouraged. Each is very short and easy to write. We&#8217;ll explain what
the inheritance relationship means and how to use it in the next few
sections.</simpara>
</section>
<section xml:id="_concepts_refining_classes">
<title>Concepts: Refining classes</title>
<simpara>Here we give a brief overview of inheritance that will give us enough
information to continue onward. We cover some of the deeper areas of the
subject in ChapterÂ <xref linkend="chapter:Polymorphism"/>.</simpara>
<section xml:id="_basic_inheritance">
<title>Basic inheritance</title>
<simpara>The process of creating an inherited class out of an existing class is
called <emphasis>inheriting</emphasis> a class, <emphasis>deriving</emphasis> a class, or simply
<emphasis>subclassing</emphasis>. The class that already exists is called a <emphasis>parent class</emphasis>,
<emphasis>base class</emphasis>, or <emphasis>superclass</emphasis> and the new class is called a <emphasis>child
class</emphasis>, <emphasis>derived class</emphasis>, or <emphasis>subclass</emphasis>.</simpara>
<simpara>When you create a child class from a parent class, the child class
inherits all of its fields and methods. Thus, you can use a child class
object anywhere you would use the parent class object. This relationship
explains the terms superclass and subclass: Since you can treat any
subclass object as if it were a superclass object, the superclass type
can be thought of as a superset including all subclass objects.</simpara>
<simpara>Others have noted that the names superclass and subclass sound
misleading because the subclass can usually do more than the superclass.
From that perspective, the child class has a superset of the fields and
methods of its parent class. To avoid confusion, we favor the
terminology of parent and child classes.</simpara>
</section>
<section xml:id="_adding_functionality">
<title>Adding functionality</title>
<simpara>When creating a child class, a programmer will normally add
functionality above and beyond the original parent class. Otherwise,
there is little point in creating a child class. For example, a simple
<literal>Fish</literal> class might be able to do things like swim and feed. A child
<literal>Flounder</literal> class has the additional ability to camouflage itself.
Another child class, the <literal>Shark</literal> class, adds the ability to eat other
<literal>Fish</literal> objects.</simpara>
<simpara>By adding a few methods, we can create a new class with special
abilities without interfering with the basic functionality of the
underlying class.</simpara>
</section>
<section xml:id="_code_reuse">
<title>Code reuse</title>
<simpara>Of course, a programmer who wished to program a <literal>Shark</literal> class could
simply copy and paste in all the code from the <literal>Fish</literal> class and then
make the necessary additions. In many ways the evolution of modern
programming languages has been specifically to minimize any copying and
pasting.</simpara>
<simpara>Old mistakes are propagated with copying and pasting. When discovered,
they must be fixed in several different locations. New mistakes can also
be introduced by cutting and pasting. Instead, we wish to guarantee that
working code from a parent class continues to work in a child class.
Ideally, code from parent classes will not need to be debugged a second
time when a child class is created.</simpara>
<simpara>Even without the issue of errors introduced by copying and pasting, the
total amount of code increases. By minimizing the amount of code, issues
of performance and storage can be improved, but not always. Object
oriented languages have taken criticism for low speed and high memory
use due to the additional complexities of objects and inheritance, but
compiler optimization, good library design, and improved JVM performance
have brought Java a long way in this area.</simpara>
</section>
</section>
<section xml:id="_syntax_inheritance_in_java">
<title>Syntax: Inheritance in Java</title>
<simpara>In this section we discuss the mechanism for creating a child class in
Java using the <literal>extends</literal> keyword. Then, we discuss access restriction
and visibility, constructor issues, the <literal>Object</literal> class, and overriding
methods.</simpara>
<section xml:id="_the_literal_extends_literal_keyword">
<title>The <literal>extends</literal> keyword</title>
<simpara>In order to make a child class in Java, we use the <literal>extends</literal> keyword.
Let&#8217;s give an example using the <literal>Fish</literal> class defined below. This class
creates a basic fish that can swim, feed, and die. We can check its
color, location, and whether or not it is alive. When it runs out of
energy, it dies.</simpara>
<programlisting xml:id="program:Fish" xreflabel="Fish" language="java" linenumbering="numbered">import java.awt.*;

public class Fish {
	protected Color color = Color.GRAY;
	private double location = 0.0;
	private double energy = 100.0;
	private boolean alive = true;

	public Color getColor() { return color; }
	public double getLocation() { return location; }
	public boolean isAlive() { return alive; }

	public void swim() {
		if( alive ) {
			location += 0.5;
			energy -= 0.25;
		}
		if( energy &lt;= 0.0 )
			die();
	}

	public void feed() { energy = 100.0; }
	public void die() { alive = false; }
}</programlisting>
<simpara>From here we can create a child class called <literal>BoringFish</literal> that does
exactly what <literal>Fish</literal> does. To do so, we use the <literal>extends</literal> keyword after
the new class name, followed by the parent class name (in this case
<literal>Fish</literal>), followed by the body of the class.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class BoringFish extends Fish {

}</programlisting>
<simpara>Just as we are allowed to make an empty class, we are allowed to make an
inherited class and add nothing, but doing so is pointless. Instead, we
can make a <literal>Flounder</literal> class that can change its color.</simpara>
<programlisting xml:id="program:Flounder" xreflabel="Flounder" language="java" linenumbering="numbered">public class Flounder extends Fish {
	public void setColor( Color newColor ) { color = newColor; }
}</programlisting>
<simpara>The <literal>Flounder</literal> class can do everything a <literal>Fish</literal> can: It can swim, feed,
and die. Now, we add the additional ability of changing color, since
flounders are famous for their ability to mimic the ocean floor they
swim over. Note that the <literal>color</literal> field in the <literal>Fish</literal> class has the
<literal>protected</literal> access modifier, not <literal>private</literal>. We&#8217;ll come back to this
point.</simpara>
<simpara>Here is a <literal>Shark</literal> class that extends <literal>Fish</literal> in another ways, by adding
the capability of eating other <literal>Fish</literal>.</simpara>
<programlisting xml:id="program:Shark" xreflabel="Shark" language="java" linenumbering="numbered">public class Shark extends Fish {
	public void eat( Fish fish ) {
		fish.die();
		feed();
	}
}</programlisting>
<simpara>Here we have added an <literal>eat()</literal> method that takes another <literal>Fish</literal> object as
a parameter. First, the <literal>Fish</literal> parameter is killed; then the <literal>eat()</literal>
method calls <literal>feed()</literal>, restoring the energy of the <literal>Shark</literal> object. Note
that the <literal>Shark</literal> object is able to call the <literal>feed()</literal> method even though
it isn&#8217;t defined inside of <literal>Shark</literal>. Because it inherits from <literal>Fish</literal>, it
has a version of <literal>feed()</literal>.</simpara>
<section xml:id="_single_inheritance_only">
<title>Single inheritance only</title>
<simpara>Particularly if you have programmed in C, you might be wondering if it
is possible to have one class inherit from *multiple* classes in Java.
In multiple inheritance, a single class can have many different parents.
Since C supports multiple inheritance, you can have a
<literal>SharkAlligatorMan</literal> class in that language that inherits from the
<literal>Shark</literal>, <literal>Alligator</literal>, and <literal>Human</literal> classes. If you go back to the sorting
problem from ChapterÂ <xref linkend="chapter:Interfaces"/>, multiple inheritance would
allow us to solve the problem with an <literal>Age</literal> class and a <literal>Weight</literal> class
from which <literal>Dog</literal>, <literal>Cat</literal>, <literal>Person</literal>, and <literal>Cheese</literal> all inherit.</simpara>
<simpara>However, the designers of Java decided not to allow multiple
inheritance, perhaps for this reason: Imagine a <literal>River</literal> class with a
<literal>run()</literal> method and a <literal>Politician</literal> class with a <literal>run()</literal> method. It seems
strange to create a class which is both a river and politician, but
there is no rule in C++ which makes doing so impossible. If you did have
a <literal>RiverPolitician</literal> class which inherits from both, what would happen
when you call the <literal>run()</literal> method? How would the <literal>RiverPolitician</literal> class
know which of its parents' methods to pick? Surely, the way that a
politician runs for office is very different from the way a river runs
along its banks.</simpara>
<simpara>If you find yourself in a situation where you want to use multiple
inheritance in Java, try to reformulate your class hierarchy into one
where your classes implement multiple interfaces. Recall that multiples
interfaces <emphasis role="strong">can</emphasis> be implemented by a single class in Java, and like
multiple inheritance, this practice allows a single class to be used in
wildly different contexts.</simpara>
</section>
<section xml:id="_interfaces_using_literal_extends_literal">
<title>Interfaces using <literal>extends</literal></title>
<simpara>The <literal>extends</literal> keyword is not limited to classes. It is possible for an
interface to extend another interface. In fact, an interface can extend
any number of other interfaces. As when a class implements multiple
interfaces, each interface in an extends list is separated by commas.</simpara>
<simpara>When an interface extends other interfaces, it includes all the methods
(and constants) they define. If a class implements an interface that
extends other interfaces, it must contain versions of all the methods
specified by <emphasis role="strong">all</emphasis> the interfaces. Recall the <literal>Ageable</literal> and <literal>Weighable</literal>
interfaces from ChapterÂ <xref linkend="chapter:Interfaces"/>, which specified the
<literal>getAge()</literal> and <literal>getWeight()</literal> methods, respectively. We could create an
interface that required both of these methods by extending <literal>Ageable</literal> and
<literal>Weighable</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface AgeableAndWeighable extends Ageable, Weighable {
}</programlisting>
<simpara>We could add additional methods to the <literal>AgeableAndWeighable</literal> interface,
but even empty it will enforce the contracts defined by both <literal>Ageable</literal>
and <literal>Weighable</literal>. It is generally not necessary to create an interface
that extends other interfaces, since a class could implement each of the
individual interfaces. Nevertheless, it can be used as a convenience to
save typing or to create a reference type with certain guaranteed
abilities.</simpara>
<simpara>Note that a class can never extend an interface. Likewise, an interface
cannot extend a class or implement another interface.</simpara>
</section>
</section>
<section xml:id="_access_restriction_and_visibility">
<title>Access restriction and visibility</title>
<simpara>The <literal>Shark</literal> example above gives an example of inheritance in which the
child class only calls methods of the parent class and does not
interfere with the fields of the parent class. Generally, this is a good
thing because it protects the state of the parent class from getting
corrupted. However, it is not always possible. If we return to the
earlier <literal>Flounder</literal> example, we had to change the <literal>color</literal> field directly,
since there was no mutator to change it.</simpara>
<simpara>Perhaps the <literal>Fish</literal> class was poorly designed because it did not have a
<literal>color</literal> mutator. On the other hand, most fish cannot change their color,
so it might be good design to prevent outside code from changing the
<literal>color</literal> field with such a mutator. There are no absolute rules for
making these kinds of decisions.</simpara>
<simpara>We introduced access modifiers in SectionÂ <xref linkend="subsection:Access_modifiers"/>, but inheritance gives them new meaning. Recall that the
access modifier for the <literal>color</literal> field of <literal>Fish</literal> was <literal>protected</literal>. A field
or method with the <literal>protected</literal> modifier can be accessed by all child
classes (as well as classes in the same package). If the modifier for
<literal>color</literal> was <literal>private</literal>, the <literal>Flounder</literal> class would not be able to change
it directly.</simpara>
<simpara>In the <literal>Shark</literal> class, it <emphasis role="strong">must</emphasis> use mutators to change the value of its
own <literal>energy</literal> and the <literal>alive</literal> field of <literal>fish</literal> since they are both marked
<literal>private</literal>. It is generally preferable to use mutator and accessor
methods whenever possible, even within the same class, so that fields
are not inadvertently corrupted.</simpara>
</section>
<section xml:id="_constructors_2">
<title>Constructors</title>
<simpara>When you create a child class, you can think of it as if a copy of the
parent class exists inside of the child. When you create an object from
a child class, how do you properly initialize the fields inside the
parent class?</simpara>
<simpara>As we discussed in ChapterÂ <xref linkend="chapter:Classes"/>, every class has a
constructor, even if it is a default one created for you. Whenever the
constructor for a child class is invoked, the constructor for the parent
class is invoked as well. If the parent class is also the child of some
other class, that grandparent class will have its constructor invoked as
well. This chain of constructors will continue, reaching all the way
back to the ultimate ancestor, <literal>Object</literal>.</simpara>
<simpara>When writing the constructor for a child class, the first line of it
should be the call to the parent constructor. If you don&#8217;t explicitly
call the parent constructor, its default (no parameter) constructor will
be called. If the parent class does not have a default constructor, then
leaving off an appropriate call to a parent constructor will result in a
compiler error. Consider the following two classes.</simpara>
<programlisting xml:id="program:Parent" xreflabel="Parent" language="java" linenumbering="numbered">public class Parent {
	private String name;
	public Parent( String name ) { this.name = name; }
	public String getName() { return name; }
}</programlisting>
<programlisting xml:id="program:Child" xreflabel="Child" language="java" linenumbering="numbered">public class Child extends Parent {
	public Child( String name ) {
		super( "Baby " + name );
	}
}</programlisting>
<simpara>As shown above, the <literal>super</literal> keyword is used to call the constructor of a
parent class. The <literal>Child</literal> constructor takes a name and prepends the
<literal>String</literal> <literal>"Baby "</literal> to it before passing it on to the <literal>Parent</literal>
constructor.</simpara>
<simpara>In a similar way, the <literal>this</literal> keyword can be used to call another
constructor in the <emphasis role="strong">same</emphasis> class, provided that a constructor to the
<emphasis role="strong">parent</emphasis> class is eventually reached. For example, we could add the
following constructor to the <literal>Child</literal> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public Child() {
        this( "Unknown" );
    }</programlisting>
<simpara>This second constructor will be called whenever a new <literal>Child</literal> object is
instantiated without any arguments. It will supply the <literal>String</literal>
<literal>"Unknown"</literal> to the other constructor, which will add <literal>"Baby"</literal> and pass
it on to the <literal>Parent</literal> class.</simpara>
</section>
<section xml:id="_overriding_methods_and_hiding_fields">
<title>Overriding methods and hiding fields</title>
<simpara>Sometimes a parent method does not provide all the power you want in the
child class. It is possible to <emphasis>override</emphasis> a parent method in the child
class. Then, when that method is called on child objects, the new method
will be called. The new method has exactly the same name and parameters.
The return type must be either exactly the same or a child class of the
original return type.</simpara>
<simpara>We can return to the <literal>Fish</literal> class example and make a new kind of fish
that never moves.</simpara>
<programlisting xml:id="program:LazyFish" xreflabel="LazyFish" language="java" linenumbering="numbered">public class LazyFish extends Fish {
	public void swim() {
		System.out.println("I think I'll just sit here.");
	}
}</programlisting>
<simpara>Whenever someone calls the <literal>swim()</literal> method on a <literal>LazyFish</literal> object, it
will just announce that it is going to sit where it is. Its location is
not updated and its energy does not change.</simpara>
<simpara>On the other hand, we could create another child class that swims twice
as fast as the original <literal>Fish</literal>.</simpara>
<programlisting xml:id="program:FastFish" xreflabel="FastFish" language="java" linenumbering="numbered">public class FastFish extends Fish {
	public void swim() {
		super.swim();
		super.swim();
	}
}</programlisting>
<simpara>Every time <literal>swim()</literal> is called on objects of type <literal>FastFish</literal>, those
objects will call the <literal>swim()</literal> method from <literal>Fish</literal> twice. Thus, this fish
will move twice as fast (and consume twice as much energy). Because the
<literal>location</literal> and <literal>energy</literal> fields are <literal>private</literal>, we must use methods from
<literal>Fish</literal> to affect them. Note the use of the keyword <literal>super</literal>, allowing us
to specify that we want to call the <literal>swim()</literal> method from <literal>Fish</literal> and not
just call the same method from <literal>FastFish</literal> again. Using the <literal>super</literal>
keyword, we can call methods from the parent. If the parent did not
override a method from an ancestor class, we can still use <literal>super</literal> to
call a method from the last class that did implement the method.
However, Java does not allow us to skip over a parent method to call a
grandparent method if there is an implementation in the parent class. In
other words, there is no way to call something like a
<literal>super.super.swim()</literal> method.</simpara>
<simpara>Just as methods are overridden, fields are <emphasis>hidden</emphasis>. It is perfectly
legal to declare a field with the same name as a field from a parent
class, but the new field will then be used instead of the old one.</simpara>
<programlisting xml:id="program:A" xreflabel="A" language="java" linenumbering="numbered">public class A {
	protected int a;
	public int getA() { return a; }
	public void setA( int value ) { a = value; }
}</programlisting>
<programlisting xml:id="program:B" xreflabel="B" language="java" linenumbering="numbered">public class B extends A {
	protected int a;
	public void setA( int value ) { a = value; }
}</programlisting>
<simpara>Class <literal>B</literal> is a child of class <literal>A</literal> and declares a field called <literal>a</literal>,
hiding a field of the same name from <literal>A</literal>. However, which <literal>a</literal> is which
can cause some confusion. Consider the following fragment of code.</simpara>
<programlisting language="java" linenumbering="unnumbered">A objectA = new A();
B objectB = new B();
objectA.setA( 5 );
objectB.setA( 10 );
System.out.println("A = " + objectA.getA() );
System.out.println("B = " + objectB.getA() );</programlisting>
<simpara>The output of this code is:</simpara>
<literallayout class="monospaced">A = 5
B = 0</literallayout>
<simpara>Calling the <literal>setA()</literal> method on an <literal>A</literal> object sets the <literal>a</literal> field inside
of <literal>A</literal>. Calling the overridden <literal>setA()</literal> method on a <literal>B</literal> object sets the
<literal>a</literal> field inside of <literal>B</literal>, but since the <literal>getA()</literal> method has not been
overridden, the <literal>a</literal> field from the <literal>A</literal> parent class part of <literal>B</literal> is
returned. Since that <literal>a</literal> field in <literal>B</literal> has not been given a value, it
still has the default value of <literal>0</literal>. Both <literal>a</literal> fields exist inside of <literal>B</literal>,
but the methods are poorly designed, leaving one field capable only of
being set and the other capable only of being retrieved.</simpara>
</section>
<section xml:id="_the_literal_object_literal_class">
<title>The <literal>Object</literal> class</title>
<simpara>You may not have realized it, but every class you created in Java used
inheritance. To provide uniformity, the designers of Java made every
class the child (or grandchild or great-grandchild&#8230;&#8203; ) of a class
called <literal>Object</literal>. When you omit the <literal>extends</literal> clause in a class
definition, you are making that class a direct child of <literal>Object</literal>.</simpara>
<simpara>As a consequence, <emphasis role="strong">all</emphasis> classes in Java are guaranteed to have the
following methods.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>clone()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Make a separate copy of an object.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>equals()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determine if two objects are the same.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>finalize()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Perform cleanup when an object is garbage collected. Similar to a destructor in C++. Rarely used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>getClass()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Find out what the class type of a given object is.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hashCode()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Get the hash code for an object, useful for making hash
tables of objects.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>notify()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used for synchronization with threaded programs. More in
ChapterÂ <xref linkend="chapter:Synchronization"/>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>notifyAll()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Same as previous.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>toString()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Get a <literal>String</literal> representation of the given object.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>wait()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used with <literal>notify()</literal> and <literal>notifyAll()</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Java provides basic implementations for most of these, but if you want
them to work well for your object, you will have to override some of
them with appropriate methods. For example, the <literal>Object</literal> version of
<literal>toString()</literal> returns the virtual address of the object in JVM memory.</simpara>
<simpara>Nevertheless, API classes usually have good <literal>equals()`and `toString()</literal>
methods. Aside from making a few useful methods available, having a
common ancestor for all classes means that you can store any object in
an <literal>Object</literal> reference. An array of type <literal>Object</literal> can hold anything,
provided that you know how to retrieve it. We discuss the finer points
of inheritance and polymorphism in ChapterÂ <xref linkend="chapter:Polymorphism"/> and
how to build lists and other data structures using <literal>Object</literal> references
in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>.</simpara>
</section>
</section>
<section xml:id="_examples_problem_solving_with_inheritance">
<title>Examples: Problem solving with inheritance</title>
<simpara>Here are two extended examples showing how we can use inheritance to
solve problems. First, we revisit the student roster example from
ChapterÂ <xref linkend="chapter:Classes"/> and then move onto an inheritance hierarchy
of polygons.</simpara>
<example>
<title>Graduate student roster</title>
<simpara>The <literal>Student</literal> class we create in ChapterÂ <xref linkend="chapter:Classes"/> is useful
but works only for undergraduate students. With only a few additions, we
can make it suitable for graduate students as well. First, lets take
another look at the <literal>Student</literal> class.</simpara>
<formalpara xml:id="program:Student" xreflabel="Student">
<title>Basic student class, designed for undergraduates.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Student {
	public static final String[] YEARS =
	{"Freshman", "Sophomore", "Junior", "Senior"};
	private String name;
	private int year;
	private double GPA;

	public Student(String name, int year, double GPA) {
		setName( name );
		setYear( year );
		setGPA( GPA );
	}

	public void setName(String name) { this.name = name; }
	public void setYear(int year) { this.year = year; }

	public void setGPA(double GPA) {
		if( GPA &gt;= 0 &amp;&amp; GPA &lt;= 4.0 )
			this.GPA = GPA;
		else
			System.out.println("Invalid GPA: " + GPA);
	}

	public String getName() { return name; };
	public int getYear() { return year; };
	public double getGPA() { return GPA; };

	public String toString() {
		return name + "\t" + YEARS[year] +
			"\t" + GPA;
	}
}</programlisting>
</para>
</formalpara>
<simpara>We want to create a <literal>GraduateStudent</literal> class that inherits from
<literal>Student</literal>. We need to add a thesis topic for each graduate student.
Likewise, we need to update the <literal>toString()</literal> method so that outputs the
appropriate data. We use <literal>4</literal> as the year value for graduate students.</simpara>
<formalpara xml:id="program:GraduateStudent" xreflabel="GraduateStudent">
<title>Class extending <literal>Student</literal> to add graduate student capabilities.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class GraduateStudent extends Student {
	private String topic;

	public GraduateStudent(String name, double GPA, String topic ) {
		super( name, 4, GPA );
		setTopic( topic );
	}

	public void setTopic(String topic) { this.topic = topic; }

	public String toString() {
		return getName() + "\t" + "Graduate" +
			"\t" + getGPA() + "\tTopic: " + topic;
	}
}</programlisting>
</para>
</formalpara>
<simpara>Because we are inheriting most of the fields we need, we only need to
declare the <literal>topic</literal> field. Then, in the <literal>GraduateStudent</literal> constructor,
we call the parent constructor with the name, year, and GPA and then set
<literal>topic</literal> to the input value.</simpara>
<simpara>Finally, we override the <literal>toString()</literal> method so that <literal>"Graduate"</literal> and
the thesis topic are output. Note that we must use the <literal>getName()</literal> and
<literal>getGPA()</literal> accessors since the actual values are <literal>private</literal>.</simpara>
<simpara>Most code that uses <literal>Student</literal> objects should be able to incorporate
<literal>GraduateStudent</literal> objects easily. Code that creates <literal>Student</literal> objects
from input will need slight modifications to handle the thesis topic.
Also, old code that only expects values of <literal>0</literal>, <literal>1</literal>, <literal>2</literal>, or <literal>3</literal> for
year may need to be modified so that it doesn&#8217;t break.</simpara>
</example>
<example>
<title>Polygons</title>
<simpara>Let&#8217;s examine a class hierarchy used to create several different
polygons. Our base class needs to be general. It can represent any kind
of closed polygon, using an array of <literal>Point</literal> objects. The <literal>Point</literal> class
is a way to package up <literal>x</literal> and <literal>y</literal> values of type <literal>int</literal>. Each coordinate
in the array gives the next vertex of the polygon.</simpara>
<programlisting language="java" linenumbering="numbered">import java.awt.*;

public class Polygon {
	protected Point[] points;

	public Polygon( Point[] points ) {
		this.points = points;
	}</programlisting>
<simpara>The <literal>import</literal> statement allows us to use the <literal>Point</literal> class as well as the
<literal>Graphics</literal> class. Our array of type <literal>Point</literal> is declared <literal>protected</literal> so
that the child classes we want to create can access it directly. The
constructor takes an array of type <literal>Point</literal> and stores it.</simpara>
<programlisting language="java" linenumbering="numbered">	public double getPerimeter() {
		double perimeter = 0.0;
		for( int i = 0; i &lt; points.length - 1; i++ )
			perimeter += points[i].distance(points[i + 1]);
		perimeter += points[0].distance(points[points.length - 1]);
		return perimeter;
	}

	public void draw( Graphics g ) {
		for( int i = 0; i &lt; points.length - 1; i++ )
			g.drawLine(points[i].x, points[i].y,
				points[i+1].x, points[i+1].y);
		g.drawLine(points[0].x, points[0].y, points[points.length
			- 1].x, points[points.length - 1].y);
	}
}</programlisting>
<simpara>The number of things that can be done with this very general <literal>Polygon</literal>
class are limited. The <literal>getPerimeter()</literal> method can determine the length
of the perimeter by adding the lengths of the segments connecting the
vertices. It is possible to determine the area enclosed by a list of
vertices, but the algorithm is complex. The <literal>draw()</literal> method draws the
polygon by drawing each line segment that connects adjacent vertices. We
discuss the <literal>Graphics</literal> class in ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>. If you compile and run this code, please note that in
Java graphics, like many computer graphics environments, the upper left
hand corner of the screen or window is considered (0,0), and
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> values <emphasis role="strong">increase</emphasis> going downward, not upward.</simpara>
<simpara>With this basic parent class defined, we can design a <literal>Triangle</literal> class
as a child of it.</simpara>
<programlisting language="java" linenumbering="numbered">import java.awt.*;

public class Triangle extends Polygon {
	public Triangle( int x1, int y1, int x2, int y2,
		int x3, int y3 ) {
		super( toPointArray( x1, y1, x2, y2, x3, y3 ) );
	}

	protected static Point[] toPointArray( int x1, int y1,
		int x2, int y2, int x3, int y3 ) {
		Point[] array = {new Point(x1, y1), new Point(x2, y2),
			new Point(x3, y3)};
		return array;
	}</programlisting>
<simpara>Again, the <literal>import</literal> statement is for the <literal>Point</literal> class. One reasonable
constructor to make a triangle would take in six values, giving the
<inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> coordinates of the three vertices of
the triangle. Of course, the <literal>Polygon</literal> class requires an array of type
<literal>Point</literal>, but the <literal>super</literal> constructor must be the first line of the
<literal>Triangle</literal> constructor. To solve this problem, we create a <literal>static</literal>
method to package the values into an array. We could have done the same
thing in the argument list of the <literal>super</literal> constructor, but it would have
looked messier. The <literal>toPointArray()</literal> is <literal>protected</literal> because there is no
reason to let external code have access to it.</simpara>
<programlisting language="java" linenumbering="numbered">	public String getType() {
		double a = points[0].distance(points[1]);
		double b = points[1].distance(points[2]);
		double c = points[2].distance(points[0]);
		if( a == b &amp;&amp; b == c )
			return "Equilateral";
		if( a == b || b == c || a == c )
			return "Isosceles";
		return "Scalene";
	}
}</programlisting>
<simpara>Finally, the <literal>getType()</literal> method allows us to do something specific with
triangles. We can use the <literal>distance()</literal> method from the <literal>Point</literal> class to
find the length of each of the three sides. By comparing these lengths,
we can determine whether the triangle represented is equilateral,
isosceles, or scalene. Of course, computing the perimeter and drawing
the triangle are already taken care of by the <literal>Polygon</literal> class.</simpara>
<simpara>We can easily make a <literal>Rectangle</literal> class along the same lines.</simpara>
<programlisting xml:id="program:Rectangle" xreflabel="Rectangle" language="java" linenumbering="numbered">import java.awt.*;

public class Rectangle extends Polygon {
	public Rectangle( int x, int y, int length, int width ) {
		super( toArray( x, y, length, width ) );
	}

	protected static Point[] toArray( int x, int y, int length,
		int width ) {
		Point[] array = {new Point(x, y), new Point(x + length, y),
			new Point(x + length, y + width), new Point(x, y + width)};
		return array;
	}

	public int getArea() {
		int length = points[1].x - points[0].x;
		int width = points[2].y - points[1].y;
		return length * width;
	}
}</programlisting>
<simpara>The constructor is similar to the <literal>Triangle</literal> constructor except that the
upper left corner of the rectangle is specified, along with the length
and the width. From these values, the appropriate array of <literal>Point</literal>
values is generated. The rectangle-specific code that we add is the
<literal>getArea()</literal> method, which determines the length and width of the
rectangle by examining the <literal>points</literal> array and then calculates area.</simpara>
<simpara>Using inheritance as form of specialization, we can go one step further
and make a <literal>Square</literal> class.</simpara>
<programlisting xml:id="program:Square" xreflabel="Square" language="java" linenumbering="numbered">public class Square extends Rectangle {
	public Square(int x, int y, int size ) {
		super( x, y, size, size );
	}
}</programlisting>
<simpara>This very short class uses everything available in <literal>Rectangle</literal> but
simplifies the constructor slightly so that the user does not have to
enter both length and width.</simpara>
</example>
</section>
<section xml:id="_solution_boolean_circuits">
<title>Solution: Boolean circuits</title>
<simpara>Here we present our solution to the Boolean Circuits problem. First, we
define a parent class for all circuit components, called <literal>Gate</literal>.</simpara>
<programlisting xml:id="program:Gate" xreflabel="Gate" language="java" linenumbering="numbered">public class Gate {
	private String name;

	public Gate( String name ) { this.name = name; }
	public String getName() { return name; }
	public String toString() {
		return getName() + ": " + getValue();
	}
	public boolean getValue() { return false; }
}</programlisting>
<simpara>The <literal>Gate</literal> class doesn&#8217;t do anything except set up ways to store a name
and to get a value. From <literal>Gate</literal>, we can define the most basic circuit
components: gates whose value is either always true or always false. It
doesn&#8217;t really matter what <literal>getValue()</literal> gives back for <literal>Gate</literal>, but we
can say that it is <literal>false</literal>.</simpara>
<programlisting xml:id="program:True" xreflabel="True" language="java" linenumbering="numbered">public class True extends Gate {
	public True() { super("true"); }
	public boolean getValue() { return true; }
}</programlisting>
<programlisting xml:id="program:False" xreflabel="False" language="java" linenumbering="numbered">public class False extends Gate {
	public False() { super("false"); }
	public boolean getValue() { return false; }
}</programlisting>
<simpara>To conform with the constructor for <literal>Gate</literal>, these new classes must pass
a <literal>String</literal> giving their name to the <literal>super</literal> constructor. The values
returned by the <literal>getValue()</literal> method are clear. Next, we want to create a
class that can be used for general unary operators.</simpara>
<programlisting xml:id="program:UnaryOperator" xreflabel="UnaryOperator" language="java" linenumbering="numbered">public class UnaryOperator extends Gate {
	private Gate input;

	public UnaryOperator( String name ) { super( name ); }
	public void setInput( Gate input ) { this.input = input; }
	public Gate getInput() { return input; }
}</programlisting>
<simpara>The important addition in the <literal>UnaryOperator</literal> class is the <literal>input</literal>
field. Any unary operator must have a single input gate that it operates
on. This class provides a mutator and accessor for <literal>input</literal>, as well as
an appropriate constructor. From <literal>UnaryOperator</literal>, we can derive two
specific operators.</simpara>
<programlisting xml:id="program:Output" xreflabel="Output" language="java" linenumbering="numbered">public class Output extends UnaryOperator {
	public Output( int i ) { super( "OUTPUT " + i ); }
	public boolean getValue() { return getInput().getValue(); }
}</programlisting>
<programlisting xml:id="program:Not" xreflabel="Not" language="java" linenumbering="numbered">public class Not extends UnaryOperator {
	public Not() { super("NOT"); }
	public boolean getValue() { return !(getInput().getValue()); }
}</programlisting>
<simpara>The <literal>Output</literal> class takes in an <literal>int</literal> value and uses it to make a
numbered name. Its <literal>getValue()</literal> method simply returns the value of its
input. The <literal>Output</literal> class doesn&#8217;t do anything except serve as a marker
for circuit output. The <literal>Not</literal> class uses <literal>"NOT"</literal> as the name supplied to
the <literal>super</literal> constructor and returns the logical NOT of the value of its
input.</simpara>
<simpara>Just as we did for unary operators, we also need a base class for binary
operators.</simpara>
<programlisting xml:id="program:BinaryOperator" xreflabel="BinaryOperator" language="java" linenumbering="numbered">public class BinaryOperator extends Gate {
	private Gate operand1;
	private Gate operand2;

	public BinaryOperator( String name ) { super( name ); }
	public Gate getOperand1() { return operand1; }
	public Gate getOperand2() { return operand2; }
	public void setOperand1( Gate operand ) { operand1 = operand; }
	public void setOperand2( Gate operand ) { operand2 = operand; }
}</programlisting>
<simpara>A <literal>BinaryOperator</literal> has two <literal>Gate</literal> fields, <literal>operand1</literal> and <literal>operand2</literal>,
representing the inputs to the operator. The <literal>BinaryOperator</literal> class has
an appropriate constructor and then accessors and mutators for the
operands. With <literal>BinaryOperator</literal> as a parent, only a few lines of code
are necessary to define any logical binary operator.</simpara>
<programlisting xml:id="program:And" xreflabel="And" language="java" linenumbering="numbered">public class And extends BinaryOperator {
	public And() { super("AND"); }

	public boolean getValue() {
		return getOperand1().getValue() &amp;&amp;
			getOperand1().getValue();
	}
}</programlisting>
<programlisting xml:id="program:Or" xreflabel="Or" language="java" linenumbering="numbered">public class Or extends BinaryOperator {
	public Or() { super("OR"); }

	public boolean getValue() {
		return getOperand1().getValue() ||
			getOperand1().getValue();
	}
}</programlisting>
<programlisting xml:id="program:Xor" xreflabel="Xor" language="java" linenumbering="numbered">public class Xor extends BinaryOperator {
	public Xor() { super("XOR"); }

	public boolean getValue() {
		return getOperand1().getValue() ^ getOperand1().getValue();
	}
}</programlisting>
<simpara>In each case, a constructor passes the name of the gate to the <literal>super</literal>
constructor. Then, each <literal>getValue()</literal> method gets the values from the two
operands and combines them with AND, OR, or XOR, respectively. This
design allows the programmer to focus only on the important element of
each class. Adding new classes for NAND, NOR, or any other possible
logical binary operator would be quick.</simpara>
<simpara>The client code that uses these classes to simulate a circuit follows.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class BooleanCircuit {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		int count = in.nextInt();
		Gate[] gates = new Gate[count];
		String name;
		int value;</programlisting>
<simpara>First we have the <literal>import</literal> needed for <literal>Scanner</literal>. Next, we read in the
total number of gates and create an array of type <literal>Gate</literal> of that length
and declare a few useful temporary variables.</simpara>
<programlisting language="java" linenumbering="numbered">		// Create gates
		for( int i = 0; i &lt; count; i++ ) {
			name = in.next().toUpperCase();
			if( name.equals("true") )
				gates[i] = new True();
			else if( name.equals("false") )
				gates[i] = new False();
			else if( name.equals("AND") )
				gates[i] = new And();
			else if( name.equals("OR") )
				gates[i] = new Or();
			else if( name.equals("XOR") )
				gates[i] = new Xor();
			else if( name.equals("NOT") )
				gates[i] = new Not();
			else if( name.equals("OUTPUT") ) {
				value = in.nextInt();
				gates[i] = new Output( value );
			}
		}</programlisting>
<simpara>Then, we parse the input, creating an appropriate gate based on the name
read in. In the case of an OUTPUT gate, we must also read in a number so
that we can identify which OUTPUT gate is which later.</simpara>
<programlisting language="java" linenumbering="numbered">		//connect gates
		while( in.hasNextInt() ) {
			value = in.nextInt();
			name = gates[value].getName();
			if( name.equals("AND") || name.equals("OR") ||
				name.equals("XOR") ) {
				BinaryOperator operator =
					(BinaryOperator)gates[value];
				operator.setOperand1( gates[in.nextInt()] );
				operator.setOperand2( gates[in.nextInt()] );
			}
			else if( name.equals("NOT") ||
				name.startsWith("OUTPUT") ) {
				UnaryOperator operator =
					(UnaryOperator)gates[value];
				operator.setInput( gates[in.nextInt()] );
			}
		}</programlisting>
<simpara>As long as there is remaining input, we read in an index. Based on the
name of the gate at that index in the array, we either read in two more
indexes (for binary operators) or just a single additional index (for
unary operators). In either case, we set the input or inputs of the
operator to the gate or gates at those indexes.</simpara>
<programlisting language="java" linenumbering="numbered">		// Compute output
		for( int i = 0; i &lt; count; i++ )
		  if( gates[i].getName().startsWith("OUTPUT") )
			System.out.println( gates[i] );
	  }
}</programlisting>
<simpara>Finally, the simulation of the circuit is absurdly simple. We look
through array until we find a gate whose name starts with <literal>"OUTPUT"</literal>.
Then, we print out its value. In order to determine its value, it will
ask its input what its value is, which in turn will ask for the values
from its input. The <literal>toString()</literal> in the <literal>Gate</literal> class will assure us that
the final output is nicely formatted. This system accommodates any
number of output gates connected arbitrarily, as long as the circuit has
no loops inside of it, such as an AND gate whose output is also one of
its inputs.</simpara>
</section>
<section xml:id="_concurrency_inheritance">
<title>Concurrency: Inheritance</title>
<simpara>Like interfaces, inheritance in Java is not closely related to
concurrency. However, two ways in which inheritance interacts with
concurrency deserve attention.</simpara>
<simpara>The first is the <literal>Thread</literal> class. Each thread of execution in Java
(except the main thread) is managed with a <literal>Thread</literal> object or an object
whose type inherits from <literal>Thread</literal>. Creating such types is done by
extending <literal>Thread</literal>, just as you would extend any other class. Further
information about extending <literal>Thread</literal> for concurrency is given in
SectionÂ <xref linkend="syntax:Threads_in_Java"/>. Extending the <literal>Thread</literal> class to make
your own customized threads of execution is an alternative to
implementing the <literal>Runnable</literal> interface mentioned in
SectionÂ <xref linkend="concurrency:Interfaces"/> and is discussed in greater detail in
SectionÂ <xref linkend="subsection:runnable"/>.</simpara>
<simpara>The second interaction between inheritance and concurrency is again very
similar to the problem with interfaces and concurrency: There is no way
to specify that a method is thread-safe. Recall that it is not allowed
to use the <literal>synchronized</literal> keyword on a method in an interface
declaration. Likewise, there is no restriction on overriding a
synchronized method with a non-synchronized method or vice versa.</simpara>
<simpara>The rules for overriding methods in Java guarantee that an object of a
child class is usable anywhere that an object of the parent class is
usable. Thus, you cannot override a public method with a private one,
reducing the visibility of a method. We discuss a similar restriction
with exceptions in SectionÂ <xref linkend="subsection:Inheritance_and_exceptions"/>.</simpara>
<simpara>If it has these restrictions, why doesn&#8217;t Java prevent a synchronized
method from being overridden by a non-synchronized method? In the first
place, a non-synchronized method can be used anywhere a synchronized one
could. (Unlike a private method, which is not accessible everywhere a
public one is.) In the second, the designers of Java have put thread
safety in the category of implementation details left up to the
programmer. Some classes need specific methods to be synchronized and
others (even child classes) do not. However, if you override a class
with a synchronized method, it is safest to mark your method
synchronized as well.</simpara>
</section>
<section xml:id="_exercises_10">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Give three advantages of using inheritance instead of copying and
pasting code from a parent class. Are there any disadvantages to using
inheritance?</simpara>
</listitem>
<listitem>
<simpara>Consider classes <literal>Radish</literal> and <literal>Carrot</literal> which both extend class
<literal>Vegetable</literal> and implement interface <literal>Crunchable</literal>. Which of the following
sets of assignments are legal and why?</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><literal>Radish radish = new Radish();</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Radish radish = new Vegetable();</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Vegetable vegetable = new Radish();</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Crunchable crunchy = new Radish();</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Radish radish = new Carrot();</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In the context of inheritance, the keyword <literal>super</literal> can be used for
two different purposes. What are they?</simpara>
</listitem>
<listitem>
<simpara>Consider the following class definitions.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class A {
    private String value;
    public A(String s) { value = "A" + s + "A"; }
    public String toString() { return value; }
}

public class B extends A {
    public B(String s) { super( "B" + s + "B" ); }
}

public class C extends B {
    public C(String s) { super( "C" + s + "C" ); }
}</programlisting>
<simpara>What is output by the following code fragment?</simpara>
<programlisting language="java" linenumbering="unnumbered">C c = new C("ABC");
System.out.println(c);</programlisting>
</listitem>
<listitem>
<simpara>Beginning Java programmers often confuse package-private access (no
explicit specifier) with <literal>public</literal> access. How is this confusion possible
when default access is more constrained than both <literal>public</literal> and
<literal>protected</literal> access? (Hint: The file system plays a role.)</simpara>
</listitem>
<listitem>
<simpara>What are the similarities and differences between overloading a
method and overriding a method?</simpara>
</listitem>
<listitem>
<simpara>What is field hiding? How can software bugs arise from this
functionality in Java?</simpara>
</listitem>
<listitem>
<simpara>Give reasons why the designers of Java decided not to allow multiple
inheritance. Would you have made the same decision? Why or why not?</simpara>
</listitem>
<listitem>
<simpara>Draw a class hierarchy establishing a sensible relationship between
the <literal>Human</literal>, <literal>Soldier</literal>, <literal>Sailor</literal>, <literal>Marine</literal>, <literal>General</literal>, and <literal>Admiral</literal>
classes. For this class hierarchy, refer to the U.S. military structure
in which the U.S. Marine Corps is a part of the U.S. Navy.</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Create an <literal>InternationalStudent</literal> class that extends <literal>Student</literal>. It
should include <literal>String</literal> fields for country of origin and also visa
status. It should include mutator and accessor methods for these two new
fields.</simpara>
</listitem>
<listitem>
<simpara>Add <literal>Pentagon</literal> and <literal>Hexagon</literal> classes that extend the <literal>Polygon</literal>
class. The constructor for each class should take an <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> and radius value, each of <literal>int</literal> type. Both classes
should be implemented to create <emphasis>regular</emphasis> polygons, that is, polygons in
which all 5 or 6 sides have the same length. The <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> values should give the center of the polygon, and each
of the 5 or 6 points should be the radius distance away from that
center.</simpara>
<simpara>Because the internal structure of <literal>Polygon</literal> keeps all vertices as
<literal>Point</literal> values, the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> coordinates of
the points must be <literal>int</literal> values. This requirement will force you to
round these <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> coordinates after using
trigonometry to determine their locations. As a result, the final
pentagons and hexagons stored and displayed will be slightly irregular.</simpara>
</listitem>
<listitem>
<simpara>The inheritance design of our solution to the Boolean circuits
problem given in SectionÂ <xref linkend="solution:Boolean_circuits"/> makes adding new
gates easy. Add classes that implement a NAND gate and a NOR gate. Then,
rewrite the <literal>main()</literal> method of <literal>BooleanCircuit</literal> to accommodate these two
extra classes.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the object hierarchy in the solution to the sort it out
problem from ChapterÂ <xref linkend="chapter:Interfaces"/>. This time, let the <literal>Cat</literal>,
<literal>Dog</literal>, and <literal>Person</literal> classes extend the <literal>Creature</literal> class defined below.</simpara>
<programlisting xml:id="program:Creature" xreflabel="Creature" language="java" linenumbering="numbered">public class Creature implements Ageable, Weighable {
	protected int age;
	protected double weight;

	public Creature( int age, double weight ) {
		this.age = age;
		this.weight = weight;
	}

	public int getAge() { return age; }

	public int getWeight() { return weight; }
}</programlisting>
<simpara>Refactor your code so that the <literal>Cat</literal>, <literal>Dog</literal>, and <literal>Person</literal> classes are as
short as possible. How many lines of code do you save?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:celestial"/> Design a celestial body simulator. You will
need to create a class containing fields for the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation> locations, <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation> velocities, radii, and masses of
each object. For each time step of length <inlineequation><alt><![CDATA[t]]></alt><mathphrase><![CDATA[t]]></mathphrase></inlineequation>, you must do
the following.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Compute the sum of forces exerted on each body by every other body.
The equation for gravitational force on body <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation> exerted by
body <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> is
<inlineequation><alt><![CDATA[\mathbf{F}_{ab} = - G \frac{m_a m_b}{{\vert \mathbf{r}_{ab} \vert}^2} \, \mathbf{\hat{r}}_{ab}]]></alt><mathphrase><![CDATA[\mathbf{F}_{ab} = - G \frac{m_a m_b}{{\vert \mathbf{r}_{ab} \vert}^2} \, \mathbf{\hat{r}}_{ab}]]></mathphrase></inlineequation>
where
<inlineequation><alt><![CDATA[G = 6.673\times 10^{-11} \mbox{N} \mbox{m}^2 \mbox{kg}^{-2}]]></alt><mathphrase><![CDATA[G = 6.673\times 10^{-11} \mbox{N} \mbox{m}^2 \mbox{kg}^{-2}]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[\vert \mathbf{r}_{ab} \vert]]></alt><mathphrase><![CDATA[\vert \mathbf{r}_{ab} \vert]]></mathphrase></inlineequation> is the distance between the
centers of objects <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[b]]></alt><mathphrase><![CDATA[b]]></mathphrase></inlineequation>, and
<inlineequation><alt><![CDATA[\mathbf{\hat{r}}_{ab} = \frac{\mathbf{r}_b - \mathbf{r}_a}{\vert\mathbf{r}_b - \mathbf{r}_a\vert}]]></alt><mathphrase><![CDATA[\mathbf{\hat{r}}_{ab} = \frac{\mathbf{r}_b - \mathbf{r}_a}{\vert\mathbf{r}_b - \mathbf{r}_a\vert}]]></mathphrase></inlineequation>,
the unit vector between the centers of the two objects.</simpara>
</listitem>
<listitem>
<simpara>Compute the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation>
components of the acceleration vector <inlineequation><alt><![CDATA[{\mathbf a}]]></alt><mathphrase><![CDATA[{\mathbf a}]]></mathphrase></inlineequation> for each
object using the equation, <inlineequation><alt><![CDATA[{\mathbf F} = m {\mathbf a}]]></alt><mathphrase><![CDATA[{\mathbf F} = m {\mathbf a}]]></mathphrase></inlineequation>,
once the sum of forces has been calculated.</simpara>
</listitem>
<listitem>
<simpara>Update the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation>
components of the velocity vector <inlineequation><alt><![CDATA[{\mathbf v}]]></alt><mathphrase><![CDATA[{\mathbf v}]]></mathphrase></inlineequation> for each
object using the equation
<inlineequation><alt><![CDATA[{\mathbf v}_{new} = {\mathbf v}_{old} + {\mathbf a}t]]></alt><mathphrase><![CDATA[{\mathbf v}_{new} = {\mathbf v}_{old} + {\mathbf a}t]]></mathphrase></inlineequation>.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Inheritance is a powerful technique, but it comes with some overhead
costs. Create a class called <literal>A</literal> with the following implementation.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class A {
    protected int a;
}</programlisting>
<simpara>Then, create 25 more classes named <literal>B</literal> through <literal>Z</literal>. Class <literal>B</literal> should
extend <literal>A</literal> and add a <literal>protected</literal> <literal>int</literal> field called <literal>b</literal>. Continue in
this manner, with each new class extending the previous one and adding
an <literal>int</literal> field named the lowercase version of the class name. Thus, if
you create an object of type <literal>Z</literal>, it will contain, through inheritance,
26 <literal>int</literal> fields named <literal>a</literal> through <literal>z</literal>. But, for a single <literal>Z</literal> object to
be created, it must call 27 (<literal>Z</literal> back through <literal>A</literal> plus <literal>Object</literal>)
constructors. You may wish to use the file I/O material in
ChapterÂ <xref linkend="chapter:File_I/O"/> to write a program to create all these
classes so that you do not have to do so by hand.</simpara>
<simpara>Finally, create a new class called <literal>All</literal> which contains 26 <literal>protected</literal>
fields of <literal>int</literal> type named <literal>a</literal> through <literal>z</literal>. Now, the purpose of doing
all this is to compare the time needed to instantiate an object of type
<literal>Z</literal> with one of type <literal>All</literal>, though they both only contained 26 <literal>int</literal>
fields named <literal>a</literal> through <literal>z</literal>.</simpara>
<simpara>Create an array of 100,000 elements of type <literal>Z</literal> and then populate it
with 100,000 <literal>Z</literal> objects. Time this process. Create an array of 100,000
elements of type <literal>All</literal> and then populate that array with 100,000 <literal>All</literal>
objects. You may wish to use the <literal>System.nanoTime()</literal> method described in
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/> to accurately time these
processes. Is there a significant difference in the times you found?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Exceptions">
<title>Exceptions</title>
<blockquote>
<attribution>
W. R. Inge
</attribution>
<simpara>The vulgar mind always mistakes the exceptional for the important.</simpara>
</blockquote>
<section xml:id="_problem_bank_burglary">
<title>Problem: Bank burglary</title>
<simpara>Let&#8217;s consider a problem in which various aspects of a bank burglary are
modeled as objects in Java. You want to write some code that will
accomplish the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Disable the burglar alarm</simpara>
</listitem>
<listitem>
<simpara>Break into the bank</simpara>
</listitem>
<listitem>
<simpara>Find the vault</simpara>
</listitem>
<listitem>
<simpara>Open the vault</simpara>
</listitem>
<listitem>
<simpara>Carry away the loot</simpara>
</listitem>
</orderedlist>
<simpara>But any number of things could go wrong! When trying to disable the
burglar alarm, you might set it off. When you try to break into the
bank, you might have thought that you&#8217;d disabled the burglar alarm but
actually failed to do so. The door of the bank might be too difficult to
open. The vault might be impossible to find, or the vault might be
impossible to open. It could even be empty. The money might be made of
enormous gold blocks that are too heavy to carry away. Finally, at any
time during the heist, a night watchman might catch you in the act.</simpara>
<simpara>If you are the criminal mastermind who planned this deed, you need to
know if (and preferably how) your henchman bungled the burglary. You
need a simple system that can inform you of any errors that have
occurred along the way. Likewise, you need to be able to react
differently depending on what went wrong.</simpara>
<simpara>We are going to model each of these error conditions with Java
<emphasis>exceptions</emphasis>. An exception is how Java indicates exceptional or
incorrect situations inside of a program. These exceptions are <emphasis>thrown</emphasis>
when the error happens. You must then write code to <emphasis>catch</emphasis> the error
and deal with it appropriately. The bank burglar program will deal with
three different classes, <literal>Bank</literal>, <literal>Vault</literal>, and <literal>Loot</literal>.</simpara>
<simpara>The <literal>Bank</literal> class has three methods, <literal>disableAlarm()</literal>, <literal>breakIn()</literal>, and
<literal>findVault()</literal>, which returns a <literal>Vault</literal> object. The <literal>Vault</literal> class has an
<literal>open()</literal> method and a <literal>getLoot()</literal> method, which returns a <literal>Loot</literal> object.
The <literal>Loot</literal> class has a <literal>carryAway()</literal> method. Below is a table of the
exceptions which can be thrown by each of the methods.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="middle">Class</entry>
<entry align="left" valign="middle">Method</entry>
<entry align="left" valign="middle">Exceptions</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle" morerows="5"><literallayout class="monospaced">Bank</literallayout></entry>
<entry align="left" valign="middle" morerows="1"><literallayout class="monospaced">disableAlarm()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">BurglarAlarmException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle" morerows="2"><literallayout class="monospaced">breakIn()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">BurglarAlarmException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">LockPickFailException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">findVault()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle" morerows="2"><literallayout class="monospaced">Vault</literallayout></entry>
<entry align="left" valign="middle" morerows="1"><literallayout class="monospaced">open()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">LockPickFailException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">getLoot()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle" morerows="1"><literallayout class="monospaced">Loot</literallayout></entry>
<entry align="left" valign="middle" morerows="1"><literallayout class="monospaced">carryAway()</literallayout></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">LootTooHeavyException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><literallayout class="monospaced">WatchmanException</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In order to deal with each of these possible errors, you need some
special Java syntax.</simpara>
</section>
<section xml:id="_concepts_error_handling">
<title>Concepts: Error handling</title>
<simpara>As a rule, computer programs are filled with errors. Writing a program
is a difficult and complex process. Even if a segment of code is free
from errors, it may call other code which contains mistakes. The user
could be making mistakes and issuing commands to a program that are
impossible to execute. Even hardware can produce errors, as in a hard
drive crash or a DVD with a scratch on its surface.</simpara>
<section xml:id="_error_codes">
<title>Error codes</title>
<simpara>A robust program should deal with as many errors as possible. One
strategy is to have every method give back a special error code
corresponding to the error that has just occurred. Then, the code
calling the method can react appropriately. Of course, many methods do
not return a numerical type, limiting this kind of error handling. A
solution that was very common in the C language, particularly in Unix
system calls, was to set a globally visible <literal>int</literal> variable called
<literal>errno</literal> to a value corresponding to the error that has just happened.</simpara>
<simpara>These solutions have a number of drawbacks. In the case of <literal>errno</literal>, if a
number of different threads were running at the same time, different
errors could occur simultaneously, but only one value could be kept in
<literal>errno</literal>. For any system that relies on checking for an error condition
after each method call, a large amount of error handling code must be
mixed in with normal code. Doing so reduces code readability and makes
it difficult to centralize error handling. Likewise, a numerical value
can be difficult to deal with. A user may have to look it up to find out
what kind of error it is.</simpara>
</section>
<section xml:id="exceptions">
<title>Exceptions</title>
<simpara>Java adopts a different error handling strategy called exceptions.
Whenever a specified error state or unusual situation is reached, an
exception is thrown. When an exception is thrown, normal execution stops
immediately. The exception looks for code that is designed to deal with
that specific exception. The code that will handle the exception can be
in the current method, in the calling method, in the caller of the
calling method, or arbitrarily far back in the chain of method calls,
all the way to <literal>main()</literal>. Each method will return, looking for code to
handle this exception, until it is found. If no handling code is found,
the exception will propagate all the way past <literal>main()</literal> to the JVM, and
the program will end.</simpara>
<simpara>Exceptions give a unified and simple way to handle all errors. You can
choose to deal with errors directly or delegate that responsibility to
methods that call the code you are writing. Selection statements and
loops are forms of local control flow, but exceptions give us the power
of non-local control flow, able to jump back through any number of
method calls.</simpara>
</section>
</section>
<section xml:id="_syntax_exceptions_in_java">
<title>Syntax: Exceptions in Java</title>
<simpara>In Java syntax, there are two important parts needed to use exceptions:
throwing the exception when an error occurs and then handling that
exception properly. Below we will explain both of these as well as the
catch or specify requirement, the <literal>finally</literal> keyword, and the process of
creating custom exceptions.</simpara>
<section xml:id="_throwing_exceptions">
<title>Throwing exceptions</title>
<simpara>By now you have probably experienced a <literal>NullPointerException</literal> in the
process of coding. This exception happens when an object reference is
<literal>null</literal> but we try to access one of its methods or fields.</simpara>
<programlisting language="java" linenumbering="unnumbered">String text = null;
int x = text.length(); // NullPointerException</programlisting>
<simpara>In this case, the exception is thrown by the JVM itself. It is possible
to catch this exception and deal with it, but a <literal>NullPointerException</literal>
generally means a mistake in the program, not an error that can be
recovered from. Although many useful exceptions such as<?asciidoc-br?>
<literal>NullPointerException</literal>, <literal>ArithmeticException</literal>, and
<literal>ArrayIndexOutOfBoundsException</literal> are implicitly thrown by the JVM, we
are permitted to throw them explicitly.</simpara>
<programlisting language="java" linenumbering="unnumbered">if( y &lt; 14 )
    throw new NullPointerException();</programlisting>
<simpara>Like any other object, we use the <literal>new</literal> keyword to instantiate a
<literal>NullPointerException</literal> using its default constructor. Once created, we
use the <literal>throw</literal> keyword to cause the exception to go into effect. Any
exception you throw explicitly must use the <literal>throw</literal> keyword, but the
majority of exceptions thrown by your programs will either be mistakes
or exceptions thrown by library code you are calling. If you write a
significant amount of library or API code, you may use <literal>throw</literal> more
often.</simpara>
</section>
<section xml:id="_handling_exceptions">
<title>Handling exceptions</title>
<simpara>Normal application programmers will find themselves writing code that
handles exceptions much more often than code that throws them. In order
to catch an exception, you must enclose the code that you think is going
to throw an exception in a <literal>try</literal> block. Immediately after the <literal>try</literal>
block, you can list one or more <literal>catch</literal> blocks. The code inside the
first <literal>catch</literal> block that matches your exception will be executed.</simpara>
<programlisting language="java" linenumbering="unnumbered">try {
    String text = null;
    int x = text.length(); //NullPointerException
    System.out.println("This will never be printed.");
}
catch( NullPointerException e ) {
    System.out.println("Surprise! A NullPointerException!");
}</programlisting>
<simpara>In this case, trying to access the <literal>length()</literal> method of a <literal>null</literal>
reference will still throw a <literal>NullPointerException</literal>, but now it will be
caught by the <literal>catch</literal> block below. The message
<literal>"Surprise! A NullPointerException!"</literal> will be printed to the screen, and
execution will continue normally after the <literal>catch</literal> block. Once the
exception is caught, it stops trying to propagate. Of course, whatever
the code was doing when the exception was thrown was abandoned
immediately because it might have depended on successful execution of
the code that threw an exception. Thus, the call to the
<literal>System.out.println()</literal> method in the <literal>try</literal> block will never be executed.</simpara>
<simpara>An exception will match the first <literal>catch</literal> block with the same class or
any superclass. Since <literal>Exception</literal> is the parent of <literal>RuntimeException</literal>
which is the parent of <literal>NullPointerException</literal>, we could write our
example with <literal>Exception</literal> instead.</simpara>
<programlisting language="java" linenumbering="unnumbered">try {
    String text = null;
    int x = text.length(); //NullPointerException
    System.out.println("This will never be printed.");
}
catch( Exception e ) {
    System.out.println("Well, of course you got a NullPointerException!");
}</programlisting>
<simpara>In general, you should write the most specific exception class possible
for your <literal>catch</literal> blocks. Otherwise, you might be catching a different
exception than you plan for or preventing an exception from propagating
up to an appropriate handler. For example, the following code has the
potential to throw either a <literal>NullPointerException</literal> or an
<literal>ArithmeticException</literal>, because of a division by 0.</simpara>
<programlisting language="java" linenumbering="unnumbered">try {
    String text = null;
    int x;
    if( Math.random() &gt; 0.5 )
        x = text.length(); //NullPointerException
    else
        x = 5 / 0; //ArithmeticException
}
catch( Exception e ) {
    System.out.println("You got some kind of exception!");
}</programlisting>
<simpara>This code will catch either kind of exception, but it will not tell you
which you got. Instead, the correct approach is to have one <literal>catch</literal>
block for each possible kind of exception.</simpara>
<programlisting language="java" linenumbering="unnumbered">try {
    String text = null;
    int x;
    if( Math.random() &gt; 0.5 )
        x = text.length(); //NullPointerException
    else
        x = 5 / 0; //ArithmeticException
}
catch( NullPointerException e ) {
    System.out.println("You got a null pointer!");
}
catch( ArithmeticException e ) {
    System.out.println("You divided by zero!");
}</programlisting>
<simpara>The list of <literal>catch</literal> blocks can be arbitrarily long. You must always go
from the most specific exceptions to the most general, like <literal>Exception</literal>,
otherwise some exceptions could never be reached. The Java compiler
enforces this requirement. The <literal>e</literal> is a reference to the exception
itself, which behaves something like a parameter in a method. It is
common to use <literal>e</literal> as the identifier but you are allowed to call it any
legal variable name. Usually, the kind of exception is all you need to
know, but every exception is an object and has fields and methods.
Particularly useful is the <literal>getMessage()</literal> method which can give
additional information about the exception.</simpara>
</section>
<section xml:id="_catch_or_specify">
<title>Catch or specify</title>
<simpara>Despite the examples given above, you will rarely write code to catch a
<literal>NullPointerException</literal> or an <literal>ArithmeticException</literal>. Both of these
exceptions are called <emphasis>unchecked</emphasis> exceptions. In
ChapterÂ <xref linkend="chapter:Arrays"/>, we used the <literal>Thread.sleep()</literal> method to put
the execution of our program to sleep for a short period of time. We
were forced to enclose this method call in a <literal>try</literal> block with a <literal>catch</literal>
block for <literal>InterruptedException</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">try{
    Thread.sleep(100);
}
catch( InterruptedException  e ) {
    System.out.println("Wake up!");
}</programlisting>
<simpara>An <literal>InterruptedException</literal> is thrown when another thread tells your
thread of execution to wake up before it finishes sleeping or waiting.
This exception is a <emphasis>checked</emphasis> exception, meaning that Java insists that
you use a <literal>try</literal>-<literal>catch</literal> pair anytime there is even a chance of it being
thrown. Otherwise your code will not compile.</simpara>
<simpara>Checked exceptions are those exceptions that your program should plan
for. Library and API code often throw checked exceptions. For example,
when trying to open a file with an API call, it&#8217;s possible that no file
with that name exists or that the user might not have permission to
access it. A program should catch the corresponding exceptions and
recover rather than crashing. Perhaps the program should prompt the user
for a new name or explain that the required permission is not set.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Arrays"/>, there were no executable statements in
the <literal>catch</literal> block used with the<?asciidoc-br?>
<literal>Thread.sleep()</literal> method. You should <emphasis role="strong">never</emphasis> write an empty <literal>catch</literal>
block. Doing so allows errors to fail silently.</simpara>
<simpara>We are allowed to put code that can throw a checked exception into a
<literal>try</literal>-<literal>catch</literal> block, but there is another possibility. Java has a catch
or specify requirement, meaning that your code is required either to
catch a checked exception or to specify that it has the potential for
causing that exception. To specify that a method can throw certain
exceptions, we use the <literal>throws</literal> keyword. Note that this is <emphasis role="strong">not</emphasis> the
same as the <literal>throw</literal> keyword.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void sleepWithoutTry( int milliseconds ) throws InterruptedException {
    Thread.sleep( milliseconds );
}</programlisting>
<simpara>In this case, there is no need for a <literal>try</literal>-<literal>catch</literal> block because the
method announces that it has a risk of throwing an
<literal>InterruptedException</literal>. Of course, any code that uses this method will
have to have a <literal>try</literal>-<literal>catch</literal> block or specify that it also throws<?asciidoc-br?>
<literal>InterruptedException</literal>. A method can throw many different exceptions,
and you can simply list them out after the <literal>throws</literal> keyword, separated
by commas.</simpara>
<simpara>Almost every exception thrown in Java is a child class of <literal>Exception</literal>,
<literal>RuntimeException</literal>, or <literal>Error</literal>. Any descendant of <literal>RuntimeException</literal> or
<literal>Error</literal> is an unchecked exception and is exempt from the catch or
specify requirement. Any direct descendant of <literal>Exception</literal> is a checked
exception and must either be caught with a <literal>try</literal>-<literal>catch</literal> block or
specified with the <literal>throws</literal> keyword. We say <emphasis role="strong">direct</emphasis> descendant because
<literal>RuntimeException</literal> is a child of <literal>Exception</literal>, leading to the confusing
situation where only those descendants of <literal>Exception</literal> which are not also
descendants of <literal>RuntimeException</literal> are checked.</simpara>
</section>
<section xml:id="_the_literal_finally_literal_keyword">
<title>The <literal>finally</literal> keyword</title>
<simpara>To deal with the situation in which some important cleanup or finalizing
task must be done no matter what, the designers of Java introduced the
<literal>finally</literal> keyword. A <literal>finally</literal> block comes after all the <literal>catch</literal> blocks
following a <literal>try</literal> block. The code inside the <literal>finally</literal> block will be
executed <emphasis role="strong">whether or not</emphasis> any exception was thrown. A <literal>finally</literal> block is
often used with file I/O to close the file, which should be closed
whether or not something went wrong in the process of reading it as we
demonstrate in ChapterÂ <xref linkend="chapter:File_I/O"/></simpara>
<simpara>The <literal>finally</literal> keyword is unusually powerful. If an exception is not
caught and propagates up another level, the <literal>finally</literal> block will be
executed before propagating the exception. Even a <literal>return</literal> statement
will wait for a <literal>finally</literal> block to be executed before returning, leading
to the following bizarre possibility.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static boolean neverTrue() {
    try {
        return true;
    }
    finally {
        return false;
    }
}</programlisting>
<simpara>This method attempts to return <literal>true</literal>, but before it can finish, the
<literal>finally</literal> block returns <literal>false</literal>. Only one value can be returned, and the
<literal>finally</literal> block wins. You should be aware of <literal>finally</literal> blocks and their
unusual semantics. Use them sparingly and only for careful cleanup
operations when necessary to guarantee that some event occurs.</simpara>
<simpara>Code in a <literal>finally</literal> block will execute <emphasis role="strong">no matter what</emphasis> unless the JVM
exits or the thread in question terminates.</simpara>
</section>
<section xml:id="_customized_exceptions">
<title>Customized exceptions</title>
<simpara>Exceptions are incredibly useful when dealing with problems encountered
by API code. In those cases, your code must merely catch exceptions
defined by someone else; however, it is sometimes useful to define your
own exceptions. For one thing, you may write an API yourself. Generally,
you will want to use the standard exceptions whenever possible, but your
code may generate some unusual or very specific error condition that you
want to communicate to a programmer using your own exception.</simpara>
<simpara>Defining a new exception is surprisingly simple. All you have to do is
write a class that extends <literal>Exception</literal>. Theoretically, you could
alternately extend <literal>RuntimeException</literal> or <literal>Error</literal>, but you typically will
not. Children of <literal>RuntimeException</literal> are intended to indicate a bug in
the program and children of <literal>Error</literal> are intended to indicate a system
error. When creating your new exception, you don&#8217;t even have to create
any methods, but it is wise to implement a default constructor and one
that takes a <literal>String</literal> as an additional message.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class EndOfWorldException extends Exception {
    public EndOfWorldException() {}

    public EndOfWorldException( String message ) {
        super( message );
    }
}</programlisting>
<simpara>As with all other classes, your exceptions should be named in a readable
way. This exception is apparently thrown when the world ends. It is
considered good style to end the name of any exception class with
<literal>Exception</literal>. An exception class is a fully fledged class. If you need to
add other fields or methods to give your exception the functionality it
needs, go ahead. However, the main value of an exception is simply in
its existence as a named error, not in any tricks it can perform.</simpara>
<simpara>Here we will give a few examples of exception handling, although
exceptions are more useful in large systems with heavy API use. We will
start with an example of a simple calculator that detects division by
zero, then look at exceptions as a tool to detect array bounds problems,
and end with a custom exception used with the <literal>Color</literal> class.</simpara>
<example>
<title>Calculator with division by zero</title>
<simpara>Here we will implement a quick calculator that reads input from the user
in the form of <emphasis role="strong">integer</emphasis> <emphasis role="strong">operator</emphasis> <emphasis role="strong">integer</emphasis>, where <emphasis role="strong">operator</emphasis> is one
of the four basic arithmetic operators (<literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal>). Our code
will perform the appropriate operation and output the answer, but we
will use exception handling to avoid killing the program when a division
by zero occurs.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class QuickCalculator {
	public static void main(String[] args){
		Scanner in = new Scanner(System.in);
		int a, b, answer = 0;
		char operator;
		String[] terms;
		String line = in.nextLine().trim().toLowerCase();
		while( !line.equals("quit") ) {
			terms = line.split(" ");
			a = Integer.parseInt(terms[0]);
			operator = terms[1].charAt(0);
			b = Integer.parseInt(terms[2]);</programlisting>
<simpara>By this point, the <literal>main()</literal> method has set up a system to read a line of
input from a user, test to see if it is the sentinel value <literal>"quit"</literal>, and
then parsing it into two <literal>int</literal> values and a <literal>char</literal> otherwise.</simpara>
<programlisting language="java" linenumbering="numbered">			try{
				switch( operator ) {
					case '+': answer = a + b; break;
					case '-': answer = a - b; break;
					case '*': answer = a * b; break;
					case '/': answer = a / b; break;
				}
				System.out.println("Answer: " + answer);
			}
			catch( ArithmeticException e ) {
				System.out.println("You can't divide by 0!");
			}
			line = in.nextLine().trim().toLowerCase();
		}
	}
}</programlisting>
<simpara>Here we have a <literal>try</literal> block enclosing the code where the operations
occur. Inside the <literal>switch</literal> statement, the code will blindly perform
addition, subtraction, multiplication, or division, depending on the
value of <literal>operator</literal>. Then, it will print the answer. However, if a
division by zero occurred, the execution would jump to the <literal>catch</literal> block
and print an appropriate message. This <literal>try</literal>-<literal>catch</literal> pair is situated
inside the loop so that the input will continue even if there was a
division by zero. We could achieve the same effect by using an <literal>if</literal>
statement to test if the divisor is zero, but our solution allows easy
extensions if there are other possible exceptions we want to catch.</simpara>
</example>
<example>
<title>Array bounds</title>
<simpara>Exceptions provide a lot of power. If we want, we can use the
<literal>ArrayOutOfBoundsException</literal> as a crutch when we don&#8217;t want to think
about the bounds of our array. Although this makes for an interesting
example, exceptions should not be used in Java to perform normal tasks.
This method takes in an array of <literal>int</literal> values and prints them all out.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void exceptionalArrayPrint( int[] array ) {
    try {
        int i = 0;
        while( true )
            System.out.print(array[i++] + " ");
    }
    catch(  ArrayIndexOutOfBoundsException e ) {}
}</programlisting>
<simpara>Although the <literal>while</literal> loop will run without stopping, the moment that <literal>i</literal>
reaches<?asciidoc-br?>
<literal>array.length</literal>, it will throw an <literal>ArrayIndexOutOfBoundsException</literal> when
it tries to access that element in <literal>array</literal>. Since we left the <literal>catch</literal>
block empty, nothing will happen, the method will return, and everything
will work fine. This example is a peculiar kind of laziness, indeed,
since a <literal>for</literal> loop could achieve the same effect with fewer lines of
code.</simpara>
<simpara>Programmers can be tempted to abuse exceptions in this way when a lot of
calculations are needed to determine the correct bounds. Consider a game
of Connect Four. To see if a player has won, the computer must examine
all horizontal, vertical, and diagonal possibilities for four in a row.
If the game board is represented as a 2D array, the programmer must be
careful to make sure that checking for four in a row does not access any
index greater than the last rows or column or smaller than 0.</simpara>
<simpara>The danger of using exceptions for these kinds of tasks has several
sources. First, the programmer may not deeply understand the problem and
may be careless about the solution. Second, there is a risk of hiding
real exceptions that are generated because of real errors. Third, the
code becomes difficult to read and unintuitive. Finally, excessive use
of exceptions can negatively impact performance.</simpara>
</example>
<example>
<title>Color ranges</title>
<simpara>The <literal>Color</literal> class provided by Java allows us to represent a color as a
triple of red, green, and blue values with each value in the range
<inlineequation><alt><![CDATA[[0,255]]></alt><mathphrase><![CDATA[[0,255]]></mathphrase></inlineequation>]. Using these three components, we can produce
<inlineequation><alt><![CDATA[256^3 = 16,777,216]]></alt><mathphrase><![CDATA[256^3 = 16,777,216]]></mathphrase></inlineequation> colors. If we were programming some
image manipulation software, we might want to be able to increase the
red, green, or blue values separately. If changing a value makes it
larger than 255, we could throw an exception. Likewise, if changing a
value makes it less than 0, we could throw a different exception. Let&#8217;s
give two custom exceptions that could serve in these roles.</simpara>
<programlisting xml:id="program:ColorUnderflowException" xreflabel="ColorUnderflowException" language="java" linenumbering="numbered">public class ColorUnderflowException extends Exception {
	public ColorUnderflowException( String message ) {
		super( message );
	}
	public ColorComponentTooSmallException() { super(); }
}</programlisting>
<programlisting xml:id="program:ColorOverflowException" xreflabel="ColorOverflowException" language="java" linenumbering="numbered">public class ColorOverflowException extends Exception {
	public ColorOverflowException( String message ) {
		super( message );
	}
	public ColorOverflowException() { super(); }
}</programlisting>
<simpara>Now we can write six methods, each of which increases or decreases the
red, green, or blue component of a <literal>Color</literal> object by 5. If the value of
the component is out of range, an appropriate exception will be thrown.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static Color increaseRed( Color color )
    throws ColorOverflowException {
    if( color.getRed() + 5 &gt; 255 )
        throw new ColorOverflowException("Red: "
            + (color.getRed() + 5));
    else
        return new Color( color.getRed() + 5, color.getGreen(),
            color.getBlue() );
}

public static Color increaseGreen( Color color )
    throws ColorOverflowException {
    if( color.getGreen() + 5 &gt; 255 )
        throw new ColorOverflowException("Green: "
            + (color.getGreen() + 5));
    else
        return new Color( color.getRed(), color.getGreen() + 5,
            color.getBlue() );
}

public static Color increaseBlue( Color color )
    throws ColorOverflowException {
    if( color.getBlue() + 5 &gt; 255 )
        throw new ColorOverflowException("Blue: "
            + (color.getBlue() + 5));
    else
        return new Color( color.getRed(), color.getGreen(),
            color.getBlue() + 5 );
}

public static Color decreaseRed( Color color ) throws ColorUnderflowException {
    if( color.getRed() - 5 &lt; 0 )
        throw new ColorUnderflowException("Red: "
            + (color.getRed() - 5));
    else
        return new Color( color.getRed() - 5,
            color.getGreen(), color.getBlue() );
}

public static Color decreaseGreen( Color color )
    throws ColorUnderflowException {
    if( color.getGreen() - 5 &lt; 0 )
        throw new ColorUnderflowException("Green: "
            + (color.getGreen() - 5));
    else
        return new Color( color.getRed(), color.getGreen() - 5,
            color.getBlue() );
}

public static Color decreaseBlue( Color color )
    throws ColorUnderflowException {
    if( color.getBlue() - 5 &lt; 0 )
        throw new ColorUnderflowException("Blue: "
            + (color.getBlue() - 5));
    else
        return new Color( color.getRed(), color.getGreen(),
            color.getBlue() - 5 );
}</programlisting>
<simpara>Finally, we can write a short method that changes a given color based on
user input and deals with exceptions appropriately.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static Color changeColor( Color color ) {
    System.out.println("Enter 'R', 'G', or 'B' to increase " +
        "the amount of red, green, or blue in your color. " +
        "Enter 'r', 'g', or 'b' to decrease the amount of " +
        "red, green, or blue in your color.");
        Scanner in = new Scanner( System.in );
    try {
        switch( in.next().trim().charAt(0) ) {
            case 'R': color = increaseRed( color ); break;
            case 'G': color = increaseGreen( color ); break;
            case 'B': color = increaseBlue( color ); break;
            case 'r': color = decreaseRed( color ); break;
            case 'g': color = decreaseGreen( color ); break;
            case 'b': color = decreaseBlue( color ); break;
        }
    }
    catch( ColorOverflowException e ) {
        System.out.println( e );
    }
    catch( ColorUnderflowException e ) {
        System.out.println( e );
    }
    return color;
}</programlisting>
<simpara>The code that uses these methods and exceptions is compact. One <literal>try</literal>
block enclosing the method calls is needed so that the exceptions can be
caught. Following the <literal>try</literal>, there is a <literal>catch</literal> block for the
<literal>ColorOverflowException</literal> and one for the <literal>ColorUnderflowException</literal>. Each
will print out its exception, including the customized message inside.
If an exception occurred, the value of <literal>color</literal> would remain unchanged
because execution would have jumped to a <literal>catch</literal> block before the
assignment could happen.</simpara>
</example>
</section>
</section>
<section xml:id="_solution_bank_burglary">
<title>Solution: Bank burglary</title>
<simpara>Here is our solution to the bank burglary problem. Although somewhat
fanciful, the process could be expanded into a more serious simulation.
We begin by defining each of the exceptions.</simpara>
<programlisting xml:id="program:BurglarAlarmException" xreflabel="BurglarAlarmException" language="java" linenumbering="numbered">public class BurglarAlarmException extends Exception {
	public BurglarAlarmException( String message ) {
		super( message );
	}
	public BurglarAlarmException() { super(); }
}</programlisting>
<programlisting xml:id="program:WatchmanException" xreflabel="WatchmanException" language="java" linenumbering="numbered">public class WatchmanException extends Exception {
	public WatchmanException( String message ) {
		super( message );
	}
	public WatchmanException() { super(); }
}</programlisting>
<programlisting xml:id="program:LockPickFailException" xreflabel="LockPickFailException" language="java" linenumbering="numbered">public class LockPickFailException extends Exception {
	public LockPickFailException( String message ) {
		super( message );
	}
	public LockPickFailException() { super(); }
}</programlisting>
<programlisting xml:id="program:LootTooHeavyException" xreflabel="LootTooHeavyException" language="java" linenumbering="numbered">public class LootTooHeavyException extends Exception {
	public LootTooHeavyException( String message ) {
		super( message );
	}
	public LootTooHeavyException() { super(); }
}</programlisting>
<simpara>Note that the default constructor for each exception is necessary, since
constructors taking a <literal>String</literal> value are provided for each class.
Although these default constructors do nothing other than call their
parent constructor, they are needed so that it is possible to create
each of these contructors <emphasis role="strong">without</emphasis> a customized message.</simpara>
<simpara>With the exceptions defined, we can assume that the <literal>Bank</literal> class and the
<literal>Vault</literal> class throw the appropriate exceptions when something goes
wrong. Thus, we can make a `Henchman`class who can try to do the heist
and react appropriately if there is a problem.</simpara>
<programlisting language="java" linenumbering="numbered">public class Henchman {
	public void burgle( Bank bank ) {
		try {
			bank.disableAlarm();
			bank.breakIn();
			Vault vault = bank.findVault();

			vault.open();
			Loot loot = vault.getLoot();
			loot.carryAway();

			System.out.println("We got " + loot + "!");
		}</programlisting>
<simpara>To burgle a bank, one must create a <literal>Henchman</literal> object then pass a <literal>Bank</literal>
object into its <literal>burgle()</literal> method. The method will try to disable the
alarm, break into the bank, find the vault, open the vault, get the loot
out of the vault, and carry it away. If all those steps happen
successfully, the method will print out a <literal>String</literal> version of the loot.
All of this code is inside of a <literal>try</literal> block. If an exception is thrown
at any point, the following <literal>catch</literal> blocks will deal with it.</simpara>
<programlisting language="java" linenumbering="numbered">		catch( BurglarAlarmException e ) {
			System.out.println("I set off the burglar because "
					+ e.getMessage());
			System.out.println("I had to run away.");
		}
		catch( WatchmanException e ) {
			System.out.println("A watchman caught me because "
					+ e.getMessage());
			System.out.println("Please bail me out of jail.");
		}
		catch( LockPickFailException e ) {
			System.out.println("I couldn't pick the vault lock.");
			System.out.println("No loot for us.");
		}
		catch( LootTooHeavyException e ) {
			System.out.println("The loot was too heavy to carry.");
			System.out.println("No loot for us.");
		}
		catch( NullPointerException e ) {
			System.out.println("The vault was hidden or empty.");
			System.out.println("No loot for us.");
		}
	}
}</programlisting>
<simpara>If a <literal>BurglarAlarmException</literal> happens, the henchman is forced to run
away. If a <literal>WatchmanException</literal> happens, the henchman is caught and must
be bailed out of jail. If a <literal>LockPickFailException</literal> or
<literal>LootTooHeavyException</literal> happens, the henchman is unable to carry the
loot off.</simpara>
<simpara>The last <literal>catch</literal> block is a little unusual. In this case, a
<literal>NullPointerException</literal> has occurred. Within the <literal>try</literal> block, two obvious
sources of this exception are the <literal>vault</literal> and the <literal>loot</literal> variables. If
either of them were <literal>null</literal>, in the case of a vault that could not be
found or a vault that was empty, trying to call a method on that <literal>null</literal>
reference would throw a <literal>NullPointerException</literal>. Although this code shows
the power of exception handling, it is a little unwieldy since we do not
know which variable was <literal>null</literal>. Also, we will hide any
<literal>NullPointerException</literal> that might have for other reasons. A better
solution would be to check for each of these <literal>null</literal> cases or create more
specific exceptions thrown by <literal>findVault()</literal> and <literal>getLoot()</literal> if either
returns <literal>null</literal>.</simpara>
</section>
<section xml:id="_concurrency_exceptions">
<title>Concurrency: Exceptions</title>
<simpara>Any thread in Java can throw an exception. That thread might be the main
thread or it might be an extra one that you spawned yourself. (Or even
one spawned behind the scenes through a library call.)</simpara>
<simpara>What happens when a thread throws an exception? As we have been
discussing in this chapter, the exception will either be caught or
passed on to its caller. If the exception is caught, the <literal>catch</literal> block
determines what happens. If the exception is passed up and up and up and
never caught, then what? If you have coded some of the examples in this
chapter, you might think the entire program crashes, but only the thread
throwing the exception dies.</simpara>
<example>
<title>Multiple threads with exceptions</title>
<simpara>In a program with a single thread, an exception thrown by the <literal>main()</literal>
method will crash the program, completely halting execution. In a
multi-threaded program, execution will continue on all threads that have
not thrown exceptions. If even a single thread is executing, the program
will run to completion before the JVM shuts down.</simpara>
<formalpara xml:id="program:CrazyThread" xreflabel="CrazyThread">
<title>This program spawns 10 threads. 9 out of 10 spawned threads as well as the main thread throw an exception and die. The remaining thread outputs the sum of the sines of 1 through 1,000,000.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class CrazyThread extends Thread {
	private int value;
	public static void main(String[] args) {
		for( int i = 0; i &lt; 10; i++ )
			new CrazyThread( i ).start();
		throw new RuntimeException();
	}

	public CrazyThread( int value ) {
		this.value = value;
	}

	public void run() {
		if( value == 7 ) {
			double sum = 0;
			for( int i = 1; i &lt;= 1000000; i++ )
				sum += Math.sin(i);
			System.out.println("Sum: " + sum);
		}
		else
			throw new RuntimeException();
	}
}</programlisting>
</para>
</formalpara>
<simpara>In the program given above, all of the threads except one will die
because of the<?asciidoc-br?>
<literal>RuntimeException</literal> that they throw. Note that we use the unchecked
<literal>RuntimeException</literal> so that Java does not complain about the lack of
<literal>catch</literal> blocks. The thread with a <literal>value</literal> of 7 will complete its
calculation and print it to the screen even though the main thread has
died. For more information on how to spawn threads, refer to
ChapterÂ <xref linkend="chapter:Concurrent_Programming"/>.</simpara>
</example>
<simpara>This behavior can cause a program that never seems to finish. You might
write a program that spawns a number of threads and does some work. Even
if the <literal>main()</literal> method has completed and all the important data has been
output, the program will not terminate if any threads are still alive.
This problem can also be caused by creating a GUI (such as a <literal>JFrame</literal>),
which spawns one or more threads indirectly, if the GUI is not properly
disposed.</simpara>
<section xml:id="_literal_interruptedexception_literal">
<title><literal>InterruptedException</literal></title>
<simpara>In conjunction with concurrency, one exception deserves special
attention:<?asciidoc-br?>
<literal>InterruptedException</literal>. This exception can happen when a thread calls
<literal>wait()</literal>, <literal>join()</literal>, or <literal>sleep()</literal>. It is a checked exception, requiring
either a <literal>catch</literal> block or a <literal>throws</literal> declaration.</simpara>
<simpara>This exception is used in cases where the executing thread must wait for
some event to occur or some time to pass. In extreme circumstances,
another thread can interrupt the waiting thread, forcing it to continue
executing before it&#8217;s done waiting. If that happens, the code in the
<literal>catch</literal> block determines how the thread should recover from being woken
prematurely.</simpara>
<simpara>Programmers who are new to concurrency in Java are often confused or
annoyed by<?asciidoc-br?>
<literal>InterruptedException</literal>, particularly since it never seems to be thrown.
Although it is thrown rarely, situations such as a system shutting down
may be best dealt with by calling <literal>interrupt()</literal> on a waiting thread,
causing such an exception. Although we will generally leave the
<literal>InterruptedException</literal> <literal>catch</literal> block empty in this book, threads written
for production code should always handle interruptions gracefully.</simpara>
</section>
</section>
<section xml:id="_exercises_11">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:exceptions_vs._error_codes"/> What are the advantages of
using exceptions instead of returning error codes?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:final_and_finally"/> The keywords <literal>final</literal> and <literal>finally</literal>,
as well as the <literal>Object</literal> method <literal>finalize()</literal>, are sometimes confused.
What is the purpose of each one?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:throws_keyword"/> What is the difference between the
<literal>throw</literal> keyword and the <literal>throws</literal> keyword?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:catch_or_specify"/> Explain the catch or specify
requirement of Java.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:checked_vs._unchecked"/> What must be done differently
when using methods that throw checked exceptions as compared to
unchecked exceptions? How do the classes <literal>Exception</literal>,<?asciidoc-br?>
<literal>RuntimeException</literal>, and <literal>Error</literal> play a role?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:whole_program_in_try"/> For every program you write, you
could choose to put the entire body of your <literal>main()</literal> method in a large
<literal>try</literal> block with a <literal>catch</literal> block at the end that catches <literal>Exception</literal>. In
this way, no exception would cause your program to crash. Why is this
approach a bad programming decision?</simpara>
</listitem>
<listitem>
<simpara>Why did the designers of Java choose to make <literal>NullPointerException</literal>
and<?asciidoc-br?>
<literal>ArithmeticException</literal> unchecked exceptions even though this choice means
that a program that unintentionally dereferences a <literal>null</literal> pointer or
divides by zero will often crash.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:checked_example"/> Consider the following two classes.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Trouble {
    public makeTrouble() {
        throw new ArithmeticException();
    }
}

public class Hazard {
    public makeHazard() {
        throw new InterruptedException();
    }
}</programlisting>
<simpara>Class <literal>Trouble</literal> will compile, but class <literal>Hazard</literal> will not. Explain why
and what could be done to make <literal>Hazard</literal> compile.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:finally_returns"/> What value will the following method
always return and why?</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int magic( String value ) {
    try {
        int x = Integer.parseInt( value );
        return x;
    }
    catch( Exception e ) {
        System.out.println("Some exception occurred.");
        return 0;
    }
    finally {
        return -1;
    }
}</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:specific_exceptions_first"/> Why will the following
segment of code fail to compile?</simpara>
<programlisting language="java" linenumbering="unnumbered">try{
    Thread.sleep(1000);
}
catch( Exception e ) {
    System.out.println("Exception occurred!");
}
catch( InterruptedException e ) {
    System.out.println("Woke up early!");
}</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:multiple_exceptions"/> Consider the following fragment of
Java.</simpara>
<programlisting language="java" linenumbering="unnumbered">try {
    throw new NullPointerException();
}
finally {
    throw new ArrayIndexOutOfBoundsException();
}</programlisting>
<simpara>This code is legal Java. It is possible to have a <literal>finally</literal> block after
a <literal>try</literal> block without any <literal>catch</literal> blocks between them. However, only a
single exception can be active at once. Which exception will propagate
up from this code and why?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>The <xref linkend="exercise:calculator_exceptions"/> <literal>NumberFormatException</literal>
exception is thrown whenever the<?asciidoc-br?>
<literal>Integer.parseInt()</literal> method receives a poorly formatted <literal>String</literal>
representation of an integer. Re-implement <literal>QuickCalculator</literal> to catch
any <literal>NumberFormatException</literal> and give an appropriate message to the user.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:celestial_exceptions"/> Refer to
ExerciseÂ <xref linkend="exercise:celestial"/> from ChapterÂ <xref linkend="chapter:Inheritance"/>.
Add to the basic mechanics of the simulation by designing two custom
exceptions, <literal>CollisionException</literal> and <literal>LightSpeedException</literal>. These
exceptions should be thrown, respectively, if two bodies collide or if
the total magnitude of a body&#8217;s velocity exceeds the speed of light.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:password_checker"/> Users often log onto systems by
entering their user name and a password. Unfortunately, human beings are
notoriously bad at picking passwords. In computer security, a tool
called a <emphasis>proactive password checker</emphasis> allows a user to pick a password
but rejects the choice if it doesn&#8217;t meet certain criteria.</simpara>
<simpara>Common criteria for a password are that it must be at least a certain
length, must contain must contain uppercase and lowercase letters, must
contain numerical digits, must contain symbols, cannot be the same as a
list of words from a dictionary, and others.</simpara>
<simpara>Write a short program with a <literal>check()</literal> method that takes a single
<literal>String</literal> parameter giving a possible password. This method should throw
an exception if the password does not meet the matching criteria listed
below.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="middle">Password criteria</entry>
<entry align="left" valign="middle">Exception</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>At least 8 characters in length</simpara></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">TooShortException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Contains both upper- and lowercase letters</simpara></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">NoMixedCaseException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Contains at least one numerical digit</simpara></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">NoDigitException</literallayout></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Contains at least one symbol</simpara></entry>
<entry align="left" valign="middle"><literallayout class="monospaced">NoSymbolException</literallayout></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Your <literal>main()</literal> method should prompt the user to select a password and
then pass it to the <literal>check()</literal> method. If the method throws an exception,
you should catch it and print an appropriate error message. Otherwise,
you should report to the user that the password is acceptable. Note that
you will need to define each of the four exceptions as well.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Throwing <xref linkend="exercise:exception_performance"/> and catching exceptions
is a useful tool for making robust programs in Java. However, the JVM
machinery needed to implement such a powerful tool is complex. Create an
array containing 100,000 random <literal>int</literal> values. First, sum all these
variables up using a <literal>for</literal> loop and time how long it takes. Then, do the
same thing, but, inside of the <literal>for</literal> loop, put a <literal>try</literal> block containing
a simple division by zero instruction such as <literal>x = 5 / 0;</literal>. After the
<literal>try</literal> block, put a <literal>catch</literal> block catching an<?asciidoc-br?>
<literal>ArithmeticException</literal>. Time this version of the code. Again, you may
wish to use <literal>System.nanoTime()</literal> to measure the time accurately. Was
there a large difference in the time taken? Do your findings have any
implications for code that routinely throws thousands of exceptions?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Concurrent_Programming">
<title>Concurrent Programming</title>
<blockquote>
<attribution>
Jorge Luis Borges
</attribution>
<simpara>Time is the substance from which I am made. Time is a river which carries me along, but I am
the river; it is a tiger that devours me, but I am the tiger; it is a fire that consumes me, but I am
the fire.</simpara>
</blockquote>
<section xml:id="_introduction_2">
<title>Introduction</title>
<simpara>So far we have focused mostly on writing sequential programs. Such
programs are executed sequentially by a computer. Sequential execution
implies that program statements are executed one at a time in a sequence
determined by program logic and input data. While it is common for
programmers to write sequential programs, the widespread availability of
multicore processors in a single computer has led to an increase in the
demand for programmers who can write <emphasis>concurrent</emphasis> programs. More than
one program statement can be executed independently by a multicore
processor.</simpara>
<simpara>A concurrent program is one in which several statements can be executed
simultaneously by two or more cores. In this chapter we show how to
write simple concurrent programs in Java that exploit the power of a
multicore computer. We begin with an example in which the fate of the
planet is in grave danger!</simpara>
</section>
<section xml:id="_problem_deadly_virus">
<title>Problem: Deadly virus</title>
<simpara>A deadly virus capable of wiping out the world&#8217;s population is about to
be released by an evil mastermind. Only he knows the security code that
can stop the countdown. The world is doomed. The single hope for
salvation lies with you and your Java programming skills. Through the
investigations of a top secret, government-funded spy ring, it has been
revealed that the security code is tied to the number
59,984,005,171,248,659. This large number is the product of two prime
numbers, and the security code is their sum. All you need to do is
factor the number 59,984,005,171,248,659 into its two prime factors.</simpara>
<simpara>Of course, there is a catch. The deadly virus is going to be released
soon, so soon that there might not be enough time for your computer to
search through all the numbers one by one. Instead, you must use
concurrency to check more than one number at a time.</simpara>
<simpara>Does this problem sound contrived? To keep information sent over the
Internet private, some kinds of public key cryptography rely on the
difficulty of factoring large numbers. Although factoring the number in
this problem is not difficult, the numbers used for public key
cryptography, typically more than 300 decimal digits long, have resisted
factorization by even the fastest computers.</simpara>
</section>
<section xml:id="_concepts_splitting_up_work">
<title>Concepts: Splitting up work</title>
<simpara>The deadly virus problem has one large task (factoring a number) to
perform. How should we split up this task so that we can do it more
quickly? Splitting up the work to be done is at the heart of any
concurrent solution to a problem.</simpara>
<simpara>In a multicore processor, each core is an independent worker. It takes
some care to coordinate these workers. First of all, we still need to
get the right answer. A concurrent solution is worthless if it is
incorrect, and by reading and writing to the same shared memory, answers
found by one core can corrupt answers found by other cores. Preventing
that problem will be addressed in ChapterÂ <xref linkend="chapter:Synchronization"/>.
If we are sure the concurrent solution is correct, we also want to
improve performance in some way. Perhaps we want the task to finish more
quickly. Perhaps we have an interactive system that should continue to
handle user requests even though it is working on a solution in the
background. Again, if the overhead of coordinating our workers takes
more time than a sequential solution or makes the system less
responsive, it is not useful.</simpara>
<simpara>There are two main ways to split up work. The first is called <emphasis>task
decomposition</emphasis>. In this approach, each worker is given a different job
to do. The second is called <emphasis>domain decomposition</emphasis>. In this approach,
the workers do the same job, but to different data.</simpara>
<simpara>It is possible to use both task and domain decomposition together to
solve the same problem. With both kinds of decomposition, it is usually
necessary to coordinate the workers so that they can share information.
In the next two subsections, we describe task decomposition and domain
decomposition in greater depth. Then we discuss mapping tasks to threads
of execution and the different memory architectures that can be used for
concurrent programming.</simpara>
<section xml:id="_task_decomposition">
<title>Task decomposition</title>
<simpara>The idea of breaking a task down into smaller subtasks is a natural one.
Imagine you are planning a dinner party. You need to buy supplies, cook
the dinner, clean your house, and set the table. If four of you were
planning the party, each could perform a separate activity. The
preparations could go much faster than if a single person was doing the
work, but coordination is still important. Perhaps the person cooking
the dinner couldn&#8217;t finish until certain supplies had been bought.</simpara>
<simpara>Task decomposition is often easier than domain decomposition because
many tasks have natural divisions. Unfortunately, it is not always an
effective way to use multiple cores on a computer. If one task finishes
long before the others, a core might sit idle.</simpara>
<simpara>The next two examples give simple illustrations of the process of
splitting a task into smaller subtasks in the context of multicore
programming.</simpara>
<example>
<title>Video game tasks</title>
<simpara>Consider a simple video game that consists of the following tasks.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>start game</simpara>
</listitem>
<listitem>
<simpara>process move</simpara>
</listitem>
<listitem>
<simpara>update score</simpara>
</listitem>
<listitem>
<simpara>repaint screen</simpara>
</listitem>
<listitem>
<simpara>end game</simpara>
</listitem>
</orderedlist>
<figure role="text-center">
<title>Execution of tasks in a video game. (a) Sequential execution on a single core. (b)Â Concurrent execution on two cores. Arrows show the flow of execution and data transfer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/video-game-tasks.svg" width="75%"/>
</imageobject>
<textobject><phrase>video game tasks</phrase></textobject>
</mediaobject>
</figure>
<simpara>Suppose that tasks B and D are independent and can be executed
concurrently if two cores are available. Task D continually updates the
screen with the old data until task C updates the information.</simpara>
<simpara>FigureÂ <xref linkend="figure:video_game_tasks"/>(a) and (b) show how the tasks in this
video game can be sequenced, respectively, on a single core or on two
cores. All tasks are executed sequentially on a single-core processor.
In a dual-core processor tasks B and C can execute on one core while
task D is executing concurrently on another. Note from the figure that
task C sends the score and any other data to task D which is
continuously updating the screen. Having two cores can allow a faster
refresh of the display as the processor does not have to wait for tasks
B or C to complete.</simpara>
</example>
<example>
<title>Math expression tasks</title>
<simpara>Suppose that the following mathematical expression is to be evaluated
for parameters <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[K]]></alt><mathphrase><![CDATA[K]]></mathphrase></inlineequation> at a given value of
<inlineequation><alt><![CDATA[t]]></alt><mathphrase><![CDATA[t]]></mathphrase></inlineequation>.
<inlineequation><alt><![CDATA[2\cdot K\cdot a\cdot t\cdot e^{-a\cdot t^2}]]></alt><mathphrase><![CDATA[2\cdot K\cdot a\cdot t\cdot e^{-a\cdot t^2}]]></mathphrase></inlineequation> We can
divide the expression into two terms:
<inlineequation><alt><![CDATA[2\cdot K\cdot a\cdot t]]></alt><mathphrase><![CDATA[2\cdot K\cdot a\cdot t]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[e^{-a\cdot t^2}]]></alt><mathphrase><![CDATA[e^{-a\cdot t^2}]]></mathphrase></inlineequation>.
Each of these terms can be assigned to a different task for evaluation.
On a dual-core processor, these two tasks can be executed on separate
cores and the results from each combined to generate the value of the
expression by the main task.</simpara>
<figure role="text-center">
<title>Evaluation of a mathematical expression (a) sequentially on a single core and (b) concurrently on two cores. Arrows show the flow of execution and data transfer. Bold typeface indicates the operation being performed.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/mathematical-expression-evaluation.svg" width="75%"/>
</imageobject>
<textobject><phrase>mathematical expression evaluation</phrase></textobject>
</mediaobject>
</figure>
<simpara>FigureÂ <xref linkend="figure:math_evaluation"/> shows how this expression can be
evaluated on single core and dual-core processors. Sometimes, using
multiple cores to evaluate an expression like this will take less time
than a single core. However, there is no guarantee that using multiple
cores will always be faster, because tasks take time to set up and to
communicate with each other.</simpara>
</example>
<simpara>These examples illustrate how a task can be divided into two or more
subtasks executed by different cores of a processor. We use a dual-core
processor for our examples, but the same ideas can be expanded to a
larger number of cores.</simpara>
</section>
<section xml:id="_domain_decomposition">
<title>Domain decomposition</title>
<simpara>In a computer program, every task performs operations on data. This data
is called the <emphasis>domain</emphasis> of that task. In domain decomposition, the data
is divided into smaller chunks where each chunk is assigned to a
different core, instead of dividing a task into subtasks. Each core
executes the same task but on different data.</simpara>
<simpara>In the example of the dinner party, we could have used domain
decomposition instead of (or in addition to) task decomposition. If you
want to cook a massive batch of mashed potatoes, you could peel 24
potatoes yourself. However, if there are four of you (and you each have
a potato peeler), each person would only need to peel 6 potatoes.</simpara>
<simpara>The strategy of domain decomposition is very useful and is one of the
major focuses of concurrency in this book. Problems in modern computing
often use massive data, comprising millions of numbers or thousands of
database records. Writing programs that can chop up data so that
multiple cores can process smaller sections of it can greatly speed up
the time it takes to finish computing a solution.</simpara>
<simpara>Domain decomposition can be more difficult than task decomposition. The
data must be divided evenly and fairly. Once each section of data has
been processed, the results must be combined. Companies like Google that
process massive amounts of information have developed terminology to
describe this process. Dividing up the data and assigning it to workers
is called the <emphasis>map</emphasis> step. Combining the partial answers into the final
answer is called the <emphasis>reduce</emphasis> step.</simpara>
<simpara>We illustrate the domain decomposition strategy in the next two
examples.</simpara>
<example>
<title>Array summation preview</title>
<simpara>Suppose that we want to apply function <inlineequation><alt><![CDATA[f()]]></alt><mathphrase><![CDATA[f()]]></mathphrase></inlineequation> to each element
of an array <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and sum the results. Mathematically, we want
to compute the following sum.</simpara>
<simpara><inlineequation><alt><![CDATA[S=\sum_{i=1}^N f\left(a(i)\right)]]></alt><mathphrase><![CDATA[S=\sum_{i=1}^N f\left(a(i)\right)]]></mathphrase></inlineequation></simpara>
<simpara>In this formula, <inlineequation><alt><![CDATA[a(i)]]></alt><mathphrase><![CDATA[a(i)]]></mathphrase></inlineequation> is the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript> element
of array <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation>. We want to perform the task of applying
function <inlineequation><alt><![CDATA[f()]]></alt><mathphrase><![CDATA[f()]]></mathphrase></inlineequation> to each element in the array and summing the
result. Let&#8217;s assume that we have a dual-core processor available to
compute the sum. We split up the array so that each core performs the
task on half of the array. Let <inlineequation><alt><![CDATA[S_1]]></alt><mathphrase><![CDATA[S_1]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[S_2]]></alt><mathphrase><![CDATA[S_2]]></mathphrase></inlineequation>
denote the sums computed by core 1 and core 2, respectively.</simpara>
<simpara><inlineequation><alt><![CDATA[S_1 =\sum_{i=1}^{\lfloor \frac{N}{2}\rfloor } f\left(a(i)\right)\hspace{.75in}
S_2 =\sum_{i=\lfloor \frac{N}{2} \rfloor +1}^{N} f\left(a(i)\right)]]></alt><mathphrase><![CDATA[S_1 =\sum_{i=1}^{\lfloor \frac{N}{2}\rfloor } f\left(a(i)\right)\hspace{.75in}
S_2 =\sum_{i=\lfloor \frac{N}{2} \rfloor +1}^{N} f\left(a(i)\right)]]></mathphrase></inlineequation></simpara>
<simpara>Assuming that <inlineequation><alt><![CDATA[N]]></alt><mathphrase><![CDATA[N]]></mathphrase></inlineequation> is even, both cores process exactly the
same amount of data. For odd <inlineequation><alt><![CDATA[N]]></alt><mathphrase><![CDATA[N]]></mathphrase></inlineequation>, one of the cores processes
one more data item than the other.</simpara>
<figure role="text-center">
<title>Computing the sum of a function of each element of an array.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/arrayDecomposition.svg" width="60%"/>
</imageobject>
<textobject><phrase>arrayDecomposition</phrase></textobject>
</mediaobject>
</figure>
<simpara>After <inlineequation><alt><![CDATA[S_1]]></alt><mathphrase><![CDATA[S_1]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[S_2]]></alt><mathphrase><![CDATA[S_2]]></mathphrase></inlineequation> have been computed, one of
the cores can add these two numbers together to get <inlineequation><alt><![CDATA[S]]></alt><mathphrase><![CDATA[S]]></mathphrase></inlineequation>.
This strategy is illustrated in FigureÂ <xref linkend="figure:array_decomposition"/>.
After the two cores have completed their work on each half of the array,
the individual sums are added together to produce the final sum.</simpara>
</example>
<example>
<title>Matrix multiplication preview</title>
<simpara>The need to multiply matrices arises in many mathematical, scientific,
and engineering applications. Suppose we are asked to write a program to
multiply two square matrices <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation>, which
are both <inlineequation><alt><![CDATA[n\times n]]></alt><mathphrase><![CDATA[n\times n]]></mathphrase></inlineequation> matrices. The product matrix
<inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> will also be <inlineequation><alt><![CDATA[n\times n]]></alt><mathphrase><![CDATA[n\times n]]></mathphrase></inlineequation>. A sequential
program will compute each element of matrix <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> one at a
time. However, a concurrent program can compute more than one element of
<inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> simultaneously using multiple cores.</simpara>
<figure role="text-center">
<title>Data decomposition to multiply two <inlineequation><alt><![CDATA[4\times 4]]></alt><mathphrase><![CDATA[4\times 4]]></mathphrase></inlineequation> matrices. The two cores perform the same multiplication tasks but on different data from matrix <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation>. The two cores compute the top and bottom two rows of <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>, respectively.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/matrixDecomposition.svg" width="75%"/>
</imageobject>
<textobject><phrase>matrixDecomposition</phrase></textobject>
</mediaobject>
</figure>
<simpara>In this problem, the task is to multiply matrices <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation>. Through domain decomposition, we can replicate this
task on each core. As shown in FigureÂ <xref linkend="figure:matrix_decomposition"/>,
each core computes only a portion of <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>. For example, if
<inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation> are <inlineequation><alt><![CDATA[4\times 4]]></alt><mathphrase><![CDATA[4\times 4]]></mathphrase></inlineequation>
matrices, we can ask one core to compute the product of the first two
rows of <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> with all four columns of <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation> to
generate the first two rows of <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>. The second core computes
the remaining two rows of <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>. Both cores can access
matrices <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation>.</simpara>
</example>
</section>
<section xml:id="_tasks_and_threads">
<title>Tasks and threads</title>
<simpara>It is the programmer&#8217;s responsibility to divide his or her solution into
a number of tasks and subtasks which will run on one or more cores on a
processor. In previous sections, we described concurrent programs as if
specific tasks could be assigned specific cores, but Java does not
provide a direct way to do so.</simpara>
<simpara>Instead, a Java programmer must group together a set of tasks and
subtasks into a <emphasis>thread</emphasis>. A thread is very much like a sequential
program. In fact, all sequential programs have only one thread. A thread
is a segment of executing code that runs through its instructions step
by step. Each thread can run independently. If you have a single core
processor, only one thread can run at a time, and all the threads will
take turns. If you have a multicore processor, as many threads as there
are cores can execute at the same time. You cannot pick which core a
given thread will run on. In most cases, you will not even be able to
tell which core a given thread is using.</simpara>
<simpara>Even though you cannot control which core a thread will use to execute,
it takes care to package up the right set of tasks into a single thread
of execution. Recall the previous examples of concurrent programming in
this chapter.</simpara>
<simpara>Consider dividing the tasks in ExampleÂ <xref linkend="example:Video_game_tasks"/> into
two threads. Tasks B and C in can be packaged into thread 1, and task D
can be packaged into thread 2. This division is shown in
FigureÂ <xref linkend="figure:tasks_in_threads"/>(a).</simpara>
<simpara>Tasks to evaluate different subexpressions in ExampleÂ <xref linkend="example:Math
expression tasks"/> can also be divided into two threads as shown in
FigureÂ <xref linkend="figure:tasks_in_threads"/>(b). In many problems there are
several reasonable ways of dividing a set of subtasks into threads.</simpara>
<simpara>Note that these figures look exactly like the earlier figures, except
that the tasks are grouped as threads instead of cores. This grouping is
matches reality better, since we can control how the tasks are packaged
into threads but not how they are assigned to cores.</simpara>
<simpara>In both examples, we have two threads. It is possible that some other
thread started these threads running. Every Java program, concurrent or
sequential, starts with one thread. We will refer to this thread as the
<emphasis>main</emphasis> thread since it contains the <literal>main()</literal> method.</simpara>
<simpara>Examples <xref linkend="example:Array_summation_preview"/> and <xref linkend="example:Matrix
multiplication preview"/> use multiple identical tasks. But these tasks
operate on different data. Nevertheless, in ExampleÂ <xref linkend="example:Array
summation preview"/>, the two tasks can be assigned two threads that
operate on different portions of the input array. The task of summing
the results from the two threads can either be a separate thread or a
subtask included in one of the other threads. In
ExampleÂ <xref linkend="example:Matrix_multiplication_preview"/>, the two tasks can
again be assigned to two distinct threads that operate on different
parts of the input matrix <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> to generate the corresponding
portions of the output matrix <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>.</simpara>
<figure>
<title>(a)Â Tasks in a video game shown packaged into two threads. (b) Tasks to evaluate a mathematical expression shown packaged into two threads. Each thread may or may not run on the same core as the other.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/task-thread-packaging.svg" width="100%"/>
</imageobject>
<textobject><phrase>task thread packaging</phrase></textobject>
</mediaobject>
</figure>
<simpara>There can be many ways to package tasks into threads. There can also be
many ways to decompose data into smaller chunks. The best ways to
perform these subdivisions of tasks or data depend on the problem at
hand and the processor architecture on which the program will be
executed.</simpara>
</section>
<section xml:id="_memory_architectures_and_concurrency">
<title>Memory architectures and concurrency</title>
<simpara>The two most important paradigms for concurrent programming are message
passing and shared memory systems. Each paradigm handles communication
between the various pieces of code running in parallel in a different
way. Message passing systems such as MPI and PVM approach this problem
by sending messages between otherwise independent pieces of code called
processes. A process which is executing a task may have to wait until it
receives a message from another process before it knows how to proceed.
Messages can be sent from a single process to a single other or
broadcast to many. Message passing systems are especially useful when
the processors doing the work do not share memory.</simpara>
<simpara>In contrast, Java uses the shared memory paradigm. In Java, a programmer
can create a number of threads which share the same memory space. Each
thread is an object which can perform work. We described threads as a
way to package up a group of tasks, and processes are another. People
use the term <emphasis>processes</emphasis> to describe executing sections of code with
separate memory and <emphasis>threads</emphasis> to describe executing sections of code
with shared memory.</simpara>
<simpara>When you first learned to program, one of the biggest challenges was
probably learning to solve a problem step by step. Each line of the
program had to be executed one at a time, logically and
deterministically. Human beings do not naturally think that way. We tend
to jump from one thing to another, making inferences and guesses,
thinking about two unrelated things at once, and so on. As you know well
by now, it is only possible to write and debug programs because of the
methodical way they work.</simpara>
<simpara>You can imagine the execution of a program as an arrow that points to
one line of code, then the next, then the next, and so on. We can think
of the movement of this arrow as the thread of execution of the program.
The code does the actual work, but the arrow keeps track of where
execution in the program currently is. The code can move the arrow
forward, it can do basic arithmetic, it can decide between choices with
<literal>if</literal> statements, it can do things repeatedly with loops, it can jump
into a method and then come back. A single thread of execution can do
all of these things, but it cannot be two places at once. It cannot both
be dividing two numbers in one part of the program and evaluating an
<literal>if</literal> statement in another. However, there is a way to split this thread
of execution so that two or more threads are executing different parts
of the program, and the next section will show you how it is done in
Java.</simpara>
</section>
</section>
<section xml:id="_syntax_threads_in_java">
<title>Syntax: Threads in Java</title>
<section xml:id="_the_literal_thread_literal_class">
<title>The <literal>Thread</literal> class</title>
<simpara>Java, like many programming languages, provides the necessary features
to package tasks and subtasks into threads. The <literal>Thread</literal> class and its
subclasses provide the tools for creating and managing threads. For
example, the following class definition allows objects of type
<literal>ThreadedTask</literal> to be created. Such an object can be executed as a
separate thread.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class ThreadedTask extends Thread {
    // Add constructor and body of class
}</programlisting>
<simpara>The constructor is written just like any other constructor, but there is
a special <literal>run()</literal> method in <literal>Thread</literal> that can be overridden by any of
its subclasses. This method is the starting point for the thread of
execution associated with an instance of the class. Most Java
applications begin with a single main thread which starts in a <literal>main()</literal>
method. Additional threads must start somewhere, and that place is the
<literal>run()</literal> method. A Java application will continue to run as long as at
least one thread is active. The following example shows two threads,
each evaluating a separate subexpression as in FigureÂ <xref linkend="figure:tasks in
threads"/>(b).</simpara>
<example>
<title>Thread samples</title>
<simpara>We will create <literal>Thread1</literal> and <literal>Thread2</literal> classes. The threads of execution
created by instances of these classes compute, respectively, the two
subexpressions in FigureÂ <xref linkend="figure:tasks_in_threads"/>(b) and save the
computed values.</simpara>
<programlisting xml:id="program:Thread1" xreflabel="Thread1" language="java" linenumbering="numbered">public class Thread1 extends Thread {
	private double K, a, t, value;

	public Thread1(double K, double a, double t) {
		this.K = K;
		this.a = a;
		this.t = t;
	}
	public void run() { value = 2*K*a*t; }
	public double getValue() { return value; }
}</programlisting>
<programlisting xml:id="program:Thread2" xreflabel="Thread2" language="java" linenumbering="numbered">public class Thread2 extends Thread {
	private double a, t, value;

	public  Thread2(double a, double t) {
		this.a = a;
		this.t = t;
	}
    public void run() { value = Math.exp(-a*t*t); }
    public double getValue() { return value; }
}</programlisting>
<simpara>The <literal>run()</literal> method in each thread above computes a subexpression and
saves its value. We show how these threads can be executed to solve the
math expression problem in ExampleÂ <xref linkend="example:Math_expression_threads"/>.</simpara>
</example>
</section>
<section xml:id="_creating_a_thread_object">
<title>Creating a thread object</title>
<simpara>Creating an object from a subclass of <literal>Thread</literal> is the same as creating
any other object in Java. For example, we can instantiate the <literal>Thread1</literal>
class above to create an object called <literal>thread1</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">Thread1 thread1 = new Thread1( 15.1, 2.8, 7.53 );</programlisting>
<simpara>Using the <literal>new</literal> keyword to invoke the constructor creates a <literal>Thread1</literal>
object, but it does not start executing it as a new thread. As with all
other classes, the constructor initializes the values inside of the new
object. A subclass of <literal>Thread</literal> can have many different constructors with
whatever parameters its designer thinks appropriate.</simpara>
</section>
<section xml:id="_starting_a_thread">
<title>Starting a thread</title>
<simpara>To start the thread object executing, its <literal>start()</literal> method must be
called. For example, the <literal>thread1</literal> object created above can be started
as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">    thread1.start();</programlisting>
<simpara>Once started, a thread executes independently. When a thread needs to
share data with another thread, it might have to wait.</simpara>
</section>
<section xml:id="_waiting_for_a_thread">
<title>Waiting for a thread</title>
<simpara>Often some thread, main or otherwise, needs to wait for another thread
before proceeding further with its execution. The <literal>join()</literal> method is
used to wait for a thread to finish executing. For example, whichever
thread executes the following code will wait for <literal>thread1</literal> to complete.</simpara>
<programlisting language="java" linenumbering="unnumbered">    thread1.join();</programlisting>
<simpara>Calling <literal>join()</literal> is a <emphasis>blocking</emphasis> call, meaning that the code calling
this method will wait until it returns. Since it can throw a a checked
<literal>InterruptedException</literal>. while the code is waiting, the <literal>join()</literal> method
is generally used within a <literal>try</literal>-<literal>catch</literal> block. We can add a
<literal>try</literal>-<literal>catch</literal> block to the <literal>thread1</literal> example so that we can recover from
being interrupted while waiting for <literal>thread1</literal> to finish.</simpara>
<programlisting language="java" linenumbering="unnumbered">    try {
        System.out.println("Waiting for thread 1...");
        thread1.join();
        System.out.println("Thread 1 finished!");
    }
    catch (InterruptedException e) {
        System.out.println("Thread 1 didn't finish!");
    }</programlisting>
<simpara>Note that the <literal>InterruptedException</literal> is thrown because the main thread
was interrupted while waiting for <literal>thread1</literal> to finish. If the <literal>join()</literal>
call returns, then <literal>thread1</literal> must have finished, and we inform the user.
If an <literal>InterruptedException</literal> is thrown, some outside thread must have
interrupted the main thread, forcing it to stop waiting for <literal>thread1</literal>.</simpara>
<simpara>In earlier versions of Java, there was a <literal>stop()</literal> method which would
stop an executing thread. Although this method still exists, it has been
deprecated and should not be used.</simpara>
<example>
<title>Math expression threads</title>
<simpara>Now that we have the syntax to start threads and wait for them to
finish, we can use the threads defined in ExampleÂ <xref linkend="example:Thread
samples"/> with a main thread to make our first complete concurrent
program. The main thread in class <literal>MathExpression</literal> creates and starts
the worker threads <literal>thread1</literal> and <literal>thread2</literal> and waits for their
completion. When the two threads complete their execution, we can ask
each for its computed value. The main thread then prints the product of
these values, which is the result of the expression we want to evaluate.</simpara>
<programlisting xml:id="program:MathExpression" xreflabel="MathExpression" language="java" linenumbering="numbered">public class MathExpression {
    public static void main (String[] args) {
        double K = 120, a = 1.2, t = 2;
        Thread1 thread1 = new Thread1(K, a, t);
        Thread2 thread2 = new Thread2(a, t);
        thread1.start(); // start thread1
        thread2.start(); // start thread2
        try { // wait for both threads to complete
            thread1.join();
            thread2.join();
            System.out.println("Value of expression: " +
            		thread1.getValue()*thread2.getValue());
        }
        catch (InterruptedException e) {
        	System.out.println("A thread didn't finish!");
        }
    }
}</programlisting>
<simpara>We want to make it absolutely clear when threads are created, start
executing, and finish. These details are crucial for the finer points of
concurrent Java programming. In FigureÂ <xref linkend="figure:tasks_in_threads"/>, it
appears as if execution of the concurrent math expression evaluation
begins with Thread 1 which spawns Thread 2. Although that figure
explains the basics of task decomposition well, the details are messier
for real Java code.</simpara>
<simpara>In the code above, execution starts with the <literal>main()</literal> method in
<literal>MathExpression</literal>. It creates <literal>Thread1</literal> and <literal>Thread2</literal> objects and waits
for them to finish. Then, it reads the values from the objects after
they have stopped executing. We could have put the <literal>main()</literal> method in
the <literal>Thread1</literal> class, omitting the <literal>MathExpression</literal> class entirely. Doing
so would make the execution match FigureÂ <xref linkend="figure:tasks_in_threads"/>
more closely, but it would make the two <literal>Thread</literal> subclasses less
symmetrical: The main thread and <literal>thread1</literal> would both independently
execute code inside the <literal>Thread1</literal> class while only <literal>thread2</literal> would
execute code inside the <literal>Thread2</literal> class.</simpara>
<figure role="text-center">
<title>Creation, starting, and joining of threads in <literal>MathExpression</literal>, <literal>Thread1</literal>, and <literal>Thread2</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/thread-lifecycle.svg" width="75%"/>
</imageobject>
<textobject><phrase>thread lifecycle</phrase></textobject>
</mediaobject>
</figure>
<simpara>FigureÂ <xref linkend="figure:thread_execution"/> shows the execution of <literal>thread1</literal> and
<literal>thread2</literal> and the main thread. Note that the creation and start of the
main thread is done implicitly by the JVM while <literal>thread1</literal> and <literal>thread2</literal>
are created explicitly and started by the main thread. Even after the
threads associated with <literal>thread1</literal> and <literal>thread2</literal> have stopped running,
the objects continue to exist. Methods and fields can continue to be
accessed.</simpara>
</example>
</section>
<section xml:id="subsection:runnable">
<title>The <literal>Runnable</literal> interface</title>
<simpara>Although it is possible to create Java threads by inheriting from the
<literal>Thread</literal> class directly, the Java API allows the programmer to use an
interface instead.</simpara>
<simpara>As an example, the <literal>Summer</literal> class takes an array of <literal>int</literal> values and
sums them up within a given range. If multiple instances of this class
are executed as separate threads, each one can sum up different parts of
an array.</simpara>
<programlisting language="java" linenumbering="numbered">public class Summer implements Runnable {
	int[] array;
	int lower;
	int upper;
	int sum = 0;

	public Summer( int[] array, int lower, int upper ) {
		this.array = array;
		this.lower = lower;
		this.upper = upper;
	}

	public void run() {
		for( int i = lower; i &lt; upper; i++ )
			sum += array[i];
	}

	public int getSum() { return sum; }
}</programlisting>
<simpara>This class is very similar to one that inherits from <literal>Thread</literal>. Imagine
for a moment that the code following <literal>Summer</literal> is <literal>extends Thread</literal>
instead of <literal>implements Runnable</literal>. The key thing a class derived from
<literal>Thread</literal> needs is an overridden <literal>run()</literal> method. Since only the <literal>run()</literal>
method is important, the designers of Java provided a way to create a
thread using the <literal>Runnable</literal> interface. To implement this interface, only
a <literal>public void run()</literal> method is required.</simpara>
<simpara>When creating a new thread, there are some differences in syntax between
the two styles. The familiar way of creating and running a thread from a
<literal>Thread</literal> subclass is as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Summer summer = new Summer( array, lower, upper );
summer.start();</programlisting>
<simpara>Since <literal>Summer</literal> does not inherit from <literal>Thread</literal>, it does not have a
<literal>start()</literal> method, and this code will not compile. When a class only
implements <literal>Runnable</literal>, it is still necessary to create a <literal>Thread</literal> object
and call its <literal>start()</literal> method. Thus, an extra step is needed.</simpara>
<programlisting language="java" linenumbering="unnumbered">Summer summer = new Summer( array, lower, upper );
Thread thread = new Thread( summer );
thread.start();</programlisting>
<simpara>This alternate way of implementing the <literal>Runnable</literal> interface seems more
cumbersome than inheriting directly from <literal>Thread</literal>, since you have to
instantiate a separate <literal>Thread</literal> object. However, most developers prefer
to design classes that implement <literal>Runnable</literal> instead of inheriting from
<literal>Thread</literal>. Why? Java only allows for single inheritance. If your class
implements <literal>Runnable</literal>, it is free to inherit from another parent class
with the features you want.</simpara>
<example>
<title>Array of threads</title>
<simpara>In domain decomposition, we often need to create multiple threads, all
from the same class. As an example, consider the following thread
declaration.</simpara>
<programlisting xml:id="program:NumberedThread" xreflabel="NumberedThread" language="java" linenumbering="numbered">public class NumberedThread extends Thread {
	private int value;

	public NumberedThread( int input ) { value = input; }

	public void run() {
		System.out.println("Thread " + value);
	}
}</programlisting>
<simpara>Now suppose that we want to create 10 thread objects of type
<literal>NumberedThread</literal>, start them, and then wait for them to complete.</simpara>
<programlisting language="java" linenumbering="unnumbered">NumberedThread[] threads = new NumberedThread[10];
for( int i = 0; i &lt; threads.length; i++ ) {
    threads[i] = new NumberedThread(i);
    threads[i].start();
}
try {
    for( int i = 0; i &lt; threads.length; i++ )
        threads[i].join();
}
catch( InterruptedException e ) {
    System.out.println("A thread didn't finish!");
}</programlisting>
<simpara>First, we declare an array to hold references to <literal>NumberedThread</literal>
objects. Like any other type, we can make an array to hold objects that
inherit from <literal>Thread</literal>. The first line of the <literal>for</literal> loop instantiates a
new <literal>NumberedThread</literal> objects, invoking the constructor which stores the
current iteration of the loop into the <literal>value</literal> field. The reference to
each <literal>NumberedThread</literal> object is stored in the array. Remember that the
constructor does <emphasis role="strong">not</emphasis> start a new thread running. The second line of
the <literal>for</literal> loop does that.</simpara>
<simpara>We are also interested in when the threads stop. Calling the <literal>join()</literal>
method forces the main thread to wait for each thread to finish.</simpara>
<simpara>The entire second <literal>for</literal> loop is nested inside of a <literal>try</literal> block. If the
main thread is interrupted while waiting for any of the threads to
finish, an <literal>InterruptedException</literal> will be caught. As before, we warn the
user that a thread didn&#8217;t finish. For production-quality code, the
<literal>catch</literal> block should handle the exception in such a way that the thread
can recover and do useful work even though it didn&#8217;t get what it was
waiting for.</simpara>
</example>
</section>
</section>
<section xml:id="_examples_concurrency_and_speedup">
<title>Examples: Concurrency and speedup</title>
<simpara>Speedup is one of the classic motivations for writing concurrent
programs. To understand speedup, let&#8217;s assume we have a problem to
solve. We write two programs to solve this problem, one that is
sequential and another that is concurrent and, hence, able to exploit
the multiple cores. Let <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation> be the average time to execute
the sequential program and <inlineequation><alt><![CDATA[t_c]]></alt><mathphrase><![CDATA[t_c]]></mathphrase></inlineequation> the average time to execute
the concurrent program. Sometimes we will use the notation
<inlineequation><alt><![CDATA[t_c^k]]></alt><mathphrase><![CDATA[t_c^k]]></mathphrase></inlineequation> to refer to the execution time of a concurrent
program with <inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation> threads. So that the comparison is
meaningful, assume that both programs are executed on the same computer.
The speedup obtained from concurrent programming is defined as follows.
<inlineequation><alt><![CDATA[\mbox{speedup}=\frac{t_s}{t_c}]]></alt><mathphrase><![CDATA[\mbox{speedup}=\frac{t_s}{t_c}]]></mathphrase></inlineequation></simpara>
<simpara>Speedup measures how much faster the concurrent program executes
relative to the sequential program. Ideally, we expect
<inlineequation><alt><![CDATA[t_c<t_s]]></alt><mathphrase><![CDATA[t_c<t_s]]></mathphrase></inlineequation>, making the speedup greater than 1. However,
simply writing a concurrent program does not necessarily make it faster
than the sequential version.</simpara>
<simpara>To determine speedup, we need to measure <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation> and
<inlineequation><alt><![CDATA[t_c]]></alt><mathphrase><![CDATA[t_c]]></mathphrase></inlineequation>. Time in a Java program can easily be measured with
the following two static methods in the <literal>System</literal> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static long currentTimeMillis()
public static long nanoTime()</programlisting>
<simpara>The first of these methods returns the current time in milliseconds
(ms). A <emphasis>millisecond</emphasis> is 0.001 seconds. This method gives the difference
between the current time on your computer&#8217;s clock and midnight of
JanuaryÂ 1,Â 1970 coordinated universal time (UTC). This point in time is
used for many timing features on many computer platforms and is called
the <emphasis>Unix epoch</emphasis>. The second method returns the current time in
nanoseconds (ns). A <emphasis>nanosecond</emphasis> is 0.000001 seconds. This method also
gives the difference between the current time and some fixed time, which
is system dependent and not necessarily the Unix epoch. The
<literal>System.nanoTime()</literal> method can be used when you want timing precision
finer than milliseconds; however, the level of accuracy it returns is
again system dependent. The next example show how to use these methods
to measure execution time.</simpara>
<example>
<title>Measuring execution time</title>
<simpara>Suppose we want to measure the execution time of a piece of Java code.
For convenience, we can assume this code is contained in the <literal>work()</literal>
method. The following code snippet measures the time to execute
<literal>work()</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">long start = System.currentTimeMillis();
work();
long end = System.currentTimeMillis();
System.out.println("Elapsed time: " + (end - start) + " ms");</programlisting>
<simpara>The output will give the execution time for <literal>work()</literal> measured in
milliseconds. To get the execution time in nanoseconds, use the
<literal>System.nanoTime()</literal> method instead.</simpara>
</example>
<simpara>Now that we have the tools to measure execution time, we can measure
speedup. The next few examples show the speedup (or lack of it) that we
can achieve using a concurrent solution to a few simple problems.</simpara>
<example>
<title>Math expression speedup</title>
<simpara>Recall the concurrent program in ExampleÂ <xref linkend="example:Math expression
threads"/> to evaluate a simple mathematical expression. This program
uses two threads. We executed this multi-threaded program on an iMac
computer with an Intel Core 2 Duo running at 2.16 Ghz. The execution
time was measured at 1,660,000 nanoseconds. We also wrote a simple
sequential program to evaluate the same expression. It took 4,100
nanoseconds to execute this program on the same computer. Plugging in
these values for <inlineequation><alt><![CDATA[t_c]]></alt><mathphrase><![CDATA[t_c]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation>, we can find
the speedup.</simpara>
<simpara><inlineequation><alt><![CDATA[\mbox{speedup}=\frac{t_s}{t_c} = \frac{4,100}{1,660,000}= 0.00246]]></alt><mathphrase><![CDATA[\mbox{speedup}=\frac{t_s}{t_c} = \frac{4,100}{1,660,000}= 0.00246]]></mathphrase></inlineequation><?asciidoc-br?>
This speedup is much less than 1. Although the result may be surprising,
the concurrent program with two threads executes much slower than the
sequential program. In this example, the cost of creating, running, and
joining threads outweighed the benefits of concurrent calculation on two
cores.</simpara>
</example>
<example>
<title>Array summation</title>
<simpara>In ExampleÂ <xref linkend="example:Array_summation_preview"/>, we introduced the
problem of applying a function to every value in an array and then
summing the results. Let&#8217;s say that we want to apply the sine function
to each value. To solve this problem concurrently, we partition the
array evenly among a number of threads, using the domain decomposition
strategy. Each thread finds the sum of the sines of the values in its
part of the array. One factor that determines whether or not we achieve
speedup is the complexity of the function, in this case sine, that we
apply. Although we may achieve speedup with sine, a simpler function
such as doubling the value might not create enough work to justify the
overhead of using threads.</simpara>
<simpara>We create class <literal>SumThread</literal> whose <literal>run()</literal> method sums the sines of those
elements of the array in its assigned partition.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.Random;

public class SumThread extends Thread {
	private static double[] data;
	private double sum = 0.0;
	private int lower;
	private int upper;
	public static final int SIZE = 1000000;
	public static final int THREADS = 8;

	public SumThread( int lower, int upper ) {
		this.lower = lower;
		this.upper = upper;
	}</programlisting>
<simpara>First, we set up all the fields that the class will need. We fix the
array size at 1,000,000 and the number of threads at 8, but these values
could easily be changed or read as input instead. In its constructor, a
<literal>SumThread</literal> takes the lower and upper bounds of its partition. Like most
ranges we discuss, the lower bound is inclusive though the upper bound
is exclusive.</simpara>
<programlisting language="java" linenumbering="numbered">	public void run() {
		for( int i = lower; i &lt; upper; i++ )
			sum += Math.sin(data[i]);
	}

	public double getSum() { return sum; }</programlisting>
<simpara>In the <literal>for</literal> loop of the <literal>run()</literal> method, the <literal>SumThread</literal> finds the sine
of each number in its array partition and adds that value to its running
sum. The <literal>getSum()</literal> method is an accessor that allows the running sum to
be retrieved.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void main( String[] args ) {
		data = new double[SIZE];
		Random random = new Random();
		int start = 0;
		for( int i = 0; i &lt; SIZE; i++ )
			data[i] = random.nextDouble();
		SumThread threads = new SumThread[THREADS];
		int quotient = data.length / THREADS;
		int remainder = data.length % THREADS;
		for( int i = 0; i &lt; THREADS; i++ ) {
			int work = quotient;
			if( i &lt; remainder )
				work++;
			threads[i] = new SumThread( start, start + work );
			threads[i].start();
			start += work;
		}</programlisting>
<simpara>The <literal>main()</literal> method begins by instantiating the array and filling it
with random values. Note that the array is a static field so that it can
be shared by all instances of <literal>SumThread</literal>. Then each thread is created
with lower and upper bounds that mark its array partition. If the
process using the array length and the number of threads to determine
upper and lower bounds doesn&#8217;t make sense, refer to
SectionÂ <xref linkend="concurrency:Arrays"/> which describes the fair division of work
to threads. If the length of the array is not divisible by the number of
threads, simple division isn&#8217;t enough. After creating each thread, its
<literal>start()</literal> method is called.</simpara>
<programlisting language="java" linenumbering="numbered">		double sum = 0.0;
		try	{
			for( int i = 0; i &lt; THREADS; i++ ) {
				thread[i].join();
				sum += thread[i].getSum();
			}
			System.out.println("Sum: " + threads[0].getSum());
		}
		catch( InterruptedException e )	{
			e.printStackTrace();
		}
	}
}</programlisting>
<simpara>After the threads have started working, the main thread creates its own
running total and iterates through each thread waiting for it to
complete. When each thread is done, the main thread adds its value to
the running total. If the main thread is interrupted while waiting for a
thread to complete, the stack trace is printed. Otherwise, the final sum
is printed out.</simpara>
</example>
<example>
<title>Matrix multiplication</title>
<simpara>In ExampleÂ <xref linkend="example:Matrix_multiplication_preview"/>, we discussed the
importance of matrix operations in many applications. Now that we know
the necessary Java syntax, we can write a concurrent program to multiply
two square matrices <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation> and compute the
resultant matrix <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation>. If these matrices have <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>
rows and <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> columns, the value at the <inlineequation><alt><![CDATA[i]]></alt><mathphrase><![CDATA[i]]></mathphrase></inlineequation><superscript>th</superscript>
row and <inlineequation><alt><![CDATA[j]]></alt><mathphrase><![CDATA[j]]></mathphrase></inlineequation><superscript>th</superscript> column of <inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> is</simpara>
<simpara><inlineequation><alt><![CDATA[C_{ij} = \sum_{k = 1}^n A_{ik}B_{kj} = A_{i1}B_{1j} + A_{i2}B_{2j} + \hdots +
A_{in}B_{nj}]]></alt><mathphrase><![CDATA[C_{ij} = \sum_{k = 1}^n A_{ik}B_{kj} = A_{i1}B_{1j} + A_{i2}B_{2j} + \hdots +
A_{in}B_{nj}]]></mathphrase></inlineequation></simpara>
<simpara>In Java, it is natural for us to store matrices as 2-dimensional arrays.
To do this multiplication sequentially, the simplest approach uses three
nested <literal>for</literal> loops. The code below is a direct translation of the
mathematical notation, but we do have to be careful about bookkeeping.
Note that mathematical notation often uses uppercase letters to
represent matrices though the Java convention is to start all variable
names with lowercase letters.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; c.length; i++ )
    for( int j = 0; j &lt; c[i].length; j++ )
        for( int k = 0; k &lt; b.length; k++ )
            c[i][j] += a[i][k] * b[k][j];</programlisting>
<simpara>The first step in making a concurrent solution to this problem is to
create a <literal>Thread</literal> subclass which will do some part of the matrix
multiplication. Below is the <literal>MatrixThread</literal> class which will compute a
number of rows in the answer matrix <literal>c</literal>.</simpara>
<programlisting xml:id="program:MatrixThread" xreflabel="MatrixThread" language="java" linenumbering="numbered">public class MatrixThread extends Thread {
	private double[][] a;
	private double[][] b;
	private double[][] c;
	private int lower;
	private int upper;

	public MatrixThread( double[][] a, double[][] b,
		double[][] c, int lower, int upper ) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.lower = lower;
		this.upper = upper;
	}

	public void run() {
		for( int i = lower; i &lt; upper; i++ )
			for( int j = 0; j &lt; c[i].length; j++ )
				for( int k = 0; k &lt; b.length; k++ )
					c[i][j] += a[i][k] * b[k][j];
	}
}</programlisting>
<simpara>The constructor for <literal>MatrixThread</literal> stores references to the arrays
corresponding to matrices <inlineequation><alt><![CDATA[A]]></alt><mathphrase><![CDATA[A]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[B]]></alt><mathphrase><![CDATA[B]]></mathphrase></inlineequation>, and
<inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> as well as lower and upper bounds on the rows of
<inlineequation><alt><![CDATA[C]]></alt><mathphrase><![CDATA[C]]></mathphrase></inlineequation> to compute. The body of the <literal>run()</literal> method is identical
to the sequential solution except that its outermost loop runs only from
<literal>lower</literal> to <literal>upper</literal> instead of through all the rows of the result. It is
critical that each thread is assigned a set of rows that does not
overlap with the rows another thread has. Not only would having multiple
threads compute the same row be inefficient, it could very likely lead
to an incorrect result, as we will see in
ChapterÂ <xref linkend="chapter:Synchronization"/>.</simpara>
<simpara>The following client code uses an array of <literal>MatrixThread</literal> objects to
perform a matrix multiplication. We assume that an <literal>int</literal> constant named
<literal>THREADS</literal> has been defined which gives the number of threads we want to
create.</simpara>
<programlisting language="java" linenumbering="unnumbered">MatrixThread[] threads = new MatrixThread[THREADS];
int quotient = c.length / THREADS;
int remainder = c.length % THREADS;
int start = 0;
for( int i = 0; i &lt; THREADS; i++ ) {
    int rows = quotient;
    if( i &lt; remainder )
        rows++;
    threads[i] = new MatrixThread( a, b, c, start, start + rows );
    threads[i].start();
    start += rows;
}
try {
    for( int i = 0; i &lt; THREADS; i++ )
        threads[i].join();
}
catch( InterruptedException e ) {
    e.printStackTrace();
}</programlisting>
<simpara>We loop through the array, creating a <literal>MatrixThread</literal> object for each
location. As in the previous example, we use the approach described in
SectionÂ <xref linkend="concurrency:Arrays"/> to allocate rows to each thread fairly.
Each new <literal>MatrixThread</literal> object is given a reference to each of the three
matrices as well as an inclusive starting and an exclusive ending row.
After the <literal>MatrixThread</literal> objects are created, we start them running with
the next line of code.</simpara>
<simpara>Next, there is a familiar <literal>for</literal> loop with the <literal>join()</literal> calls that force
the main thread to wait for the other threads to finish. Presumably,
code following this snippet will print the values of the result matrix
or use it for some other calculations. If we don&#8217;t use the <literal>join()</literal>
calls to be sure the threads have finished, we might print out a result
matrix that has only been partially filled in.</simpara>
<simpara>We completed the code for threaded matrix multiplication and executed it
on an iMac computer running on an Intel running at 2.16 Ghz. The program
was executed for matrices of different sizes (<inlineequation><alt><![CDATA[n \times n]]></alt><mathphrase><![CDATA[n \times n]]></mathphrase></inlineequation>).
For each size, the sequential and concurrent execution times in seconds
and the corresponding speedup are listed in the following table.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Size (<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>)</entry>
<entry align="left" valign="top"><inlineequation><alt><![CDATA[t_s]]></alt><mathphrase><![CDATA[t_s]]></mathphrase></inlineequation> (s)</entry>
<entry align="left" valign="top"><inlineequation><alt><![CDATA[t_c]]></alt><mathphrase><![CDATA[t_c]]></mathphrase></inlineequation> (s)</entry>
<entry align="left" valign="top">Speedup</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>0.013</simpara></entry>
<entry align="left" valign="top"><simpara>0.9</simpara></entry>
<entry align="left" valign="top"><simpara>0.014</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>1.75</simpara></entry>
<entry align="left" valign="top"><simpara>4.5</simpara></entry>
<entry align="left" valign="top"><simpara>0.39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>15.6</simpara></entry>
<entry align="left" valign="top"><simpara>10.7</simpara></entry>
<entry align="left" valign="top"><simpara>1.45<superscript>*</superscript></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Only with <inlineequation><alt><![CDATA[1000\times1000]]></alt><mathphrase><![CDATA[1000\times1000]]></mathphrase></inlineequation> matrices did we see improved
performance when using two threads. In that case, we achieved a speedup
of 1.45, marked with an asterisk. In the other two cases, performance
became worse.</simpara>
</example>
</section>
<section xml:id="_concepts_thread_scheduling">
<title>Concepts: Thread scheduling</title>
<simpara>Now that we have seen how multiple threads can be used together, a
number of questions should be coming to the forefront. Who decides when
these threads run? How is processor time shared between threads? Can we
make any assumptions about the order in which the threads will run? Can
we affect this order?</simpara>
<simpara>These questions focus on thread scheduling. Because different concurrent
systems handle scheduling differently, we will only describe scheduling
in Java. Although sequential programming is all about precise control
over what happens <emphasis role="strong">next</emphasis>, concurrency takes much of this control away
from the programmer. When threads are scheduled and which processor they
run on is handled by a combination of the JVM and the OS. With normal
JVMs, there is no explicit way to access the scheduling and alter it to
your liking.</simpara>
<simpara>Of course, there are a number of implicit ways a programmer can affect
scheduling. In Java, as in several other languages and programming
systems, threads have <emphasis>priorities</emphasis>. Higher priority threads run more
often than lower priority threads. Some threads are performing
mission-critical operations which must be carried out as quickly as
possible, and some threads are just doing periodic tasks in the
background. A programmer can set the priorities accordingly.</simpara>
<simpara>Setting priorities gives only a very general way of controlling which
thread will run. The threads themselves might have more specific
information about when they will and will not need processor time. A
thread may need to wait for a specific event and will not need to run
until then. Java allows threads to interact with the scheduler through
<literal>Thread.sleep()</literal> and <literal>Thread.yield()</literal>, which we will discuss in
SectionÂ <xref linkend="syntax:Thread_states"/>, and through the <literal>wait()</literal>, method which
we will discuss in ChapterÂ <xref linkend="chapter:Synchronization"/>.</simpara>
<section xml:id="_nondeterminism">
<title>Nondeterminism</title>
<simpara>In Java, the mapping of a thread inside the JVM to a thread in the OS
varies. Some implementations give each Java thread an OS thread, some
put all Java threads on a single OS thread (with the side effect of
preventing concurrency), and some allow for the possibility of changing
which OS thread a Java thread uses. Thus, the performance and, in some
cases, the correctness of your program might vary, depending on which
system you are running. This is, yet again, one of those times when Java
is platform independent&#8230;&#8203; but not entirely.</simpara>
<simpara>Unfortunately, the situation is even more complicated. Making threads
part of your program means that the same program could run differently
on the <emphasis role="strong">same</emphasis> system. The JVM and the OS have to cooperate to schedule
threads, and both programs are complex mountains of code which try to
balance many factors. If you create three threads, there is no guarantee
that the first will run first, the second second, and the third third,
not even if it happens that way the first 10 times you run the program.
ExerciseÂ <xref linkend="exercise:NumberedThread"/> shows that the pattern of thread
execution can vary a lot.</simpara>
<simpara>In all the programs before this chapter, the same sequence of input
would always produce the same sequence of output. Perhaps the biggest
hurdle created by this nondeterminism is that programmers must shift
their paradigm considerably. The processor can switch between executions
of threads at any time, even in the middle of operations. Every possible
interleaving of thread execution can crop up at some point. Unless you
can be sure that your program behaves properly for all of them, you may
never be able to debug your code completely. What is so insidious about
some nondeterministic bugs is that they can occur rarely and be almost
impossible to reproduce. In this chapter, we introduce how to create and
run threads, but making these threads interact properly is a major
problem we tackle in subsequent chapters.</simpara>
<simpara>After those dire words of warning, we&#8217;d like to remind you that
nondeterminism is not in itself a bad thing. Many threaded applications
with a lot of input and output, such as server applications, necessarily
exist in a nondeterministic world. For these programs, many different
sequences of thread execution may be perfectly valid. Each individual
program may have a different definition of correctness. For example, if
a stock market server receives two requests to buy the last share of a
particular stock at almost the same time from two threads corresponding
to two different clients, it might be correct for either one of them to
get that last share. However, it would never be correct for <emphasis role="strong">both</emphasis> of
them to get it.</simpara>
</section>
<section xml:id="_polling">
<title>Polling</title>
<simpara>So far the only mechanism we have introduced for coordinating different
threads is using the <literal>join()</literal> method to wait for a thread to end.
Another technique is <emphasis>polling</emphasis>, or <emphasis>busy waiting</emphasis>. The idea is to keep
checking the state of one thread until it changes.</simpara>
<simpara>There are a number of problems with this approach. The first is that it
wastes CPU cycles. Those cycles spent by the waiting thread continually
checking could have been used productively by some other thread in the
system. The second problem is that we have to be certain that the state
of the thread we are waiting for won&#8217;t change back to the original state
or to some other state. Because of the unpredictability of scheduling,
there is no guarantee that the waiting thread will read the state of the
other thread when it has the correct value.</simpara>
<simpara>We bring up polling partly because it has a historical importance to
parallel programming, partly because it can be useful in solving some
problems in this chapter, and partly because we want you to understand
the reasons why we need better techniques for thread communication.</simpara>
</section>
</section>
<section xml:id="_syntax_thread_states">
<title>Syntax: Thread states</title>
<simpara>A widely used Java tool for manipulating scheduling is the
<literal>Thread.sleep()</literal> method. This method can be called any time you want a
thread to do nothing for a set period of time. Until the sleep timer
expires, the thread will not be scheduled for any CPU time, unless it is
interrupted. To make a thread of execution sleep, call <literal>Thread.sleep()</literal>
in that thread of execution with a number of milliseconds as a
parameter. For example, calling <literal>Thread.sleep(2000)</literal> will make the
calling thread sleep for two full seconds.</simpara>
<simpara>Another useful tool is the <literal>Thread.yield()</literal> method. It gives up use of
the CPU so that the next waiting thread can run. To use it, a thread
calls <literal>Thread.yield()</literal>. This method is very useful in practice, but
according to official documentation, the JVM does not <emphasis role="strong">have</emphasis> to do to
anything when a <literal>Thread.yield()</literal> call happens. The Java specification
does not demand a particular implementation. A JVM could ignore a
<literal>Thread.yield()</literal> call completely, but most JVMs will move on to the next
thread in the schedule.</simpara>
<figure role="text-center">
<title>Thread states and transitions.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/thread-states.svg" width="80%"/>
</imageobject>
<textobject><phrase>thread states</phrase></textobject>
</mediaobject>
</figure>
<simpara>FigureÂ <xref linkend="figure:thread_states"/> shows the lifecycle of a thread. A
thread begins its life in the New Thread state, after the constructor is
called. When the <literal>start()</literal> method is called, the thread begins to run
and transitions to the Runnable state. Being Runnable doesn&#8217;t
necessarily mean that the thread is executing at any given moment but
that it is ready to run at any time. When in the Runnable state, a
thread may call <literal>Thread.yield()</literal>, relinquishing use of the processor,
but it will still remain Runnable.</simpara>
<simpara>However, if a thread goes to sleep with a <literal>Thread.sleep()</literal> call, waits
for a condition to be true using a <literal>wait()</literal> call, or performs a blocking
I/O operation, the thread will transition to the Not Runnable state. Not
Runnable threads cannot be scheduled for processor time until they wake
up, finish waiting, or complete their I/O. The final state is
Terminated. A thread becomes Terminated when its <literal>run()</literal> method
finishes. A Terminated thread cannot become Runnable again and is no
longer a separate thread of execution.</simpara>
<simpara>Any object with a type that is a subclass of <literal>Thread</literal> can tell you its
current state using the <literal>getState()</literal> method. This method returns an
<emphasis>enum</emphasis> type, whose value must come from a fixed list of constant
objects. These objects are <literal>Thread.State.NEW</literal>, <literal>Thread.State.RUNNABLE</literal>,
<literal>Thread.State.BLOCKED</literal>, <literal>Thread.State.WAITING</literal>,
<literal>Thread.State.TIMED_WAITING</literal>, and <literal>Thread.State.TERMINATED</literal>. Although
the others are self explanatory, we lump the <literal>Thread.State.BLOCKED</literal>,
<literal>Thread.State.WAITING</literal>, and <literal>Thread.State.TIMED_WAITING</literal> values into
the Not Runnable state, since the distinction between the three is not
important for us.</simpara>
<simpara>Threads also have priorities in Java. When an object that is a subclass
of <literal>Thread</literal> is created in Java, its priority is initially the same as
the thread that creates it. Usually, this priority is
<literal>Thread.NORM_PRIORITY</literal>, but there are some special cases when it is a
good idea to raise or lower this priority. Avoid changing thread
priorities because it increases platform dependence and because the
effects are not always predictable. Be aware that priorities exist, but
don&#8217;t use them unless and until you have a good reason.</simpara>
<example>
<title>Military marching</title>
<simpara>Let&#8217;s apply the ideas discussed above to a lighthearted example. You
might be familiar with sound of soldiers marching: &#8220;Left, Left, Left,
Right, Left!&#8221; We can design a thread that prints <literal>Left</literal> and another
thread that prints <literal>Right</literal>. We can combine the two to print the correct
sequence for marching and loop the whole thing 10 times so that we can
see how accurately place the words. We want to use the scheduling tools
discussed above to get the timing right. Let&#8217;s try <literal>Thread.sleep()</literal>
first.</simpara>
<programlisting xml:id="program:LeftThread" xreflabel="LeftThread" language="java" linenumbering="numbered">public class LeftThread extends Thread {
	public void run() {
		for( int i = 0; i &lt; 10; i++ ) {
			System.out.print("Left ");
			System.out.print("Left ");
			System.out.print("Left ");
			try { Thread.sleep(10); }
			catch( InterruptedException e ) {
				e.printStackTrace();
			}
			System.out.println("Left");
		}
	}
}</programlisting>
<simpara>Class <literal>LeftThread</literal> has a <literal>for</literal> loop which prints out <literal>Left</literal> three times,
waits for 10 milliseconds, prints out <literal>Left</literal> again, then repeats.</simpara>
<programlisting xml:id="program:RightThread" xreflabel="RightThread" language="java" linenumbering="numbered">public class RightThread extends Thread {
	public void run() {
		try { Thread.sleep(5); }
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		for( int i = 0; i &lt; 10; i++ ) {
			System.out.print("Right ");
			try { Thread.sleep(10); }
			catch( InterruptedException e ) {
				e.printStackTrace();
			}
		}
	}
}</programlisting>
<simpara>Class <literal>RightThread</literal> waits for 5 milliseconds to get synchronized, then
has a <literal>for</literal> loop which prints out <literal>Right</literal>, waits for 10 milliseconds,
and repeats. The driver program below creates a thread for each of these
classes and then starts them. If you run this program, you should see 10
lines of <literal>Left Left Left Right Left</literal>, but there are a few problems.</simpara>
<programlisting xml:id="program:MilitaryMarching" xreflabel="MilitaryMarching" language="java" linenumbering="numbered">public class MilitaryMarching {
	public static void main( String[] args ) {
		LeftThread left = new LeftThread();
		RightThread right = new RightThread();
		left.start();
		right.start();
		try {
			left.join();
			right.join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
	}
}</programlisting>
<simpara>The first problem is that we have to wait some amount of time between
calls. We could shorten the <literal>Thread.sleep()</literal> calls, but there are limits
on the resolution of the timer. The bigger problem is that the two
threads can sometimes get out of sync. If you run the program many
times, you may see a <literal>Right</literal> out of place once in a while. If you
increase the repetitions of the <literal>for</literal> loops to a larger number, the
errors are more likely. Whether or not you see errors is somewhat system
dependent. We can try <literal>Thread.yield()</literal> instead of <literal>Thread.sleep()</literal>.</simpara>
<programlisting xml:id="program:LeftYieldThread" xreflabel="LeftYieldThread" language="java" linenumbering="numbered">public class LeftYieldThread extends Thread {
	public void run() {
		for( int i = 0; i &lt; 10; i++ ) {
			System.out.print("Left ");
			System.out.print("Left ");
			System.out.print("Left ");
			Thread.yield();
			System.out.println("Left");
		}
	}
}</programlisting>
<programlisting xml:id="program:RightYieldThread" xreflabel="RightYieldThread" language="java" linenumbering="numbered">public class RightYieldThread extends Thread {
	public void run() {
		for( int i = 0; i &lt; 10; i++ ) {
			System.out.print("Right ");
			Thread.yield();
		}
	}
}</programlisting>
<simpara>These new versions of the two classes have essentially replaced calls to
<literal>Thread.sleep()</literal> with calls to <literal>Thread.yield()</literal>. Without the need for
exception handling, the code is simpler, but we have traded one set of
problems for another. If there are other threads operating in the same
application, they will be scheduled in ways that will interfere with the
pattern of yielding. Also, if you are running this code on a machine
with a single processor and a single core, you have a good chance of
seeing something which matches the expected output. If you are running
this on multiple cores, everything will be jumbled. It is likely that
the <literal>LeftYieldThread</literal> will be running on one processor with the
<literal>RightYieldThread</literal> on another. In that case, neither has any competition
to yield to.</simpara>
<simpara>Finally, let us look at a polling solution which still falls short of
the mark. To do this, we need state variables inside of each class to
keep track of whether or not it is done. Each thread needs a reference
to the other thread to make queries, and the driver program must be
updated to add these in before starting the threads.</simpara>
<programlisting xml:id="program:LeftPollingThread" xreflabel="LeftPollingThread" language="java" linenumbering="numbered">public class LeftPollingThread extends Thread {
	private RightThread right;
	private boolean done = false;

	public void setRight( RightPollingThread right ) {
		this.right = right;
	}

	public void run() {
		for( int i = 0; i &lt; 10; i++ ) {
			System.out.print("Left ");
			System.out.print("Left ");
			System.out.print("Left ");
			done = true;
			while( !right.isDone() );
			right.setDone( false );
			System.out.println("Left");
		}
	}

	public boolean isDone()	{ return done; }
	public void setDone( boolean value ) { done = value; }
}</programlisting>
<programlisting xml:id="program:RightPollingThread" xreflabel="RightPollingThread" language="java" linenumbering="numbered">public class RightPollingThread extends Thread {
	private LeftThread left;
	private boolean done = false;

	public void setLeft( LeftPollingThread left ) {
		this.left = left;
	}

	public void run() {
		for( int i = 0; i &lt; 10; i++ ) {
			while( !left.isDone() );
			left.setDone(false);
			System.out.print("Right ");
			done = true;
		}
	}

	public boolean isDone()	{ return done; }
	public void setDone( boolean value ) { done = value; }
}</programlisting>
<simpara>Whether single core or multicore, this solution will always give the
right output. Or it should. Java experts will point out that we are
violating a technicality of the Java Memory Model. Because we are not
using synchronization tools, we have no guarantee that the change of the
<literal>done</literal> variable will even be <emphasis role="strong">visible</emphasis> from one thread to another. In
practice, this problem should affect you rarely, but to be safe, both of
the <literal>done</literal> variables should be declared with the keyword <literal>volatile</literal>.
This keyword makes Java aware that the value may be accessed at any time
from arbitrary threads.</simpara>
<simpara>Another issue is that there is <emphasis role="strong">no</emphasis> concurrency. Each thread must wait
for the other to complete. Of course, this problem does not benefit from
a concurrent solution, but applying this solution to problems which can
benefit from concurrency might cause performance problems. Each thread
wastes time busy waiting in a <literal>while</literal> loop for the other to be done,
consuming CPU cycles while it does so. You will notice that the code
must still be carefully written. Each thread must set the other thread&#8217;s
<literal>done</literal> value to <literal>false</literal>. If threads were responsible for setting their
own <literal>done</literal> values to <literal>false</literal>, one thread might print its information and
go back to the top of the <literal>for</literal> loop before the other thread had reset
its own <literal>done</literal> to <literal>false</literal>.</simpara>
<simpara>In short, coordinating two or more threads together is a difficult
problem. None of the solutions we give here are fully acceptable. We
introduce better tools for coordination and synchronization in
ChapterÂ <xref linkend="chapter:Synchronization"/>.</simpara>
</example>
</section>
<section xml:id="_solution_deadly_virus">
<title>Solution: Deadly virus</title>
<simpara>Finally, we give the solution to the deadly virus problem. By this
point, the threaded part of this problem should not seem very difficult.
It is simpler than some of the examples, such as matrix multiplication.
We begin with the worker class <literal>FactorThread</literal> that can be spawned as a
thread.</simpara>
<formalpara xml:id="program:FactorThread" xreflabel="FactorThread">
<title>Thread class used to find the sum of the two factors of a large odd composite.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class FactorThread extends Thread {
	private long lower;
	private long upper;

	public FactorThread( long lower, long upper ) {
		this.lower = lower;
		this.upper = upper;
	}

	public void run() {
		if( lower % 2 == 0 ) //only check odd numbers
			lower++;
		while( lower &lt; upper ) {
			if( Factor.NUMBER % lower == 0 ) {
				System.out.println("Security code: " +
					(lower + Factor.NUMBER / lower));
				return;
			}
			lower += 2;
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>The constructor for <literal>FactorThread</literal> takes an upper and lower bound,
similar to <literal>MatrixThread</literal>. Once a <literal>FactorThread</literal> object has those
bounds, it can search between them. The number to factor is stored in
the <literal>Factor</literal> class. If any value divides that number evenly, it must be
one of the factors, making the other factor easy to find, sum, and print
out. We have to add a couple of extra lines of code to make sure that we
only search the odd numbers in the range. This solution is tuned for
efficiency for this specific security problem. A program to find general
prime factors would have to be more flexible. Next let us examine the
driver program <literal>Factor</literal>.</simpara>
<formalpara xml:id="program:Factor" xreflabel="Factor">
<title>Driver class which creates threads to lower the average search time for the factors of a large odd composite.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Factor {
	public static final int THREADS = 4;
	public static final long NUMBER = 59984005171248659L;

	public static void main( String[] args ) {
		FactorThread[] threads = new FactorThread[THREADS];
		long root = (long)Math.sqrt(NUMBER); // go to square root
		long start = 3;  // no need to test 2
		long quotient = root / THREADS;
		long remainder = root % THREADS;

		for( int i = 0; i &lt; THREADS; i++ ) {
			long work = quotient;
			if( i &lt; remainder )
				work++;
			threads[i] = new FactorThread( start, start + work );
			threads[i].start();
			start += work;
		}
		try {
			for( int i = 0; i &lt; THREADS; i++ )
				threads[i].join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>Static constants hold both the number to be factored and the number of
threads. In the <literal>main()</literal> method, we create an array of threads for
storage. Then, we create each <literal>FactorThread</literal> object, assigning upper and
lower bounds at the same time, using the standard technique from
SectionÂ <xref linkend="concurrency:Arrays"/> to divide the work fairly. Because we
know the number we&#8217;re dividing isn&#8217;t even, we start with 3. By only
going up to the square root of the number, we know that we will only
find the smaller of the two factors. In that way we can avoid having one
thread find the smaller while another is finds the larger.</simpara>
<simpara>Afterwards, we have the usual <literal>join()</literal> calls to make sure that all the
threads are done. In this problem, these calls are unnecessary. One
thread will print out the correct security code, and the others will
search fruitlessly. If the program went on to do other work, we might
need to let the other threads finish or even interrupt them. Don&#8217;t
forget <literal>join()</literal> calls since they are usually very important.</simpara>
</section>
<section xml:id="_summary_5">
<title>Summary</title>
<simpara>In this chapter we have examined tasks and domains. We have explained
two strategies to obtain a concurrent solution to a programming problem.
One strategy, task decomposition, splits a task into two or more
subtasks. These subtasks can then be packaged as Java threads and
executed on different cores of a multicore processor. Another strategy,
domain decomposition, partitions input data into smaller chunks and
allows different threads to work concurrently on each chunk of data.</simpara>
<simpara>A concurrent solution to a programming problem can execute more quickly
than a sequential solution. Speedup measure how effective a concurrent
solution is at exploiting the architecture of a multicore processor.
Note that not all concurrent programs lead to speedup as some run slower
than their sequential counterparts. Writing a concurrent program is a
challenge that forces us to discover solutions that best exploit a given
processor and OS.</simpara>
<simpara>Java provides a rich set of primitives and syntactic elements to write
concurrent programs. Only a few of these have been introduced in this
chapter. Subsequent chapters give additional tools to code more complex
concurrent programs.</simpara>
</section>
<section xml:id="_exercises_12">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:thread_methods"/> The <literal>start()</literal>, <literal>run()</literal>, and <literal>join()</literal>
methods are essential parts of the process of using threads in Java.
Explain the purpose of each method.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Thread_vs._Runnable"/> What is the difference between
extending the <literal>Thread</literal> class and implementing the <literal>Runnable</literal> interface?
When should you use one over the other?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:sleep_and_yield"/> How do the <literal>Thread.sleep()</literal> method and
the <literal>Thread.yield()</literal> method each affect thread scheduling?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:math_expression"/> Consider the expression in
ExampleÂ <xref linkend="example:Math_expression_tasks"/>. Suppose that the multiply and
exponentiation operations require 1 and 10 time units, respectively.
Compute the number of time units required to evaluate the expression as
in FigureÂ <xref linkend="figure:math_evaluation"/>(a) and (b).</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:multicore-exercise"/> Suppose that a computer has one
quadcore processor. Can the tasks in ExamplesÂ <xref linkend="example:Video game
tasks"/> and <xref linkend="example:Math_expression_tasks"/> be further subdivided to
improve performance on four cores? Why or why not?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:speedup"/> Consider the definition of speedup from
SectionÂ <xref linkend="examples:Concurrency_and_speedup"/>. Let&#8217;s assume you have a
job 1,000,000 units in size. A thread can process 10,000 units of work
every second. It takes an additional 100 units of work to create a new
thread. What is the speedup if you have a dual-core processor and create
2 threads? What if you have a quadcore processor and create 4 threads?
Or an 8-core processor and create 8 threads? You may assume that a
thread does not need to communicate after it has been created.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:speedup_bounds"/> In which situations can speedup be
smaller than the number of processors? Is it ever possible for speedup
to be greater than the number of processors?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Amdahl"/> Amdahl&#8217;s Law is a mathematical description of
the maximum amount you can improve a system by only improving a part of
it. One form of it states that the maximum speedup attainable in a
parallel program is <inlineequation><alt><![CDATA[\frac{1}{1 - P}]]></alt><mathphrase><![CDATA[\frac{1}{1 - P}]]></mathphrase></inlineequation> where <inlineequation><alt><![CDATA[P]]></alt><mathphrase><![CDATA[P]]></mathphrase></inlineequation>
is the fraction of the program which can be parallelized to an arbitrary
degree. If 30% of the work in a program can be fully parallelized but
the rest is completely serial, what is the speedup with 2 processors? 4?
8? What implications does Amdahl&#8217;s Law have?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:task_parallelization"/> Consider the following table of
tasks:</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="middle">Task</entry>
<entry align="center" valign="middle">Time</entry>
<entry align="center" valign="middle">Concurrency</entry>
<entry align="left" valign="middle">Dependency</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Washing Dishes</simpara></entry>
<entry align="center" valign="middle"><simpara>30</simpara></entry>
<entry align="center" valign="middle"><simpara>3</simpara></entry>
<entry align="left" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Cooking Dinner</simpara></entry>
<entry align="center" valign="middle"><simpara>45</simpara></entry>
<entry align="center" valign="middle"><simpara>3</simpara></entry>
<entry align="left" valign="middle"><simpara>Washing Dishes</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Cleaning Bedroom</simpara></entry>
<entry align="center" valign="middle"><simpara>10</simpara></entry>
<entry align="center" valign="middle"><simpara>2</simpara></entry>
<entry align="left" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Cleaning Bathroom</simpara></entry>
<entry align="center" valign="middle"><simpara>30</simpara></entry>
<entry align="center" valign="middle"><simpara>2</simpara></entry>
<entry align="left" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Doing Homework</simpara></entry>
<entry align="center" valign="middle"><simpara>30</simpara></entry>
<entry align="center" valign="middle"><simpara>1</simpara></entry>
<entry align="left" valign="middle"><simpara>Cleaning Bedroom</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In this table, the <emphasis role="strong">Time</emphasis> column gives the number of minutes a task
takes to perform with a single person, the <emphasis role="strong">Concurrency</emphasis> column gives
the maximum number of people who can be assigned to a task, and the
<emphasis role="strong">Dependency</emphasis> column shows which tasks cannot start until other tasks
have been finished. Assume that people assigned to a given task can
perfectly divide the work. In other words, the time a task takes is the
single person time divided by the number of people assigned. What is the
minimum amount of time needed to perform all tasks with only a single
person? What is the minimum amount of time needed to perform all tasks
with an unlimited number of people? What is the smallest number of
people needed to achieve this minimum time?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:interleavings"/> Consider the following code snippet.</simpara>
<programlisting language="java" linenumbering="unnumbered">x = 13;
x = x * 10;</programlisting>
<simpara>Consider this snippet as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">x = 7;
x = x + x;</programlisting>
<simpara>If we assume that these two snippets of code are running on separate
threads but that <literal>x</literal> is a shared variable, what are the possible values
<literal>x</literal> could have after both snippets have run? Remember that the execution
of these snippets can be interleaved in any way.</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:polling"/> Re-implement the array summing problem from
ExampleÂ <xref linkend="example:Array_summation"/> using polling instead of <literal>join()</literal>
calls. Your program should not use a single call to <literal>join()</literal>. Polling is
not an ideal way to solve this problem, but it is worth experimenting
with the technique.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:echo_effect"/> Composers often work with multiple tracks
of music. One track might contain solo vocals, another drums, a third
one violins, and so on. After recording the entire take, a mix engineer
might want to apply special effects such as an echo to one or more
tracks.</simpara>
<simpara>To understand how to add echo to a track, suppose that the track
consists of a list of audio samples. Each sample in a mono (not stereo)
track can be stored as a <literal>double</literal> in an array. To create an echo effect,
we combine the current value of an audio sample with a sample from a
fixed time earlier. This time is called the <emphasis>delay</emphasis> parameter. Varying
the delay can produce long and short echoes.</simpara>
<simpara>If the samples are stored in array <literal>in</literal> and the delay parameter is
stored in variable <literal>delay</literal>, the following code snippet can be used to
create array <literal>out</literal> which contains the sound with an echo.</simpara>
<programlisting language="java" linenumbering="unnumbered">double[] out = new double[in.length + delay];
//sound before echo starts
for( int i = 0; i &lt; delay; i++ )
    out[i] = in[i];
//sound with echo
for( int i = delay; i &lt; in.length; i++ )
    out[i] = a*in[i] + b*in[i - delay];
//echo after sound is over
for( int i = in.length; i &lt; out.length; i++ )
    out[i] = b*in[i - delay];</programlisting>
<simpara>Parameters <literal>a</literal> and <literal>b</literal> are used to control the nature of the echo. When
<literal>a</literal> is <literal>1</literal> and <literal>b</literal> is <literal>0</literal>, there is no echo. When <literal>a</literal> is <literal>0</literal> and <literal>b</literal> is
<literal>1</literal>, there is no mixing. Audio engineers will control the values of <literal>a</literal>
and <literal>b</literal> to create the desired echo effect.</simpara>
<simpara>Write a threaded program that computes the values in <literal>out</literal> in parallel
for an arbitrary number of threads.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:sleep_timer"/> Write a program which takes a number of
minutes and seconds as input. In this program, implement a timer using
<literal>Thread.sleep()</literal> calls. Each second, print the remaining time to the
screen. How accurate is your timer?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:concurrent_approximation"/> As you know,
<inlineequation><alt><![CDATA[\pi\approx
3.1416]]></alt><mathphrase><![CDATA[\pi\approx
3.1416]]></mathphrase></inlineequation>. A more precise value can be found by writing a program which
approximates the area of a circle. The area of a circle can be
approximated by summing up the area of rectangles filling curve of the
arc of the circle. As the width of the rectangle goes to zero, the
approximation becomes closer and closer to the true area. Recall that
that height <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> of a circle centered at the origin at any
distance <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> is given by <inlineequation><alt><![CDATA[y = \sqrt{r^2 - x^2}]]></alt><mathphrase><![CDATA[y = \sqrt{r^2 - x^2}]]></mathphrase></inlineequation>
where <inlineequation><alt><![CDATA[r]]></alt><mathphrase><![CDATA[r]]></mathphrase></inlineequation> is the radius of the circle.</simpara>
<simpara>Write a parallel implementation of this problem which divides up
portions of the arc of the circle among several threads and then sums
the results after they all finish. By setting <inlineequation><alt><![CDATA[r = 2]]></alt><mathphrase><![CDATA[r = 2]]></mathphrase></inlineequation>, you
need only sum one quadrant of a circle to get <inlineequation><alt><![CDATA[\pi]]></alt><mathphrase><![CDATA[\pi]]></mathphrase></inlineequation>. You
will need to use a very small rectangle width to get an accurate answer.
When your program finishes running, you can compare your value against
<literal>Math.PI</literal> for accuracy.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:time-measurement"/> Use the <literal>currentTimeMillis()</literal> method
to measure the time taken to execute a relatively long-running piece of
Java code you have written. Execute your program several times and
compare the execution time you obtain during different executions. Why
do you think the execution times are different?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:thread_overhead"/> Thread creation overhead is an
important consideration in writing efficient parallel programs. Write a
program which creates a large number of threads which do nothing. Test
how long it takes to create and join various numbers of threads. See if
you can determine how long a single thread creation operation takes on
your system, on average.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:matrix_multiply"/> Create serial and concurrent
implementations of matrix multiplication like those described in
ExampleÂ <xref linkend="example:Matrix_multiplication"/>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Experiment with different matrix sizes and thread counts to see how
the speedup performance changes. If possible, run your tests on machines
with different numbers of cores or processors.</simpara>
</listitem>
<listitem>
<simpara>Given a machine with <inlineequation><alt><![CDATA[k>1]]></alt><mathphrase><![CDATA[k>1]]></mathphrase></inlineequation> cores, what is the maximum
speedup you can expect to obtain?</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><xref linkend="exercise:NumberedThread"/> Repeatedly run the code in
ExampleÂ <xref linkend="example:Array_of_threads"/> which creates several
<literal>NumberedThread</literal> objects. Can you discover any patterns in the order
that the threads print? Add a loop and some additional instrumentation
to the <literal>NumberedThread</literal> class which will allow you to measure how long
each thread runs before the next thread has a turn.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:ArraySum"/> Create serial and parallel implementations of
the array summing problem solved in ExampleÂ <xref linkend="example:Array_summation"/>.
Experiment with different array sizes and thread counts to see how
performance changes. How does the speedup differ from matrix multiply?
What happens if you simply sum the numbers instead of taking the sine
first?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:TreeSum"/> The solution to the array summing problem in
ExampleÂ <xref linkend="example:Array_summation"/> seems to use concurrency
half-heartedly. After all the threads have computed their sums, the main
thread sums up the partial sums sequentially.</simpara>
<simpara>An alternative approach is to sum up the partial sums concurrently. Once
a thread has computed the sum of the sines of each partition, the sums
of each pair of neighboring partitions should be merged into a single
sum. The process can be repeated until the final sum has been computed.
At each step, half of the remaining threads will have nothing left to do
and will stop. The pattern of summing is like a tree which starts with
<inlineequation><alt><![CDATA[k]]></alt><mathphrase><![CDATA[k]]></mathphrase></inlineequation> threads working at the first stage,
<inlineequation><alt><![CDATA[\frac{k}{2}]]></alt><mathphrase><![CDATA[\frac{k}{2}]]></mathphrase></inlineequation> working at the second stage,
<inlineequation><alt><![CDATA[\frac{k}{4}]]></alt><mathphrase><![CDATA[\frac{k}{4}]]></mathphrase></inlineequation> working at the third, and so on, until a
single thread completes the summing process.</simpara>
<figure>
<title>Example of concurrent tree-style summation with 8 threads.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/13-concurrency/images/treesummation.svg" width="100%"/>
</imageobject>
<textobject><phrase>treesummation</phrase></textobject>
</mediaobject>
</figure>
<simpara>Update the <literal>run()</literal> method in the <literal>SumThread</literal> class so that it adds its
assigned elements as before and then adds its neighbors sum to its own.
To do so, it must use the <literal>join()</literal> method to wait for the neighboring
thread. It should perform this process repeatedly. After summing their
own values, each even numbered thread should add in the partial sum from
its neighbor. At the next step, each thread with a number divisible by 4
should add the partial sum from its neighbor. At the next step, each
thread with a number divisible by 8 should add the partial sum from its
neighbor, and so on. Thread 0 will perform the final summation.
Consequently, the main thread only needs to wait for thread 0. So that
each thread can wait for other threads, the <literal>threads</literal> array will need to
be a static field. FigureÂ <xref linkend="figure:tree_summation"/> illustrates this
process.</simpara>
<simpara>Once you have implemented this design, test it against the original
<literal>SumThread</literal> class to see how it performs. Restrict the number of threads
you create to a power of 2 to make it easier to determine which threads
wait and which threads terminate.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Synchronization">
<title>Synchronization</title>
<blockquote>
<attribution>
Mary Catherine Bateson
</attribution>
<simpara>Sharing is sometimes more demanding than giving.</simpara>
</blockquote>
<section xml:id="_introduction_3">
<title>Introduction</title>
<simpara>Concurrent programs allow multiple threads to be scheduled and executed,
but the programmer does not have a great deal of control over when
threads execute. As explained in SectionÂ <xref linkend="concepts:Thread_scheduling"/>,
the JVM and the underlying OS are responsible for scheduling threads
onto processor cores.</simpara>
<simpara>While writing a concurrent program, you have to ensure that the program
will work correctly even though different executions of the same program
will likely lead to different sequences of thread execution. The problem
we introduce next illustrates why one thread execution sequence might be
perfectly fine while another might lead to unexpected and incorrect
behavior (and even people starving!)</simpara>
</section>
<section xml:id="_problem_dining_philosophers">
<title>Problem: Dining philosophers</title>
<simpara>Concurrency gives us the potential to make our programs faster but
introduces a number of other problems. The way that threads interact can
be unpredictable. Because they share memory, one thread can corrupt the
value in another thread&#8217;s variables. We introduce synchronization tools
in this chapter that can prevent threads from corrupting data, but these
tools create new pitfalls. To explore these pitfalls, we give you
another problem to solve.</simpara>
<simpara>Imagine a number of philosophers sitting at a round table with plates
that are periodically filled with rice. Between adjacent philosophers
are single chopsticks so that there are exactly the same number of
chopsticks as there are philosophers. These philosophers only think and
eat. In order to eat, a philosopher must pick up both the chopstick on
her left and the chopstick on her right. FigureÂ <xref linkend="figure:dining"/> shows
an example of the situation.</simpara>
<figure role="text-center">
<title>Table for five dining philosophers.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/14-synchronization/images/diners.svg" width="50%"/>
</imageobject>
<textobject><phrase>diners</phrase></textobject>
</mediaobject>
</figure>
<simpara>Your goal is to write a class called <literal>DiningPhilosopher</literal> which extends
<literal>Thread</literal>. Each thread created in the <literal>main()</literal> method should be a
philosopher who thinks for some random amount of time, then acquires the
two necessary chopsticks and eats. No philosopher should starve. No
philosophers should be stuck indefinitely fighting over chopsticks.</simpara>
<simpara>Although this problem sounds simple, the solution is somewhat complex.
Make sure that you understand the concepts and Java syntax in this
chapter thoroughly before trying to implement your solution. It is
important that no two philosophers try to use the same chopstick at the
same time. Likewise, we need to avoid a situation where every
philosopher is waiting for every other philosopher to give up a
chopstick.</simpara>
</section>
<section xml:id="_concepts_thread_interaction">
<title>Concepts: Thread interaction</title>
<simpara>This dining philosopher problem highlights some difficulties which were
emerging toward the end of the last chapter. In
ExerciseÂ <xref linkend="exercise:interleavings"/> two snippets of code could run
concurrently and modify the same shared variable, potentially producing
incorrect output. Because of the nondeterministic nature of scheduling,
we have to assume that the code executing in two or more threads can be
interleaved in any possible way. When the <emphasis role="strong">result</emphasis> of computation
changes depending on the order of thread execution, it is called a <emphasis>race
condition</emphasis>. Below is a simple example of a race condition in Java.</simpara>
<formalpara xml:id="program:RaceCondition" xreflabel="RaceCondition">
<title>A short example of a race condition.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class RaceCondition extends Thread {
	private static int counter = 0;
	public static final int THREADS = 4;
	public static final int COUNT = 1000000;

	public static void main( String[] args ) {
		RaceCondition[] threads = new RaceCondition[THREADS];
		for( int i = 0; i &lt; THREADS; i++ ) {
			threads[i] = new RaceCondition();
			threads[i].start();
		}
		try {
			for( int i = 0; i &lt; THREADS; i++ )
				threads[i].join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		System.out.println("Counter:\t" + counter );
	}

	public void run() {
		for( int i = 0; i &lt; COUNT / THREADS; i++ )
			counter++;
	}
}</programlisting>
</para>
</formalpara>
<simpara>This short (and pointless) class attempts to increment the variable
<literal>counter</literal> until it reaches <literal>1000000</literal>. To illustrate the race condition,
we have divided the work of incrementing <literal>counter</literal> evenly among a number
of threads. If you run this program, the final value of <literal>counter</literal> will
often not be <literal>1000000</literal>. Depending on which JVM, OS, and how many cores
you have, you may never get <literal>1000000</literal>, and the answer you do get will
vary a lot. On all systems, if you change the value of <literal>THREADS</literal> to <literal>1</literal>,
the answer should always be correct.</simpara>
<simpara>Looking at the code, the problem might not be obvious. Everything
centers on the statement <literal>counter++</literal> in the <literal>for</literal> loop inside the
<literal>run()</literal> method. But, this statement appears to execute in a single step!
Each thread should increase the value of <literal>counter</literal> a total of
<literal>COUNT/THREADS</literal> times, adding up to <literal>1000000</literal>. The trouble is that
<literal>counter++</literal> is not a single step. Recall that <literal>counter++</literal> is shorthand
for <literal>counter = counter + 1</literal>. To be even more explicit we could write it
as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">temp = counter;
counter = temp + 1;</programlisting>
<simpara>One thread may get as far as storing <literal>counter</literal> into a temporary
location, but then it runs out of time and the next thread in the
schedule runs. If that is the case, this next thread may do a series of
increments to <literal>count</literal> which are all overwritten when the first thread
runs again. Because the first thread had an old value of <literal>counter</literal>
stored in <literal>temp</literal>, adding 1 to <literal>temp</literal> has the effect of ignoring many
increments. This situation can happen on a single processor with threads
switching back and forth, but it is even more dangerous on a multicore
system.</simpara>
<simpara>The primary lesson here is that threads can switch between each other at
any time with unpredictable effects. The secondary lesson is that the
source code is too coarse-grained to show <emphasis>atomic</emphasis> operations. An atomic
operation is one which cannot be interrupted by a context switch to
another thread. The actual code that the JVM runs is much lower level
than source code.</simpara>
<simpara>We can&#8217;t easily force a non-atomic operation to be atomic, but there are
ways to restrict access to certain pieces of code under certain
conditions. The name we give to a piece of code which should not be
accessed by more than one thread at a time is a <emphasis>critical section</emphasis>. In
the example above, the single line of code which increments <literal>counter</literal> is
a critical section, and the error in the program would be removed if
only one thread were able to run that line of code at a time.</simpara>
<simpara>Protecting a critical section is done with <emphasis>mutual exclusion</emphasis> tools.
They are called mutual exclusion tools because they enforce the
requirement that one thread executing a critical section excludes the
possibility of another. There are many different techniques, algorithms,
and language features in computer science which can be used to create
mutual exclusion. Java relies heavily on a tool called a <emphasis>monitor</emphasis> which
hides some of the details of enforcing mutual exclusion from the user.
Mutual exclusion is a deeply researched topic with many approaches other
than monitors. If you plan to write concurrent programs in another
language, you may need to brush up on the features provided by that
language.</simpara>
</section>
<section xml:id="_syntax_thread_synchronization">
<title>Syntax: Thread synchronization</title>
<section xml:id="_the_literal_synchronized_literal_keyword">
<title>The <literal>synchronized</literal> keyword</title>
<simpara>In Java, the language feature which allows you to enforce mutual
exclusion is the <literal>synchronized</literal> keyword. There are two ways to use this
keyword: with a method or with an arbitrary block of code. In the method
version, you add the <literal>synchronized</literal> modifier before the return type.
Let&#8217;s imagine a class with a private <literal>String</literal> field called <literal>message</literal>
which is set to be <literal>"Will Robinson!"</literal> by the constructor. Now, we define
the following method.</simpara>
<programlisting language="java" linenumbering="unnumbered">public synchronized void danger() {
    message = "Danger, " + message;
}</programlisting>
<simpara>If <literal>danger()</literal> is called five times from different threads, <literal>message</literal>
will contain<?asciidoc-br?>
<literal>"Danger, Danger, Danger, Danger, Danger, Will Robinson!"</literal> Without the
<literal>synchronized</literal> keyword, <literal>danger()</literal> would suffer from a race condition
similar to the one in <literal>RaceCondition</literal>. Some of the <literal>String</literal>
concatenations might be overwritten by other calls to <literal>danger()</literal>. You
would never have more than five copies of <literal>"Danger, "</literal> appended to the
beginning of <literal>message</literal>, but you might have fewer.</simpara>
<simpara>Any time a thread enters a piece of code protected by the <literal>synchronized</literal>
keyword, it implicitly acquires a lock which only a single thread can
hold. If another thread tries to access the code, it is forced to wait
until the lock is released. This lock is <emphasis>re-entrant</emphasis>. Re-entrant means
that, when a thread currently holds a lock and tries to get it again, it
succeeds. This situation frequently occurs with synchronized methods
which call other synchronized methods.</simpara>
<simpara>Consider method <literal>safety()</literal> which does the &#8220;opposite&#8221; of <literal>danger()</literal>, by
removing occurrences of <literal>"Danger, "</literal> from the beginning of <literal>message</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public synchronized void safety() {
    if( message.startsWith("Danger, ") )
        message = message.substring( 8 );
}</programlisting>
<simpara>Will the <literal>danger()</literal> and <literal>safety()</literal> methods play nicely together? In
other words, will a thread be blocked from entering <literal>safety()</literal> if
another thread is already in <literal>danger()</literal>? Yes! The locks in Java are
connected to objects. When you use the <literal>synchronized</literal> keyword on a
method, the object the method is being called on (whichever object
<literal>this</literal> refers to inside the method) serves as the lock. Thus, only one
thread can be inside of either of these methods. If you have 10
synchronized methods in an object, only one of them can execute at a
time in a given object.</simpara>
<simpara>Perhaps this level of control is too restrictive. You may have six
methods which conflict with each other and four others which conflict
with each other but not the first six. Using <literal>synchronized</literal> in each
method declaration would unnecessarily limit the amount of concurrency
your program could have.</simpara>
<simpara>Although it takes a little more work, using <literal>synchronized</literal> with a block
of code allows more fine-grained control. The following version of
<literal>danger()</literal> is equivalent to the earlier one.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void danger() {
    synchronized( this ) {
        message = "Danger, " + message;
    }
}</programlisting>
<simpara>Using <literal>synchronized</literal> on a block of code gives us more flexibility in two
ways. First, we can choose exactly how much code we want to control,
instead of the whole method. Second, we can choose which object we want
to use for synchronization. For the block style, any arbitrary object
can be used as a lock. Objects keep a list of threads which are waiting
to get the lock and do all the other management needed to make the
<literal>synchronized</literal> keyword work.</simpara>
<simpara>If you have two critical sections which are unrelated to each other, you
can use the fine-grained control the block style provides. First, you&#8217;ll
need some objects to use as locks, probably declared so that they can
easily be shared, perhaps as static fields of a class.</simpara>
<programlisting language="java" linenumbering="unnumbered">private static Object lock1 = new Object();
private static Object lock2 = new Object();</programlisting>
<simpara>Then, wherever you need control over concurrency, you use them as locks.</simpara>
<programlisting language="java" linenumbering="unnumbered">synchronized( lock1 ) {
    //do dangerous thing 1
}

//do safe things

synchronized( lock2 ) {
    //do dangerous thing 2, unrelated to dangerous thing 1
}</programlisting>
<simpara>Since declaring a method with <literal>synchronized</literal> is equivalent to having its
body enclosed in a block beginning with <literal>synchronized(this)</literal>, what about
<literal>static</literal> methods? Can they be <literal>synchronized</literal>? Yes, they can. Whenever a
class is loaded, Java creates an object of type <literal>Class</literal> which
corresponds to that class. This object is what synchronized static
methods inside the class will use as a lock. For example, a synchronized
static method inside of the <literal>Eggplant</literal> class will lock on the object
<literal>Eggplant.class</literal>.</simpara>
</section>
<section xml:id="_the_literal_wait_literal_and_literal_notify_literal_methods">
<title>The <literal>wait()</literal> and <literal>notify()</literal> methods</title>
<simpara>Protecting critical sections with the <literal>synchronized</literal> keyword is a
powerful technique, and many other synchronization tools can be built
using just this tool. However, efficiency demands a few more options.</simpara>
<simpara>Sometimes a thread is waiting for another thread to finish a task so
that it can process the results. Imagine one thread collecting votes
while another one is waiting to count them. In this example, the
counting thread must wait for all votes to be cast before it can begin
counting. We could use a synchronized block and an indicator <literal>boolean</literal>
called <literal>votingComplete</literal> to allow the collector thread to signal to the
counting thread.</simpara>
<programlisting language="java" linenumbering="unnumbered">while( true ) {
    synchronized( this ) {
        if( votingComplete )
            break;
    }
}
countVotes();</programlisting>
<simpara>What&#8217;s the problem with this design? Notice that the counting thread is
running through the <literal>while</literal> loop over and over waiting for
<literal>votingComplete</literal> to become <literal>true</literal>. On a single processor, the counting
thread would slow down the job of the collecting thread which is trying
to process all the votes. On a multicore system, the counting thread is
still wasting CPU cycles that some other thread could use. This
phenomenon is known as <emphasis>busy waiting</emphasis>, for obvious reasons.</simpara>
<simpara>To combat this problem, Java provides the <literal>wait()</literal> method. When a thread
is executing synchronized code, it can call <literal>wait()</literal>. Instead of busy
waiting, a thread which has called <literal>wait()</literal> will be removed from the
list of running threads. It will wait in a dormant state until someone
comes along and notifies the thread that its waiting is done. If you
recall the threadstate diagram from ChapterÂ <xref linkend="chapter:Concurrent
Programming"/>, there is a Not Runnable state which threads enter by
calling <literal>sleep()</literal>, calling <literal>wait()</literal>, or performing blocking I/O. Using
<literal>wait()</literal>, we can rewrite the vote counting thread.</simpara>
<programlisting language="java" linenumbering="unnumbered">synchronized( this ) {
    while( !votingComplete ) {
        wait();
    }
}
countVotes();</programlisting>
<simpara>Notice that the <literal>while</literal> loop has moved inside the synchronized block.
Doing so before might have kept our program from terminating: As long as
the vote counting thread held the lock, the vote collecting thread would
not be allowed to modify <literal>votingComplete</literal>. When a thread calls <literal>wait()</literal>,
however, it gives up the corresponding lock it is holding until it wakes
up and runs again. Why use the <literal>while</literal> loop at all, now? There is no
guarantee that the condition you are waiting for is <literal>true</literal>. Many threads
may be waiting on this particular lock. We use the <literal>while</literal> loop to check
that <literal>votingComplete</literal> is <literal>true</literal> and wait again if it isn&#8217;t.</simpara>
<simpara>In order to notify a waiting thread, the other thread calls the
<literal>notify()</literal> method. Like <literal>wait()</literal>, <literal>notify()</literal> must be called within a
synchronized block or method. Here is corresponding code the vote
collecting thread would use to notify the counting thread that voting is
complete.</simpara>
<programlisting language="java" linenumbering="unnumbered">// finish collecting votes
synchronized( this ) {
    votingComplete = true;
    notifyAll();
}</programlisting>
<simpara>A call to <literal>notify()</literal> will wake up one thread waiting on the lock object.
If there are many threads waiting, the method <literal>notifyAll()</literal> used above
can be called to wake them all up. In practice, it is usually safer to
call <literal>notifyAll()</literal>. If a particular condition changes and a single
waiting thread is notified, that thread may need to notify the next
waiting thread when it is done. If your code is not very carefully
designed, some thread may end up waiting forever and never be notified
if you only rely on <literal>notify()</literal>.</simpara>
<example>
<title>Producer/consumer</title>
<simpara>To illustrate the use of <literal>wait()</literal> and <literal>notify()</literal> calls inside of
synchronized code, we give a simple solution to the producer/consumer
problem below. This problem is a classic example in the concurrent
programming world. Many times one thread (or a group of threads) is
producing data, perhaps from some input operation. At the same time, one
thread (or, again, potentially many threads) are taking these chunks of
data and consuming them by performing some computational or output task.</simpara>
<simpara>Every resource inside of a computer is finite. Producer/consumer
problems often assume a bounded buffer which stores items from the
producer until the consumer can take them away. Our solution does all
synchronization on the buffer. Many different threads can share this
buffer, but all accesses will be controlled.</simpara>
<formalpara xml:id="program:Buffer" xreflabel="Buffer">
<title>An example of a synchronized buffer.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Buffer {
	public final static int SIZE = 10;
	private Object[] objects = new Object[SIZE];
	private int count = 0;

	public synchronized void addItem( Object object )
		throws InterruptedException {
		while( count == SIZE )
			wait();
		objects[count] = object;
		count++;
		notifyAll();
	}

	public synchronized Object removeItem()
		throws InterruptedException {
		while( count == 0 )
			wait();
		count--;
		Object object = objects[count];
		notifyAll();
		return object;
	}
}</programlisting>
</para>
</formalpara>
<simpara>When adding an item, producers enter the synchronized <literal>addItem()</literal>
method. If <literal>count</literal> shows that the buffer is full, the producer must wait
until the buffer has at least one open space. After adding an item to
the buffer, the producer then notifies all waiting threads. The consumer
does the mirror image in <literal>removeItem()</literal>. A consumer thread cannot
consume anything if the buffer is empty and must then wait. After there
is an object to consume, the consumer removes it and notifies all other
threads.</simpara>
<simpara>Both methods are synchronized, making access to the buffer completely
sequential. Although it seems undesirable, sequential behavior is
precisely what is needed for the producer/consumer problem. All
synchronized code is a protection against unsafe concurrency. The goal
is to minimize the amount of time spent in synchronized code and get
threads back to concurrent execution as quickly as possible.</simpara>
</example>
<example>
<title>Bank account</title>
<simpara>Although producer/consumer is a good model to keep in mind, there are
other ways that reading and writing threads might interact. Consider the
following programming problem, similar to one you might find in real
life.</simpara>
<simpara>As a rising star in a bank&#8217;s IT department, you have been given the job
of creating a new bank account class called <literal>SynchronizedAccount</literal>. This
class must have methods to support the following operations: deposit,
withdraw, and check balance. Each method should print a status message
to the screen on completion. Also, the method for withdraw should return
<literal>false</literal> and do nothing if there are insufficient funds. Because the
latest system is multi-threaded, these methods must be designed so that
the bookkeeping is consistent even if many threads are accessing a
single account. No money should magically appear or disappear.</simpara>
<simpara>There is an additional challenge. To maximize concurrency,
<literal>SynchronizedAccount</literal> should be synchronized differently for read and
write accesses. Any number of threads should simultaneously be able to
check the balance on an account, but only one thread can deposit or
withdraw at a time.</simpara>
<simpara>To solve this problem, our implementation of the class has a <literal>balance</literal>
variable to record the balance, but it also has a <literal>readers</literal> variable to
keep track of the number of threads which are reading from the account
at any given time.</simpara>
<programlisting language="java" linenumbering="numbered">public class SynchronizedAccount {
	private double balance = 0.0;
	private int readers = 0;</programlisting>
<simpara>Next, the <literal>getBalance()</literal> method is called by threads which wish to read
the balance. Access to the <literal>readers</literal> variable is synchronized. But,
after passing that first <literal>synchronized</literal> block, the code which stores the
balance is not synchronized. In this way, multiple readers can access
the data at the same time. For this example, the concurrency controls we
have are overkill. The command <literal>amount = balance</literal> does not take a great
deal of time. If it did, however, it would make sense for readers to
execute it concurrently as we do. After reading the balance, this method
decrements <literal>readers</literal>. If <literal>readers</literal> reaches 0, a call to <literal>notifyAll()</literal> is
made, signaling that threads trying to deposit to or withdraw from the
account can continue.</simpara>
<programlisting language="java" linenumbering="numbered">	public double getBalance()	throws InterruptedException {
		double amount;
		synchronized( this ) {
			readers++;
		}
		amount = balance;
		synchronized( this ) {
			if( --readers == 0 )
				notifyAll();
		}
		return amount;
	}</programlisting>
<simpara>The <literal>deposit()</literal> and <literal>withdraw()</literal> methods are wrappers for the
<literal>changeBalance()</literal> method, which has all the interesting concurrency
controls.</simpara>
<programlisting language="java" linenumbering="numbered">	public void deposit( double amount )
		throws InterruptedException {
		changeBalance( amount );
		System.out.println("Deposited $" + amount + "." );
	}

	public boolean withdraw( double amount )
		throws InterruptedException {
		boolean success = changeBalance( -amount );
		if( success )
			System.out.println("Withdrew $" + amount + "." );
		else
			System.out.println("Failed to withdraw $" +
				amount + ": insufficient funds." );
		return success;
	}</programlisting>
<simpara>The <literal>changeBalance()</literal> method is synchronized so that it can have
exclusive access to the <literal>readers</literal> variable. As long as <literal>readers</literal> is
greater than 0, this method will wait. Eventually, the readers should
finish their job and notify the waiting writer which can finish changing
the balance of the account.</simpara>
<programlisting language="java" linenumbering="numbered">	private synchronized boolean changeBalance( double amount )
		throws InterruptedException {
		boolean success;
		while( readers &gt; 0 )
				wait();
		if( success = (balance + amount &gt; 0) )
			balance += amount;
		return success;
	}
}</programlisting>
</example>
</section>
</section>
<section xml:id="_pitfalls_synchronization_challenges">
<title>Pitfalls: Synchronization challenges</title>
<simpara>As you can see from the dining philosophers problem, synchronization
tools help us get the right answer but also create other difficulties.</simpara>
<section xml:id="subsection:deadlock">
<title>Deadlock</title>
<simpara><emphasis>Deadlock</emphasis> is the situation when two or more threads are both waiting
for the others to complete, forever. Some combination of locks or other
synchronization tools has forced a blocking dependence onto a group of
threads which will never be resolved.</simpara>
<simpara>In the past, people have described four conditions which must exist for
deadlock to happen.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mutual Exclusion: Only one thread can access the resource (often a
lock) at a time.</simpara>
</listitem>
<listitem>
<simpara>Hold and Wait: A thread holding a resource can ask for additional
resources.</simpara>
</listitem>
<listitem>
<simpara>No Preemption: A thread holding a resource cannot be forced to
release it by another thread.</simpara>
</listitem>
<listitem>
<simpara>Circular Wait: Two or more threads hold resources which make up a
circular chain of dependency.</simpara>
</listitem>
</orderedlist>
<example>
<title>Deadlock philosophers</title>
<simpara>We illustrate deadlock with an example of how <emphasis role="strong">not</emphasis> to solve the dining
philosophers problem. What if all the philosophers decided to pick up
the chopstick on her right and then the chopstick on her left? If the
timing was just right, each philosopher would be holding one chopstick
in her right hand and be waiting forever for her neighbor on the left to
give up a chopstick. No philosopher would ever be able to eat. Here is
that scenario illustrated in code.</simpara>
<programlisting language="java" linenumbering="numbered">public class DeadlockPhilosopher extends Thread {
	public static final int SEATS = 5;
	private static boolean[] chopsticks = new boolean[SEATS];
	private int seat;

	public DeadlockPhilosopher( int seat ) {
		this.seat = seat;
	}</programlisting>
<simpara>After setting up the class and the constructor, things get interesting
in the <literal>run()</literal> method. First a philosopher tries to get her left
chopstick, then sleeps for 50 milliseconds, then tries to get her right
chopstick. Without sleeping, this code would usually run just fine.
Every once in a while, the philosophers would become deadlocked, but it
would be hard to predict when. By introducing the sleep, we can all but
guarantee that the philosophers will deadlock every time.</simpara>
<programlisting language="java" linenumbering="numbered">	public void run() {
		try	{
			getChopstick( seat );
			Thread.sleep(50);
			getChopstick( seat - 1 );
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		eat();
	}</programlisting>
<simpara>The remaining two methods are worth examining to see how the
synchronization is done, but by getting the two chopsticks separately
above, we have already gotten ourselves into trouble.</simpara>
<programlisting language="java" linenumbering="numbered">	private void getChopstick( int location )
		throws InterruptedException {
		if( location &lt; 0 )
			location += SEATS;
		synchronized( chopsticks ) {
			while( chopsticks[location] )
				chopsticks.wait();
			chopsticks[location] = true;
		}
		System.out.println("Philosopher " + seat +
			" picked up chopstick " + location + ".");
	}

	private void eat() {
		//done eating, put back chopsticks
		synchronized( chopsticks ) {
			chopsticks[seat] = false;
			if( seat == 0)
				chopsticks[SEATS - 1] = false;
			else
				chopsticks[seat - 1] = false;
			chopsticks.notifyAll();
		}
	}
}</programlisting>
</example>
<example>
<title>Deadlock sum</title>
<simpara>Here is another example of deadlock. We emphasize deadlock because it is
one of the most common and problematic issues with using synchronization
carelessly.</simpara>
<simpara>Consider two threads which both need access to two separate resources.
In our example, the two resources are random number generators. The goal
of each of these threads is to acquire locks for the two shared random
number generators, generate two random numbers each, and sum the numbers
generated. (Note that locks are unnecessary for this problem anyway,
because access to <literal>Random</literal> objects is synchronized.)</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.Random;

public class Deadlock extends Thread {
	private static Random random1 = new Random();
	private static Random random2 = new Random();
	private boolean reverse;
	private int sum;</programlisting>
<simpara>The class begins as expected, creating shared <literal>static</literal> <literal>Random</literal> objects
<literal>random1</literal> and <literal>random2</literal>. Then, in the <literal>main()</literal> method, the main thread
spawns two new threads, passing <literal>true</literal> to one and <literal>false</literal> to the other.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void main(String[] args) {
		Thread thread1 = new Deadlock( true );
		Thread thread2 = new Deadlock( false );
		thread1.start();
		thread2.start();
		try {
			thread1.join();
			thread2.join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
	}</programlisting>
<simpara>Next, the mischief begins to unfold. One of the two threads stores
<literal>true</literal> in its <literal>reverse</literal> field.</simpara>
<programlisting language="java" linenumbering="numbered">	public Deadlock( boolean reverse ) {
		this.reverse = reverse;
	}</programlisting>
<simpara>Finally, we have the <literal>run()</literal> method where all the action happens. If the
two running threads both acquire locks for <literal>random1</literal> and <literal>random2</literal> in
the same order, everything would work out fine. However, the reversed
thread locks on <literal>random2</literal> and then <literal>random1</literal>, with a <literal>sleep()</literal> in
between. The non-reversed thread tries to lock on <literal>random1</literal> and then
<literal>random2</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">	public void run() {
		if( reverse ) {
	        synchronized(random2) {
			  System.out.println(
				"Reversed Thread: synchronized on random2");
			  try{ Thread.sleep(50); }
			  catch (InterruptedException e) {
				  e.printStackTrace();
			  }
			  synchronized(random1) {
			    System.out.println(
					"Reversed Thread: synchronized on random1");
			    sum = random1.nextInt() + random2.nextInt();
			  }
	        }
	    }
		else {
	        synchronized(random1) {
			  System.out.println(
				"Normal Thread: synchronized on random1");
			  try { Thread.sleep(50); }
			  catch (InterruptedException e) {
				  e.printStackTrace();
			  }
			  synchronized(random2) {
			    System.out.println(
					"Normal Thread: synchronized on random2");
			    sum = random1.nextInt() + random2.nextInt();
			  }
		        }
		}
	}
}</programlisting>
<simpara>If you run this code, it should invariably deadlock with <literal>thread1</literal>
locked on <literal>random2</literal> and <literal>thread2</literal> locked on <literal>random1</literal>. No sane
programmer would intentionally code the threads like this. In fact, the
extra work we did to acquire the locks in opposite orders is exactly
what causes the deadlock. For more complicated programs, there may be
many different kinds of threads and many different resources. If two
different threads (perhaps written by different programmers, even) need
both resource A and resource B at the same time but try to acquire them
in reverse order, this kind of deadlock can occur without such an
obvious cause.</simpara>
<simpara>For deadlock of this type, the circular wait condition can be broken by
ordering the resources and always locking the resources in ascending
order. Of course, this solution only works if there is some universal
way of ordering the resources and the ordering is always followed by all
code in the program.</simpara>
<simpara>Ignoring the deadlock problems with the example above, it gives a nice
example of the way Java intended synchronization to be done: when
possible, use the resource you need as its own lock. Many other
languages require programmers to create additional locks or semaphores
to protect a given resource, but this approach causes problems if the
same lock is not consistently used. Using the resource itself as a lock
elegantly avoids this problem.</simpara>
</example>
</section>
<section xml:id="section:starvation_and_livelock">
<title>Starvation and livelock</title>
<simpara><emphasis>Starvation</emphasis> is another problem which can occur with careless use of
synchronization tools. Starvation is a general term which covers any
situation in which some thread never gets access to the resources it
needs. Deadlock can be viewed as a special case of starvation since none
of the threads which are deadlocking make progress.</simpara>
<simpara>The dining philosophers problem was framed around the idea of eating
with humorous intent. If a philosopher is never able to acquire
chopsticks, that philosopher will quite literally starve.</simpara>
<simpara>Starvation does not necessarily mean deadlock, however. Examine the
implementation in ExampleÂ <xref linkend="example:Bank_account"/> for the bank account.
That solution is correct in the sense that it preserves mutual
exclusion. No combination of balance checks, deposits, or withdrawals
will cause the balance to be incorrect. Money will neither be created
nor destroyed. A closer inspection reveals that the solution is not
entirely fair. If a single thread is checking the balance, no other
thread can make a deposit or a withdrawal. Balance checking threads
could be coming and going constantly, incrementing and decrementing the
<literal>readers</literal> variable, but if <literal>readers</literal> never goes down to zero, threads
waiting to make deposits and withdrawals will wait forever.</simpara>
<simpara>Another kind of starvation is <emphasis>livelock</emphasis>. In deadlock, two or more
threads get stuck and wait forever, doing nothing. Livelock is similar
except that the two threads keep executing code and waiting for some
condition that never arrives. A classic example of livelock is two
polite (but oddly predictable) people who are speaking with each other:
Both happen to start talking at exactly the same moment and then stop to
hear what the other has to say. After exactly one second, they both
begin again and immediately stop. Lather, rinse, repeat.</simpara>
<example>
<title>Livelock party preparations</title>
<simpara>Imagine three friends who are going to a party. Each of them starts
getting ready at different times. They follow the pattern of getting
ready for a while, waiting for their friends to get ready, and then
calling their friends to see if the other two are ready. If all three
are ready, then the friends will leave. Unfortunately, if a friend calls
and either of the other two aren&#8217;t ready, he&#8217;ll become frustrated and
stop being ready. Perhaps he&#8217;ll realize that he&#8217;s got time to take a
shower or get involved in some other activity for a while. After
finishing that activity, he&#8217;ll become ready again and wait for his
friends to become ready.</simpara>
<simpara>If the timing is just right, the three friends will keep becoming ready,
waiting for a while, and then becoming frustrated when they realize that
their friends aren&#8217;t ready. Here is a rough simulation of this process
in code.</simpara>
<programlisting language="java" linenumbering="numbered">public class Livelock extends Thread {
	private static int totalReady = 0;
	private static Object lock = new Object();

	public static void main(String[] args) {
		Livelock friend1 = new Livelock();
		Livelock friend2 = new Livelock();
		Livelock friend3 = new Livelock();</programlisting>
<simpara>The first few lines create a shared variable called <literal>totalReady</literal> which
keeps track of the total number of friends ready. To avoid race
conditions, a shared <literal>Object</literal> called <literal>lock</literal> will be used to control
access to <literal>totalReady</literal>. Then, the <literal>main()</literal> method creates <literal>Livelock</literal>
objects representing each of the friends.</simpara>
<programlisting language="java" linenumbering="numbered">		try {
			friend1.start();
			Thread.sleep(100);
			friend2.start();
			Thread.sleep(100);
			friend3.start();

			friend1.join();
			friend2.join();
			friend3.join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		System.out.println("All ready!");
	}</programlisting>
<simpara>The rest of the <literal>main()</literal> method starts each of the threads representing
the friends running, with a 100 millisecond delay before the next thread
starts . Then, the <literal>main()</literal> method waits for them all to finish. If
successful, it will print <literal>All ready!</literal> to the screen.</simpara>
<programlisting language="java" linenumbering="numbered">	public void run() {
		boolean done = false;

		try {
			while( !done ) {
				Thread.sleep(75); //prepare for party
				synchronized( lock ) {
					totalReady++;
				}
				Thread.sleep(75); //wait for friends
				synchronized( lock ) {
					if( totalReady &gt;= 3 )
						done = true;
					else
						totalReady--;
				}
			}
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
	}
}</programlisting>
<simpara>In the <literal>run()</literal> method, each friend goes through a loop until the <literal>done</literal>
variable is <literal>true</literal>. In this loop, an initial call to <literal>Thread.sleep()</literal>
for 75 milliseconds represents preparing for the party. After that,
<literal>totalReady</literal> is incremented by one. Then, the friend waits for another
75 milliseconds. Finally, he checks to see if everyone else is ready by
testing whether <literal>totalReady</literal> is <literal>3</literal>. If not, he decrements <literal>totalReady</literal>
and repeats the process.</simpara>
<simpara>At roughly 75 milliseconds into the simulation, the first friend becomes
ready, but he doesn&#8217;t check with his friends until 150 milliseconds.
Unfortunately, the second friend doesn&#8217;t become ready until 175
milliseconds. He then checks with his friends at 225 milliseconds,
around which time the first friend is becoming ready a second time.
However, the third friend isn&#8217;t ready until 275 milliseconds. When he
then checks at 350 milliseconds, the first friend isn&#8217;t ready anymore.
On some systems the timing might drift such that the friends all become
ready at the same time, but it could take a long, long while.</simpara>
<simpara>In reality, human beings would not put off going to a party
indefinitely. Some people would decide that it was too late to go.
Others would go alone. Others would go over to their friends' houses and
demand to know what was taking so long. Computers are not nearly as
sensible and must obey instructions, even if they cause useless
repetitive patterns. Realistic examples of livelock are hard to show in
a short amount of code, but they do crop up in real systems and can be
very difficult to predict.</simpara>
</example>
</section>
<section xml:id="_sequential_execution">
<title>Sequential execution</title>
<simpara>When designing a parallel program, you may notice that synchronization
tools are necessary to get a correct answer. Then, when you run this
parallel version and compare it to the sequential version, it runs no
faster or, worse, runs slower than the sequential version. Too much zeal
with synchronization tools may produce a program which gives the right
answer but does not exploit any parallelism.</simpara>
<simpara>For example, we can take the <literal>run()</literal> method from the parallel
implementation of matrix multiply given in ExampleÂ <xref linkend="example:Matrix
multiplication"/> and use the <literal>synchronized</literal> keyword to lock on the
matrix itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void run() {
    synchronized( c ) {
        for( int i = lower; i &lt; upper; i++ )
            for( int j = 0; j &lt; c[i].length; j++ )
                for( int k = 0; k &lt; b.length; k++ )
                    c[i][j] += a[i][k] * b[k][j];
    }
}</programlisting>
<simpara>In this case, only a single thread would have access to the matrix at
any given time, and all speedup would be lost.</simpara>
<simpara>For this version of matrix multiply, no synchronization is needed. In
the case of the producer/consumer problem, synchronization is necessary,
and the only way to manage the buffer properly is to enforce sequential
execution. Sometimes sequential execution cannot be avoided, but you
should always know which pieces of code are truly executing in parallel
and which are not if you hope to get the maximum amount of speedup. The
<literal>synchronized</literal> keyword should be used whenever it is needed, but no
more.</simpara>
</section>
<section xml:id="_priority_inversion">
<title>Priority inversion</title>
<simpara>In ChapterÂ <xref linkend="chapter:Concurrent_Programming"/> we suggest that you use
thread priorities rarely. Even good reasons to use priorities can be
thwarted by <emphasis>priority inversion</emphasis>. In priority inversion, a lower
priority thread holds a lock needed by a higher priority thread,
potentially for a long time. Because the high priority thread cannot
continue, the lower priority thread gets more CPU time, as if it were a
high priority thread.</simpara>
<simpara>Worse, if there are some medium priority threads in the system, the low
priority thread may hold the lock needed by the high priority thread for
even longer because those medium priority threads reduce the amount of
CPU time the low priority thread has to finish its task.</simpara>
</section>
</section>
<section xml:id="solution:dining_philosophers">
<title>Solution: Dining philosophers</title>
<simpara>Now we give our solution to the dining philosophers problem. Although
deadlock was the key pitfall we were trying to avoid, many other issues
can crop up in solutions to this problem. A single philosopher may be
forced into starvation, or all philosophers may experience livelock
through some pattern of picking up and putting down chopsticks which
never quite works out. A very simple solution could allow the
philosophers to eat, one by one, in order. Then, the philosophers would
often and unnecessarily be waiting to eat, and the program would
approach sequential execution.</simpara>
<simpara>The key element that makes our solution work is that we force a
philosopher to pick up two chopsticks atomically. The philosopher will
either pick up both chopsticks or neither.</simpara>
<programlisting language="java" linenumbering="numbered">public class DiningPhilosopher extends Thread {
	public static final int SEATS = 5;
	private static boolean[] chopsticks = new boolean[SEATS];
	private int seat;

	public DiningPhilosopher( int seat ) {
		this.seat = seat;
	}</programlisting>
<simpara>We begin with the same setup as the deadlocking version given in
SectionÂ <xref linkend="subsection:deadlock"/>. Unlike that example, we include a
<literal>main()</literal> method here for completeness. In <literal>main()</literal>, we set all the
chopsticks to <literal>false</literal> (unused), create and start a thread for each
philosopher, and then wait for them to finish.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void main(String args[]) {
		for( int i = 0; i &lt; SEATS; i++ )
			chopsticks[i] = false;
		DiningPhilosopher[] philosophers =
			new DiningPhilosopher[SEATS];
		for( int i = 0; i &lt; SEATS; i++ ) {
			philosophers[i] = new DiningPhilosopher( i );
			philosophers[i].start();
		}
		try	{
			for( int i = 0; i &lt; SEATS; i++ )
				philosophers[i].join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		System.out.println("All philosophers done.");
	}</programlisting>
<simpara>This <literal>run()</literal> method is different from the deadlocking version but not in
a way that prevents deadlock. We added the <literal>for</literal> loop so that you could
see the philosophers eat and think many different times without
problems. We also added the <literal>think()</literal> method to randomize the amount of
time between eating so that each run of the program is less
deterministic.</simpara>
<programlisting language="java" linenumbering="numbered">	public void run() {
		for( int i = 0; i &lt; 100; i++ ) {
			think();
			getChopsticks();
			eat();
		}
	}

	private void think() {
		Random random = new Random();
		try {
			sleep( random.nextInt(20) + 10 );
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
	}</programlisting>
<simpara>The real place where deadlock is prevented is in the <literal>getChopsticks()</literal>
method. The philosopher acquires the <literal>chopsticks</literal> lock and then picks up
the two chopsticks she needs only if both are available. Otherwise, she
waits.</simpara>
<programlisting language="java" linenumbering="numbered">	private void getChopsticks() {
		int location1 = seat;
		int location2;
		if( seat == 0 )
			location2 = SEATS - 1;
		else
			location2 = seat - 1;
		synchronized( chopsticks ) {
			while( chopsticks[location1]
				|| chopsticks[location2] ) {
				try {
					chopsticks.wait();
				}
				catch( InterruptedException e )	{
					e.printStackTrace();
				}
			}
			chopsticks[location1] = true;
			chopsticks[location2] = true;
		}
		System.out.println("Philosopher " + seat +
			" picked up chopsticks " + location1 + " and "
			+ location2 + ".");
	}</programlisting>
<simpara>Finally, in the <literal>eat()</literal> method, the philosopher eats the rice. We would
assume that some other computation would be done here in a realistic
problem <emphasis role="strong">before</emphasis> entering the <literal>synchronized</literal> block. The eating itself
does not require a lock. After eating is done, the lock is acquired to
give back the chopsticks (hopefully after some cleaning), and then all
waiting philosophers are notified that some chopsticks may have become
available.</simpara>
<programlisting language="java" linenumbering="numbered">	private void eat() {
		//eat rice first
		synchronized( chopsticks ) {
			chopsticks[seat] = false;
			if( seat == 0)
				chopsticks[SEATS - 1] = false;
			else
				chopsticks[seat - 1] = false;
			chopsticks.notifyAll();
		}
	}
}</programlisting>
<simpara>Our solution prevents deadlock and livelock because some philosopher
will get control of two chopsticks eventually, yet there are still
issues. Note that each philosopher only eats and thinks 100 times. If,
instead of philosophers sharing chopsticks, each thread were a server
sharing network storage units, the program could run for an unspecified
amount of time: days, weeks, even years. If starvation is happening to a
particular philosopher in our program, the other philosophers will
finish after 100 rounds, and the starved philosopher can catch up. If
there were no limitation on the loop, a starving philosopher might never
catch up.</simpara>
<simpara>Even if you increase the number of iterations of the loop quite a lot,
you would probably not see starvation of an individual thread because we
are cheating in another way. Some unlucky sequence of chopstick accesses
by two neighboring philosophers could starve the philosopher between
them. By making the <literal>think()</literal> method wait a random amount of time, such
a sequence will probably be interrupted. If all philosophers thought for
exactly the same amount of time each turn, an unlucky pattern could
repeat over and over. It is not unreasonable to believe that the amount
of thinking a philosopher (or a server) will do at any given time will
vary, but this kind of behavior will vary from system to system.</simpara>
<simpara>It is very difficult to come up with a perfect answer to some
synchronization problems. Such problems have been studied for many
years, and research continues to find better solutions.</simpara>
</section>
<section xml:id="_exercises_13">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:synchronized_keyword"/> What is the purpose of the
<literal>synchronized</literal> keyword? How does it work?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:constructor_leak"/> The language specification for Java
makes it illegal to use the <literal>synchronized</literal> keyword on constructors.
During the creation of an object, it is possible to <emphasis>leak</emphasis> data to the
outside world by adding a reference to the object under construction to
some shared data structure. What&#8217;s the danger of leaking data in this
way?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:wait_or_notify_without_synchronized"/> If you call
<literal>wait()</literal> or <literal>notify()</literal> on an object, it must be inside of a block
synchronized on the same object. If not, the code will compile, but an
<literal>IllegalMonitorStateException</literal> may be thrown at run time. Why is it
necessary to own the lock on an object before calling <literal>wait()</literal> or
<literal>notify()</literal> on it?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:notify_vs._notifyAll"/> Why is it safer to call
<literal>notifyAll()</literal> than <literal>notify()</literal>? If it is generally safer to call
<literal>notifyAll()</literal>, are there any scenarios in which there are good reasons
to call <literal>notify()</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:restaurant_synchronization"/> Imagine a simulation of a
restaurant with many waiter and chef objects. The waiters must submit
orders to the kitchen staff, and the chefs must divide the work among
themselves. How would you design this system? How would information and
food be passed from waiter to chef and chef to waiter? How would you
synchronize the process?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:race_condition"/> What is a race condition? Give a real
life example of one.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:per_object_lock"/> Let&#8217;s reexamine the code that
increments a variable with several threads from
SectionÂ <xref linkend="concepts:Thread_interaction"/>. We can rewrite the <literal>run()</literal>
method as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">public synchronized void run() {
    for( int i = 0; i &lt; COUNT / THREADS; i++ )
        counter++;
}</programlisting>
<simpara>Will this change fix the race condition? Why or why not?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:deadlock_conditions"/> Examine our deadlock example from
ExampleÂ <xref linkend="example:Deadlock_sum"/>. Explain why this example fulfills all
four conditions for deadlock. Be specific about which threads and which
resources are needed to show each condition.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:priority_inversion"/> What is priority inversion? Why can
a low priority thread holding a lock be particularly problematic?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:better_producer/consumer"/> In
ExampleÂ <xref linkend="example:Producer/consumer"/> the <literal>Buffer</literal> class used to
implement a solution to the producer/consumer problem only has a single
lock. When the buffer is empty and a producer puts an item in it, both
producers and consumers are woken up. A similar situation happens
whenever the buffer is full and a consumer removes an item. Re-implement
this solution with two locks so that a producer putting an item into an
empty buffer only wakes up consumers and a consumer removing an item
from a full buffer only wakes up producers.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:fair_bank_account"/> In ExampleÂ <xref linkend="example:Bank_account"/>
we used the class <literal>SynchronizedAccount</literal> to solve a bank account problem.
As we mention in SectionÂ <xref linkend="section:starvation_and_livelock"/>, depositing
and withdrawing threads can be starved out by a steady supply of balance
checking threads. Add additional synchronization tools to
<literal>SynchronizedAccount</literal> so that balance checking threads will take turns
with depositing and withdrawing threads. If there are no depositing or
withdrawing threads, make your implementation continue to allow an
unlimited number of balance checking threads to read concurrently.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:philosophers_with_hunger"/> The solution to the dining
philosophers problem given in SectionÂ <xref linkend="solution:dining_philosophers"/>
suffers from the problem that a philosopher could be starved by the two
philosophers on either side of her, if she happened to get unlucky. Add
variables to each philosopher which indicate hunger and the last time a
philosopher has eaten. If a given philosopher is hungry and has not
eaten for longer than her neighbor, her neighbor should not pick up the
chopstick they share. Add synchronization tools to enforce this
principle of fairness. Note that this solution should not cause
deadlock. Although one philosopher may be waiting on another who is
waiting on another and so on, <emphasis role="strong">some</emphasis> philosopher in the circle must have
gone hungry the longest, breaking circular wait.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:time_lock_acquisition"/> Critical sections can slow down
your program by preventing parallel computation. However, the locks used
to enforce critical sections can add extra delays on top of that. Design
a simple experiment which repeatedly acquires a lock and does some
simple operation. Test the running time with and without the lock. See
if you can estimate the time needed to acquire a lock in Java on your
system.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:thread_time_on_CPU"/> Design a program which
experimentally determines how much time a thread is scheduled to spend
running on a CPU before switching to the next thread. To do this, first
create a tight loop which runs a large number of iterations, perhaps
1,000,000 or more. Determine how much time it takes to run a single run
of those iterations. Then, write an outer loop which runs the tight loop
several times. Each iteration of the outer loop, test to see how much
time has passed. When you encounter a large jump in time, typically at
least 10 times the amount of time the tight loop usually takes to run to
completion, record that time. If you run these loops in multiple threads
and average the unusually long times together for each thread, you
should be able to find out about how long each thread waits between
runs. Using this information, you can estimate how much time each thread
is allotted. Bear in mind that this is only an estimation. Some JVMs
will change the amount of CPU time allotted to threads for various
reasons. If you are on a multicore machine, it will be more difficult to
interpret your data since some threads will be running concurrently.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:priority_inversion_experiment"/> Create an experiment to
investigate priority inversion in the following way.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create two threads, setting the priority of the first to
<literal>MIN_PRIORITY</literal> and the priority of the second to <literal>MAX_PRIORITY</literal>. Start
the first thread running but wait 100 milliseconds before starting the
second thread. The first thread should acquire a shared lock and then
perform some lengthy process such as finding the sum of the sines of the
first million integers. After it finishes its computation, it should
release the lock, and print a message. The second thread should try to
acquire the lock, print a message, and then release the lock. Time the
process. Because the lock is held by the lower priority thread, the
higher priority thread will have to wait until the other thread is done
for it to finish.</simpara>
</listitem>
<listitem>
<simpara>Once you have a feel for the time it takes for these two threads to
finish alone, create 10 more threads that must also perform a lot of
computation. However, these threads do not try to acquire the lock. How
much do they delay completion of the task? How does this delay relate to
the number of cores in your processor? How much does the delay change if
you set the priorities of these new threads to <literal>MAX_PRIORITY</literal> or
<literal>MIN_PRIORITY</literal>?</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Constructing_Graphical_User_Interfaces">
<title>Constructing Graphical User Interfaces</title>
<blockquote>
<attribution>
Napoleon Bonaparte
</attribution>
<simpara>A good sketch is better than a long speech.</simpara>
</blockquote>
<section xml:id="_problem_math_applet">
<title>Problem: Math applet</title>
<simpara>An <emphasis>applet</emphasis> is a graphical Java program that runs inside of a special
environment, usually a web browser. The beauty of an applet is that
anyone with a Java-enabled web browser can run the program without any
special knowledge or computer skills. Most users don&#8217;t even realize they
are running a program.</simpara>
<figure>
<title>The <literal>MathTutorApplet</literal> as seen through the Google Chrome browser. (a)Â Initial applet. (b)Â Selecting an operation to practice. (c)Â After some practice.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/mathTutorAppletFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>mathTutorAppletFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>Let&#8217;s write an applet that will allow young math students to practice
their arithmetic. Specifically, we are interested in addition,
subtraction, multiplication, and division with small, positive integers.
For this program, we will consider addition and subtraction basic and
multiplication and division advanced. Our applet should allow the user
to select a check box in a menu setting the mode to advanced or basic.
The user should then be able to select one of the four operations from
another menu. Once the operation is selected, the applet should generate
a random problem testing that operation. The problem should be displayed
as a label on the applet with a text field to one side. The user should
be able to enter an answer in the text field and hit a button to submit
it. The applet should check the answer and display the updated number of
correct and incorrect answers.</simpara>
<simpara>FigureÂ <xref linkend="elementaryArithPracticeFigure"/> shows the final applet in two
different states. The screen to the left appears when the applet is
first initialized. The applet is set in basic mode, and the Submit
button is disabled until a problem is generated.</simpara>
</section>
<section xml:id="_concepts_graphical_user_interfaces">
<title>Concepts: Graphical user interfaces</title>
<simpara>The applet shown above with its menus, labels, buttons, and other
interactive components is called a graphical user interface, or GUI. A
GUI is a means of communication between a computer program and a
(usually human) user. (Although it is possible for some programs such as
scripts to interact with a GUI, most program to program communication is
done in other ways.) While communication through input and output on the
console is one way to communicate with a program, GUIs offer a
user-friendly alternative that has become extremely commonplace. In
fact, GUIs are so common that many people have never used anything else
to interact with programs and may not even suspect that other kinds of
interaction are possible.</simpara>
<simpara>This chapter will teach you how to write programs with GUIs. Although
GUIs can make input and output easier for the user, the programmer has
to shoulder the burden of arranging the layout and appearance of the GUI
and making it function properly. ChapterÂ <xref linkend="chapter:Simple Graphical User
Interfaces"/> introduced a way to make simple GUIs, but those GUIs came
in preset flavors designed for displaying a message, getting a range of
responses in the form of buttons, or reading a short piece of text as
input. In this chapter we will explore ways to make GUIs of arbitrary
complexity with no limitations on the size or shape of the GUI or the
components it contains.</simpara>
<simpara>A typical GUI consists of a <emphasis>frame</emphasis> (also known as a window) on which
are displayed one or more components (known as widgets), such as panels,
buttons, and text boxes. <emphasis>Panels</emphasis> are used to organize the contents
within the frame. A frame contains at least one panel, but additional
ones can be added. Each panel can also contain widgets: buttons, labels,
text boxes, and even other panels. Using code to create a GUI with all
the widgets laid out exactly where you want them is half the work of
making a GUI-driven program in Java.</simpara>
<simpara>Some components like labels are read-only to the user. They display
information such as status messages. Other components are more dynamic
in the sense that the user can use these to give input to the program.
Such components are associated with events. Handling events inside of a
program is the other half of writing a GUI program in Java. Layout is
concerned with appearance, but event handling is concerned with
functionality.</simpara>
<simpara>There are IDEs such as NetBeans have graphical tools that automatically
generate the GUI code for you. We focus on how to write this code
yourself because doing so gives you more control and helps you
understand Java GUIs better.</simpara>
<section xml:id="_swing_and_awt">
<title>Swing and AWT</title>
<simpara>Most of the components you will use to create GUIs are defined in
classes that belong to the Java Swing library. This library contains
many interfaces and classes. Several components of the Swing library are
built upon another library known as the Abstract Window Toolkit that is
commonly referred to as AWT. In earlier chapters, you have seen, and
probably used, one class in the Swing library, the <literal>JOptionPane</literal> class.</simpara>
<simpara>The AWT is an older library which provides direct access to the OS
widgets. Thus, an AWT <literal>Button</literal> object in Microsoft Windows creates a
Windows button. Swing, however, draws its own button. AWT GUIs look
exactly like other GUIs from the same OS. Swing GUIs can be configured
to look similar using <emphasis>look and feel</emphasis> settings, or developers can choose
to use a default Java look and feel that will look almost the same
across all platforms.</simpara>
<simpara>We will discuss Swing widgets such as <literal>JButton</literal> and <literal>JTextField</literal>. Swing
components usually have a <literal>J</literal> at the beginning of their names to
distinguish them from similar AWT components. (The AWT contains <literal>Button</literal>
and <literal>TextField</literal>. If you see examples from other sources using widgets
that do not start with <literal>J</literal>, they are probably using AWT.) Although Swing
is built on top of the older AWT library, it is not a good idea to mix
Swing and AWT components in a single GUI, though it is possible.</simpara>
<simpara>The Swing library is far too large for us to cover in its entirety.
Instead, our goal is to show you how to construct GUIs using some of the
most common Java widgets. Once you have grasped the material in this
chapter, you will be able to read and understand how to use many other
interesting Swing components, as well as other Java libraries for
constructing GUIs. Since a frame is the basis for most windowed GUIs, we
will begin by showing you how to create a frame and display it on the
screen.</simpara>
</section>
</section>
<section xml:id="_syntax_guis_in_java">
<title>Syntax: GUIs in Java</title>
<section xml:id="_creating_a_frame">
<title>Creating a frame</title>
<simpara>A frame is the Java terminology for a window. Except when programming an
applet, GUI components in Java will usually be found on a frame. In
Swing, a frame is an object whose type is derived from the <literal>JFrame</literal>
class. Here is a line of code that creates a <literal>JFrame</literal> object.</simpara>
<programlisting language="java" linenumbering="unnumbered">JFrame soundCheck = new JFrame("Sound Check");</programlisting>
<simpara>The above statement declares and creates a <literal>JFrame</literal> object named
<literal>soundCheck</literal>. The title of the frame is &#8220;Sound Check&#8221; and is given as
an argument to the <literal>JFrame</literal> constructor. Although calling the
constructor creates the frame, you need to make it visible for it to
show up on the screen.</simpara>
<programlisting language="java" linenumbering="unnumbered">soundCheck.setVisible(true);</programlisting>
<simpara>The <literal>setVisible()</literal> method causes the <literal>soundCheck</literal> frame to be visible on
the screen as a window. You can specify its size as in the following
code.</simpara>
<programlisting language="java" linenumbering="unnumbered">soundCheck.setSize(300,200);</programlisting>
<simpara>The <literal>setSize()</literal> method sets the width and height of the frame specified
in pixels. In the above example, the width of <literal>soundCheck</literal> is set to 300
pixels and its height to 200 pixels. The window created by the above
code is resizable. You could use the following code if you do not want
the user to be able to resize the window.</simpara>
<programlisting language="java" linenumbering="unnumbered">soundCheck.setResizable(false);</programlisting>
<simpara>Your entire GUI will often be a frame you create and the components
inside that frame. You might want your application to end when you close
the frame by clicking on the close button towards the top. The actual
location of this button depends on the operating system and the look and
feel managers you are using. Regardless, the following statement can be
used to set the behavior of the application when you close the frame
window.</simpara>
<programlisting language="java" linenumbering="unnumbered">soundCheck.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</programlisting>
<warning>
<title>Pitfall: Closing frames</title>
<simpara>Some books and online tutorials suggest setting <literal>JFrame.EXIT_ON_CLOSE</literal>
as the default close operation for a <literal>JFrame</literal> instead of
<literal>JFrame.DISPOSE_ON_CLOSE</literal>. In our opinion, this option should never be
used.</simpara>
<simpara>Using <literal>JFrame.EXIT_ON_CLOSE</literal> is equivalent to calling
<literal>System.exit(0)</literal>, which shuts down the JVM. In a single-threaded
application, the difference between disposing and exiting is small.
However, in a multi-threaded application, shutting down the JVM means
killing off all the other threads, no matter what task they are
performing. In general, <literal>System.exit()</literal> should never be called,
whether the program has a GUI or not.</simpara>
<simpara>By using <literal>JFrame.DISPOSE_ON_CLOSE</literal>, the frame releases all the
resources it has been using and terminates any threads it uses to redraw
itself and check for events. If there are no other threads running, the
application will then shut down.</simpara>
<simpara>It is still necessary to select <emphasis role="strong">some</emphasis> default closing operation. By
default, the operation is set to <literal>JFrame.HIDE_ON_CLOSE</literal>, which hides
the frame but does not end its threads. Unfortunately, if the frame is
the only way you have of interacting with your application, you can no
longer use it! At that point, you may have to use a process or task
manager to shut down the JVM by hand.</simpara>
</warning>
<example>
<title>Empty frame</title>
<simpara>ProgramÂ <xref linkend="program:EmptyFrame"/> creates and displays an empty frame with
the title &#8220;Sound Check.&#8221; Note that we have used the <literal>import</literal> statement
to let the compiler know that we are using the Swing library. The first
line inside the <literal>main()</literal> method declares and creates a <literal>JFrame</literal> object
and assigns a title to it. The following line sets its size. The third
line sets the default close operation and the following line makes the
frame visible. The frame so created is shown in
FigureÂ <xref linkend="emptyFrameFigure"/>. Note that the frame is resizable.</simpara>
<formalpara xml:id="program:EmptyFrame" xreflabel="EmptyFrame">
<title>Program to create an empty frame.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class EmptyFrame {
    public static void main(String[] args){
    	//Create frame
        JFrame soundCheck = new JFrame("Sound Check");
        soundCheck.setSize(350,150); //Set size in pixels
        soundCheck.setDefaultCloseOperation(
        		JFrame.DISPOSE_ON_CLOSE);
        soundCheck.setVisible(true); //Display it
    }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>An empty frame titled &#8220;Sound Check.&#8221;</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/emptyFrameFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>emptyFrameFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>You may resize the frame at any point in the program even after the
frame has been created and made visible. The initial size may or may not
be set prior to making the frame visible. Similarly, the frame title can
be set, and reset, at any point in the program.</simpara>
</example>
</section>
<section xml:id="_widgets">
<title>Widgets</title>
<simpara>A widget is a component of a GUI. Java provides a large variety of
widgets including panels, buttons, text boxes, check boxes, and menus.
While laying out a GUI, one or more of the widgets are created and then
placed on a frame. A widget is declared and created like any other
object.</simpara>
<programlisting language="java" linenumbering="unnumbered">Widget w = new Widget(arguments);</programlisting>
<simpara>Here we use class <literal>Widget</literal> to represent some Java widget class like
<literal>JButton</literal> or , and we use reference <literal>w</literal> to represent the name of a
widget like <literal>startButton</literal>. Arguments supplied while constructing a
widget allow you to set attributes such as its icon, color, size, or
text to display. A widget can be added to a frame and removed when not
needed. Its attributes can also be changed after creation.</simpara>
<simpara>Although widgets can be added directly to a frame, it is often
convenient to lay out a GUI by placing panels on a frame and then
placing widgets on the panels. Each panel can hold zero or more widgets.
A panel is also referred to as a <emphasis>container</emphasis> object. Next we show you
how to create a panel, populate it with widgets, place it on a frame,
and display the completed frame.</simpara>
<simpara>A panel is an instance of the <literal>JPanel</literal> class and can be created as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">JPanel soundPanel = new JPanel();</programlisting>
<simpara>This statement creates a panel named <literal>soundPanel</literal>. Thus far, the panel
is empty. Let&#8217;s create two buttons and add these to <literal>soundPanel</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">JButton chirp = new JButton("Chirp");
JButton bark = new JButton("Bark");
soundPanel.add(chirp);
soundPanel.add(bark);</programlisting>
<simpara>The first two lines above create two buttons named <literal>chirp</literal> and <literal>bark</literal>.
These buttons are labeled using the <literal>String</literal> values <literal>"Chirp"</literal> and
<literal>"Bark"</literal>, but their labels could be any <literal>String</literal> values. The last two
statements add the two buttons one by one to the <literal>soundPanel</literal>. Then we
add the panel to a frame object.</simpara>
<programlisting language="java" linenumbering="unnumbered">soundCheck.add(soundPanel);</programlisting>
<simpara>This statement adds the <literal>soundPanel</literal> to <literal>soundCheck</literal> frame that we
created in ExampleÂ <xref linkend="example:Empty_frame"/>.</simpara>
<simpara>Another useful widget is <literal>JTextField</literal>. It creates a text field that can
be used by a program for both input and output of <literal>String</literal> data.</simpara>
<programlisting language="java" linenumbering="unnumbered">JTextField message = new JTextField("This is not a pipe.");</programlisting>
<simpara>This statement creates an object named <literal>message</literal> as an instance of the
<literal>JTextField</literal> class. When displayed, it will show the message &#8220;This is
not a pipe.&#8221; The user can replace this text by typing, but we will need
to talk about event handling before we can read the text and act on it
from within a program. The following example combines various concepts
and widgets already introduced into one program.</simpara>
<example>
<title>GUI with buttons and text field</title>
<simpara>We will now write an application with a GUI that contains three buttons
labeled &#8220;Chirp,&#8221; &#8220;Bark,&#8221; and &#8220;Exit.&#8221; In addition it contains a
text field that initially displays the text, &#8220;Listen to nature!&#8221;</simpara>
<simpara>In this example the buttons are only for display. You can click each
one, but the program will not do anything useful. Similarly, the text
field will not be changed by the program after it is initialized. In the
next subsection we add actions to each button and make the program more
useful.</simpara>
<formalpara xml:id="program:FrameWithPanel" xreflabel="FrameWithPanel">
<title>Program to create a frame with a panel containing three buttons.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;

public class FrameWithPanel {
    public static void main(String[] args){
    	//Create frame
        JFrame soundCheck = new JFrame("Sound Check");
        JPanel soundPanel = new JPanel();
        //Create three buttons
        JButton chirp = new JButton("Chirp");
        JButton bark = new JButton("Bark");
        JButton exit = new JButton("Exit");
        JTextField message = new JTextField("Listen to nature!");
        soundPanel.add(chirp); // Add chirp to panel /*@\label{addBirdChirp}@*/
        soundPanel.add(bark); //Add bark to panel
        soundPanel.add(message); //Add message box
        soundPanel.add(exit); //Add exit button/*@\label{addExit}@*/
        soundCheck.add(soundPanel); //Add the panel to the frame/*@\label{addPanelToFrame}@*/
        soundCheck.setSize(350,150); //Set size in pixels
        soundCheck.setDefaultCloseOperation(
        	JFrame.DISPOSE_ON_CLOSE);
        soundCheck.setVisible(true); //Display frame
    }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>GUI consisting of a frame, a panel, three buttons, and a text field.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/frameWithAPanelFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>frameWithAPanelFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the <literal>main()</literal> method in ProgramÂ <xref linkend="frameWithAPanelFigure"/>, we first
create a frame named <literal>soundCheck</literal> and a panel named <literal>soundPanel</literal>. Next,
we create three buttons named <literal>chirp</literal>, <literal>bark</literal>, and <literal>exit</literal>, labeled
&#8220;Chirp,&#8221; &#8220;Bark,&#8221; and &#8220;Exit,&#8221; respectively. LinesÂ <xref linkend="addBirdChirp"/>
until <xref linkend="addExit"/> add the three buttons and the text field to
<literal>soundPanel</literal>. At lineÂ <xref linkend="addPanelToFrame"/>, <literal>soundPanel</literal> is added to
<literal>soundCheck</literal>. After setting the closing operation, the frame is made
visible. The final GUI is shown in FigureÂ <xref linkend="frameWithAPanelFigure"/>.
Note that the same GUI may look different on different platforms. Later
we will see how to add multiple panels to a frame.</simpara>
</example>
</section>
<section xml:id="_adding_actions_to_widgets">
<title>Adding actions to widgets</title>
<simpara>Many widgets in Java can be used to cause an action. For example, a user
could click a button labeled &#8220;Chirp,&#8221; causing the program to play a
bird chirp sound. Clicking a button generates an <emphasis>event</emphasis>. In Java, an
event is processed by one or more <emphasis>listeners</emphasis>. Java provides various
types of listeners, some of which are introduced here and a few others
in SectionÂ <xref linkend="subsection:Applets"/>. Next we show you how to handle action
events generated by a few different kinds of widgets.</simpara>
<section xml:id="_the_literal_actionlistener_literal_interface">
<title>The <literal>ActionListener</literal> interface</title>
<simpara>Java provides an <literal>ActionListener</literal> interface. This interface has a single
method named <literal>actionPerformed()</literal>. This method takes an <literal>ActionEvent</literal> as
input and performs a suitable action based on the event. A <literal>JButton</literal>
object generates <literal>ActionEvent</literal> when it is pressed. Any class that
implements the <literal>ActionListener</literal> interface can be registered as an action
listener on a <literal>JButton</literal> or any other widget that generates an
<literal>ActionEvent</literal>.</simpara>
<simpara>As discussed in ChapterÂ <xref linkend="chapter:Interfaces"/>, an interface is a set of
method signatures. If you implement an interface, you promise to have
all of the methods in the interface. If a class implements
<literal>ActionListener</literal>, it&#8217;s saying that it knows what to do when an action is
performed. The following statements show how to add an <literal>ActionListener</literal>
to a button and implement its <literal>actionPerformed()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">JButton chirp = new JButton("Chirp");
chirp.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //Code to perform an action goes here
            }
        });</programlisting>
<simpara>The first line above creates a button named <literal>chirp</literal>. The second line
adds an action listener to the button. The process of adding an action
listener to an object is also known as <emphasis>registering</emphasis> a listener on the
object. Note that the sole argument to this <literal>addActionListener()</literal> method
is a newly created <literal>ActionListener</literal> object. Inside this newly created
and anonymous <literal>ActionListener</literal> object, we implement the
<literal>actionPerformed()</literal> method. Whatever code we want to execute in response
to the clicking of the <literal>chirp</literal> button goes inside the
<literal>actionPerformed()</literal> method.</simpara>
<simpara>This syntax may look strange to you. <literal>ActionListener</literal> is an interface,
which cannot be instantiated. What is that <literal>new</literal> keyword doing? It&#8217;s
doing something pretty amazing by creating an instance of an <emphasis>anonymous
class</emphasis>. On the fly, we&#8217;re creating a class that has never existed
before. It doesn&#8217;t even have a name. All we know about it is that it
implements the interface <literal>ActionListener</literal>.</simpara>
<simpara>Note that there are braces after the constructor call, defining what&#8217;s
inside of this class. Inside, we have only created an
<literal>actionPerformed()</literal> method, but we could have created fields as well as
other methods. It&#8217;s a little ugly to create a whole new class and
instantiate it in the middle of calling the <literal>addActionListener()</literal>
method, but it&#8217;s also very convenient. We need to supply an object that
reacts to the event exactly the way we want it to. Since one doesn&#8217;t
exist yet, we have to create it. Of course, it is possible to supply any
object that implements the <literal>ActionListener</literal> interface, not just
instances of anonymous classes. For more information about nested
classes, inner classes, and anonymous classes, refer to
SectionsÂ <xref linkend="advanced:Nested_classes"/> and <xref linkend="advanced:Local and anonymous
classes"/>.</simpara>
<example>
<title>GUI with actions</title>
<simpara>We now modify ProgramÂ <xref linkend="program:FrameWithPanel"/> to respond to button
clicks. When the <literal>chirp</literal> button is clicked, the program will display the
message &#8220;Chirp requested.&#8221; in the text field. Similarly, when the
<literal>bark</literal> button is clicked, the program will display &#8220;Bark requested.&#8221;</simpara>
<simpara>ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/> is largely the same as
ProgramÂ <xref linkend="program:FrameWithPanel"/>. It adds the same buttons and text
field but then adds an action listener to each button. The action
performed when the <literal>chirp</literal> and <literal>bark</literal> buttons are clicked is to display
a message in the text box. When the <literal>exit</literal> button is clicked, the
listener displays a message on the console and exits the program.</simpara>
<formalpara xml:id="program:FrameWithPanelAndActions" xreflabel="FrameWithPanelAndActions">
<title>Program to demonstrate handling of action events.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.event.*;

public class FrameWithPanelAndActions {
    public static void main(String[] args){
        final JFrame soundCheck = new JFrame("Sound Check");
        JPanel soundPanel = new JPanel();
        JButton chirp = new JButton("Chirp");
        JButton bark = new JButton("Bark");
        JButton exit = new JButton("Exit");
        final JTextField message = new JTextField(
        	"Listen to nature!");
        soundPanel.add(chirp);
        soundPanel.add(bark);
        soundPanel.add(message);
        soundPanel.add(exit);
		// Add action listeners to various buttons
        chirp.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e){
            	message.setText("Chirp requested."); /*@\label{chirpRequestedLine}@*/
            }
        });
        bark.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e){
            	message.setText("Bark requested.");
            }
        });
        exit.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e){
                System.out.println("Exit");
                soundCheck.dispose();
            }
        });
        soundCheck.add(soundPanel);
        soundCheck.setSize(350,150);
        soundCheck.setDefaultCloseOperation(
        	JFrame.DISPOSE_ON_CLOSE);
        soundCheck.setVisible(true);
    }
}</programlisting>
</para>
</formalpara>
<simpara>Note that the sequence in which you add the buttons to the panel
determines the appearance of the GUI. The action listeners can be added
either before or after the panel has been set up but should be added
before the frame is made visible.</simpara>
<simpara>Do not be overly concerned with why the <literal>final</literal> keyword is used when
declaring <literal>soundCheck</literal> and <literal>message</literal>. You might be surprised that you
are even allowed to reference these local variables inside of the third
<literal>ActionListener</literal> class. An inner class has access to all the fields
inside of its outer class and access to local variables declared in the
same scope as the inner class. For technical reasons, any local variable
used in an anonymous inner class must be declared <literal>final</literal>. This
restriction does not apply to class variables.</simpara>
</example>
<example>
<title>GUI with alternate action listener style</title>
<simpara>In the previous example we added an <literal>ActionListener</literal> object to each
button and implemented its <literal>actionPerformed()</literal> method with anonymous
inner classes. An alternate way to use <literal>ActionListener</literal> is to implement
<literal>ActionListener</literal> on the surrounding class and include an
<literal>actionPerformed()</literal> method exactly once instead of creating several
individual anonymous inner classes which each handle an event. Let&#8217;s
examine one such implementation in
ProgramÂ <xref linkend="program:AlternateActionListener"/> and contrast it with
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/>. Note that both programs
generate exactly the same GUI and exhibit identical behavior.</simpara>
<formalpara xml:id="program:AlternateActionListener" xreflabel="AlternateActionListener">
<title>Program to demonstrate handling of action events by implementing <literal>ActionListener</literal> at the class level.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.event.*;

public class AlternateActionListener implements ActionListener {
  JFrame soundCheck = new JFrame("Sound Check");
  JPanel soundPanel = new JPanel();
  JButton chirpButton = new JButton("Bird");
  JButton barkButton = new JButton("Dog");
  JButton exitButton = new JButton("Exit");
  JTextField message = new JTextField("Listen to nature!");

  public AlternateActionListener (){/*@\label{alternateActionListenerLine}@*/
    chirpButton.addActionListener(this);
    barkButton.addActionListener(this);
    exitButton.addActionListener(this);
    soundPanel.add(chirpButton);
	soundPanel.add(barkButton);
    soundPanel.add(message);
	soundPanel.add(exitButton);
    soundCheck.add(soundPanel);
    soundCheck.setSize(200,125);
    soundCheck.setDefaultCloseOperation(
    	JFrame.DISPOSE_ON_CLOSE);
    soundCheck.setVisible(true);
  }

  public void actionPerformed(ActionEvent e){/*@\label{actionPerformedLine}@*/
    Object button = e.getSource(); /*@\label{identifyObjectLine}@*/
    if(button == chirpButton)
      message.setText("Chirp requested.");
    else if(button == barkButton)
      message.setText("Bark requested.");
    else {
      System.out.println("Exit");
      soundCheck.dispose();
    }
  }

  public static void main(String[] args){
    new AlternateActionListener();
  }
}</programlisting>
</para>
</formalpara>
<simpara>In ProgramÂ <xref linkend="program:AlternateActionListener"/> class
<literal>AlternateActionListener</literal> implements <literal>ActionListener</literal>. Doing so requires
the class to include <literal>actionPerformed()</literal>. The constructor, starting at
lineÂ <xref linkend="alternateActionListenerLine"/>, adds an <literal>ActionListener</literal> to each
button. The listener added is <literal>this</literal>, specifying that the
<literal>AlternateActionListener</literal> object is the one that will process any action
event generated by the buttons. The remainder of the code for the
constructor is essentially the same as that from the <literal>main()</literal> method in
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/>.</simpara>
<simpara>The <literal>actionPerformed()</literal> method, starting at
lineÂ <xref linkend="actionPerformedLine"/>, has exactly one parameter, an
<literal>ActionEvent</literal> object. Whenever an action event occurs, its attributes
are bundled into an <literal>ActionEvent</literal> object and passed into the
<literal>actionPerformed()</literal> method. At lineÂ <xref linkend="identifyObjectLine"/> the
<literal>getSource()</literal> method is used to determine which object is responsible
for the event. Variable <literal>button</literal> holds the object returned by
<literal>getSource()</literal>. The next <literal>if</literal> statement compares <literal>button</literal> with <literal>chirp</literal>
and <literal>bark</literal> to determine if either of these generated the event. Then a
suitable message is displayed in the <literal>message</literal> box. If neither button
generated the event, it must have been <literal>exit</literal>, and the frame disposes
itself after displaying &#8220;Exit&#8221; on the console.</simpara>
<simpara>The <literal>main()</literal> method simply creates an instance of
<literal>AlternateActionListener</literal> and terminates. The program does not end
because the threads for the GUI are still running.</simpara>
</example>
<simpara>It is instructive to note the differences between
ProgramsÂ <xref linkend="program:FrameWithPanelAndActions"/> and
<xref linkend="program:AlternateActionListener"/>. In
ProgramÂ <xref linkend="program:AlternateActionListener"/>, most of the code has been
moved from the ` main()` method to the constructor. Various objects,
namely the <literal>soundCheck</literal> frame, the <literal>soundPanel</literal> panel, all three
buttons, and the text box are now fields of the object instead of local
variables in the <literal>main()</literal> method. This removes the need to mark
<literal>soundCheck</literal> and <literal>message</literal> as <literal>final</literal>.</simpara>
<simpara>We have examined two ways of adding an <literal>ActionListener</literal> to a Java
program. The choice of which style to use depends on your needs. Adding
an anonymous <literal>ActionListener</literal> to each object can require you to use the
<literal>final</literal> keyword to reference local variables, but it is otherwise quick
and easy. Using a named class (often the main program class or a
subclass of <literal>JFrame</literal>) as the <literal>ActionListener</literal> allows you to handle many
events in a centralized location. It can be easier to find errors when
all events are handled in one <literal>actionPerformed()</literal> method, but the method
can become long and complex as well.</simpara>
</section>
<section xml:id="_the_literal_mouselistener_literal_interface">
<title>The <literal>MouseListener</literal> interface</title>
<simpara>Clicking a button is great, but a mouse can be used to generate other
events too. For example, in a screen full of pictures, you might want to
highlight a picture when the cursor hovers over it. Or you might want to
create a drawing program which uses a mouse as a pen. To process general
mouse events, we need an object that implements the <literal>MouseListener</literal>
interface, which defines the following methods.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>mouseClicked()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mouseEntered()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mouseExited()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mousePressed()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mouseReleased()</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The function of each method is implied by its name. The <literal>mouseEntered()</literal>
event fires when the mouse cursor moves from outside of the area covered
by a widget into the area above it. Conversely, the <literal>mouseExited()</literal>
event fires when a mouse cursor was over a widget and has just moved
away. The <literal>mousePressed()</literal> event fires when a mouse button is pressed
over a widget. The <literal>mouseReleased()</literal> event fires when a mouse button is
released over a widget. The <literal>mouseClicked()</literal> event is a combination of
both the <literal>mousePressed()</literal> and <literal>mouseReleased()</literal> events, occurring only
if a mouse button was pressed and then released while the cursor was
over a widget. As you can see, a widget only fires events when the
cursor is over the component (or has just left). Thus, a widget only
reports events that have to do with it, not the general state of the
mouse.</simpara>
<simpara>Each method in <literal>MouseListener</literal> receives a <literal>MouseEvent</literal> object as its
argument. To handle mouse events, a class must implement the
<literal>MouseListener</literal> interface. This is similar to the implementation of the
<literal>ActionListener</literal> interface from the previous section, but implementing
<literal>MouseListener</literal> requires a definition for <emphasis role="strong">each</emphasis> of the five methods
listed above. The next example illustrates <literal>MouseListener</literal> in use.</simpara>
<example>
<title>Mouse listener</title>
<simpara>We write a program that displays a GUI containing two buttons labeled
&#8220;One&#8221; and &#8220;Two.&#8221; In addition a text box displays a suitable message
when the cursor enters a button. When a button is clicked, the status
box should display the total number of times that button has been
clicked so far.</simpara>
<simpara>ProgramÂ <xref linkend="program:SimpleMouseEvents"/> generates the GUI shown in
FigureÂ <xref linkend="simpleMouseEventsFigure"/>. At
lineÂ <xref linkend="simpleMouseEventsClassDefLine"/> class <literal>SimpleMouseEvents</literal> is
declared, implementing the <literal>MouseListener</literal> interface. The following few
lines declare frame <literal>frame</literal>, buttons <literal>one</literal> and <literal>two</literal>, and a text box
<literal>status</literal>. Two integers <literal>oneClicks</literal> and <literal>twoClicks</literal> are initialized to 0
and are used to keep track of the number of times each button has been
clicked.</simpara>
<formalpara xml:id="program:SimpleMouseEvents" xreflabel="SimpleMouseEvents">
<title>Program to demonstrate the handling of mouse generated events using the <literal>MouseListener</literal> interface.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleMouseEvents implements MouseListener {/*@\label{simpleMouseEventsClassDefLine}@*/
	JFrame frame = new JFrame("Mouse Events");
	JTextField status = new JTextField(
		"Mouse status comes here.");
	JButton one = new JButton("One");
	JButton two = new JButton("Two");
	int oneClicks = 0, twoClicks = 0; //Number of clicks

    public SimpleMouseEvents() {/*@\label{simpleMouseEventsConstructorLine}@*/
        JPanel panel = new JPanel();
        one.addMouseListener(this);
        two.addMouseListener(this);
        panel.add(one);
        panel.add(two);
        panel.add(status);
        frame.add(panel);
        frame.setSize(200,100);
        frame.setDefaultCloseOperation(
        	JFrame.DISPOSE_ON_CLOSE);
        frame.setVisible(true);
    }

    // Implement all abstract methods in MouseListener
    public void mouseEntered(MouseEvent e) { /*@\label{mouseEnteredEventLine}@*/
	    if (e.getSource() == one) /*@\label{getObjectEnteredLine}@*/
	        status.setText("Mouse enters One.");
	    else
	        status.setText("Mouse enters Two.");
    }

	public void mouseClicked(MouseEvent e) {
		if (e.getSource() == one) {/*@\label{getObjectClickedLine}@*/
			oneClicks++;
			status.setText("One clicked "+ oneClicks +
				" times.");
		}
		else {
			twoClicks++;
			status.setText("Two clicked "+ twoClicks  +
				" times.");
		}
	}

	public void mouseExited(MouseEvent e) {} /*@\label{exitedNotImplementedLine}@*/
	public void mousePressed(MouseEvent e) {}
	public void mouseReleased(MouseEvent e) {}
	public static void main(String[] args){
		  new SimpleMouseEvents();
	}
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>GUI consisting of two buttons and a text box. Button clicks and entry of the cursor into a button are reported by the text box.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/simpleMouseEventsFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>simpleMouseEventsFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>The first line of the <literal>SimpleMouseEvents</literal> constructor creates the panel
<literal>panel</literal>. It does not need to be a field, and it is always preferable to
keep a variable local if it can be. The next two lines add a
<literal>MouseListener</literal> to the two buttons. Note the use of <literal>this</literal> in the
argument to <literal>addMouseListener()</literal> which refers to the object being
created by the constructor. Next, the panel is set up and added to the
frame. Finally the frame size and its default close operations are set,
and the frame is made visible.</simpara>
<simpara>Implementation of the methods in the <literal>MouseListener</literal> interface begins at
lineÂ <xref linkend="mouseEnteredEventLine"/>. The <literal>mouseEntered()</literal> method is invoked
when the cursor enters either of the two buttons. First we retrieve the
source of the event using the <literal>getSource()</literal> method and identify which
object generated the event. A suitable message is displayed in the
status box using the <literal>setText()</literal> method.</simpara>
<simpara>The <literal>mouseClicked()</literal> method is invoked when the mouse cursor is placed
over a button and clicked. As before, we retrieve the source of the
event using the <literal>getSource()</literal> method. A suitable message, including the
number of clicks, is displayed in the text box. Of course, recording the
button clicks could have been done with an <literal>ActionListener</literal> instead.</simpara>
<simpara>The only job of the <literal>main()</literal> method is to create an instance of
<literal>SimpleMouseEvents</literal>. You may wish to compile and execute the program and
test whether or not the program behaves as described.</simpara>
</example>
</section>
<section xml:id="_mouse_adapter">
<title>Mouse adapter</title>
<simpara>Creating a <literal>MouseListener</literal> requires all five methods in the interface to
be implemented. In some cases, as in ExampleÂ <xref linkend="example:Mouse_listener"/>,
there is no need to implement all the methods because we are not
interested in all the corresponding events. In such situations we are
forced to include the methods without any statement in the method body.
However, you might want to include the methods only when they are
needed. The <literal>MouseAdapter</literal> abstract class helps us avoid implementing
methods we do not need.</simpara>
<simpara><literal>MouseAdapter</literal> is an abstract class, unlike the <literal>MouseListener</literal>
interface. The advantage of using <literal>MouseAdapter</literal> is that it already
provides a skeletal implementation of each method needed to process
mouse events. We can override these implementations as needed, and we do
not need to provide an implementation of a method that is not used.</simpara>
<example>
<title>Mouse adapter</title>
<simpara>ProgramÂ <xref linkend="program:SimpleMouseAdapter"/> is a revised version of
ProgramÂ <xref linkend="program:SimpleMouseEvents"/>. At
lineÂ <xref linkend="simpleMouseAdapterClassDefLine"/> class <literal>SimpleMouseAdapter</literal>
extends the abstract class <literal>MouseAdapter</literal>. Thus, it inherits all the
empty methods defined in <literal>MouseAdapter</literal>. We then override only the
implementations of the methods we want to use, <literal>mouseEntered()</literal> and
<literal>mouseClicked()</literal> in this example. Remember that an abstract class is
<emphasis role="strong">extended</emphasis> whereas an interface is <emphasis role="strong">implemented</emphasis>.</simpara>
<formalpara xml:id="program:SimpleMouseAdapter" xreflabel="SimpleMouseAdapter">
<title>Program to handle mouse generated events using the <literal>MouseAdapter</literal> abstract class.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleMouseAdapter extends MouseAdapter {/*@\label{simpleMouseAdapterClassDefLine}@*/
    JFrame frame = new JFrame("Mouse Events");
    JTextField status = new JTextField(
    	"Mouse status comes here.");
    JButton one = new JButton("One");
    JButton two = new JButton("Two");
    int oneClicks = 0, twoClicks = 0;

    public SimpleMouseAdapter () {
    	JPanel panel = new JPanel();
        one.addMouseListener(this);
        two.addMouseListener(this);
        panel.add(one);
        panel.add(two);
        panel.add(status);
        frame.add(panel);
        frame.setSize(200,100);
        frame.setDefaultCloseOperation(
        	JFrame.DISPOSE_ON_CLOSE);
        frame.setVisible(true);
    }

    // Override only those methods we wants
    public void mouseEntered(MouseEvent e) { /*@\label{implementMouseEnteredLine}@*/
	    if (e.getSource() == one)
	        status.setText("Mouse enters One.");
	    else
	        status.setText("Mouse enters Two.");
    }

    public void mouseClicked(MouseEvent e) {/*@\label{implementMouseClickedLine}@*/
    	if (e.getSource() == one) {
			oneClicks++;
			status.setText("One clicked "+ oneClicks +
				" times.");
		}
		else {
			twoClicks++;
			status.setText("Two clicked "+ twoClicks  +
				" times.");
		}
    }

    public static void main(String[] args){
      new SimpleMouseAdapter ();
    }
}</programlisting>
</para>
</formalpara>
</example>
</section>
<section xml:id="_other_event_listeners">
<title>Other event listeners</title>
<simpara>In this chapter we describe two types of listeners in Java,
<literal>ActionListener</literal> and <literal>MouseListener</literal>. You may have noticed that none of
the mouse events we discussed involved the movement of the mouse inside
of the component, only whether it was entering or exiting the component.
Because tracking mouse movement is more computationally expensive than
tracking presses, releases, enters, and exits, Java uses yet another
listener to handle mouse movement, <literal>MouseMotionListener</literal>. It contains
the methods <literal>mouseDragged()</literal> and <literal>mouseMoved()</literal>, which are used to
handle mouse movement with or without the button pressed.</simpara>
<simpara>An <literal>ItemListener</literal> can be attached to a widget such as a check box or a
radio button to listen for a check box to be selected. This listener is
illustrated in SectionÂ <xref linkend="subsection:Applets"/>.</simpara>
<simpara>Java provides several other listeners to handle a variety of events. For
example, the <literal>DocumentListener</literal> can be attached to a <literal>JTextField</literal> or a
<literal>JTextArea</literal> object to listen to document events, which include the
<literal>insertUpdate()</literal> event that is fired when a character is inserted the
text box. A <literal>KeyListener</literal> can also be attached to text boxes to listen
to key events such as the return key being typed, which can have similar
functionality. These events could be useful while writing a text editor
application, for example.</simpara>
<simpara>After you have mastered the contents of this chapter, you may plan to
write more complex GUIs than the ones we discuss. For further
information, you may wish to follow the Java tutorial on writing event
listeners provided by Oracle at
<link xl:href="http://download.oracle.com/javase/tutorial/uiswing/events/index.html">http://download.oracle.com/javase/tutorial/uiswing/events/index.html</link>.</simpara>
</section>
</section>
<section xml:id="_adding_sounds_and_images">
<title>Adding sounds and images</title>
<simpara>Sounds and images can also be added to a Java GUI application. While
Java offers a rich set of sound APIs, we restrict our examples to
playing sound clips from audio files that come in <literal>au</literal> or <literal>wav</literal> formats.
We also introduce the <literal>ImageIcon</literal> class to create icons from image
files.</simpara>
<section xml:id="_sounds">
<title>Sounds</title>
<simpara>First, let&#8217;s see how to define an audio clip.</simpara>
<programlisting language="java" linenumbering="unnumbered">AudioClip chirpClip = Applet.newAudioClip(chirpURL);</programlisting>
<simpara>This statement declares <literal>chirpClip</literal> with type <literal>AudioClip</literal>. It
instantiates <literal>chirpClip</literal> using the <literal>newAudioClip()</literal> method found in the
<literal>Applet</literal> class in the <literal>java.applet</literal> package. Note that the argument to
the <literal>newAudioClip()</literal> method is an object of type <literal>URL</literal>. URL stands for
<emphasis>universal resource locator</emphasis>. It serves as a web address from which
files can be retrieved. A <literal>URL</literal> object can be defined as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">URL chirpURL =
    new URL("http://users.etown.edu/w/wittmanb/chirp.wav");</programlisting>
<simpara>Above we specify the full URL to access an audio file named <literal>chirp.wav</literal>.
Alternately you can give the file name from a local directory.</simpara>
<programlisting language="java" linenumbering="unnumbered">URL chirpURL = new URL("file:sounds/chirp.wav");</programlisting>
<simpara>The prefix <literal>file:</literal> indicates that the <literal>chirp.wav</literal> file is in a local
directory. Once a clip has been declared and loaded, it can be played as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">chirpClip.play();</programlisting>
<simpara>This command will play the clip in <literal>chirpClip</literal> loaded from the specified
URL, exactly once. If you want to play the clip in a loop, use the
<literal>loop()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">chirpClip.loop();</programlisting>
<simpara>To stop a clip from playing, use the <literal>stop()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">chirpClip.stop();</programlisting>
<simpara>Now that we have seen how to declare, load, play, and stop an audio
clip, we are ready to write a more interesting version of
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/>.</simpara>
<example>
<title>Sound game</title>
<simpara>We can rewrite ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/> so that the
new program plays the sound clips in a loop when the corresponding
button is clicked. Think of the new program as a Java version of the
pull-string toys that children use to play animal sounds. Our program
only has two sounds, but more could be added.</simpara>
<figure role="text-center">
<title>GUI for the sound game application. (a)Â On program start. (b)Â After the &#8220;Chirp&#8221; button has been clicked and the clip is playing.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/soundGameFigures.svg" width="80%"/>
</imageobject>
<textobject><phrase>soundGameFigures</phrase></textobject>
</mediaobject>
</figure>
<simpara>We will add a new button labeled &#8220;Stop Sound&#8221; that stops the playback
of sounds when clicked. Let&#8217;s assume that this program is only allowed
to play one sound at a time. When it starts, the GUI will look like
FigureÂ <xref linkend="SoundGameFigures"/>(a). Note that the <literal>stop</literal> button is gray,
indicating that it is disabled.</simpara>
<simpara>The complete program for the game is shown in
ProgramÂ <xref linkend="program:SoundGame"/>. Because most of this program is similar
to ProgramÂ <xref linkend="program:FrameWithPanel"/>, we will only look at the
differences. The action listeners for the <literal>chirp</literal> and <literal>bark</literal> buttons are
called when these two buttons are clicked. On lineÂ <xref linkend="buttonDisableLine"/>
we disable the <literal>bark</literal> button when the bird chirp sound is playing. Also,
on lineÂ <xref linkend="buttonEnableLine"/> we enable the <literal>stop</literal> button so that the
user can stop the chirp sound. Note that the <literal>stop</literal> button begins
disabled and remains that way until a sound is played. The GUI now looks
like FigureÂ <xref linkend="SoundGameFigures"/>(b).</simpara>
<formalpara xml:id="program:SoundGame" xreflabel="SoundGame">
<title>An animal sound game.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.event.*;
import java.applet.*;
import java.net.URL;

public class SoundGame {
  public static void main (String[] args) throws Exception {
    final JFrame soundGame = new JFrame("Sound Game");
    JPanel soundPanel = new JPanel();
    final JButton chirp = new JButton("Chirp");
    final JButton bark = new JButton("Bark");
    final JButton stop = new JButton("Stop Sound");
    final JButton exit = new JButton("Exit");
    final JTextField message =
    	new JTextField("Click Chirp or Bark.   ");
    URL chirpURL = new URL("file:sounds/chirp.wav");
    URL barkURL = new URL("file:sounds/bark.wav");
    final AudioClip chirpClip = Applet.newAudioClip(chirpURL);
    final AudioClip barkClip = Applet.newAudioClip(barkURL);
    soundPanel.add(chirp);
    soundPanel.add(bark);
    soundPanel.add(stop);
    soundPanel.add(exit);
    soundPanel.add(message);
    soundGame.add(soundPanel);
    stop.setEnabled(false); /*@\label{stopButtonDisableLine}@*/
    chirp.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e){
        message.setText("Chirp sound playing.");
        bark.setEnabled(false);  /*@\label{buttonDisableLine}@*/
        chirpClip.loop(); /*@\label{soundPlayLine}@*/
        stop.setEnabled(true); /*@\label{buttonEnableLine}@*/
      }
    });
    bark.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        message.setText("Bark sound playing.");
        chirp.setEnabled(false);
        barkClip.loop();
        stop.setEnabled(true);
      }
    });
    stop.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        message.setText("Click Chirp or Bark.");
        chirpClip.stop();
        bark.setEnabled(true);
        barkClip.stop();
        chirp.setEnabled(true);
        stop.setEnabled(false);
      }
    });
    exit.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        System.out.println("Exit");
        soundGame.dispose();
      }
    });
    soundGame.setSize(175,175); //Set size in pixels
    soundGame.setDefaultCloseOperation(
    	JFrame.DISPOSE_ON_CLOSE);
    soundGame.setVisible(true); //Display it
  }
}</programlisting>
</para>
</formalpara>
<simpara>The actions for the <literal>bark</literal> button are very similar to the actions for
the <literal>chirp</literal> button, but the actions for <literal>stop</literal> are different. When
<literal>stop</literal> is clicked, the action listener does not know which sound is
playing. For that reason, it stops both sounds and then disables the
stop button. An exercise asks you to modify the program so that the
action listener associated with the <literal>stop</literal> button knows which sound is
playing.</simpara>
</example>
</section>
<section xml:id="_images_and_icons">
<title>Images and icons</title>
<simpara>Images are often useful when creating GUIs. In this section we show you
how to use images to create icons and then use the icon to decorate
buttons and labels. First, let&#8217;s see how an icon object can be created.
Suppose we have a picture file named <literal>smile.jpg</literal> in a directory named
<literal>pictures</literal>. Note that the <literal>pictures</literal> directory should be located in same
directory as the class files for the program. The following statement
creates an object of type <literal>ImageIcon</literal> from this picture.</simpara>
<programlisting language="java" linenumbering="unnumbered">ImageIcon smileIcon = new ImageIcon("pictures/smile.jpg");</programlisting>
<simpara>Note that the file name, along with its path, is passed to the
<literal>ImageIcon</literal> constructor as a string. Now we can add the image to a
button.</simpara>
<programlisting language="java" linenumbering="unnumbered">JButton smile = new JButton();
smile.add(smileIcon);</programlisting>
<simpara>Similarly you can add an image icon to a label. The next example gives a
simple program that creates a button with an image.</simpara>
<example>
<title>Icon example</title>
<simpara>FigureÂ <xref linkend="IconExampleFigure"/> shows a GUI with a button decorated with a
picture. ProgramÂ <xref linkend="program:IconExample"/> gives the code to create this
GUI using the <literal>ImageIcon</literal> class.</simpara>
<figure role="text-center">
<title>A GUI with a button decorated by an image icon.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/iconExampleFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>iconExampleFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>As explained earlier, an image icon is created at
lineÂ <xref linkend="iconCreationLine"/> from a JPEG file named <literal>smile.jpg</literal> located in
the <literal>pictures</literal> directory. The following line creates a button named
<literal>smile</literal> and decorates it with the icon by supplying it as an argument to
the <literal>JButton</literal> constructor. Note that, if the file cannot be found, the
program will fail <emphasis>quietly</emphasis>. This means that no exception is thrown.
Instead, the button will appear with no image. Subsequent lines add the
button to the frame, set the frame size and its default close operation,
and make the frame visible.</simpara>
<formalpara xml:id="program:IconExample" xreflabel="IconExample">
<title>A program to create a GUI with a button decorated by a picture.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;

public class IconExample {
  public static void main(String[] args) {
	JFrame iconFrame = new JFrame("Icon Example");
	ImageIcon smileIcon = new ImageIcon(/*@\label{iconCreationLine}@*/
		"pictures/smile.jpg");
	JButton  smile = new JButton(smileIcon);/*@\label{adIconToButtonLine}@*/
	iconFrame.add(smile);
	iconFrame.setSize(325,250);
	iconFrame.setDefaultCloseOperation(
		JFrame.DISPOSE_ON_CLOSE);
	iconFrame.setVisible(true);
  }
}</programlisting>
</para>
</formalpara>
</example>
</section>
<section xml:id="_labels_icons_and_text">
<title>Labels, icons, and text</title>
<simpara>In some applications you might want to show a picture with an attached
text label. For example, in a shopping cart for an online clothing
store, you might have seen pictures of clothes, each labeled with a name
and a price. The <literal>JLabel</literal> class is flexible, able to display text alone,
an image alone, or both. Note that a <literal>JLabel</literal> is only for displaying
information and is incapable of firing events or reading user input.</simpara>
<simpara>Here are three different ways to create a label.</simpara>
<programlisting language="java" linenumbering="unnumbered">ImageIcon hibiscus = new ImageIcon("pictures/hibiscus.jpg")
JLabel textOnly = new JLabel("Text only");
JLabel flower = new JLabel(hibiscus);
JLabel labeledflower = new JLabel("Red Hibiscus", hibiscus, JLabel.CENTER);</programlisting>
<simpara>The first <literal>JLabel</literal> constructor above creates a label displaying only
text, namely, &#8220;Text only.&#8221; The second constructor creates a label
decorated with an icon created from a picture. The third constructor
creates a label with the same icon and additional text. Note the last
argument in this third case. <literal>JLabel.CENTER</literal> is a constant that
specifies that the content of the label (both the image and the text)
should be placed horizontally in the center of the label. A horizontal
alignment of left or right can also be specified using the constants
<literal>JLabel.LEFT</literal> or <literal>JLabel.RIGHT</literal>, respectively. These three horizontal
alignment indicators are some of the many constants found in Swing.</simpara>
<simpara>Sometimes you might want to place the text below the icon that decorates
the label. This can be done as follows by setting the horizontal and
vertical positions of the text.</simpara>
<programlisting language="java" linenumbering="unnumbered">flower.setVerticalTextPosition(JLabel.BOTTOM);
flower.setHorizontalTextPosition(JLabel.CENTER);</programlisting>
<example>
<title>Label example</title>
<simpara>FigureÂ <xref linkend="labelExampleFigure"/>(a) is generated by executing ProgramÂ 
<xref linkend="program:LabelExample"/>. You will see the GUI shown in
FigureÂ <xref linkend="labelExampleFigure"/>(b) if the alignment instructions at
linesÂ <xref linkend="verticalTextPositioningLine"/> and
<xref linkend="horizontalTextPositioningLine"/> are omitted.</simpara>
<figure>
<title>(a) A GUI with a label decorated by an image icon and a title beneath it. (b) The GUI with unaligned text.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/labelExampleFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>labelExampleFigure</phrase></textobject>
</mediaobject>
</figure>
<formalpara xml:id="program:LabelExample" xreflabel="LabelExample">
<title>A program to create a GUI with a label decorated by a picture and text.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;

public class LabelExample {
	public static void main(String[] args) {
		JFrame frame = new JFrame("Label Example");
		ImageIcon hibiscus = new ImageIcon(
			"pictures/hibiscus.jpg");
		JLabel flower = new JLabel("Red Hibiscus",
			hibiscus, JLabel.CENTER);
		flower.setVerticalTextPosition(JLabel.BOTTOM); /*@\label{verticalTextPositioningLine}@*/
		flower.setHorizontalTextPosition(JLabel.CENTER);/*@\label{horizontalTextPositioningLine}@*/
		frame.add(flower);
		frame.setSize(300,250);
		frame.setDefaultCloseOperation(
			JFrame.DISPOSE_ON_CLOSE);
		frame.setVisible(true);
  }
}</programlisting>
</para>
</formalpara>
</example>
</section>
</section>
<section xml:id="_layout_managers">
<title>Layout managers</title>
<simpara>Java provides a number of <emphasis>layout managers</emphasis> to assist with the design of
GUIs. A layout manager is an object that controls the placement of
widgets on a frame or panel. Every container has a default layout
manager, but it is possible to set it to other ones. In this section we
will introduce the three layout managers <literal>FlowLayout</literal>, <literal>GridLayout</literal>, and
<literal>BorderLayout</literal>. Java also provides several other layout managers, each
designed for different layouts.</simpara>
<section xml:id="_literal_flowlayout_literal">
<title><literal>FlowLayout</literal></title>
<simpara>The <literal>FlowLayout</literal> manager is one of simplest layout managers. When a
container is using the <literal>FlowLayout</literal> manager, widgets will be added in
order from left to right. When there is no more space, subsequent
widgets will be added starting on the next row. In addition, each row of
components is centered within the container. The <literal>JPanel</literal> container uses
<literal>FlowLayout</literal> by default, but it is possible to set it explicitly as
well.</simpara>
<programlisting language="java" linenumbering="unnumbered">JPanel panel = new JPanel(new FlowLayout());</programlisting>
<simpara>When we have added more than one widget to a <literal>JFrame</literal> in previous
examples, we have first added them to a <literal>JPanel</literal>. The reason we have
done so is because <literal>FlowLayout</literal> is the default layout manager for
<literal>JPanel</literal> containers. Although every <literal>JFrame</literal> has a container, it uses
the <literal>BorderLayout</literal> manager by default, which would have complicated our
examples. The next example illustrates <literal>FlowLayout</literal> further.</simpara>
<example>
<title>FlowLayout</title>
<simpara>ProgramÂ <xref linkend="program:FlowLayoutExample"/> creates a GUI with several
buttons. It first creates a frame. At lineÂ <xref linkend="setLayoutManagerLine"/> it
creates a panel and set its layout manager to <literal>FlowLayout</literal>. Then, it
uses a <literal>for</literal> loop to create a new button, label it appropriately, and
add it to the panel.</simpara>
<simpara>The <literal>Flowlayout</literal> manager neatly places the buttons along a number of
rows depending on the width of the frame. The GUI created is shown in
FigureÂ <xref linkend="figure:FlowLayoutExampleFigure"/>. Run the program and resize
the frame to see the effect on the layout of the buttons.</simpara>
<formalpara xml:id="program:FlowLayoutExample" xreflabel="FlowLayoutExample">
<title>Adding several buttons using <literal>FlowLayout</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;

public class FlowLayoutExample {
  public static void main(String[] args) {
    JFrame frame = new JFrame("FlowLayout Example");
    JPanel panel = new JPanel(new FlowLayout());  /*@\label{setLayoutManagerLine}@*/
    final int MAX_BUTTONS = 6;
    for(int i = 0; i &lt; MAX_BUTTONS; i++)
    	panel.add(new JButton("   " + i + "   "));/*@\label{createAButtonLine}@*/
    frame.add(panel);
    frame.setSize(250,100);
    frame.setResizable(false);/*@\label{disableResizableLine}@*/
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    frame.setVisible(true);
  }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>Using the <literal>FlowLayout</literal> manager to generate a GUI containing six buttons.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/flowLayoutExampleFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>flowLayoutExampleFigure</phrase></textobject>
</mediaobject>
</figure>
</example>
</section>
<section xml:id="_literal_gridlayout_literal">
<title><literal>GridLayout</literal></title>
<simpara>The <literal>GridLayout</literal> manager lays out components in a grid with a set number
of rows and columns. As with other layout managers, <literal>GridLayout</literal> can be
applied to frames and panels.</simpara>
<programlisting language="java" linenumbering="unnumbered">JFrame frame = new JFrame("Grid Layout");
frame.setLayout(new GridLayout(3, 2, 5, 5));</programlisting>
<simpara>This snippet creates a frame named <literal>frame</literal> and sets its layout manager
to <literal>GridLayout</literal>. The first two arguments to <literal>GridLayout</literal> give the number
of rows and columns, respectively. The last two arguments give the
horizontal and vertical gaps between the neighboring cells in the grid.
In this example the frame will contain a total of six cells organized
into three rows with two columns.</simpara>
<figure role="text-center">
<title>A 3 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 2 grid layout containing six buttons using left to right orientation.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/gridLayoutLToRFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>gridLayoutLToRFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>FigureÂ <xref linkend="gridLayoutLToRFigure"/> shows how <literal>frame</literal> will look after six
buttons, labeled 0 through 5, have been added to it in that order. A key
feature of using a <literal>GridLayout</literal> is that all cells in the grid will be
the same size and will stretch to fill the entire container. Also note
the equal spacing between the neighboring cells. It is possible to add
more or fewer cells than specified in the <literal>GridLayout</literal> constructor, but
the layout manager will be forced to guess at your intentions.</simpara>
<example>
<title>Animal identifier</title>
<simpara>We can write a program to displays pictures of animals and identify
which animal the mouse is current hovering over. The animal&#8217;s name will
be displayed in the title of the frame.
FigureÂ <xref linkend="animalIdentifierFigure"/> shows this GUI.</simpara>
<figure role="text-center">
<title>A GUI for an animal identifier. Note that the bison is identified according to the frame title.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/animalIdentifierFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>animalIdentifierFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>ProgramÂ <xref linkend="program:AnimalIdentifier"/> creates the GUI shown in
FigureÂ <xref linkend="animalIdentifierFigure"/>. Class <literal>AnimalIdentifier</literal> declares
four labels and a frame as fields. The labels are named <literal>bison</literal>, <literal>dove</literal>,
<literal>gecko</literal>, and <literal>spider</literal>.</simpara>
<formalpara xml:id="program:AnimalIdentifier" xreflabel="AnimalIdentifier">
<title>A program that identifies which animal is in various images when the mouse hovers over the image. Images are laid out using a <literal>GridLayout</literal> manager.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class AnimalIdentifier implements MouseListener {
  JLabel bison, dove, gecko, spider;
  JFrame frame = new JFrame("Animal Identifier: Bison");

  public AnimalIdentifier() {/*@\label{PicIdentifierConstructorLine}@*/
	JPanel panel = new JPanel(new GridLayout(2,2,5,5));
    ImageIcon bisonIcon = new ImageIcon("pictures/bison.jpg");
    ImageIcon doveIcon = new ImageIcon("pictures/dove.jpg");
    ImageIcon geckoIcon = new ImageIcon("pictures/gecko.jpg");
    ImageIcon spiderIcon = new ImageIcon("pictures/spider.jpg");
    bison = new JLabel(bisonIcon);
    bison.addMouseListener(this); /*@\label{buttonDecoratorLine}@*/
    dove = new JLabel(doveIcon);
    dove.addMouseListener(this);
    gecko = new JLabel(geckoIcon);
    gecko.addMouseListener(this);
    spider = new JLabel(spiderIcon);
    spider.addMouseListener(this);
    // Add labels
    panel.add(bison); /*@\label{prepareButtonPanelLine}@*/
    panel.add(dove);
    panel.add(gecko);
    panel.add(spider);
    frame.add(panel);
    frame.setSize(400,400);
    frame.pack();
    frame.setDefaultCloseOperation(
    	JFrame.DISPOSE_ON_CLOSE);
    frame.setVisible(true);
  }
  // Implement all abstract methods in MouseListener
  public void mouseEntered(MouseEvent e) { /*@\label{mouseEventEnteredLine}@*/
    Object label = e.getSource();/*@\label{getPicMouseEventLine}@*/
    if (label == bison)
      frame.setTitle("Animal Identifier: Bison");
    else if(label == dove)
      frame.setTitle("Animal Identifier: Dove");
    else if (label == gecko)
      frame.setTitle("Animal Identifier: Gecko");
    else if (label == spider)
      frame.setTitle("Animal Identifier: Spider");
  }

  public void mouseExited(MouseEvent e) {
	  System.out.println("Mouse exited."); /*@\label{mouseEventsLine}@*/
  }

  public void mousePressed(MouseEvent e) {
	  System.out.println("Mouse pressed.");
  }

  public void mouseReleased(MouseEvent e) {
	  System.out.println("Mouse released");
  }

  public void mouseClicked(MouseEvent e) {
	  System.out.println("Mouse clicked.");
  }

  public static void main(String[] args) {
    new AnimalIdentifier();
  }
}</programlisting>
</para>
</formalpara>
<simpara>Inside the constructor, we create a panel with a
<inlineequation><alt><![CDATA[2 \times 2]]></alt><mathphrase><![CDATA[2 \times 2]]></mathphrase></inlineequation> <literal>GridLayout</literal>. Then, we create four image icons,
one to decorate each label. Next, starting at
lineÂ <xref linkend="buttonDecoratorLine"/>, each of the four labels is created with
its respective icon. We also add a <literal>MouseListener</literal> to each label.
Starting at lineÂ <xref linkend="prepareButtonPanelLine"/>, the buttons are added to
the panel, and the panel is added to the frame. The last few lines set
the size of the frame, pack it, set its close operation, and make it
visible.</simpara>
<simpara>Since <literal>AnimalIdentifier</literal> implements <literal>MouseListener</literal>, we need to define
all the methods in the <literal>MouseListener</literal> interface. These are implemented
starting at lineÂ <xref linkend="mouseEventEnteredLine"/>. As we are only interested in
displaying the name of a picture when the mouse moves over it, the
<literal>mouseEntered()</literal> method is where most of our even handling code will be.
At lineÂ <xref linkend="getPicMouseEventLine"/> we get the label the mouse entered. We
compare this label to the four labels and change the frame title
correspondingly.</simpara>
<simpara>We implement the remaining methods from <literal>MouseListener</literal> to report the
event on the console. The <literal>main()</literal> method creates a new instance of
class <literal>AnimalIdentifier</literal>, launching the GUI.</simpara>
<simpara>Play with ProgramÂ <xref linkend="program:AnimalIdentifier"/>. What happens when you
resize the window?</simpara>
</example>
</section>
<section xml:id="_literal_borderlayout_literal">
<title><literal>BorderLayout</literal></title>
<simpara>The <literal>BorderLayout</literal> manager is the default one for a <literal>JFrame</literal>. It allows
components to be laid out spatially in regions of a container. These
regions are north, south, east, west, and center. This layout is
intuitively easy to understand, but it is difficult to describe
precisely.</simpara>
<simpara>You can only add one component to each region of the layout, and adding
a component to any region is optional. The regions will stretch or
shrink to accommodate the components inside. The north and south regions
will only be as tall as needed to hold their contents, but their width
will stretch as wide as the entire container. The east and west regions
will only be as wide as needed to hold their contents, but their height
will stretch as tall as needed to fit the remaining height of the
container. Both the height and the width of the center region will
stretch as big as it needs to fill the container.</simpara>
<example>
<title>BorderLayout</title>
<simpara>Here is an example of a frame using <literal>BorderLayout</literal>. Five buttons have
been added, one to each region, using the program shown below.</simpara>
<formalpara xml:id="program:BorderLayoutExample" xreflabel="BorderLayoutExample">
<title>Program showing buttons laid out in each of the five regions of a <literal>BorderLayout</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;

public class BorderLayoutExample {
  public static void main(String[] args) {
    JFrame frame = new JFrame("BorderLayout Example");
    JPanel panel = new JPanel(new BorderLayout());
    panel.add(new JButton("North"), BorderLayout.NORTH);
    panel.add(new JButton("South"), BorderLayout.SOUTH);
    panel.add(new JButton("East"), BorderLayout.EAST);
    panel.add(new JButton("West"), BorderLayout.WEST);
    panel.add(new JButton("Center"), BorderLayout.CENTER);
    frame.add(panel);
    frame.setSize(300,200);
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    frame.setVisible(true);
  }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>A GUI demonstrating <literal>BorderLayout</literal> generated by ProgramÂ <xref linkend="program:BorderLayoutExample"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/borderLayoutFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>borderLayoutFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>Unlike <literal>FlowLayout</literal> or <literal>GridLayout</literal>, the location must be specified to
add a component to a <literal>BorderLayout</literal>. (There is an overloaded <literal>add()</literal>
method to add a component to specific grid cell in a <literal>GridLayout</literal>, but
it is not necessary to use it.) With <literal>BorderLayout</literal>, the <literal>add()</literal> method
uses a second parameter, which is <literal>BorderLayout.NORTH</literal>,
<literal>BorderLayout.SOUTH</literal>, <literal>BorderLayout.EAST</literal>, <literal>BorderLayout.WEST</literal>, or
<literal>BorderLayout.CENTER</literal>, depending on where you want to add the component.
If you do not specify a second parameter, the component will be added to
the center region. Since only one component can be in each region,
adding a component to a region that is already occupied will replace the
old component with the new one.</simpara>
</example>
<simpara>At first glance, <literal>BorderLayout</literal> seems that it would rarely be useful.
However, this layout is commonly used because it can be used to
establish a spatial relationship between different parts of a GUI. A
container with a <literal>BorderLayout</literal> generally has other containers with
their own layouts added to its regions, as shown in the following
example.</simpara>
<example>
<title>Calculator layout</title>
<simpara>We can make a GUI application that functions as a simple calculator. The
calculator has the ten digits 0-9, a plus button, a minus button, and an
enter button. At the top is a display that shows the current value.</simpara>
<simpara>We create ten <literal>JButton</literal> objects for the digits and three more <literal>JButton</literal>
objects for plus, minus, and enter. The display is a <literal>JLabel</literal>. The code
is given below.</simpara>
<formalpara xml:id="program:CalculatorLayout" xreflabel="CalculatorLayout">
<title>Program to layout a simple calculator.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;

public class CalculatorLayout {
  public static void main(String[] args) {
    JFrame frame = new JFrame("Calculator Layout");
    JPanel panel = new JPanel(new BorderLayout());
    JPanel numbers = new JPanel(new GridLayout(4,3));
    numbers.add(new JButton("7"));
    numbers.add(new JButton("8"));
    numbers.add(new JButton("9"));
    numbers.add(new JButton("4"));
    numbers.add(new JButton("5"));
    numbers.add(new JButton("6"));
    numbers.add(new JButton("1"));
    numbers.add(new JButton("2"));
    numbers.add(new JButton("3"));
    numbers.add(new JButton("0"));
    numbers.add(new JButton("+"));
    numbers.add(new JButton("-"));
    panel.add(numbers, BorderLayout.CENTER);
    JButton enter = new JButton("Enter");
    panel.add(enter, BorderLayout.SOUTH);
    JLabel display = new JLabel("0");
    panel.add(display, BorderLayout.NORTH);
    frame.add(panel);
    frame.setSize(250,300);
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    frame.setVisible(true);
  }
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>GUI generated by ProgramÂ <xref linkend="program:CalculatorLayout"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/calculatorLayoutFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>calculatorLayoutFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>This program uses a <literal>BorderLayout</literal> to put a container with a
<literal>GridLayout</literal> in a spatial arrangement with other components. First, we
put the ten digit buttons in a panel with a <literal>GridLayout</literal> having 4 rows
and 3 columns. We put the plus button and the minus button in the
remaining two cells of the grid. We add this grid panel to the larger
panel in the center region. We put the enter button in the south region
and the display in the north region.</simpara>
</example>
<simpara>There is no limit to how deeply you can nest containers within each
other. Sometimes you must create a very complex GUI using many
<literal>BorderLayout</literal> managers to achieve the appearance you want.</simpara>
<simpara>The three layout managers discussed in this section are the simplest,
but there are others. The <literal>BoxLayout</literal> manager is a useful tool for
laying out components in a stack or in a row. The <literal>GridBagLayout</literal>
manager can be used to create complex layouts in a single container
using a grid-based framework that is much more flexible than
<literal>GridLayout</literal>, but the complexity of programming <literal>GridBagLayout</literal> is
significant. The <literal>SpringLayout</literal> and <literal>GroupLayout</literal> managers are also
powerful, but they are designed for use with a GUI builder utility.</simpara>
</section>
</section>
<section xml:id="_menus">
<title>Menus</title>
<simpara>Menus provide a useful form of interface that is expected from most GUI
applications. In this section we show how to create menus and respond to
the selection of menu items. Menus are placed on a menu bar. Each menu
usually consists of several menu items that could be selected by the
user. In addition to simple text, a menu item can be a button, a radio
button, check box, or an icon. A menu can have one or more sub-menus
opening out of a menu item.</simpara>
<section xml:id="_creating_menus">
<title>Creating menus</title>
<simpara>First we have to create a menu bar.</simpara>
<programlisting language="java" linenumbering="unnumbered">JMenuBar bar = new JMenuBar();</programlisting>
<simpara>This statement creates an object of type <literal>JMenuBar</literal> named <literal>bar</literal> which
can hold menus. A <literal>JFrame</literal> has only one menu bar. We can create several
menus and add them to the menu bar.</simpara>
<programlisting language="java" linenumbering="unnumbered">JMenu type = new JMenu("Type");
JMenu operations = new JMenu("Operations");
bar.add(type);
bar.add(operations);</programlisting>
<simpara>These statements create two menus named <literal>type</literal> and <literal>operations</literal> labeled
&#8220;Type&#8221; and &#8220;Operations,&#8221; respectively. The two menus are added to
the existing menu bar using the <literal>add()</literal> method. Menus can be populated
with menu items as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">JMenuItem addition = new JMenuItem("Addition");
JMenuItem subtraction = new JMenuItem("Subtraction")
operation.add(addition);
operation.add(subtraction);</programlisting>
<simpara>These statements create two menu items named <literal>addition</literal> and
<literal>subtraction</literal>. These menu items are then added to the menu <literal>operations</literal>.
After having created a menu bar together with its menus and their
respective menu items, we need to add it to a frame.</simpara>
<programlisting language="java" linenumbering="unnumbered">JFrame frame = new JFrame("Menu Example");
frame.setJMenuBar(bar);</programlisting>
<simpara>These statements create a frame and set its menu bar to <literal>bar</literal>. It is
possible to use the <literal>add()</literal> method instead of the <literal>setJMenuBar()</literal> method
to add a <literal>JMenuBar</literal> to a <literal>JFrame</literal>. However, doing so will add the
<literal>JMenuBar</literal> to the regular content area, <emphasis role="strong">not</emphasis> to the menu area.</simpara>
<simpara>Sometimes you might need to disable a menu item and enable it only under
certain conditions.</simpara>
<programlisting language="java" linenumbering="unnumbered">JMenuItem subtraction = new JMenuItem("Subtraction");
subtraction.setEnabled(false);</programlisting>
<simpara>These statements create a menu item named <literal>subtraction</literal> and disable it.
A disabled menu item shows as a gray item and does not respond to
attempts to select it. Note that <literal>JButton</literal> objects and many other
widgets can be disabled in the same way.</simpara>
</section>
<section xml:id="_adding_events_to_menus">
<title>Adding events to menus</title>
<simpara>An action listener can be added to each menu item, just like a
<literal>JButton</literal>. Then, when a menu item is clicked by the user, an action
event is generated. A <literal>JCheckBoxMenuItem</literal> object can be added to a
<literal>JMenu</literal> as well. This object will have a check box which can be selected
or unselected. A regular <literal>JMenuItem</literal> object generates an <literal>ActionEvent</literal>
which is handled by an <literal>ActionListener</literal>. A <literal>JCheckBoxMenuItem</literal>, however,
generates an <literal>ItemEvent</literal> handled by an <literal>ItemListener</literal>. Here are examples
of both situations.</simpara>
<programlisting language="java" linenumbering="unnumbered">JMenuItem subtraction = new JMenuItem("Subtraction");
JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem("Check yourself");
subtraction.addActionListener(this);
checkbox.addItemListener(this);</programlisting>
<simpara>A <literal>JMenuItem</literal> works just like a <literal>JButton</literal>. In fact, the same action
listener code could handle events for both buttons and menu items.
However, a <literal>JCheckBoxMenuItem</literal> generates an <literal>ItemEvent</literal> (like many other
check box and list widgets that we do not discuss) when the state of its
check box changes. Thus, when you select a check box, a
<inlineequation><alt><![CDATA[\surd]]></alt><mathphrase><![CDATA[\surd]]></mathphrase></inlineequation> sign appears to its left and an <literal>ItemEvent</literal> is
generated. When you select an already checked check box, the sign
disappears and another <literal>ItemEvent</literal> is generated. Although an
<literal>ActionEvent</literal> and an <literal>ItemEvent</literal> are very similar, Java differentiates
between them because an <literal>ItemEvent</literal> has more information: By using the
<literal>getStateChange()</literal> method, it is possible to tell whether the widget
that fired the <literal>ItemEvent</literal> is now selected or deselected.</simpara>
<example>
<title>Math tutor</title>
<simpara>Here we give the code to generate the GUI shown in
FigureÂ <xref linkend="MathTutorFigure"/> which displays basic (addition and
subtraction) as well as advanced (multiplication and division) problems.
In SectionÂ <xref linkend="subsection:Applets"/> we transform this GUI into an applet
like the one described in SectionÂ <xref linkend="problem:Math_applet"/>.</simpara>
<figure>
<title>GUI for the <literal>MathTutor</literal>. (a)Â No menu selected. (b)Â Type selected. (c)Â Operations selected.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/mathTutorFigure.svg" width="100%"/>
</imageobject>
<textobject><phrase>mathTutorFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>As shown in FigureÂ <xref linkend="MathTutorFigure"/>, this GUI has a menu bar
consisting of two menus labeled &#8220;Type&#8221; and &#8220;Operations.&#8221; The
&#8220;Type&#8221; menu contains a check box labeled &#8220;Advanced&#8221; while the
&#8220;Operations&#8221; menu contains four menu items labeled &#8220;Add,&#8221;
&#8220;Subtract,&#8221; &#8220;Multiply,&#8221; and &#8220;Divide.&#8221; Note that the &#8220;Multiply&#8221;
and &#8220;Divide&#8221; menu items are disabled. They will be enabled when the
user selects the &#8220;Advanced&#8221; check box.</simpara>
<simpara>Before we introduce the program that creates this GUI, we need a helper
class called <literal>ProblemGenerator</literal> that can randomly generate arithmetic
problems. The class is designed so that the answers are always positive
integers.</simpara>
<formalpara xml:id="program:ProblemGenerator" xreflabel="ProblemGenerator">
<title>Utility class to generate random addition, subtraction, multiplication, and division problems.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Random;
import javax.swing.*;

public class ProblemGenerator {
	public static Random random = new Random();

	public static int addPractice( JLabel label ) {
		int a = random.nextInt(12) + 1;
		int b = random.nextInt(12) + 1;
		label.setText( a + " + " + b + " = ");
		return a + b;
	}

	public static int subtractPractice( JLabel label ) {
		int a = random.nextInt(12) + 1;
		int b = a + random.nextInt(12) + 1;
		label.setText( b + " - " + a + " = ");
		return b - a;
	}

	public static int multiplyPractice( JLabel label ) {
		int a = random.nextInt(12) + 1;
		int b = random.nextInt(12) + 1;
		label.setText( a + " \u00D7 " + b + " = ");
		return a * b;
	}

	public static int dividePractice( JLabel label ) {
		int a = random.nextInt(12) + 1;
		int b = a*(random.nextInt(12) + 1);
		label.setText( b + " \u00F7 " + a + " = ");
		return b / a;
	}
}</programlisting>
</para>
</formalpara>
<simpara>The code listed above has four static methods <literal>addPractice()</literal>,
<literal>subtractPractice()</literal>, <literal>multiplyPractice()</literal>, and <literal>dividePractice()</literal>. Each
method generates an appropriate math problem, sets an input <literal>JLabel</literal> to
display the problem, and returns the solution. Note that <literal>\\u00D7</literal> and
<literal>\\u00F7</literal> are the Unicode values for the multiplication and division
symbols.</simpara>
<simpara>ProgramÂ <xref linkend="program:MathTutor"/> generates the GUI in
FigureÂ <xref linkend="MathTutorFigure"/>. Class <literal>MathTutor</literal> begins by creating only
the objects that need to interact with event handlers: four menu items,
a label, and a text field.</simpara>
<formalpara xml:id="program:MathTutor" xreflabel="MathTutor">
<title>Program that uses menus to generate math problems.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class MathTutor implements ActionListener, ItemListener {
	private JMenuItem add = new JMenuItem("Addition");
	private JMenuItem subtract = new JMenuItem("Subtraction");
	private JMenuItem multiply = new JMenuItem("Multiply");
	private JMenuItem divide = new JMenuItem ("Divide");
    private JLabel score =
    	new JLabel("Score: 0 Correct 0 Incorrect");
    private JLabel label = new JLabel();
    private JTextField field = new JTextField(10);
    private JButton submit = new JButton("Submit");

    public MathTutor() {
        JFrame frame = new JFrame("Math Tutor");
        JMenuBar menuBar = new JMenuBar();
        JMenu type = new JMenu("Type");
        JMenu operations = new JMenu("Operations");
        JCheckBoxMenuItem advanced =
        	new JCheckBoxMenuItem("Advanced");
    	// Add ActionListeners to menu items
    	add.addActionListener(this);/*@\label{addActionsToMenuItemsLine}@*/
        subtract.addActionListener(this);
        multiply.addActionListener(this);
        divide.addActionListener(this);
        // Add ItemListener to checkbox menu item
        advanced.addItemListener(this);
        // Fill menu for problem type
        type.add(advanced); /*@\label{createMenuLine}@*/
        // Fill menu for operations
        operations.add(add);
        operations.add(subtract);
        operations.add(multiply);
        operations.add(divide);
        // Disable advanced operations
        multiply.setEnabled(false); /*@\label{defaultDisableLine}@*/
        divide.setEnabled(false);
        // Fill menu bar set on frame
        menuBar.add(type);
        menuBar.add(operations);
        frame.setJMenuBar(menuBar);
		// Add widgets to frame and display GUI
        frame.add( score, BorderLayout.NORTH );
        frame.add( label, BorderLayout.WEST );
        frame.add( field, BorderLayout.EAST );
        frame.add( submit, BorderLayout.SOUTH );
        frame.setSize(250, 125);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setVisible(true);
    }

    public void itemStateChanged(ItemEvent e) {
    	if(e.getStateChange() == ItemEvent.SELECTED ) {
            add.setEnabled(false); /*@\label{enableDisableAdvancedLine}@*/
            subtract.setEnabled(false);
            multiply.setEnabled(true);
            divide.setEnabled(true);
    	}
    	else {
			add.setEnabled(true); /*@\label{enableDisableBasicLine}@*/
			subtract.setEnabled(true);
			multiply.setEnabled(false);
			divide.setEnabled(false);
    	}
    }

    public void actionPerformed(ActionEvent e){
    	Object menuItem = e.getSource();
    	if( menuItem == add )
    		ProblemGenerator.addPractice( label );
        else if( menuItem == subtract )
        	ProblemGenerator.subtractPractice( label );
        else if( menuItem == multiply )
        	ProblemGenerator.multiplyPractice( label );
        else if( menuItem == divide )
        	ProblemGenerator.dividePractice( label );
    	field.setText("");
    }

    public static void main(String[] args){
        new MathTutor();
    }
}</programlisting>
</para>
</formalpara>
<simpara>Inside the <literal>MathTutor</literal> constructor, the frame and remaining widgets are
created. Action listeners are added to the four operations menu items.
An item listener is added to the &#8220;Advanced&#8221; check box menu item,
because it requires a different kind of event handler. Note that
<literal>MathTutor</literal> implements both the <literal>ActionListener</literal> and <literal>ItemListener</literal>
interfaces, allowing it to handle both kinds of events.</simpara>
<simpara>Starting at lineÂ <xref linkend="createMenuLine"/>, the two menus are populated with
their respective menu items. At lineÂ <xref linkend="defaultDisableLine"/> the
<literal>multiply</literal> and <literal>divide</literal> menu items are disabled because the application
starts in basic mode. The menus are then added to the menu bar, and the
menu bar is set on the frame. Finally, the label and text field are
added to the frame, which is made visible. Note that these two widgets
are added directly to the frame with the parameters <literal>BorderLayout.NORTH</literal>
and <literal>BorderLayout.SOUTH</literal>. <literal>JFrame</literal> objects use the <literal>BorderLayout</literal>
manager by default.</simpara>
<simpara>The <literal>itemStateChanged()</literal> method enables the <literal>multiply</literal> and <literal>divide</literal>
menus and disables the <literal>add</literal> and <literal>subtract</literal> menus if the <literal>advanced</literal>
check box is selected and does the reverse if it has been unselected.</simpara>
<simpara>The <literal>actionPerformed()</literal> method is similar to earlier examples. Depending
on which menu item fired the event, the appropriate static methods from
the <literal>ProblemGenerator</literal> class are used to display a math problem on
<literal>label</literal>.</simpara>
<simpara>The <literal>main()</literal> method creates an instance of <literal>MathTutor</literal>, initiating GUI
construction.</simpara>
</example>
</section>
</section>
<section xml:id="subsection:Applets">
<title>Applets</title>
<simpara>An applet is a Java program that is written to run inside a web browser.
A normal Java application is stored on disk and runs on the command line
or as a window on your desktop (or both), but an applet exists inside of
a webpage. This means that the code that launches an applet is usually
embedded in HTML code.</simpara>
<simpara>Almost all of the GUI tools we discuss are useful for writing an applet.
For example, you can write an applet that has menus, buttons, text
fields, and any other widget that Swing offers. You can also add
listeners to various objects for the applet to respond to events.</simpara>
<simpara>A Swing applet is derived from the <literal>JApplet</literal> class, which is a subclass
of the older AWT class <literal>Applet</literal>.</simpara>
<simpara>An applet differs from a stand-alone Java application in several
important ways. The first is that applets are sent across the Internet.
Unless you have increased security settings on your browser, they will
generally run as soon as you visit a page with an applet embedded in it,
without even asking your permission. This poses a huge security risk,
but the designers of Java have worked to protect us. Unsigned applets
(which are the ones we will talk about creating) cannot read, write, or
execute files, make network connections to servers other than the one
they come from, or interact with most other local system settings.
However, applets loaded from a local directory (instead of downloaded
over the Internet) do not have these restrictions. Be sure to remember
these restrictions when you design applets for distribution over the
Internet.</simpara>
<simpara>Another important and concrete difference from normal Java classes is
that an applet should not define a constructor. Instead, an applet uses
the <literal>init()</literal> method. When the applet is executed, often through a
browser, its <literal>init()</literal> method is called first. You can use this method to
set up the applet GUI by adding various widgets and event listeners.</simpara>
<example>
<title>RainbowApplet</title>
<simpara>We can create a simple applet with a button and a label. Clicking this
button sets the text on the label to contain some information about the
colors in a rainbow. This applet is shown in
FigureÂ <xref linkend="rainbowAppletFigure"/>. ProgramÂ <xref linkend="program:RainbowApplet"/>
defines the applet.</simpara>
<figure role="text-center">
<title>A simple applet containing one button.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/rainbowAppletFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>rainbowAppletFigure</phrase></textobject>
</mediaobject>
</figure>
<formalpara xml:id="program:RainbowApplet" xreflabel="RainbowApplet">
<title>An applet with a button and a label.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class RainbowApplet extends JApplet{
	private JLabel label = new JLabel();

    public void init(){
        JButton button = new JButton("Rainbows");
        add(button, BorderLayout.NORTH);
        add(label, BorderLayout.SOUTH);
        button.addActionListener(new ActionListener(){
        	public void actionPerformed ( ActionEvent e){
        		label.setText("Have the colors ROYGBIV.");
        	}
        });
    }
}</programlisting>
</para>
</formalpara>
<simpara>Note that class <literal>RainbowApplet</literal> extends <literal>JApplet</literal>, as will most applets
you write. The label is declared as a field, so that the event handler
can access it. The <literal>init()</literal> method creates a <literal>JButton</literal> with the label
&#8220;Rainbows,&#8221; adds both the label and the button to the applet, and adds
an action listener to the button with an anonymous inner class event
handler.</simpara>
<simpara>Note that the button and the label were added to the applet just as it
would have been done inside of a <literal>JFrame</literal> constructor. They were added
with the <literal>BorderLayout.WEST</literal> and <literal>BorderLayout.EAST</literal> constants because a
<literal>JApplet</literal> uses a <literal>BorderLayout</literal> manager by default.</simpara>
</example>
<simpara>As you can see, creating an applet is very similar to creating a GUI
based on a <literal>JFrame</literal>. In fact, it may be easier. However, we need to
create an HTML file for the applet to be accessible via a browser. HTML
stands for <emphasis>hypertext markup language</emphasis>. HTML is the core language for
writing webpages. HTML is designed for marking up text and images to be
displayed within a browser. It is not as complicated as Java, but we do
not have time or space to describe the language deeply.</simpara>
<simpara>HTML is a language made up of <emphasis>tags</emphasis> that mark parts of a document with
formatting instructions. All of the tags we will need to embed an applet
will start with the name of the tag in angle brackets and then end with
the same name in angle brackets but preceded by a slash. For example, to
mark text as bold in HTML, you can use the <literal>&lt;strong&gt;</literal> tag as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">&lt;strong&gt;Here is text that will appear in a bold font.&lt;/strong&gt;</programlisting>
<simpara>To run <literal>RainbowApplet</literal> we need to create an HTML file that includes the
applet&#8217;s class file inside the <literal>&lt;applet&gt;</literal> tag.</simpara>
<example>
<title>RainbowApplet HTML</title>
<simpara>We want to make <literal>RainbowApplet</literal> executable via a browser. In addition,
we would like the source code of the applet to be linked from the same
webpage. The following HTML code embeds the <literal>RainbowApplet</literal> and links to
its source.</simpara>
<programlisting language="java" linenumbering="unnumbered">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Rainbow Applet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;applet code="RainbowApplet.class" width="200" height="100"&gt;&lt;/applet&gt;
        &lt;hr /&gt;&lt;a href="RainbowApplet.java"&gt;The source.&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
<figure role="text-center">
<title>The <literal>RainbowApplet</literal> as seen through a web browser. Clicking on the link displays the Java source code of the applet in ProgramÂ <xref linkend="program:RainbowApplet"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/rainbowAppletInBrowserFigure.png" width="60%"/>
</imageobject>
<textobject><phrase>rainbowAppletInBrowserFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>An <literal>&lt;html&gt;</literal> tag encloses an entire HTML document. Inside is the <literal>&lt;head&gt;</literal>
tag, followed by the <literal>&lt;body&gt;</literal> tag. The <literal>&lt;head&gt;</literal> tag contains information
about the page such as its title, which is given in the <literal>&lt;title&gt;</literal> tag.
The <literal>&lt;body&gt;</literal> tag contains the viewable content of the web page. In this
case, there is an <literal>&lt;applet&gt;</literal> tag, a <literal>&lt;hr/&gt;</literal> tag, and an <literal>&lt;a&gt;</literal> tag in the
body.</simpara>
<simpara>The <literal>&lt;applet&gt;</literal> tag is used to embed our applet. The name of the applet
class must be given as the argument, in double quotes, to the <literal>code</literal>
attribute. The <literal>width</literal> and <literal>height</literal> attributes specify the size of the
applet on the screen. The <literal>&lt;hr/&gt;</literal> tag puts the horizontal line between
the applet and the link. It is the only tag in our example that does not
have both an opening and closing half. Finally, the <literal>&lt;a&gt;</literal> tag is used to
make a clickable link. On a web page, it will display &#8220;The source,&#8221;
but it will navigate to the file <literal>RainbowApplet.java</literal> when clicked.</simpara>
<simpara>Put this code in an HTML file named <literal>RainbowApplet.html</literal>. (Note that the
name of your HTML file should be descriptive, but it does not have to
match the name of the applet class.) If your browser is Java compatible
and has the appropriate plug-in installed, you should be able to run the
applet by double-clicking on the HTML file. Of course, if you are able
to upload the HTML file and the class file to a web server, you can view
the applet and share it with anyone with an Internet connection.</simpara>
</example>
<simpara>Applets can be much more complex than <literal>RainbowApplet</literal>. We now solve the
problem posed at the beginning of the chapter with an applet with a
fully functional GUI designed to be an arithmetic tutor.</simpara>
</section>
</section>
<section xml:id="_solution_math_applet">
<title>Solution: Math applet</title>
<simpara>The applet that meets the specification given at the beginning of the
chapter is similar to ProgramÂ <xref linkend="program:MathTutor"/>. Modifications must
be made to convert that program into an applet and add full
functionality to the event handlers. We now go through this rather long
Java program step by step. GUI programs in Java tend to be longer than
their command line versions because of the code needed to set up all the
widgets.</simpara>
<figure role="text-center">
<title>The Type (a) and Operations (b) menus in the <literal>MathTutorApplet</literal>. Note that the &#8220;Multiply&#8221; and &#8220;Divide&#8221; operations are disabled because the &#8220;Advanced&#8221; option is not checked.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/menusInArithPracticeFigure.svg" width="80%"/>
</imageobject>
<textobject><phrase>menusInArithPracticeFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>MathTutorApplet.java</literal> file begins with the usual Swing imports and
the class declaration, followed by a list of its fields.</simpara>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class MathTutorApplet extends JApplet
	implements ActionListener, ItemListener {
    private JMenuItem add = new JMenuItem("Addition");
    private JMenuItem subtract = new JMenuItem("Subtraction");
    private JMenuItem multiply = new JMenuItem("Multiply");
    private JMenuItem divide = new JMenuItem ("Divide");
    private JLabel score =
    	new JLabel("Score: 0 Correct 0 Incorrect");
    private JLabel label = new JLabel();
    private JTextField field = new JTextField(10);
    private JButton submit = new JButton("Submit");
	private int correct = 0;
    private int incorrect = 0;
    private int answer = -1;</programlisting>
<simpara>Note that the <literal>int</literal> variables <literal>correct</literal>, <literal>incorrect</literal>, and <literal>answer</literal> have
been added to the fields to keep track of the correct and incorrect
answers and the current answer that the user is trying to find.</simpara>
<simpara>Following the field declarations is the definition of the <literal>init()</literal>
method. As you can see, this method is almost identical to the
constructor in the <literal>MathTutor</literal> stand-alone application. Indeed, the
<literal>init()</literal> method is very much like the constructor for an applet.</simpara>
<programlisting language="java" linenumbering="numbered">    public void init() {
        JMenuBar menuBar = new JMenuBar();
        JMenu type = new JMenu("Type");
        JMenu operations = new JMenu("Operations");
        JCheckBoxMenuItem advanced =
        	new JCheckBoxMenuItem("Advanced");
    	// Add ActionListeners to menu items and buttons
    	add.addActionListener(this);
        subtract.addActionListener(this);
        multiply.addActionListener(this);
        divide.addActionListener(this);
        submit.addActionListener(this);
        // Add ItemListener to checkbox menu item
        advanced.addItemListener(this);
        // Fill menu for problem type
        type.add(advanced);
        // Fill menu for operations
        operations.add(add);
        operations.add(subtract);
        operations.add(multiply);
        operations.add(divide);
        // Disable advanced operations and submit
        multiply.setEnabled(false);
        divide.setEnabled(false);
        submit.setEnabled(false);
        // Fill menu bar and set on applet
        menuBar.add(type);
        menuBar.add(operations);
        setJMenuBar(menuBar);
		//Add widgets to applet content
        add( score, BorderLayout.NORTH );
        add( label, BorderLayout.WEST );
        add( field, BorderLayout.EAST );
        add( submit, BorderLayout.SOUTH );
    }</programlisting>
<simpara>Just like the <literal>MathTutor</literal> constructor, this method creates the menu bar,
the menus, and the menu items. Then, it adds action listeners to the
menu items and the button and an item listener to the check box menu
item. Next it adds <literal>advanced</literal> to the &#8220;Type&#8221; menu and the four
operation menu items to the &#8220;Operations&#8221; menu. It disables the
advanced menu items (since the applet starts in basic mode) and the
button (since it is impossible to submit an answer before a problem has
been given). Finally, it puts the menus on the menu bar, sets the menu
bar on the applet, and adds the two text fields, the label, and the
button to the applet content area using appropriate <literal>BorderLayout</literal>
constants.</simpara>
<simpara>One big difference between the <literal>MathTutor</literal> constructor and the
<literal>MathTutorApplet</literal> <literal>init()</literal> method is that the <literal>MathTutor</literal> constructor
creates a <literal>JFrame</literal> object. In <literal>MathTutorApplet</literal> no <literal>JFrame</literal> is necessary
because the class itself is a child of <literal>JApplet</literal> and thus is a GUI
container.</simpara>
<programlisting language="java" linenumbering="numbered">    public void itemStateChanged(ItemEvent e) {
    	if(e.getStateChange() == ItemEvent.SELECTED ) {
            add.setEnabled(false);
            subtract.setEnabled(false);
            multiply.setEnabled(true);
            divide.setEnabled(true);
    	}
    	else {
			add.setEnabled(true);
			subtract.setEnabled(true);
			multiply.setEnabled(false);
			divide.setEnabled(false);
    	}
    }</programlisting>
<simpara>The <literal>itemStateChanged()</literal> method is the same as its counterpart in
<literal>MathTutor</literal>. If the state change is <literal>ItemEvent.SELECTED</literal>, we enable the
advanced menus and disable the basic ones. Otherwise, we do the reverse.
Note that this method would be more complicated if we were listening to
more than one object. Since we are only listening to the <literal>advanced</literal>
check box menu item, we know that it is what is being selected or
deselected.</simpara>
<programlisting language="java" linenumbering="numbered">    public void actionPerformed(ActionEvent e) {
    	Object object = e.getSource();
    	if( object == submit ) {
    		int response = Integer.parseInt(field.getText());
    		if( response == answer )
    			correct++;
    		else
    			incorrect++;
			label.setText("");
    		score.setText("Score: " + correct + " Correct " +
    				incorrect + " Incorrect");
			submit.setEnabled(false);
    	}
    	else {
	    	if( object == add )
	    		answer = ProblemGenerator.addPractice(label);
	        else if( object == subtract )
	        	answer = ProblemGenerator.subtractPractice(label);
	        else if( object == multiply )
	        	answer = ProblemGenerator.multiplyPractice(label);
	        else if( object == divide )
	        	answer = ProblemGenerator.dividePractice(label);
	    	submit.setEnabled(true);
	    }
    	field.setText("");
    }
}</programlisting>
<simpara>Finally, the <literal>actionPerformed()</literal> method deals with the menu item and
button clicks. If <literal>submit</literal> was clicked, we parse the text in the text
field to get an <literal>int</literal> value and compare it to the answer. Depending on
its correctness, we update the correct and incorrect counts, clear the
problem label, and update the <literal>score</literal> label. Finally, we disable the
<literal>submit</literal> button so that the user can&#8217;t submit an answer until another
problem has been given.</simpara>
<simpara>The next part of the <literal>actionPerformed()</literal> method has the same
functionality as the <literal>actionPerformed()</literal> method from <literal>MathTutor</literal>. It
updates <literal>label</literal> to contain a randomly generated problem with an
operation that matches whichever menu item was picked. It also saves the
answer into the <literal>answer</literal> field so that we can check the user&#8217;s response
later. Then, it enables the <literal>submit</literal> button since there is a problem to
answer. No matter what object triggered the action, the last line of the
method clears the text field.</simpara>
<simpara>We need some HTML to test the applet. Here is a suitable HTML file
similar to the <literal>RainbowApplet.html</literal> file presented before.</simpara>
<programlisting language="java" linenumbering="unnumbered">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Math Tutor Applet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;applet code="MathTutorApplet.class" width="250" height="125"&gt;&lt;/applet&gt;
        &lt;hr /&gt;&lt;a href="MathTutorApplet.java"&gt;The source code.&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
<simpara>In the stand-alone <literal>MathTutor</literal> application, we created a <literal>JFrame</literal> and
set its size to 250 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 125 pixels. The <literal>width</literal> and
<literal>height</literal> attributes in the HTML allow us to accomplish something
similar. Note that the widgets in the applet have more room than in the
<literal>JFrame</literal> version because the size of the <literal>JFrame</literal> includes the title bar
and window borders.</simpara>
<simpara>The functionality of this applet is limited, but it still shows off
menus, buttons, labels, text fields, applet creation, and two different
kinds of event listeners.</simpara>
</section>
<section xml:id="_concurrency_guis">
<title>Concurrency: GUIs</title>
<simpara>Stand-alone Java programs have at least one thread, the main thread.
Applets have a similar thread that calls its <literal>init()</literal> and <literal>start()</literal>
methods. Applications with GUIs (including applets) create additional
threads to manage the GUI behind the scenes.</simpara>
<simpara>Although a GUI will create several threads, the most important for the
programmer to worry about is called the <emphasis>event dispatch thread</emphasis> (EDT).
This thread handles events like button clicks. When you write your
<literal>actionPerformed()</literal> method, remember that the EDT is the one that will
actually execute the code inside.</simpara>
<simpara>If you are writing a complex program, the EDT may interact with many
other threads, and the synchronization issues discussed in
ChapterÂ <xref linkend="chapter:Synchronization"/> will become important. However, only
the EDT is allowed to change the state of widgets in a GUI. Using other
threads to do so will work some of the time, but it is not thread-safe
and violates the design of Swing.</simpara>
<section xml:id="_worker_threads">
<title>Worker threads</title>
<simpara>Thread safety is not the most common multi-threaded GUI problem,
however. Unresponsive GUIs can be found on almost every platform, as you
have no doubt experienced. In Java, unresponsive GUIs usually happen
because the programmer is using the event dispatch thread to do some
task that takes too long. Because the EDT is responsible for updating
the GUI, the GUI freezes, and the user has to wait.</simpara>
<simpara>This is quite a conundrum. On the one hand, the EDT is the only thread
allowed to update widgets. On the other, it has to do its work quickly
so that the GUI is responsive. The solution is to spawn <emphasis>worker threads</emphasis>
to do the job. When they are done, they inform the EDT so that it is
able to update the GUI.</simpara>
<simpara>Let&#8217;s look at a GUI with two <literal>JButton</literal> widgets and two <literal>JLabel</literal> widgets.
When one button is pressed, the EDT goes to sleep for 5 seconds before
displaying an answer on the first label (in this case, approximately
<inlineequation><alt><![CDATA[\sqrt{2}]]></alt><mathphrase><![CDATA[\sqrt{2}]]></mathphrase></inlineequation>). When the other button is pressed, it increments
a counter and displays the value in the second label.</simpara>
<formalpara xml:id="program:UnresponsiveGUI" xreflabel="UnresponsiveGUI">
<title>A GUI that becomes unresponsive when the &#8220;Compute&#8221; button is pressed.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class UnresponsiveGUI extends JFrame
	implements ActionListener {
	JLabel label = new JLabel("Answer:");
	JButton compute = new JButton("Compute");
	JLabel counter = new JLabel("0");
	JButton increment = new JButton("Increment");
	int count = 0;

	public static void main(String args[]) {
		UnresponsiveGUI frame = new UnresponsiveGUI();
		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		frame.setSize(250,150);
		frame.setVisible(true);
	}

	public UnresponsiveGUI() {
		setLayout(new GridLayout(4,1));
		setTitle("Unresponsive GUI");
		add(label);
		compute.addActionListener(this);
		add(compute);
		add(counter);
		increment.addActionListener(this);
		add(increment);
	}

	public void actionPerformed(ActionEvent e) {
		if( e.getSource() == compute ) {
			label.setText("Computing...");
	    	try {
	            Thread.sleep(5000);/*@\label{unresponsive sleep}@*/
	        } catch( Exception ignore ) { }
	        label.setText("Answer: " + Math.sqrt(2.0));
		}
		else {
			count++;
			counter.setText("" + count);
		}
	}
}</programlisting>
</para>
</formalpara>
<figure role="text-center">
<title>GUI generated by ProgramÂ <xref linkend="program:UnresponsiveGUI"/>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/15-gui/images/unresponsiveGUIFigure.png" width="40%"/>
</imageobject>
<textobject><phrase>unresponsiveGUIFigure</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you click the &#8220;Compute&#8221; button, the GUI becomes unresponsive.
Specifically, you cannot click on the &#8220;Increment&#8221; button, but you
should still be able to move the frame around the desktop on most
systems. Furthermore, some thread in the GUI is registering the clicks
you do on the &#8220;Increment&#8221; button, but events triggered by those clicks
are not handled until after the EDT wakes up. At that point, the counter
will shoot up in value unpredictably.</simpara>
<simpara>One solution is to create an anonymous inner class that extends
<literal>SwingWorker</literal>. The <literal>SwingWorker</literal> class is abstract, but it is also
<emphasis>generic</emphasis>, meaning that it has type parameters (given in angle brackets)
which specify what type of objects it interacts with. Generic classes
are often containers like <literal>LinkedList</literal> where the type parameter says
what kind of objects will be kept in the list. ChapterÂ <xref linkend="chapter:Dynamic
Data Structures"/> covers generics in some depth. The reason we need
generics for <literal>SwingWorker</literal> is so that it can specify what kind of object
it will return when it finishes its work. The first type parameter
specifies the type that the worker will return when it completes its
work. The second specifies the type that the worker will return
periodically in the process of doing work (which can be useful for
updating progress bars). Examine the following program which has added a
<literal>SwingWorker</literal> to its <literal>actionPerformed()</literal> method but is otherwise the
same as ProgramÂ <xref linkend="program:UnresponsiveGUI"/>.</simpara>
<formalpara xml:id="program:WorkerGUI" xreflabel="WorkerGUI">
<title>A GUI that uses <literal>SwingWorker</literal> to avoid becoming unresponsive.</title>
<para>
<programlisting language="java" linenumbering="numbered">import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class WorkerGUI extends JFrame implements ActionListener {
	JLabel label = new JLabel("Answer:");
	JButton compute = new JButton("Compute");
	JLabel counter = new JLabel("0");
	JButton increment = new JButton("Increment");
	int count = 0;

	public static void main(String args[]) {
		WorkerGUI frame = new WorkerGUI();
		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		frame.setSize(250,150);
		frame.setVisible(true);
	}

	public WorkerGUI() {
		setLayout(new GridLayout(4,1));
		setTitle("Worker GUI");
		add(label);
		compute.addActionListener(this);
		add(compute);
		add(counter);
		increment.addActionListener(this);
		add(increment);
	}

	public void actionPerformed(ActionEvent e) {
		if( e.getSource() == compute ) {
			SwingWorker worker = new SwingWorker&lt;String, Void&gt;() {
			    public String doInBackground() {
			    	try {
			            Thread.sleep(5000);/*@\label{responsive sleep}@*/
			        } catch( Exception ignore ) {}
			        return "Answer: " + Math.sqrt(2.0);
			    }

			    public void done() {
			        try {
			        	label.setText(get());
			        } catch (Exception ignore) {}
			    }
			};

			worker.execute();
			label.setText("Computing...");
		}
		else {
			count++;
			counter.setText("" + count);
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>In this program, the first type parameter for the <literal>SwingWorker</literal> is
<literal>String</literal> because we are going to set the text in a <literal>JLabel</literal> with its
result. The second parameter is <literal>Void</literal>, meaning that we do not intend to
return any values periodically. Most child classes of <literal>SwingWorker</literal>
should override the <literal>doInBackground()</literal> and <literal>done()</literal> methods.</simpara>
<simpara>The <literal>doInBackground()</literal> method performs the time-consuming work that we
want done on another thread. In our example, the &#8220;work&#8221; is going to
sleep, but it will generally be some CPU or I/O intensive process.
Afterwards, it returns the answer it found. The <literal>done()</literal> method is
called automatically by the EDT after <literal>doInBackground()</literal> finishes. After
the <literal>SwingWorker</literal> object has been created, the <literal>execute()</literal> method starts
it working. The GUI will look identical to the unresponsive version
(except for the title), but it will remain responsive.</simpara>
<simpara>This syntax is not particularly elegant, but it accomplishes a complex
task. It spawns a thread transparently, and then the EDT is given work
when the thread gives back its answer. Using a <literal>SwingWorker</literal> is not
always required, but it is a useful tool to have in your arsenal if you
plan on writing industrial-strength GUIs.</simpara>
</section>
</section>
<section xml:id="_summary_6">
<title>Summary</title>
<simpara>In this chapter we introduce the basics of constructing a GUI to allow
users to interact with an application. We show how to add widgets such
as buttons and text boxes and use layout managers to organize their
appearance. We show how you can add action listeners and other event
handlers so that user actions can perform useful tasks. Finally, we show
how these techniques can be applied to GUIs on stand-alone applications
as well as applets that run inside of a web browser.</simpara>
<simpara>While Java offers a large variety of widgets and listeners, this
introduction is limited to a few of the most commonly used. Once you
understand the basics of GUI construction as described in this chapter,
it should be easy to understand the extensive Java tutorial at
<link xl:href="http://download.oracle.com/javase/tutorial/uiswing/components/">http://download.oracle.com/javase/tutorial/uiswing/components/</link> or other
reference sources.</simpara>
</section>
<section xml:id="_exercises_14">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:finalButtonExercise"/> In
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/>, why have we declared the
buttons and the text box to be <literal>final</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:actionVsMouseListener"/> Note that both <literal>ActionListener</literal>
and <literal>MouseListener</literal> interfaces can be used to process button clicks.
Under which circumstances is <literal>ActionListener</literal> better? Under which is
<literal>MouseListener</literal> better?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:adapterInterfaceExercise"/> Why is the <literal>MouseAdapter</literal>
abstract class useful?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:multipleMenuBars"/> What do you expect will happen if you
used <literal>setJMenuBar()</literal> to set two different menu bars on a single <literal>JFrame</literal>
object?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:listenerExercise"/> Describe the situations that the
following event listeners are useful for: <literal>ActionListener</literal>,
<literal>MouseListener</literal>, <literal>ItemListener</literal>, and <literal>KeyListener</literal></simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:actionListenerComparisonExercise"/> Remove the two
instances of the keyword <literal>final</literal> from
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/> and try to compile it. Why
does the compiler complain? What do you conclude regarding the use of
<literal>final</literal> with respect to local variables used in the <literal>actionPerformed()</literal>
method of an anonymous inner class? Why is this not a concern for
top-level, named classes used as an <literal>ActionListener</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:frameWithPanelExercise"/> Write a program that creates a
GUI containing two buttons labeled &#8220;Start&#8221; and &#8220;Done.&#8221; The GUI frame
should be labeled &#8220;Start and Done.&#8221;</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:mouseEventsExercise"/> Modify
ProgramÂ <xref linkend="program:SimpleMouseEvents"/> by implementing the
<literal>mouseExited()</literal>, <literal>mousePressed()</literal>, and <literal>mouseReleased()</literal> methods. Each
method must display a suitable message in the text box when the
corresponding event occurs. For example, when the mouse exits button
<literal>one</literal>, the text box should display &#8220;Mouse exits One.&#8221;</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:iconAndSoundExercise"/> Modify
ProgramÂ <xref linkend="program:IconExample"/> such that clicking the icon-decorated
button generates a roaring sound. Note that this will require you to add
an <literal>ActionListener</literal> to the button, create an audio clip for the desired
sound, and then play this click when the button is clicked. Consider
visiting <link xl:href="http://www.freesound.org/">http://www.freesound.org/</link> for free sound files.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:addIconToLabelExercise"/> Write a Java program that
creates a GUI containing a label with a picture of yourself.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:SoundGameExtension"/> Extend the <literal>SoundGame</literal> class
developed in ExampleÂ <xref linkend="example:Sound_game"/> to include sounds for
various animals. You may find a variety of publicly available sounds
files for use in your program. The Freesound link above is only one
source.</simpara>
<simpara>Note that some sites explicitly ask you not to embed the sound file URL
into your program. In those cases, download the sound file into your
local directory and load it from there into your application.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:SoundGameProperStopExercise"/> In ExampleÂ <xref linkend="example:Sound
game"/> we stopped both the chirp and the bark sounds because the action
listener corresponding to the &#8220;Stop Playing&#8221; button does not know
which sound is playing. Modify ProgramÂ <xref linkend="program:SoundGame"/> so that
only the sound that is playing is stopped. You may need to declare
another variable to keep track of which is playing.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:animalIdentifierExercise"/> Modify
ProgramÂ <xref linkend="program:AnimalIdentifier"/> so that it plays a sound associated
with an animal when the mouse is clicked over its label. Note that this
is an example of a situation where a <literal>MouseListener</literal> can be used to
listen for mouse click events though an <literal>ActionListener</literal> cannot. As in
Exercises <xref linkend="exercise:SoundGameExtension"/> and
<xref linkend="exercise:iconAndSoundExercise"/>, you may need to download sounds from
the Internet.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:addSessionCountExercise"/> Modify the applet from
SectionÂ <xref linkend="solution:Math_applet"/> to display the problem number the user
is working on. The first problem is numbered &#8220;ProblemÂ 1&#8221; with
subsequent problems 2, 3, and so on. The number should increase each
time the user hits the Submit button. Find a suitable place on the GUI
to display this information. You may need to add a panel to reorganize
the GUI.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:anonymousInnerClass"/> Remove the <literal>actionPerformed()</literal> and
<literal>itemStateChanged()</literal> methods from the <literal>MathTutorApplet</literal> class given in
SectionÂ <xref linkend="solution:Math_applet"/>. Move the code from these methods into
individual anonymous inner classes added to the <literal>add</literal>, <literal>subtract</literal>,
<literal>multiply</literal>, <literal>divide</literal>, <literal>submit</literal>, and <literal>advanced</literal> objects.</simpara>
<simpara>Note that you are now able to remove <literal>ActionListener</literal> and <literal>ItemListener</literal>
from the list of implemented interfaces for the <literal>MathTutorApplet</literal> class.
Reorganizing the code this way should have no impact on the
functionality of the applet. Is doing so a good idea or not? Why?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:panelSequencingExercise"/> In
ProgramÂ <xref linkend="program:FrameWithPanelAndActions"/> exchange the first two
<literal>add()</literal> method calls on the <literal>soundPanel</literal> so that <literal>bark</literal> is added to the
panel before the <literal>chirp</literal>. Explain how the appearance of the GUI is
changed.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:multiplePanelsExercise"/> Modify
ProgramÂ <xref linkend="program:FrameWithPanel"/> by adding a second panel named
<literal>secondPanel</literal>. Create a new button named <literal>train</literal> with the label
&#8220;Train.&#8221; Add <literal>train</literal> to <literal>secondPanel</literal>. Now add <literal>secondPanel</literal> to
<literal>soundCheck</literal> and look at the GUI generated. Can you explain why only one
panel is visible?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:flowLayoutFrameSizeExercise"/> Remove
lineÂ <xref linkend="disableResizableLine"/> from
ProgramÂ <xref linkend="program:FlowLayoutExample"/>. Run the modified program and
resize the frame to various sizes. How does the placement of the buttons
change?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:flowLayoutPackExercise"/> Modify
ProgramÂ <xref linkend="program:FlowLayoutExample"/> by deleting the lines that set the
frame size. What does the resulting GUI look like? Now add the following
code just before lineÂ <xref linkend="disableResizableLine"/>:</simpara>
<programlisting language="java" linenumbering="unnumbered">demo.pack();</programlisting>
<simpara>When you run the modified program, what is the impact of using the
<literal>pack()</literal> method?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:gridLayoutExercise"/> Create a GUI with a frame that uses
<literal>GridLayout</literal> and has a suitable size. Use a 3 <inlineequation><alt><![CDATA[\times]]></alt><mathphrase><![CDATA[\times]]></mathphrase></inlineequation> 2
layout with a horizontal and vertical spacing of 5 pixels each. Use a
loop to add eight buttons to your frame, labeled 1 through 8. Observe
how the frame expands to include all the buttons even though the
initially specified <literal>GridLayout</literal> had only 6 cells. Depending on the
frame size, you might have to resize the window to see all cells and
buttons. What happens if you add fewer than 6?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:poorAdditionOfMenuBar"/> Write a Java program that creates
a GUI with a frame and a menu bar containing a single menu. Add a menu
item to this menu. Use the <literal>add()</literal> method, not the <literal>setJMenuBar()</literal>
method, to add the menu bar to the frame. What is the difference between
using the <literal>add()</literal> method and the <literal>setJMenuBar()</literal> method to add a menu
bar to a <literal>JFrame</literal>?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:rainbowAppletExercise"/> Use the example from the book to
create a suitable HTML file that embeds the <literal>RainbowApplet</literal> class from
ExampleÂ <xref linkend="example:RainbowApplet"/> and links to the Java source code. Now
upload the class file, the source code, and the HTML file to a web
server so that you can run the applet over the Internet. Have a friend
test out your code on a computer in another location to make sure that
it works.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:unresponsive_GUI"/> Recall that
ProgramÂ <xref linkend="program:UnresponsiveGUI"/> is unresponsive because the event
dispatch thread goes to sleep for 5 seconds (5,000 milliseconds) on
lineÂ <xref linkend="unresponsive_sleep"/>. Experiment with this value to determine
what is a reasonable amount of time for the EDT to be blocked before the
GUI feels unresponsive.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:busy_GUI"/> ProgramÂ <xref linkend="program:UnresponsiveGUI"/> is
unrealistic because the EDT simply goes to sleep. Normally, a GUI
becomes unresponsive because the EDT is performing extensive
calculations or doing slow I/O operations. Replace lineÂ <xref linkend="unresponsive
sleep"/> with a short loop that performs significant calculations. One
simple way to spend a lot of computational time is by summing the sines
of random numbers, similar to the work done in ExampleÂ <xref linkend="example:Array
summation"/>. How many sines do you need to compute to make the GUI
unresponsive for 5 seconds?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:busy_workers"/> Take the computationally expensive loop
from ExerciseÂ <xref linkend="exercise:busy_GUI"/> and use it to replace
lineÂ <xref linkend="responsive_sleep"/> in ProgramÂ <xref linkend="program:WorkerGUI"/>, the
<literal>SwingWorker</literal> version of the program. Does the program become
unresponsive if you run it? If possible, run the program on Windows,
Mac, and Linux environments. If it is unresponsive in some environments
but not others, why do you think that might be?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Testing_and_Debugging">
<title>Testing and Debugging</title>
<blockquote>
<attribution>
John Peel
</attribution>
<simpara>I never make stupid mistakes. Only very, very clever ones.</simpara>
</blockquote>
<section xml:id="section:Fixing_bugs">
<title>Fixing bugs</title>
<simpara>This chapter is about finding, fixing, and, more importantly, preventing
bugs in software. This chapter is unique in that it is not based on
clearly stated concrete problems with straightforward solutions. As it
stands now, finding and fixing bugs in software, especially concurrent
software, is a problem which no one has solved completely. The first
half of this chapter will focus on common bugs and how to fix them. The
second half will focus on design techniques for preventing bugs and
testing to see if any hidden bugs remain in your code.</simpara>
<section xml:id="_common_sequential_bugs">
<title>Common sequential bugs</title>
<simpara>We will begin with bugs commonly found in sequential programs, some of
which have already been mentioned as common mistakes in previous
chapters. We will not discuss syntax errors or any other errors which
can be caught at compile time. Instead, all bugs discussed in this
chapter are run-time bugs.</simpara>
<simpara>There are an infinite number of possible bugs and so they cannot all be
listed. Below are a few of the most common categories of bugs to affect
beginner (and occasionally veteran) programmers.</simpara>
<variablelist>
<varlistentry>
<term>Precision Errors</term>
<listitem>
<simpara>Floating point numbers have limited precision inside of a computer.
Programs that assume infinite precision may break when real results
are slightly larger or smaller than expected.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Overflow and Underflow</term>
<listitem>
<simpara>In some sense the cousin of precision in floating point types is the
limited range of values that integer types can take on. If the value
goes too high, it wraps back around and becomes a negative number. If
the values becomes too low, the opposite can happen.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Casting Errors</term>
<listitem>
<simpara>Casting can have many subtle effects in a program. Sometimes
programmers divide two integers and forget that the result is an
integer. Incorrectly casting objects can lead to
`ClassCastException`s.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Loop Errors</term>
<listitem>
<simpara>Loops are a favorite place for bugs to hide. Three of the most common
loop mistakes are:</simpara>
<itemizedlist>
<listitem>
<simpara>Off-by-one errors: The loop executes one more or one fewer time than
expected.</simpara>
</listitem>
<listitem>
<simpara>Infinite loop: A classic. The loop continues executing until the
program runs out of memory or a user stops the program externally.</simpara>
</listitem>
<listitem>
<simpara>Zero loop: The loop does not execute even once, even though the
programmer expected it to.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Equivalence Testing Errors</term>
<listitem>
<simpara>If a programmer uses the <literal>==</literal> operator to compare two references, it
will be true only if the two references point at the same object.
Although doing so is occasionally necessary, the <literal>equals()</literal> method
should usually be used to compare the attributes of the objects
pointed at by the references.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Array Errors</term>
<listitem>
<simpara>Arrays are often involved with loop errors. Two problems specific to
arrays are:</simpara>
<itemizedlist>
<listitem>
<simpara>Out of bounds: A math mistake or an off-by-one error could lead to
trying to access an element of an array that comes before element 0 or
after the last element.</simpara>
</listitem>
<listitem>
<simpara>Uninitialized object arrays: Arrays of primitive data types can be
created and used instantly; however, arrays of object types are filled
with nulls until each element is assigned an object, often a new
object.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Scope Errors</term>
<listitem>
<simpara>Some errors can be caused by a programmer&#8217;s misunderstanding about the
visibility of a variable.</simpara>
<itemizedlist>
<listitem>
<simpara>Shadowing variables: If a local variable is declared with the same
name as a field or class variable, changes within a method will be
made to that local variable. This principle is straightforward, but,
if a programmer does not notice the shadow declaration, the behavior
of the code can be very confusing.</simpara>
</listitem>
<listitem>
<simpara>Reference vs. value: When primitive data is passed as an argument
into a method, its value is copied into the method, and the original
data is unchanged. When an object is passed as an argument into a
method, the reference is unchanged, but methods called on the object
can still affect it.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Null Pointer Errors</term>
<listitem>
<simpara>By this point in your programming experience, you have almost
certainly experienced a <literal>NullPointerException</literal>. This is, in many ways,
a catch-all category, because a null reference is generally not due to
a simple typographical error. In the simplest case, a reference simply
has not been initialized with some default constructor, but more often
there is a logical error in the design of the code.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_concepts_approaches_to_debugging">
<title>Concepts: Approaches to debugging</title>
<simpara>When you have discovered the existence of a bug, pinning down its cause
can be difficult. There are a number of different techniques that are
useful for narrowing down the possible problems.</simpara>
<section xml:id="_assertions">
<title>Assertions</title>
<simpara>A common cause of program errors is an incorrect assumption by a
programmer. A programmer can assume that the user will only enter
positive numbers, that a library call will not throw any exceptions, or
that a linked list is not empty. Some assumptions are reasonable, but it
is important to make sure that they are correct.</simpara>
<simpara>Using <emphasis>assertions</emphasis> is a way to check some of your assumptions, often
those surrounding a method call. In most languages, an assertion tests a
condition. If that condition is true, nothing happens, but, if it is
false, the program shuts down or an error or exception is thrown. Using
assertion statements is particularly important with methods because you
want to be sure that both your input and output are in the ranges you
expect them to be.</simpara>
<simpara>Java supports assertions natively, as we will discuss in the next
section. However, virtually every language allows you to create your own
assertions should they not be present as a language construct.</simpara>
</section>
<section xml:id="_print_statements">
<title>Print statements</title>
<simpara>Computer programs execute quickly. Even if they executed a million times
more slowly no human is sensitive enough to decipher the flow of
electrons inside the processor as a program executes. The simple truth
is that we have no idea what is happening when our programs execute. We
believe that we understand our programs well, and the output usually
confirms that our program is doing what we imagine that it should be
doing.</simpara>
<simpara>If the output does not match what is expected, we may not have enough
data to understand the problem. Since there have been programmers, they
have been printing out additional debug information to find their
errors. This technique can go a step beyond simple assertion statements
because you can print out the values of the variables rather than just
test to see if they are in a range.</simpara>
<simpara>Once you have found the error in your code, it can be tedious to remove
all of your debug statements. Some programmers use a special print
command that can be turned off using a global variable or compiler
option. Others send their output to <literal>stderr</literal> so that it doesn&#8217;t
interfere with the legitimate output of the program. Much depends upon
the system, the language, and the individual tastes of the programmer.</simpara>
</section>
<section xml:id="_step_through_execution">
<title>Step-through execution</title>
<simpara>With the rise of modern debugging environments, using print statements
has lost some of its appeal. Most languages allow the programmer to run
his or her program in a special debug mode in which it is possible to
execute a single line of code at a time. These tools usually give the
option of stepping over method calls or stepping into them, on a case by
case basis.</simpara>
<simpara>As the program executes, the programmer can inspect the values of the
variables in the code. This method of debugging is excellent because it
allows the programmer to watch the execution of the code at whatever
pace he or she desires. Pinpointing problems becomes trivial if you know
which variables you need to watch.</simpara>
<simpara>Despite the power of this technique, it has critics. Some older
programmers look down on these tools because they make beginning
programmers lazier and, in some cases, less careful about writing code
correctly in the first place. It should be noted that step-through
execution modes are not available for every language and for every
system. Some embedded software or operating system programming cannot be
debugged on the real hardware in this way. Of course, most of these
systems can be run in virtual environments that do allow step-through
debugging.</simpara>
<simpara>Even when step through debugging is available, there are difficulties
that can limit its effectiveness. If the bug occurs sporadically,
perhaps due to race conditions, a programmer may not know where to start
looking. Certain data structures such as the <literal>list</literal> template in C++ may
not be easily traversable using the inspection facilities of the
debugger. Likewise, the bug or the source of the unexplained behavior
could be buried in library code. The debugger does not always have
access to library code for stepping through.</simpara>
</section>
<section xml:id="_breakpoints">
<title>Breakpoints</title>
<simpara>Breakpoints are a feature of step-through debuggers designed to make
them easier to use. A user can specify a particular line of code (with
some restrictions) as being a place where the debugger should pause
execution. Debuggers typically rely on at least one breakpoint in order
to skip all the preliminary parts of the code and skip straight to the
perceived trouble spot.</simpara>
<simpara>Sometimes an error will predictably crop up after many thousands of
iterations of a loop or unpredictably in the case of bugs dependent on
race conditions or user input. For either of these cases, conditional
breakpoints can be used to save the debugger a great deal of time.
Rather than always pausing execution on a given line, a conditional
breakpoint will only pause if a certain condition is met.</simpara>
</section>
</section>
<section xml:id="_syntax_java_debugging_tools">
<title>Syntax: Java debugging tools</title>
<section xml:id="_assertions_2">
<title>Assertions</title>
<simpara>As we mentioned before, many languages have assertions as a built-in
language construct. In Java, there are two forms this feature takes. The
simpler can be done by typing the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">assert condition;</programlisting>
<simpara>In this case, <literal>condition</literal> is a boolean value that is expected to be true
for the program to function properly. The more complicated form of the
feature can be used as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">assert condition : value;</programlisting>
<simpara>This form adds a value that can be attached to the assertion to give the
user more information about the problem. This value can be any primitive
data type, any object type, or a statement that evaluates to one of the
two.</simpara>
<simpara>If you have never used an <literal>assert</literal> statement before, you might want to
test it out by forcing an assertion to fail. You might try</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 5;
assert (x &lt; 4) : "x is too large!";</programlisting>
<simpara>Then, if you compile your program and run it through the JVM, you will
be shocked when <emphasis role="strong">absolutely nothing happens</emphasis>. Actually, some of you with
older Java compilers may have heard complaints when you tried to
compile. If you have a Java 1.3 compiler or earlier, it will treat
<literal>assert</literal> like an identifier. Some old Java 1.4 compilers may also give
warnings or require special flags to be set to compile. However, if you
have an up to date compiler, the problem is that the JVM must have
assertions enabled at runtime. Assertions are intended to be a special
debugging tool and ignored otherwise. To turn run program
<literal>AssertionTest</literal> with assertions enabled, type</simpara>
<programlisting language="java" linenumbering="unnumbered">java -ea AssertionTest</programlisting>
<simpara>With this option, an exception should be thrown at runtime.</simpara>
<programlisting language="java" linenumbering="unnumbered">Exception in thread "main" java.lang.AssertionError: x is too large!</programlisting>
<simpara>There are other options allowing you to enable or disable assertions for
specific packages or classes.</simpara>
<simpara>Now that you know how to use assertions, you need to know when they are
a good idea. The Java Tutorials on the Oracle website suggest five
situations where assertions are useful: internal invariants,
control-flow invariants, preconditions for methods, postconditions for
methods, and class invariants. <emphasis>Internal invariants</emphasis> are those
situations when you assume that reaching a certain place in your code,
like the <literal>else</literal> branch of an <literal>if</literal> statement, will force a variable to
have a certain value. For internal invariants, you assert that the
variable has the expected value. A <emphasis>control-flow invariant</emphasis> means that
you assume that your code will always execute along a certain path. For
control-flow invariants, you assert <literal>false</literal> if the JVM reaches a point
in the code you expected it never would. <emphasis>Method preconditions</emphasis> are
those conditions you expect to be true about the state of objects or the
input to a method before the method is called.</simpara>
<simpara>The philosophy of Java is that <literal>public</literal> methods should <emphasis>not</emphasis> have
assertions used to test their preconditions. Instead, illegal input
values for a <literal>public</literal> method should cause exceptions to be thrown, so
that improper usage can always be dealt with. In contrast, <emphasis>method
postconditions</emphasis> are the states that various variables and objects should
have at the end of a method call. Using assertions to check these values
is fine, since they reflect an error on the part of whoever wrote the
method. <emphasis>Class invariants</emphasis> are conditions about the state of every
instance of a class that should be true as long as the class is in a
consistent state. Perhaps a method call rearranges the innards of an
object, but, by the end of the method call, the object should be
consistent again. You should use assertions to check class invariants at
the end of every method that could make the object violate the
invariants.</simpara>
<simpara>Wonderful as assertions are, there are times when they should not be
used. The key danger of assertions is that they are usually turned off.
Thus, any statement that is part of an assertion should not have
side-effects that are necessary for the normal operation of the program.
For example, imagine that you have a object called <literal>bacteria</literal> that
mutates periodically. The mutation returns <literal>true</literal> if successful and
<literal>false</literal> if there was an unexpected error. You should <emphasis role="strong">not</emphasis> test for that
failure inside an assert, as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">assert bacteria.mutate() : "Mutation failed!";</programlisting>
<simpara>With assertions disabled, the <literal>bacteria</literal> object will no longer mutate.
Instead, your assertion should test only the result of the computation.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean success = bacteria.mutate();
assert success : "Mutation failed!";</programlisting>
<simpara>As stated above, checking for bad input coming into <literal>public</literal> methods
should not be done with assertions because turning off assertions will
remove your error checking.</simpara>
</section>
<section xml:id="_print_statements_2">
<title>Print statements</title>
<simpara>Print statements are one of the most time-honored methods of debugging
and remain a quick, dirty, yet effective means of finding errors. Java
does not provide any special tools to make print statements easier to
use for debugging. Some purists might argue that all of this kind of
debugging which focuses on progressively narrowing own the location of a
problem until the bad assumption, logical error, or typographical error
can be found should be done only with assertions.</simpara>
<simpara>Nevertheless, there are a few tips to make print statements a better
debugging tool in Java. The first is the use of <literal>System.err</literal>. By now,
you have used <literal>System.out.print()</literal> and <literal>System.out.println()</literal> so many
times, you are probably tired of them. Any output method that can be
used with <literal>System.out</literal> can also be used with <literal>System.err</literal>. For example,
there is a <literal>System.err.print()</literal> and a <literal>System.err.println()</literal> method. If
you simply run a program from the command line and watch the output, you
should see no difference between using <literal>System.out</literal> and <literal>System.err</literal>.
However, if you redirect the output of your program to a file using the
<literal>&gt;</literal> operator, only the <literal>System.out</literal> code will be sent to the file.
Anything printed with <literal>System.err</literal> will be sent to the screen.
Alternatively, you can redirect <literal>System.err</literal> to a file by using the <literal>2&gt;</literal>
operator. Using <literal>System.err</literal> makes it easier to separate legitimate
output from error messages, but it also makes it easier to comment out
your debug code by doing a find and replace on your code.</simpara>
<simpara>A more extensive method for using print statements to debug is by
defining your own class for printing. Every method in it can call a
corresponding method in <literal>System.out</literal> or <literal>System.err</literal>. You can define a
<literal>boolean</literal> value at the class level that determines whether or not
methods in your debug printing class print or stay silent. When you want
to change from debugging to your submission or retail version of the
code, you can simply switch this value to <literal>false</literal>.</simpara>
<simpara>A &#8220;modernized&#8221; method of using print statements is creating a simple
GUI instead. In preparing materials for this textbook, we were
occasionally frustrated by the fact that multiple threads can interfere
with each other while printing on the screen: You can&#8217;t always tell
which thread is printing which characters. By displaying the output of
each thread in separate <literal>JTextArea</literal> or <literal>JLabel</literal> widgets on a simple GUI,
you can disentangle the output of each thread.</simpara>
</section>
<section xml:id="_step_through_debugging_in_java">
<title>Step-through debugging in Java</title>
<simpara>Since DrJava is a great educational tool and Eclipse is so widely used,
we are going to review the step-through debugging features of each
program. Similar tools are available with other IDE&#8217;s and for most
languages.</simpara>
<simpara>The debugger in DrJava is very simple. To enable the debugger, check the
Debug Mode checkbox in the Debugger menu. Doing so should bring up a
debugging pane in the DrJava window. In or out of debug mode, it should
be possible to set breakpoints on any executable line of code, either by
choosing the Toggle Breakpoint on Current Line command from the Debugger
menu or by typing <literal>Ctrl+B</literal>. Once you have set at least one breakpoint,
you can run the program. If a line with a breakpoint on it is reached,
then the execution of the program will pause.</simpara>
<simpara>In the debugging pane, there should now be a list of threads, with the
one that hit the breakpoint highlighted. Having reached this point, the
debugging pane has four buttons you can use to move through code:
<emphasis role="strong">Resume</emphasis>, <emphasis role="strong">Step Into</emphasis>, <emphasis role="strong">Step Over</emphasis>, and <emphasis role="strong">Step Out</emphasis>. The <emphasis role="strong">Resume</emphasis> button
allows the program to continue execution, until it hits another
breakpoint. The <emphasis role="strong">Step Into</emphasis> button advances the execution of the program
by one statement, moving into a method is there is a method call. The
<emphasis role="strong">Step Over</emphasis> button also advances the execution of the program by one
statement, but it skips over method calls. The <emphasis role="strong">Step Out</emphasis> button
advances the execution of the program to the end of the current method
and returns, popping the current method off the stack.</simpara>
<simpara>In the debugging pane, there will be a Watches tab that allows you to
find out the value of a given variable in local scope. All you need to
do is type the variable&#8217;s name, and its value and type should be
displayed. Next to the Threads tab, there should also be a Stack tab,
showing the current method call stack.</simpara>
<simpara>The Eclipse tools are similar but much more advanced. You can set
breakpoints in Eclipse either by right clicking on the shaded bar
immediately to the left of the line you are interested in or by
selecting Toggle Breakpoint from the Run menu. To debug a program in
Eclipse, right click on the file you wish to run in the Package Explorer
and select Debug As Java Application. If your program is already set up
to run, you can simply click the Debug button in the toolbar. Whenever
you hit a breakpoint, Eclipse will switch to the Debug perspective if it
is not already there. Once execution is suspended on a breakpoint, you
can use commands nearly identical to the ones in DrJava. The commands
Resume, Step Into, and Step Over from the Run menu are the same as
DrJava versions, and Step Return is the equivalent of Step Out. Eclipse
adds the useful command Run to Line, which will execute code until it
reaches the specified line.</simpara>
<simpara>By right-clicking on a breakpoint in Eclipse, you can access its
properties. Though properties, you can specify that a breakpoint only
halts execution when a specific condition is true or only for a specific
thread. The more advanced debugging in Eclipse also provides more
comprehensive variable watch and inspection options. Simply by hovering
over a variable, its type and value are displayed. You can also inspect
an object and traverse its fields. As with DrJava, you can explicitly
watch variables, but local variables are also displayed by default.</simpara>
<simpara>The difference between a good programmer and a bad programmer is often
just experience. Having seen a bug before means you know to expect it in
the future. There is no substitute for pulling your hair out over a bug
for hours before finally squashing it, but we will give a few examples
corresponding to the common bugs listed in Section <xref linkend="section:Fixing_bugs"/>.</simpara>
<example>
<title>Precision errors</title>
<simpara>Precision can cause some subtle errors, especially with <literal>float</literal> types.
Here is an example of a program attributed to Cleve Moler that gives
some estimation of the threshold for floating point precision. Note that
<literal>a</literal> <inlineequation><alt><![CDATA[\approx 4/3]]></alt><mathphrase><![CDATA[\approx 4/3]]></mathphrase></inlineequation>, making <literal>b</literal> <inlineequation><alt><![CDATA[\approx 1/3]]></alt><mathphrase><![CDATA[\approx 1/3]]></mathphrase></inlineequation>, <literal>c</literal>
<inlineequation><alt><![CDATA[\approx 1]]></alt><mathphrase><![CDATA[\approx 1]]></mathphrase></inlineequation>, and <literal>d</literal> <inlineequation><alt><![CDATA[\approx 0]]></alt><mathphrase><![CDATA[\approx 0]]></mathphrase></inlineequation>. Nevertheless,
the comparison <literal>(d == 0.0)</literal> in the <literal>if</literal> statement in this code will
evaluate to <literal>false</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">double a, b, c, d;

a = 4.0 / 3.0;
b = a - 1;
c = b + b + b;
d = c - 1;
System.out.println(d);
if( d == 0.0 )
    System.out.println("Success!");</programlisting>
<simpara>The output for this fragment is <literal>-2.220446049250313E-16</literal>. Computer
scientists who specialize in numerical analysis have tricks for
minimizing the amount of floating point error introduced, but awareness
is an easy solution to these kinds of bugs. When testing for specific
values of a floating point number, it is wise to test for a range rather
than a single value. For example, the condition <literal>(d == 0.0)</literal> could be
replaced by <literal>(Math.abs(d) &lt; 0.000001)</literal>.</simpara>
</example>
<example>
<title>Overflow and underflow</title>
<simpara>As you well know, the <literal>int</literal> and <literal>long</literal> types have limited bits for
storage. If an arithmetic operation pushes the value of an <literal>int</literal>
variable larger than <literal>Integer.MAX_VALUE</literal>, the variable will come full
circle and become a negative number, usually with a large magnitude. The
converse happens when a variable is pushed lower than the smallest value
it can hold. These situations are called overflow and underflow,
respectively, and Java throws no exceptions when they occur. Programmers
who deal with large magnitude values in <literal>int</literal> or <literal>long</literal> types get used
to underflow and overflow, and, when unexpected values are output by
their programs, they are usually quick to pin down the problem variable.</simpara>
<simpara>Overflow and underflow can cause much more subtle bugs when programmers
forget the limited range of values for <literal>byte</literal> and <literal>char</literal> types. For
example, a curious beginner programmer might want to print out a table
of all of the possible values for <literal>char</literal>. Perhaps the programmer has
forgotten the range of values a <literal>char</literal> can take. Perhaps surprisingly,
the following loop does not terminate.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( char letter = '\0'; letter &lt; 100000; letter++ )
    System.out.print( letter );</programlisting>
<simpara>Each time <literal>letter</literal> reaches <literal>Character.MAX_VALUE</literal> which is <literal>'\uFFFF'</literal> or
<literal>65535</literal> as a numerical value, the next increment pushes its value back
to 0. These kinds of errors with <literal>byte</literal> and <literal>char</literal> values are most
common when variables of those types are being used as numbers. Some
examples are cryptography, low level file operations, and manipulation
of multimedia data. The best solution is care and attention. It can help
to store the values in variables with more bits such as <literal>int</literal> or <literal>long</literal>
values, but care must still be taken to ensure that these values are
within the appropriate range before storing them back into variables
with a smaller number of bits.</simpara>
<simpara>For example, color values in many image formats are stored as red, green
blue values with a <literal>byte</literal> used for each of the three colors. In this
system, the darkest color, black, is represented as <literal>(0,0,0)</literal>, i.e. zero
values for each of the three <literal>byte`s. At the same time, the lightest
color, white, is represented conceptually as `(255,255,255)</literal>. In
principle, we can perform a very simple filter to increase contrast and
lightness by simply doubling all the pixel values. Given red, green, and
blue color values stored in three <literal>byte</literal> variables called <literal>red</literal>,
<literal>green</literal>, and <literal>blue</literal>, a naive implementation of this filter might be as
follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">red *= 2;
green *= 2;
blue *= 2;</programlisting>
<simpara>In Java, this code would not work. The first problem is that, even
though image standards are written with color values between 0 and 255,
Java <literal>byte</literal> values are <emphasis role="strong">signed</emphasis>. The web standard for the color purple
has red, green, and blue values of <literal>(128,0,128)</literal>. Since Java <literal>byte</literal>
values are signed, printing the <literal>byte</literal> values for each component of
purple directly will actually print <literal>(-128,0,-128)</literal>. Multiplying the
green value by 2 is clearly still 0. However, multiplying -128 by 2 as a
<literal>byte</literal> value is -256 which underflows back to 0. Thus, &#8220;brightening&#8221;
purple actually turns it into <literal>(0,0,0)</literal>, black. Properly applying the
filter to a <literal>byte</literal> requires a conversion to the <literal>int</literal> type, masking out
the sign bit, scaling by 2, capping the values at 255, and then casting
back into a <literal>byte</literal>. Despite the complicated description, the code is not
too unwieldy.</simpara>
<programlisting language="java" linenumbering="unnumbered">red = (byte)Math.min( 255, 2*(red &amp; 0xFF)); //bitwise AND automatically upcasts to int
green = (byte)Math.min( 255, 2*(green &amp; 0xFF));
blue = (byte)Math.min( 255, 2*(blue &amp; 0xFF));</programlisting>
</example>
<example>
<title>Casting errors</title>
<simpara>The previous example about scaling color component values is an
excellent example of the dangers of casting. Someone can easily forget
that the implicit cast to convert a <literal>byte</literal> to an <literal>int</literal> always uses a
signed conversion. Likewise, the explicit cast needed to store an <literal>int</literal>
into a <literal>byte</literal> will cheerfully convert any arbitrarily large <literal>int</literal> into a
<literal>byte</literal>, even though the final value might not be expected by the
programmer.</simpara>
<simpara>Many other casting errors crop up commonly. The most classic example
might be muddling floating point and integer types.</simpara>
<programlisting language="java" linenumbering="unnumbered">int x = 5;
int y = 3;
double value = 2.0*(x/y);</programlisting>
<simpara>Above, it is easy for a programmer to forget that the division of <literal>x</literal>
and <literal>y</literal> is integer division. After all, the <literal>2.0</literal> is right there,
causing an implicit cast to <literal>double</literal>. Of course, this cast happens after
the division, and the answer stored into <literal>value</literal> is <literal>2.0</literal> and not the
<literal>3.3333333333333335</literal> that the programmer might have expected.</simpara>
<simpara>Newer programmers sometimes forget that an explicit cast from a floating
point type to an integer type always uses truncation, never rounding.</simpara>
<programlisting language="java" linenumbering="unnumbered">int three = (int)2.99999;</programlisting>
<simpara>This assignment will always store <literal>2</literal> into <literal>three</literal>. The <literal>Math.round()</literal>
method or some other additional step is needed to perform rounding.</simpara>
<simpara>Casting errors are not limited to primitive data types. Object casting
will be discussed at length in ChapterÂ <xref linkend="chapter:Polymorphism"/>. The
biggest danger there is an incorrect explicit upcast.</simpara>
<programlisting language="java" linenumbering="unnumbered">Fruit snack = new ChiliPepper();
Apple apple = (Apple)snack;</programlisting>
<simpara>In a botanical sense, a chili pepper is indeed a fruit and its parallel
Java class is apparently a child of the <literal>Fruit</literal> class. For some reason,
the programmer thought that the only <literal>Fruit</literal> that would be pointed at by
a <literal>snack</literal> reference would be of type <literal>Apple</literal>. Instead of a mouth on
fire, the programmer gets a <literal>ClassCastException</literal>. This two line example
is so simple that it should never come up in serious programming. A much
more common example is an array or linked-list whose type is some
superclass of the item you generally expect to be in there. If a large
team is working on a body of code which such a list in it, half of the
team might expect the list to contain only <literal>Apple</literal> objects while the
other expected only <literal>ChiliPepper</literal> objects. The use of generics,
discussed in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>, can reduce the
number of casting errors of this kind, but some applications require a
list to hold many different types with a common superclass. In those
cases, some amount of explicit (and therefore dangerous) casting will
usually be necessary when retrieving the objects from the list.</simpara>
</example>
<simpara>Loops give Java much of its expressive power and unsurprisingly give it
much of its power to express incorrect as well as correct code. We are
just going to mention a few of the most common loop errors.</simpara>
<example>
<title>Off-by-one errors</title>
<simpara>Computer scientists often use zero-based counting. This departure from
&#8220;normal&#8221; practices is just one source of loops that iterate one time
more or less than they should. A good rule of thumb is, if you want to
iterate <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> times, start at 0 and go up to but not including
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. Alternatively, if you have a reason not to be
zero-based, you can start at 1 and go up to and including
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 1; i &lt; 50; i++ )
    System.out.println("Question " + i + ".");</programlisting>
<simpara>Perhaps you want to make a template for an exam. Instead of being
zero-based, you start at 1 because most exams do not have a Question 0.
Unfortunately, you have gotten so used to use a strictly less than for
your ending condition, you forget to change it. You only get 49
questions printed out. If your only purpose is making an exam, you can
catch your mistake and move on. If you are writing a program that
dispenses a quantity of heart medication into a patient&#8217;s IV in a
hospital, one iteration too few or too many could cause the patient to
get too little of the drug to make a difference or too much of the drug
to be safe.</simpara>
<simpara>Input is another tricky area when it comes to being off by one.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 0;
double sum = 0;
int count = 0;
Scanner scanner = new Scanner( System.in );
while( i &gt;= 0 ) {
    sum += i;
    System.out.print("Enter an integer (negative to quit): ");
    i = scanner.nextInt();
    count++;
}
System.out.println("Average: " + (sum / count));</programlisting>
<simpara>This fragment of code appears to be a perfectly innocent loop that finds
the average of the numbers entered by a user. The loop uses a sentinel
value so that the user simply enters a negative number when all the
numbers have been entered. The value of <literal>sum</literal> is updated before the user
enters a value; thus, the harmless <literal>0</literal> from the declaration of <literal>i</literal> is
included but the final negative number entered to leave the loop is not.
Unfortunately, the value of <literal>count</literal> is incremented for every turn of the
loop, even the extra one for the negative number. To combat this
problem, an <literal>if</literal> statement could be used inside of the loop or <literal>count</literal>
could simply be initialized to <literal>-1</literal>. The mistake is a simple one, but it
doesn&#8217;t jump out at you unless you trace a few executions. What is most
insidious is that, especially for large sets of input numbers, the error
is going to be small. Catching this kind of bug will be discussed more
throughly in the second half of this chapter, dealing with testing.</simpara>
</example>
<example>
<title>Infinite loops</title>
<simpara>Infinite loops come in many different flavors, from the <literal>char</literal> overflow
example earlier to traversing a linked-list which has a cycle in it.
Many infinite loops are caused by simple typographical errors. Perhaps
the most classic is:</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 1;
while( i &lt;= 100 );
{
    System.out.println(i);
    i++;
}</programlisting>
<simpara>It&#8217;s usually a beginning programmer who leaves a semicolon at the end of
the <literal>while</literal> header, but even veterans can get a little enthusiastic
about semicolons. Often a programmer confronted with such a bug (which
causes no ouput, in this case) will scour the body of the loop for some
clue as to why it isn&#8217;t advancing yet never carefully scrutinizing the
condition. An extra semicolon the end of a <literal>for</literal> loop header will
usually cause an error but will usually <emphasis role="strong">not</emphasis> cause an infinite loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">public double average(int[] array) {
    double sum = 0;
    int count = 0;
    for( int i = 0; i &lt; 100; i++ ) {
        sum += array[i];
        count++;
        if( i == 0 )
            i--;
    }
    return sum / count;
}</programlisting>
<simpara>This example is the kind that might be too confusing to appear in a
textbook, but nearly everyone has written worse code while learning to
program. We could suppose that this method is meant to average the
values in an array, but, for some reason, zero valued entries are not to
be counted. The student probably meant to have the following <literal>if</literal>
statement:</simpara>
<programlisting language="java" linenumbering="unnumbered">        if( array[i] == 0 )
            count--;</programlisting>
<simpara>Those two small changes turn the method into a working but slightly
inelegant solution. When debugging remember that index variables in
<literal>for</literal> loops can get changed in the body of the loop and change the
expected behavior. Generally it is a bad idea to change the value of an
index variable anywhere other than the header of a <literal>for</literal> loop, but there
are times when doing so gives the cleanest solution.</simpara>
<simpara>Many loop errors are caused by a bad header. Getting the an inequality
backwards or switching increment and decrement will usually make a loop
that runs a very long time or not at all. We&#8217;ll see the second
possibility just a little later.</simpara>
<programlisting language="java" linenumbering="unnumbered">for (i = 10; i &gt; 0; i++) {
  System.out.println(i + "!");
}
System.out.println("Blast-off!");</programlisting>
<simpara>In this case, the programmer clearly wanted to count <emphasis role="strong">down</emphasis> from 10 to
1, but after so much incrementing, he or she forgot to make <literal>i</literal>
decrement. As a result, the value of <literal>i</literal> increases for a very long (but
not infinite) time, until it overflows.</simpara>
</example>
<example>
<title>Zero loops</title>
<simpara>On the other end of the spectrum, a bad condition can make a loop
execute zero times on <literal>for</literal> and <literal>while</literal> loops. For some input, doing so
might be intended behavior. In other cases, no input will ever cause the
loop to execute.</simpara>
<programlisting language="java" linenumbering="unnumbered">int i = 0;
double sum = 0;
int count = -1;
Scanner scanner = new Scanner( System.in );
while( i &gt; 0 ) {
    sum += i;
    System.out.print("Enter an integer (negative to quit): ");
    i = scanner.nextInt();
    count++;
}
System.out.println("Average: " + (sum / count));</programlisting>
<simpara>We have just returned to our earlier example of averaging a set of
numbers input by the user. This time we have intialized <literal>count</literal> to be -1
to avoid the off-by-one error, but we have also changed the inequality
of the <literal>while</literal> loop from greater than or equal to strictly greater. As a
consequence, the loop is never entered because the zero, the initial
value of <literal>i</literal>, is too small.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static boolean isPrime( int n ) {
    for( int i = 1; i &lt; n; i++ ) {
        if( n % i == 0 )
            return false;
    }
}</programlisting>
<simpara>Here is a simple method intended to test the number <literal>n</literal> for primality.
Unfortunately, the programmer started the index <literal>i</literal> at 1 instead of 2.
As a consequence, this loop will only run once before finding that every
number is divisible by 1. True, this is not a loop that executes zero
times, but only once is still just as wrong.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static boolean isPrime( int n ) {
    for( int i = 2; i &lt; n; i++ ) {
        if( n % i == 0 )
            return false;
        else
            return true;
    }
}</programlisting>
<simpara>This example is very similar code, trying to solve the same problem.
Again, the loop only runs once because the programmer forgot that
finding a single case when a number is not evenly divisible by another
number does not make it prime. Many, many beginning programmers make
this mistake when asked to solve this problem. Perhaps some insight
about the nature of bugs can be gained from this example. By the time a
student writes a program of this kind, he or she should have a fair idea
of how <literal>for</literal> loops and <literal>if</literal> statements work. Likewise, the student will
have a fair understanding of the notion of primality. Yet, in the
process of combining the ideas together, it is easy to get sloppy and
write code that gives some semblance of being correct without being.</simpara>
</example>
<example>
<title>Equivalence testing errors</title>
<simpara>Equivalence is tricky in Java. Very inexperienced programmers confuse
the <literal>=</literal> operator with the <literal>==</literal> operator, but using the <literal>==</literal> operator to
test for equivalence between two references causes more (and subtler)
problems. Comparing two references with the <literal>==</literal> operator will evaluate
to <literal>true</literal> if and only if the two references point at the exact same
object.</simpara>
<programlisting language="java" linenumbering="unnumbered">String string1 = new String("Test");
String string2 = new String("Test");
if( string1 == string2 )
    System.out.println("Identical");
else
    System.out.println("Different");</programlisting>
<simpara>Because these two <literal>String</literal> references point to two different <literal>String</literal>
objects, which happen to have identical contents, the <literal>==</literal> returns
<literal>false</literal> and the output is <literal>Different</literal>. With <literal>String</literal> objects this matter
is further confused by a Java optimization called <literal>String</literal> pooling.</simpara>
<programlisting language="java" linenumbering="unnumbered">String string1 = "Test";
String string2 = "Test";
if( string1 == string2 )
    System.out.println("Identical");
else
    System.out.println("Different");</programlisting>
<simpara>Because Java keeps a pool of existing <literal>String</literal> values, only one copy of
<literal>"Test"</literal> is in the pool, and both <literal>string1</literal> and <literal>string2</literal> point to it.
Thus, this second fragment of code prints <literal>Identical</literal>. Because of
<literal>String</literal> pooling, programmers can write code which can work in some
situations and fail in other, if it is dependent on the <literal>==</literal> operator.</simpara>
<simpara>For <literal>String</literal> objects as well as almost every reference type, it is
almost always the case that the <literal>equals()</literal> method should be used to test
for comparison instead of the <literal>==</literal> operator. There are a few instances
when it is necessary to know if two references really and truly do refer
to the same location in memory, but these instances should be a tiny
minority.</simpara>
<simpara>That said, the <literal>equals()</literal> method is not bullet-proof. With <literal>String</literal>
objects and most of the rest of the Java API, you can expect very good
behavior from the <literal>equals()</literal> method. However, if you create your own
class, you are expected to implement the <literal>equals()</literal> method. By default,
the <literal>equals()</literal> method inherited from <literal>Object</literal> only does an equality test
using <literal>==</literal>.</simpara>
<simpara>Properly implementing the <literal>equals()</literal> method takes care and thought. If
your class contains references to other custom classes, you must be
certain that they also properly implement their own <literal>equals()</literal> methods.
Likewise, to conform to Java standards, a custom <literal>equals()</literal> method
should also imply that you implement a custom <literal>hashCode()</literal> method so
that objects that are equivalent with <literal>equals()</literal> give the same hash
value. It seems nit-picky to mention this, but many real-world
applications depend on the efficient and correct operation of hash
tables.</simpara>
</example>
</section>
<section xml:id="_array_errors">
<title>Array errors</title>
<simpara>Any time you have a large collection of data, there are always
opportunities for bugs. With catastrophic array bugs, Java usually gives
very good exceptions that will point you to the line number. Once you
have gotten to this point, the bug should be obvious. The biggest
difficulties arise when some unusual course of events is responsible for
the bug cropping up and you have to reconstruct what it is.</simpara>
<example>
<title>Out of bounds</title>
<simpara>We have all experienced an <literal>ArrayIndexOutOfBoundsException</literal>. Either a
little carelessness with our indexes or a mistake about the size of the
array can lead us to try to access an element that isn&#8217;t in the array.
In the C language, a negative index is sometimes a legal location but
never in Java. It is very common to go just slightly beyond the bounds
of the array, particularly with a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">int[] array = new int[100];
for(int i = 0; i &lt;= 100; i++ )
    array[i] = i;</programlisting>
<simpara>In this example, the last iteration of the loop will access index <literal>100</literal>
when <literal>array</literal> only goes up to index <literal>99</literal>.</simpara>
<simpara>The causes for going out of bounds can be more subtle. We can imagine an
array of linked lists used as a hashtable, perhaps for storing words in
a dictionary. If we want to hash based on the first letter of the word,
we could have an array of length 26. Consider the following helper
method used to add a new <literal>String</literal> to the hashtable.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void add(String word) {
    int index = word.toLowerCase().charAt(0) - 'a';
    list[index].add( word );
}</programlisting>
<simpara>We can assume that the <literal>add()</literal> method for a given linked list works
properly, but we may already have caused other problems. For one thing,
we assumed that <literal>word</literal> began with either an upper or lower case letter.
We are depending on other code to check the input and throw out words
like <literal>"$1"</literal> or <literal>"-isms"</literal>. Incidentally, we are also assuming that
<literal>word</literal> has at least one character in it. Even if we expect the input to
the method to be error free, the addition of error checking is rarely a bad idea.</simpara>
</example>
<example>
<title>Uninitialized object arrays</title>
<simpara>Another simple mistake that can occur with arrays is failing to
initialize an object array. With a primitive data type like <literal>int</literal>,
creating an array with 1,000 elements automatically allocates enough
space to hold those elements and even initializes each one to a default
value, zero in the case of an <literal>int</literal>. With an object data type, however,
each element of the array is just a reference to <literal>null</literal> until it is
initialized.</simpara>
<programlisting language="java" linenumbering="unnumbered">Hippopotamus[] hippos = new Hippopotamus[15];
hippos[3].feed();</programlisting>
<simpara>This example causes a <literal>NullPointerException</literal>. New programmers are often
confused by this error because, if they are expecting an error, they are
expecting the exception to say something about the array. For more
experienced programmers, this kind of mistake is usually more of a
forehead-slapping, how-silly-of-me-to-forget error than a mind-numbing
puzzler that will take hours to debug. It is probably just a matter of
instantiating each element in the array before you try to feed those
hungry, hungry hippos.</simpara>
</example>
<programlisting language="java" linenumbering="unnumbered">Hippopotamus[] hippos = new Hippopotamus[15];
for( int i = 0; i &lt; hippos.length; i++ )
    hippos[i] = new Hippopotamus();
hippos[3].feed();</programlisting>
</section>
<section xml:id="_scope_errors">
<title>Scope errors</title>
<simpara>We don&#8217;t have variables in real life, and, as a consequence, out
intuition about them is sometimes wrong. Which variable you are
accessing at any given time can appear obvious, even if it really isn&#8217;t.</simpara>
<example>
<title>Shadowing variables</title>
<simpara>Java allows variables in different scopes to be declared with the same
identifier. If the scopes are two separate methods, then they will never
interfere with each other. However, if one scope encloses another, the
inner variable will <emphasis>shadow</emphasis> or hide the outer variable.</simpara>
<programlisting xml:id="program:Shadow" xreflabel="Shadow" language="java" linenumbering="numbered">public class Shadow {
	int darkness = 10;

	public void deepen( int darkness ) {
		darkness += darkness;
		if( darkness &gt; 100 )
			darkness = 100;
	}

	public int getDarkness() { return darkness; }
}</programlisting>
<simpara>In this example, the field <literal>darkness</literal> is being shadowed by the local
variable <literal>darkness</literal> in the <literal>deepen()</literal> method. It appears that the
programmer wanted to increase the field <literal>darkness</literal> by the amount passed
into the parameter <literal>darkness</literal> and failed to notice that both variables
had the same name. As a consequence, the parameter <literal>darkness</literal> will
double itself and then never be used again while the field <literal>darkness</literal>
will never increase. This kind of bug could go uncaught for a long while
until a programmer notices that the <literal>Shadow</literal> object is not increasing in
darkness no matter how many times it is told to.</simpara>
<simpara>This kind of mistake is also common in constructors, since it is
reasonable to give a certain parameter a name similar to the field it is
about to initialize. Some programmers explicitly prefix all fields with
<literal>this</literal> even though it is often redundant. Three additions of <literal>this</literal> will
fix the problem in the preceding example.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public void deepen( int darkness ) {
        this.darkness += darkness;
        if( this.darkness &gt; 100 )
            this.darkness = 100;
    }</programlisting>
<simpara>In Java, scope is also defined in terms of classes and their parent
classes. A parent class variable can be shadowed by a child class
variable of the same name.</simpara>
<programlisting xml:id="program:Bodybuilder" xreflabel="Bodybuilder" language="java" linenumbering="numbered">public class Bodybuilder {
	public int strength = 8;

	public boolean isStrongEnough( int strengthNeeded ) {
		return strength &gt;= strengthNeeded;
	}

	public void setStrength( int value ) { strength = value; }
}</programlisting>
<programlisting xml:id="program:BraggingBodybuilder" xreflabel="BraggingBodybuilder" language="java" linenumbering="numbered">public class BraggingBodybuilder extends Bodybuilder {
	public int strength = 10;

	public void brag() {
		System.out.println("My strength is " + strength + "!");
	}
}</programlisting>
<simpara>This example looks like a simple case of inheritance, but whoever wrote
the <literal>BraggingBodybuilder</literal> class seems to have mistakenly included the
field <literal>strength</literal> again. As a consequence, any <literal>BraggingBodybuilder</literal> will
always brag that his or her strength is 10, even when code sets his or
her strength to other values. When strength is tested, it will use the
<literal>strength</literal> field from the superclass <literal>Bodybuilder</literal> which is set by the
<literal>setStrength()</literal> method. Sometimes similar behavior is desired, but it
seems to be accidental here. When classes have large numbers of fields,
making such a mistake becomes easier.</simpara>
<programlisting language="numberLines" linenumbering="unnumbered">Bodybuilder builder = new BraggingBodybuilder();
builder.strength = 15;/*@\label{line:strength=15}@*/
BraggingBodybuilder bragger = (BraggingBodybuilder)builder;
bragger.brag();
bragger.strength = 20;/*@\label{line:strength=20}@*/
bragger.brag();</programlisting>
<simpara>Dynamic and static binding complicate this scope problem further. This
fragment of code using the class definitions above highlights these
complications. Because fields are statically bound to the class of the
object, the <literal>strength</literal> field for <literal>Bodybuilder</literal> will be set to 15 on line
<xref linkend="line:strength=15"/>, and the <literal>strength</literal> field for <literal>BraggingBodybuilder</literal>
will be set to 20 on line <xref linkend="line:strength=20"/>. Thus, the first call to
<literal>brag()</literal> will print out <literal>My strength is 10!</literal>, but the second call will
print out <literal>My strength is 20!</literal>.</simpara>
</example>
<example>
<title>Reference vs. value</title>
<simpara>The final category of scope error we will talk about occurs because of
confusion between passing by reference and passing by value when using
methods. Everything variable in Java is passed by value. However, when
that value is itself a reference, it is possible to change the values
that it references.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void increaseMagnitude( int number ) {
    number *= 10;
}</programlisting>
<simpara>A novice Java programmer might write a method like the above, expecting
the value of <literal>number</literal> to increase by 10 in the calling code. Some
languages like Perl use call by reference as default. Other languages
like C++ and C# allow the user to mark certain parameters as call by
reference. Programmers comfortable with such languages may be confused
about the workings of Java.</simpara>
<simpara>On the other hand, becoming used to the pass by reference style of Java
can cause other errors.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void increaseMagnitude( int[] numbers ) {
    numbers[0] *= 10;
}</programlisting>
<simpara>In this similar example, the 0 index element of <literal>numbers</literal> is increased
by a factor of 10. Unlike the previous code, the increase in the value
of that element will affect the array passed in by the calling code. The
values in the array are shared by the <literal>increaseMagnitude()</literal> method and
the calling code. The same phenomenon can be observed with the fields of
objects whose references are passed into a method.</simpara>
</example>
</section>
<section xml:id="_null_pointer_errors">
<title>Null pointer errors</title>
<simpara>Null pointer errors usually raise a <literal>NullPointerException</literal> in Java. This
category of errors is something of a catch-all that could happen for
many different reasons, some of which have already been mentioned.
Because of loop errors, some variables might not be initialized. A
<literal>NullPointerException</literal> could be raised because the elements of an object
array have not be initialized. Scope problems could cause a reference to
be null if the programmer was mistakenly updating another reference,
leaving the reference in question uninitialized.</simpara>
<simpara>Though common, it is very difficult to give a blanket explanation for
why most null pointer errors happen. Usually there is some fundamental
error in program logic. Linked lists and tree structures that rely on
null references to mark the end of a list or an empty child node are
especially susceptible to these errors.</simpara>
<simpara>One significant source of errors is careless usage of method parameters.
A programmer may pass in objects that do not conform to the expectations
of the method or even null references instead of objects. Well written
methods, particularly library calls, should be designed to throw an
appropriate exception when this happens. Poorly designed code may
blindly use a null reference without checking it first, causing a
<literal>NullPointerException</literal>.</simpara>
</section>
</section>
<section xml:id="_concurrency_parallel_bugs">
<title>Concurrency: Parallel bugs</title>
<simpara>We will only briefly discuss parallel bugs here because we have already
gone into depth about the dangers of parallel programming in
ChapterÂ <xref linkend="chapter:Synchronization"/>. Except in the case of deadlocks and
livelocks, the real trouble with parallel bugs is that they make the
appearance of ordinary sequential bugs become nondeterministic.</simpara>
<section xml:id="_race_conditions">
<title>Race conditions</title>
<simpara>A race condition describes the situation when the output of a program is
dependent on the timing of the execution of two or more threads. Because
of the complexity of the JVM and the OS and the fact that many other
processes may be running and interacting, it is usually impossible to
determine how two threads will be scheduled. As a consequence, if the
output of the program depends on unpredictable timing, the output will
also be unpredictable.</simpara>
<simpara>In Java, the way that race conditions usually impact the program is
through some variable shared between multiple threads. When the schedule
of threads becomes unpredictable, the changes made to this variable can
come out of sequence, and its value becomes unpredictable. Incorrect
output means that your program has a bug, but the most frustrating
aspect of race conditions is that they are nondeterministic. Your
program could sometimes have the right answer and sometimes not. Your
program could always have the wrong answer, but not always the same one.
The truly insidious issue with race conditions is that they will usually
cause errors only a tiny percentage of the time. Thus, rigorous testing
such as we will discuss in the second half of this chapter is necessary
to even be aware that a race condition is occurring.</simpara>
</section>
<section xml:id="_deadlocks_and_livelocks">
<title>Deadlocks and livelocks</title>
<simpara>Both deadlocks and livelocks describe situations in which some part of
your program will stop making progress because of thread interaction. In
the case of deadlock, there will be some circular wait in which thread A
is waiting for thread B which is waiting, directly or indirectly, on
thread A. In the case of livelock, some repetitive pattern of waiting
for a condition that will never be satisfied is still going on, but the
threads continue to use CPU time and are not simply waiting.</simpara>
<simpara>If your program reaches a deadlock state, it will not terminate. If
threads updating a GUI become deadlocked, your windows may freeze.
Typically, deadlocks are nondeterministic and occur only some of the
time. Like all race conditions, they can be difficult to detect and
duplicate. In fact, <literal>Thread.stop()</literal>, <literal>Thread.suspend()</literal>, and
<literal>Thread.resume()</literal>, three seemingly useful and fundamental methods that
were originally part of the Java <literal>Thread</literal> class, have been deprecated
because they are deadlock prone.</simpara>
</section>
<section xml:id="_sequential_execution_2">
<title>Sequential execution</title>
<simpara>One bug which is impossible to achieve in non-parallel code is
sequential execution. This situation arises when, usually due to overuse
of synchronization tools, parallel code runs sequentially. Each segment
of code, instead of running in parallel, is forced to wait for another
to complete. A certain amount of serial execution is necessary to
maintain program correctness and avoid race conditions, but Amdahl&#8217;s Law
gives a rigid, mathematical characterization of how easily speedup can
be lost if the serial execution takes up large portions of the code.
Because setting up threads and using other concurrency tools does have
some overheard, a parallel program executing sequentially can even run
more slowly than a completely sequential version.</simpara>
<simpara>Because programs are usually parallelized for the sake of speedup, it is
possible to time sections of programs to see how well you have
parallelized them. Sequential execution due to synchronization tools is
only one of the many problems that can cause slow execution. The threads
may be competing for a limited resource such as an I/O device or may be
fighting over a small section of memory, causing cache misses. Tuning
applications for maximum performance requires an expert understanding of
the concurrency issues within software as well as the underlying OS and
hardware characteristics. For now, it&#8217;s enough to be aware of the risk
of sequential execution and be as careful as possible when applying
locks and other synchronization tools.</simpara>
</section>
</section>
<section xml:id="_finding_and_avoiding_bugs">
<title>Finding and avoiding bugs</title>
<simpara>What would you do if you wanted to design a system for administering a
dose of radiation to a specific location on a patient to help treat them
for cancer? Depending on the specification of the problem, you might
need to control various voltage sources, read data from various sensors,
and create a terminal interface or a GUI. With a well designed
specification, you could probably apply your knowledge of loops and
control structures to some API and provide a software solution that met
requirements.</simpara>
<simpara>But, how would you know that it worked? Sure, you could run a series of
tests, but how many tests would it take for you to be convinced that it
worked perfectly? What if your grade was dependent on it working without
a single error? Or your job? Or your life?</simpara>
<simpara>You have probably already faced the stress of trying to get a program to
work as well as possible for the sake of your grade. It is not such a
far cry to imagine your job being on the line if you make a mistake as a
professional programmer. But, what about your life? Perhaps you will
never put your life in the hands of code you write, but odds are that
you have already put your life in the hands of someone else&#8217;s code.
Software controls airplanes, automobiles, medical equipment, and
countless other applications where a bug in the code could actually
result in loss of human life.</simpara>
<simpara>Sadly, there have been cases when such bugs have surfaced with deadly
consequences. One of the most famous examples of the dangers of badly
written software is the Therac-25. The Therac-25 was a machine designed
to deliver therapeutic radiation for medical purposes. Between 1985 and
1987, use of the Therac-25 caused at least six incidents of massive
radiation overdoses, leading to at least three deaths.</simpara>
<simpara>Like most failures of this scope, there was more than a single cause
behind the Therac-25 tragedies. For one thing, the machines did give an
error code. However, the user manual did not explain the error code, and
the technicians were not trained to deal with the errors. Even when
patients complained about pain caused by the machine, the technicians
and even the manufacturers of the Therac-25 were confident that the
machine was operating correctly because neither of the previous models,
the Therac-6 and the Therac-20, had suffered any problems.
Overconfidence has played a significant role in many of the worst
systems failures, including the devastating Chernobyl disaster.</simpara>
<simpara>Ignoring the human errors, a number of software errors were also
responsible for the Therac-25 overdoses. The overdoses occurred when
technicians made incorrect keystrokes giving confusing instructions to
the Therac-25 about which mode of operation it should be in. In this
situation, the machine would operate with a high-power beam but without
the beam spreader that was necessary for its safe operation. The
designers ignored the possibility that this series of keystrokes would
happen. Also, a race condition was involved in this bug since it
depended on one task that set up the equipment and another that received
input from the technician. This race condition was never caught because
only technicians with long practice could work fast enough to cause the
bug. Finally, a counter was incremented for use as a flag variable, but
arithmetic overflow occasionally caused this flag to have the wrong
value.</simpara>
<simpara>In the remaining half of this chapter, we will discuss a number of
testing methodologies and design strategies to minimize errors in
software.</simpara>
</section>
<section xml:id="_concepts_design_implementation_and_testing">
<title>Concepts: Design, implementation, and testing</title>
<simpara>Unfortunately, there is no foolproof way to design software. There are
many researchers who work to design new languages and new development
tools that limit certain kinds of mistakes, but it is impossible to
design a language as powerful as C or Java which will also prevent all
software bugs. A consequence of the halting problem, a fundamental
concept in the theory of computation, is that there is no way to design
a test that will detect all potential infinite loops (or infinite
recursion) for all programs.</simpara>
<simpara>With careful design, implementation, and testing, most errors can
reduced almost to nothingness. In the following subsections, we will
discuss these three aspects of programming and how you can apply them to
writing better programs.</simpara>
<section xml:id="_design">
<title>Design</title>
<simpara>We have remarked in the past that good design pays off ten-fold in
implementation, and that payoff continues to increase by factors of ten
as you move on to testing and eventually deployment.</simpara>
<simpara>One of the first design decisions you may have to make is choice of
language. Some languages are better designed for certain tasks than
others. For example, languages like Ada have been carefully designed to
minimize programming mistakes such as mis-matched <literal>else</literal> blocks. Many
functional languages like ML are designed so that memory errors such as
a <literal>NullPointerException</literal> are impossible. Even Java has taken clear steps
to avoid some of the errors possible in C and other languages that allow
pointer arithmetic, such as bus errors. However, many other factors such
as portability, compatibility, and speed will affect your language
decision.</simpara>
<simpara>If you are working in industry, you may be given a specification from
your client or your supervisors. As you design the software needed to
meet the specification, you may use UML diagrams to map out the classes
and interactions you plan to implement in your program.</simpara>
<simpara>There are many questions you may ask yourself as you design your
solution. Will your solution be compatible with the system and future
changes made in the system? Is it easy to add features to your solution?
Does your solution deal gracefully with mistakes in user input or
external hardware and software failures? Is your code easy to maintain,
particularly by future programmers who were not involved in its initial
development. Are the components of the system modular? Can they be
worked on, tested, and upgraded independently? Are the components of
your system designed well enough to be reused for other applications?
Are the elements of your system secure from malicious attacks? Finally,
is it easy for the user to work with your software?</simpara>
<simpara>Each one of these questions is related to a separate sub-field in
software engineering. It may be impossible to address them all
completely, but different applications will have different priorities.
One method for OO software engineering uses <emphasis>design patterns</emphasis>. The idea
behind design patterns is that most classes share some common design
principles with a large category of classes. By naming and recognizing
each category, you can apply the same rules to designing new classes
from a category you are already familiar with. Each category is called a
design pattern. Java uses design patterns extensively in its API.
Describing design patterns in greater depth is beyond the scope of this
book, but you may want to consult the Gang of Four&#8217;s excellent book
<emphasis>Design Patterns</emphasis>.</simpara>
<simpara>Another important idea in design is <emphasis>design by contract</emphasis>. Although this
is also a rich, complex area of software engineering, the idea can be
applied to methods in a straightforward way. For each method, you have a
formal explanation of what its input should be, what its output should
be, and what else can be changed in the process. For some languages and
some segments of code, it is possible to prove that a given method does
exactly what it is supposed to do. Nevertheless, Donald Knuth, a giant
in computer science, is famous for having said, "Beware of bugs in the
above code; I have only proved it correct, not tried it."</simpara>
</section>
<section xml:id="_implementation">
<title>Implementation</title>
<simpara>When the time comes to actually implement your design, there are a
number of other techniques you can use to minimize errors in this phase.
One interesting technique is <emphasis>pair programming</emphasis>, in which two
programmers sit at a single computer and work together. Ideally, one
programmer is thinking about the immediate problems posed by the next
few lines of code while the other is thinking about the larger context
of the program. Two sets of eyes is always beneficial when looking at
something as detailed and confusing as a computer program.</simpara>
<simpara>In keeping with the theme of having more than one set of eyes looking at
a program, it is generally recognized that it is useful to have the
individuals who test the software be independent from those who develop
it. By keeping the testers separate, they are not infected by the
assumptions and biases that the developers have made while writing the
software. Some communication between the two groups is necessary, but
there is a lot of value in black box testing, which we will explain in
the next subsection.</simpara>
<simpara>Another piece of general advice is to rely on standard libraries as much
as possible. Reinventing your own libraries is partly a waste of time
and partly dangerous because your own libraries have not undergone as
much testing as the standard ones. Likewise, it makes your code less
portable. Some expert developers may need to write special libraries for
speed or memory efficiency, but they are the exception, not the rule.</simpara>
<simpara>There are a number of Java specific implementation guidelines. People
have written entire books about good software engineering in Java, and
so we will only give a few obvious pointers.</simpara>
<simpara>Although it is tempting to do so when working under time pressure, never
write empty exception handlers. Doing so swallows exceptions blindly,
giving the user no idea what the errors in his or her program are. By
the same token, always make your exception handlers as narrow as
possible. Simply putting a <literal>catch( Exception e )</literal> at the end of any
<literal>try</literal>-block has one of two possible outcomes: In one case your handler
is vague and the user is informed that a general error of some kind has
occurred. In the other your handler is more precise than it has a right
to be. You might have assumed that a file I/O error was most likely to
occur and always report that failure. Instead, an
<literal>ArrayOutOfBoundsException</literal> could happen and be mistakenly reported as a
file I/O problem.</simpara>
<simpara>You should test the input to any public methods you write and throw a
pre-determined exception if the input is invalid. Never use assertions
to test input to public methods. In fact, you should never depend on
assertions to catch errors since they must be turned on in the JVM to
have effect. Assertions are great for debugging code before it is
released but have little or no value in the field.</simpara>
</section>
<section xml:id="_testing">
<title>Testing</title>
<simpara>Once you have designed and implemented your program (or perhaps even
during the process of implementation), you should test it to see if it
behaves as expected and required. The most common form of software
testing done by students is a form of a <emphasis>smoke test</emphasis>. A smoke test is a
basic test of functionality. Such a test should simply run through the
major features of a program and verify that they seem to work under
ordinary circumstances. Often a student will barely finish the program
before the deadline and be unable to perform anything but the most basic
tests.</simpara>
<simpara>Smoke tests are useful because it is pointless to test the finer details
of a system that is clearly broken, but the software engineering
industry uses many other kinds of testing to ensure that a given piece
of software meets its specification. We will briefly cover three broad
areas of testing: black box testing, white box testing, and regression
testing.</simpara>
<section xml:id="_black_box_testing">
<title>Black-box testing</title>
<simpara>Black box testing assumes that the tester knows nothing about the
internal mechanisms of the software he or she is testing. The software
is viewed as a "black box" that only has inputs and outputs. The tester
chooses some subset of the possible inputs and tests to see if the
output matches the specification.</simpara>
<simpara>For simple programs with very little input, it may be possible to test
<emphasis role="strong">all</emphasis> possible input values, but doing so is impractical for most
programs. A short list of techniques for determining the appropriate set
of input values for black box testing follows.</simpara>
<variablelist>
<varlistentry>
<term>Equivalence Partitioning</term>
<listitem>
<simpara>The idea behind equivalence partitioning is that large ranges of data
may be functionally equivalent from the point of view of causing
errors. If a tester can run a test for one element from a range of
data, then the entire range can be tested quickly. To perform this
kind of testing, the tester must partition data into ranges that
function differently. The partition created is usually not really a
partition in a mathematical sense as the sub-domains are overlapping.
This is one reason why equilvalence partitioning is also referred to
as <emphasis>subdomain</emphasis> testing.<?asciidoc-br?>
For example, a program controlling the temperature of the water in an
aquarium may have legal input ranges between 32F and 212F. However, if
the program warms the water when it is below 75F and cools it when it
is above 90F, then values below 0, values from 0 to 74, values from 75
to 90, values from 91 to 212, and values above 212 all constitute
different partitions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Boundary Value Analysis</term>
<listitem>
<simpara>Once inputs have been partitioned into equivalent ranges, testers can
focus on those values which are near the boundary of those ranges. For
example, an input containing a person&#8217;s age may be allowed to range
between 0 and 150. The values -1, 0, 1, 149, 150, and 151 are good
candidates for input from the perspective of boundary value analysis.
As with equivalence partitioning, boundary value analysis is useful
not only for the boundaries between valid and invalid data but also
for the boundaries between any input ranges with different program
behavior such as the boundaries separating the five ranges of values
for the aquarium thermostat program described above.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>All-Pairs Testing</term>
<listitem>
<simpara>Most software bugs are triggered by a single piece of input. Some
harder to discover bug require two separate piece of input to have
specific values at the same time before they manifest. With each
increase in the number of different inputs that must each have
specific values at the same time to cause a bug, the bug becomes
increasingly difficult to track down but also increasingly unlikely to
exist. It may be possible to test all possible values for a given
input but impossible to test all possible values for all inputs at the
same time. All-pairs testing is a compromise between these two
extremes that tests all possible pairs of inputs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Fuzz Testing</term>
<listitem>
<simpara>The concept behind fuzz testing is to use large amounts of invalid,
unlikely, or random data as input to a program. Although this kind of
testing is used only to test the reliability and robustness of a
program receiving unexpected input, it has a number of advantages. One
significant advantage of fuzz testing is that it is quick and easy to
design test cases. Another is that it makes no assumptions about the
program behavior, catching errors that might never occur to a human
being.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_white_box_testing">
<title>White-box testing</title>
<simpara>The philosophy of white box is the opposite of black box testing. When
using white box testing techniques, the tester has access to the program
internals. The tester should employ techniques to test every possible
path that execution can take through the code. Traversing a particular
path of execution through a program is called <emphasis>exercising</emphasis> that path.</simpara>
<simpara>In order to exercise every possible path, it is necessary to force each
conditional statement to be true and false on some path. Some
combinations of true and false may be impossible, but, ignoring this
fact, a program with <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> independent conditionals would
require <inlineequation><alt><![CDATA[2^n]]></alt><mathphrase><![CDATA[2^n]]></mathphrase></inlineequation> runs to test them all. Because of the large
number of possible execution paths, white box testing generally tries to
maximize coverage over metrics that are not quite so demanding.</simpara>
<simpara>Method coverage is the percentage of methods that are called by test
cases at least once. Ideally, this number is 100%. Statement coverage is
the percentage of statements that are executed by test cases. Again,
this number should be as close to 100% as possible. Branch coverage is
the percentage of conditionals that have been executed on both their
true and false branches. Getting total coverage here is difficult, but
good testing can come close.</simpara>
<simpara>As with black box testing, equivalence partitioning and boundary value
methods can be used to reduce the total number of test cases. Also, it
is important to test those parts of your programs reached only in error
conditions in addition to normal operation.</simpara>
</section>
<section xml:id="_regression_testing">
<title>Regression testing</title>
<simpara>Regression testing is a form of testing that is not often necessary for
student code because they are small projects. The motivating idea behind
this kind of testing is that, in the act of fixing a bug or adding a
feature, existing code can be broken. Thus, even after a system has been
thoroughly tested, small changes or additions require the entire system
to be retested. As the size of a program grows, the chance of unintended
consequences increases, along with the value of performing regression
testing.</simpara>
<simpara>Regression testing can incorporate both black and white box testing.
Doing regression testing could simply mean running all the existing
tests over again. At the very minimum, each time a test uncovers a bug,
that test should be added to the test suite used after each build of the
program. The use of regression testing also implies that regular testing
is being done on your code. Regular testing gives developers the
opportunity to track changes in other aspects of their program such as
memory usage, run time, and other non-functional issues.</simpara>
</section>
</section>
</section>
<section xml:id="_syntax_java_testing_tools">
<title>Syntax: Java testing tools</title>
<simpara>There is an open-source tool for testing Java called JUnit testing.
There are other testing tools for Java, and there are a wide array of
tools for testing software in virtually any language. We cover JUnit
here because it is widely accepted as a standard Java testing tool and
because it is open-source. First, we&#8217;ll explain how to use JUnit, and
then we&#8217;ll discuss some of the tools available to help test concurrent
software.</simpara>
<section xml:id="_junit_testing">
<title>JUnit testing</title>
<simpara>JUnit testing is used for unit testing Java. Unit testing is the process
testing of separate software components that will eventually work
together. By testing them individually, debugging can be done before
interactions between different components make it more difficult to find
the underlying bug. After unit testing comes integration testing to test
how the components work together. Finally, system testing is the testing
of the complete, integrated system against its specifications.</simpara>
<section xml:id="_annotations">
<title>Annotations</title>
<simpara>Our coverage of JUnit testing is based on JUnit 4. This version of JUnit
simplifies the syntax of creating JUnit tests, but it also relies on
<emphasis>annotations</emphasis>. Annotations are additional information written into Java
code that affects how the compiler or run-time system treats the code.
They are like comments, but they can affect code execution or
compilation, though usually indirectly. Applying an annotation to a
method is called <emphasis>decorating</emphasis>. A class, a method, a variable, a package,
or even an individual method parameter can be decorated.</simpara>
<simpara>Three annotations are built into the language: <literal>@Deprecated</literal>,
<literal>@Override</literal>, and <literal>@SuppressWarnings</literal>. If a method is decorated with
<literal>@Deprecated</literal>, it is deprecated and included only for backwards
compatibility. The compiler will give a warning if you call deprecated
code such as the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Deprecated
public void oldMethod() {
    ...
}</programlisting>
<simpara>Many methods in the extensive Java API are deprecated, like
<literal>Thread.suspend()</literal> due to its inherent deadlock risk. As of Java 5 when
annotations were introduced, these methods were all decorated with
<literal>@Deprecated</literal>. The <literal>@Override</literal> annotation marks a method that is
overriding superclass method, causing a compiler error if the method is
not correctly overriding some superclass method. The <literal>@SuppressWarnings</literal>
annotation allows certain warning messages to be suppressed, like using
deprecated code if you really have to.</simpara>
</section>
<section xml:id="_basic_junit_syntax">
<title>Basic JUnit syntax</title>
<simpara>First of all, JUnit is not a part of the standard Java API. To use it,
you should download the latest jar file from <link xl:href="http://www.junit.org">http://www.junit.org</link> and
add the path to that jar file to your class path. To access the JUnit
facilities in your code, you need the following import.</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.junit.*;</programlisting>
<simpara>Then, you need to set up a testing class just like you would any other
class. The key difference is that each method in the testing class is
designed to test some functionality of a code component. For example,
let&#8217;s imagine that we want to test certain functionality of the Java
<literal>Math</literal> library such as the <literal>ceil()</literal>, <literal>pow()</literal>, and <literal>sin()</literal> methods.</simpara>
<simpara>To do so, we create a class called <literal>MathTest</literal> with three methods inside
of it called <literal>ceil()</literal>, <literal>pow()</literal>, and <literal>sin()</literal>. We will use each method to
test the functionality of the three methods that, respectively, have the
same names. There is no requirement to name the methods any particular
way. Tests in JUnit do not have to test single method calls. They could
test any functional aspect of an object or class. Nevertheless, for
documentation reasons it is wise to give the test methods names that
reflect what is being tested.</simpara>
<simpara>So, where do annotations come in? The header for the <literal>ceil()</literal> method
would be as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void ceil()</programlisting>
<simpara>The only thing necessary to use a method in a JUnit test is to annotate
it with <literal>@Test</literal>. It is also necessary to make any function used for
testing <literal>public</literal> with a <literal>void</literal> return type and no parameters. Otherwise,
the JUnit framework will crash when you try to run the tests. Each
method with a <literal>@Test</literal> annotation is run once by JUnit, but JUnit cannot
supply any arguments to them. They should be self-contained tests
without any outside input.</simpara>
<simpara>The exception to this rule is that you can perform some set up for the
tests and then some clean up afterwards. Any method decorated with
<literal>@Before</literal> will be run before <emphasis role="strong">every</emphasis> test, and any method decorated with
<literal>@After</literal> will be run after <emphasis role="strong">every</emphasis> test. If you have some set up or
clean up that is expensive to run, you can use the annotations
<literal>@BeforeClass</literal> or <literal>@AfterClass</literal> to decorate a static method that is run
once before or after all the tests.</simpara>
<simpara>So far we have talked about the major aspects of writing a JUnit test
class except for the actual test. How does the JUnit test report a
success or a failure to the tester? As you would expect in Java, we use
the exception handling mechanism to indicate failures. If the test
method returns normally, the test is considered a success. If an
unhandled exception or error is thrown by the method, the test is
considered a failure. One of the most common ways of implementing this
is by using a form of assertions.</simpara>
<simpara>Of course, you could simply add an <literal>assert</literal> into the test code, then
enable assertions while running the test, but this approach means that
your tests could all incorrectly pass if you forget to enable
assertions. Instead, use the following import.</simpara>
<programlisting language="java" linenumbering="unnumbered">import static org.junit.Assert.*;</programlisting>
<simpara>With this static import, you will have access to many static methods
that provide useful assertion functionality. The simplest of these is
<literal>assertTrue()</literal>, which is essentially equivalent to an <literal>assert</literal> without
requiring assertions to be enabled. For example, we could code the body
of the <literal>ceil()</literal> test method as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void ceil() {
    assertTrue( 4 == Math.ceil(3.1) );
}</programlisting>
<simpara>Another useful method is <literal>assertEquals()</literal> (and its close cousin
<literal>assertArrayEquals()</literal>) which takes two parameters and throws an
<literal>AssertionError</literal> if the two are not equal. There are overloaded versions
of this method for <literal>long</literal> and <literal>Object</literal> types. Note that the preferred
<literal>assertEquals()</literal> method for the <literal>double</literal> type takes three parameters,
including an epsilon threshold in case the values don&#8217;t match exactly.</simpara>
<example>
<title>JUnit math testing</title>
<simpara>Using these methods, we can finally write a complete (though very
simple) implementation of <literal>MathTest.java</literal>.</simpara>
<formalpara xml:id="program:MathTest" xreflabel="MathTest">
<title>A simple testing suite.</title>
<para>
<programlisting language="java" linenumbering="numbered">import org.junit.*;
import static org.junit.Assert.*;

public class MathTest {
  private static double sqrt2;

  @BeforeClass
  public static void setUp() { sqrt2 = Math.sqrt(2);}

  @Test
  public void ceil() {
    assertTrue( 4 == Math.ceil(3.1) );
  }

  @Test
  public void pow() {
    assertEquals( 2, Math.pow( sqrt2, 2 ), 0.000001 );
  }

  @Test
  public void sin() {
    assertEquals( sqrt2/2.0, Math.sin(Math.PI / 4.0), 0.000001 );
  }
}</programlisting>
</para>
</formalpara>
<simpara>Note that the <literal>setUp()</literal> method is extremely trivial here, and no clean
up is needed. JUnit has many other powerful features that allow you to
run suites of tests or repeated tests with specific parameterized
values, but we are only going to introduce one more feature here. In an
ideal world, you are actually developing tests as you develop code.
Sometimes, in fact, you might have completed a test for a specific
feature before you have finished implementing it. Or, perhaps a feature
in your program is broken at the moment, but you want to continue
running tests on the rest of the features.</simpara>
</example>
<simpara>In these cases and others, it is useful to turn off a particular test
temporarily. To do this, you add the annotation <literal>@Ignore</literal> before the
<literal>@Test</literal> annotation. In parentheses after the <literal>@Ignore</literal> annotation, you
should ideally put in parentheses a <literal>String</literal> giving the reason why the
test is being ignored.</simpara>
</section>
<section xml:id="_running_junit">
<title>Running JUnit</title>
<simpara>Once you have created your JUnit test classes, you will want to run
them. There are tools built into IDE&#8217;s like Eclipse to make this easier,
but the command line is always an option. As we said before, you need to
include the JUnit jar file in your classpath. You can either do this
permanently, by adding it to a <literal>CLASSPATH</literal> environment variable in a way
dependent on your OS, or for a particular run of a Java tool. Assuming
that you haven&#8217;t added the jar file to your classpath permanently, let&#8217;s
say that you are using JUnit 4.5 from a jar file called <literal>junit-4.5.jar</literal>
that can be found in <literal>C:\Utilities\Java\JUnit\</literal>. To compile <literal>MathTest</literal>,
you would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">javac -classpath .;C:\Utilities\Java\JUnit\junit-4.5.jar MathTest.java}</programlisting>
<simpara>To actually run the code, you still need to include <literal>junit-4.5.jar</literal> in
your classpath, but you also need to invoke the test runner called
<literal>org.junit.runner.JUnitCore</literal> as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">java -classpath .;C:\Utilities\Java\JUnit\junit-4.5.jar
    org.junit.runner.JUnitCore MathTest</programlisting>
<simpara>If you had multiple test classes, you could just list them all after
<literal>org.junit.runner.JUnitCore</literal> and all the methods marked <literal>@Test</literal> in them
would be run. Note that methods without an <literal>@Test</literal> decoration will not
be run as tests, but there is no rule against having them. In this way,
you can use un-decorated methods as helper methods for your test
methods.</simpara>
<simpara>When you run JUnit tests, you should see the version number of JUnit
used, a dot printed out for each test, the amount of time taken, and
then something like <literal>OK (3 tests)</literal> if all of your tests ran without an
error. If there is an error, it will list each error, probably with a
long stack trace showing the propagation of the exception.</simpara>
</section>
</section>
</section>
<section xml:id="_concurrency_testing_tools">
<title>Concurrency: Testing tools</title>
<simpara>In this section, we describe some tools that exist specifically to help
you catch those bugs that are present as a direct result of concurrency.
You have probably noticed that this section is quite short, and that
shortness reflects the shortage of good tools available. The design of
concurrent debugging and testing tools is still an open research topic.
As always, the nondeterminism of concurrency makes bugs difficult to pin
down. You could run a JUnit test 1,000,000 times and never see a
peculiar race condition bug. From a brute force perspective, we could
try to test all possible interleavings of thread execution, but this
approach is not practical for large programs because the number of
interleavings grows exponentially. Nevertheless, some research has
focused on attacking the problem from this direction.</simpara>
<section xml:id="_contest">
<title>ConTest</title>
<simpara>One tool that uses this idea is ConTest from IBM. The way the JVM
normally works makes some interleavings more likely than others. If the
correct output is very likely and the incorrect is very unlikely, it is
easy for you to believe that your program works correctly. ConTest is a
tool that <emphasis>instruments</emphasis> class files after they have been compiled by
Java. When it instruments these files, it adds extra method calls into
concurrent code designed to introduce some randomness into the system.
By introducing <literal>sleep()</literal> and <literal>yield()</literal> methods in random places, the JVM
can be forced into producing interleavings that would otherwise be
unusual. The designers of ConTest have used heuristics so that ConTest
adds this randomness in &#8220;smart&#8221; locations designed to maximize unusual
interleavings and catch bugs.</simpara>
<simpara>ConTest is not a panacea. Although it can reveal bugs that are very
rare, it still must be combined with strong testing methodologies so
that those bugs can be caught when they appear. Another difficulty with
using ConTest is that it cannot tell you where the problem happened or
when it is likely to happen under normal circumstances. You are still
dependent on your test design to reveal the source of the problem.
Finally, ConTest cannot guarantee every possible ordering. Very rare
bugs may not manifest even after thousands of runs with ConTest
instrumented code. For more information about ConTest, visit
<literal><link xl:href="http://www.ibm.com/developerworks/java/library/j-contest.html">http://www.ibm.com/developerworks/java/library/j-contest.html</link></literal>.</simpara>
</section>
<section xml:id="_concutest">
<title>Concutest</title>
<simpara>We hope we have convinced you of the value of using JUnit testing to
unit test your programs. Of course, JUnit has several limitations when
it comes to concurrent programs. JUnit uses exceptions to report failed
test cases. Unfortunately, JUnit only reports exceptions from the main
thread, not from any child threads that may be spawned. ConcJUnit allows
exceptions thrown by child threads to be reported and also forces all
child threads to join with the main thread.</simpara>
<simpara>In this way, it will be clear if any errors happened while a child
thread was being executed, either causing an exception to be thrown or
causing a child thread to fail to rejoin the main thread.</simpara>
<simpara>ConcJUnit is part of a larger suite of tools called <emphasis role="strong">Concutest</emphasis>
maintained at<?asciidoc-br?>
<link xl:href="http://www.cs.rice.edu/~mgricken/research/concutest/">http://www.cs.rice.edu/~mgricken/research/concutest/</link>. Concutest includes
Thread Checker, a tool that allows programmers to use annotations to
test thread invariants. The Concutest project is also developing a
Schedule-Based Execution environment to allow programmers to test
programs using specific sets of concurrent interleavings.</simpara>
</section>
<section xml:id="_intel_tools">
<title>Intel tools</title>
<simpara>There are many other industry tools for debugging and optimizing
threaded programs. Intel produces software such as the Intel Thread
Checker to find concurrent errors as well as the Intel Vtune Performance
Analyzer and Intel Thread Profiler to help tune threaded programs. These
products from Intel, like many concurrency tools, are focused on C/C++
and Fortran platforms. Historically, concurrency has been centered in
the high performance and scientific computing markets. Java, in
contrast, has been perceived as a slow language, more suited for desktop
applications. As the role of concurrency continues to evolve, so will
the tools to help programmers.</simpara>
</section>
</section>
<section xml:id="_examples_testing_a_class">
<title>Examples: Testing a class</title>
<simpara>The larger the system, the more critical testing becomes. We do not have
the space to give or explain a complex testing example, but we can give
you another example of JUnit testing.</simpara>
<example>
<title>A broken class</title>
<simpara>We are going to rely on an example from physics and create a
<literal>PointCharge</literal> class that has a certain charge and a specific location in
3D space. We are also going to introduce some errors into the class.
Because the class is so simple, the errors should be obvious.
Nevertheless, we have picked errors that are reasonable to make.</simpara>
<formalpara xml:id="program:PointCharge" xreflabel="PointCharge">
<title>Example physics class with errors.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class PointCharge {
	private double charge;  // C
	private double x;       // m
	private double y;       // m
	private double z;       // m
	public static final double K = 8.9875517873681764e9; //N m^2 C^-2

	public PointCharge( double charge, double x, double y, double z ) {
		this.charge = charge;
		this.x = x;
		this.y = y;
		this.z = y;
	}

	public double getCharge() { return charge; }

	public double distance( PointCharge p ) {
		return distance( p.x, p.y, p.z );
	}

	private double distance( double x, double y, double z ) {
		double deltaX = this.x - x;
		double deltaY = this.y - y;
		double deltaZ = this.z - z;
		return Math.sqrt( deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ );
	}

	public double scalarForce( PointCharge p ) {
		double r = distance( p );
		return K*charge*p.charge/r*r;
	}

	public double fieldMagnitude( double x, double y, double z ) {
		double r = distance( x, y, z );
		return charge/(r*r);
	}
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>PointCharge</literal> class has the expected constructor and then a method
to determine distance to another <literal>PointCharge</literal>. This method in turn
relies on a private helper method that can compute distance to an
arbitrary <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>, and <inlineequation><alt><![CDATA[z]]></alt><mathphrase><![CDATA[z]]></mathphrase></inlineequation>
location. Finally, the &#8220;important&#8221; work done by the class are in
determining the scalar force between two charges and the magnitude of
the electric field due to the charge at some location. Recall from
physics that the force <inlineequation><alt><![CDATA[F]]></alt><mathphrase><![CDATA[F]]></mathphrase></inlineequation> between two charges
<inlineequation><alt><![CDATA[q_1]]></alt><mathphrase><![CDATA[q_1]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[q_2]]></alt><mathphrase><![CDATA[q_2]]></mathphrase></inlineequation> is
<inlineequation><alt><![CDATA[k_\mathrm{e} \frac{q_1q_2}{r^2}]]></alt><mathphrase><![CDATA[k_\mathrm{e} \frac{q_1q_2}{r^2}]]></mathphrase></inlineequation> where
<inlineequation><alt><![CDATA[k_\mathrm{e}]]></alt><mathphrase><![CDATA[k_\mathrm{e}]]></mathphrase></inlineequation> is the proportionality constant
<inlineequation><alt><![CDATA[8.9875517873681764 \times 10^9 \ \mathrm{N  \cdot m^2 \cdot C^{-2}}]]></alt><mathphrase><![CDATA[8.9875517873681764 \times 10^9 \ \mathrm{N  \cdot m^2 \cdot C^{-2}}]]></mathphrase></inlineequation>
and <inlineequation><alt><![CDATA[r]]></alt><mathphrase><![CDATA[r]]></mathphrase></inlineequation> is the distance between the charges. Likewise the
electric field <inlineequation><alt><![CDATA[E]]></alt><mathphrase><![CDATA[E]]></mathphrase></inlineequation> at a given location due to a charge
<inlineequation><alt><![CDATA[q]]></alt><mathphrase><![CDATA[q]]></mathphrase></inlineequation> is <inlineequation><alt><![CDATA[k_\mathrm{e} \frac{q}{r^2}]]></alt><mathphrase><![CDATA[k_\mathrm{e} \frac{q}{r^2}]]></mathphrase></inlineequation>.</simpara>
</example>
<example>
<title>Testing the distance methods</title>
<simpara>Let&#8217;s come up with a test for the <literal>distance()</literal> methods first. We&#8217;re
going to need some other `PointCharge`s. Let&#8217;s make 4 altogether: one at
the origin and three one meter along each positive axis. We can create
these charges in a set up method. While we&#8217;re at it, we&#8217;ll give them a
variety of positive and negative charges.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Before
public void setUp() {
    charge1 = new PointCharge( 1, 0, 0, 0 );
    charge2 = new PointCharge( 2, 1, 0, 0 );
    charge3 = new PointCharge( -1, 0, 1, 0 );
    charge4 = new PointCharge( 0, 0, 0, 1 );
}</programlisting>
<simpara>To test the <literal>distance()</literal> method thoroughly, we will check the distance
from <literal>charge1</literal> to all the other charges as well as <literal>charge2</literal> to
<literal>charge3</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void distance() {
    assertEquals( 1.0, charge1.distance(charge2), 0.001 );
    assertEquals( 1.0, charge1.distance(charge3), 0.001 );
    assertEquals( 1.0, charge1.distance(charge4), 0.001 );
    assertEquals( Math.sqrt(2.0), charge2.distance(charge3), 0.001 );
}</programlisting>
<simpara>The distances between <literal>charge1</literal> and the other three should be 1, and the
distance between <literal>charge2</literal> and <literal>charge3</literal> should be about
<inlineequation><alt><![CDATA[\sqrt{2}]]></alt><mathphrase><![CDATA[\sqrt{2}]]></mathphrase></inlineequation>. Yet, when we run this test with JUnit, the test
fails. We get:</simpara>
<programlisting language="java" linenumbering="unnumbered">java.lang.AssertionError: expected:&lt;1.0&gt; but was:&lt;1.4142135623730951&gt;</programlisting>
<simpara>for the second assertion in the method. But why? If we comb through the
<literal>distance()</literal> methods in <literal>PointCharge</literal>, they all look correct. The
problem must be deeper. <literal>PointCharge</literal> does not have accessor methods for
its location, and so we can&#8217;t test those. Checking the constructor, we
find the culprit: <literal>this.z = y;</literal>, a simple cut and paste error.</simpara>
<simpara>With the <literal>distance()</literal> methods working, we can test other things. We are
going to run a similar test for <literal>scalarForce()</literal> generated by plugging in
appropriate values into the equation for <inlineequation><alt><![CDATA[F]]></alt><mathphrase><![CDATA[F]]></mathphrase></inlineequation>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void scalarForce() {
    assertEquals( 2*PointCharge.K, charge1.scalarForce(charge2), 0.001 );
    assertEquals( -PointCharge.K, charge1.scalarForce(charge3), 0.001 );
    assertEquals( 0.0, charge1.scalarForce(charge4), 0.000001 );
    assertEquals( -PointCharge.K, charge2.scalarForce(charge3), 0.001 );
}</programlisting>
<simpara>When we run this test with JUnit, the last assertion fails. We get the
following output.</simpara>
<programlisting language="java" linenumbering="unnumbered">java.lang.AssertionError: expected:&lt;-8.987551787368176E9&gt;
    but was:&lt;-1.797510357473635E10&gt;</programlisting>
<simpara>A close inspection reveals that the actual value is about twice the
expected value. Where does this extra factor of 2 come from? Scanning
the code for <literal>scalarForce()</literal>, we find <literal>return K*charge*p.charge/r*r;</literal></simpara>
<simpara>We forgot parentheses and messed up our equation. What we really wanted
was <literal>return K*charge*p.charge/(r*r);</literal></simpara>
<simpara>The most striking thing about this example is that three test cases
passed! Perhaps that means that we were choosing values that were too
simple, but it also illustrates the importance of serious testing.</simpara>
</example>
<example>
<title>Testing the field magnitude method</title>
<simpara>Finally, let&#8217;s test the value of the <literal>fieldMagnitude()</literal> method. For
simplicity, we&#8217;ll test the field at the locations of <literal>charge1</literal>,
<literal>charge3</literal>, and <literal>charge4</literal> with respect to <literal>charge2</literal>.</simpara>
<simpara>This time the first assertion fails. We get the following output.</simpara>
<programlisting language="java" linenumbering="unnumbered">java.lang.AssertionError: expected:&lt;1.797510357473635E10&gt; but was:&lt;2.0&gt;</programlisting>
<simpara><literal>2.0</literal> seems like a very strange result when we were expecting a value
with an order of magnitude 10 times larger. Perhaps the constant was
omitted? Yes, our version of <literal>fieldMagnitude()</literal> left off a factor of
<literal>K</literal>. Once we fix that, our code finally produces the <literal>OK (3 tests)</literal> we
have been waiting to see from JUnit. Why didn&#8217;t we fail the assertions
after the first one? Because of the exception handling mechanism, each
JUnit test method stops once a failure has happened.</simpara>
</example>
<simpara>Here is the fully corrected version of <literal>PointCharge</literal> renamed
<literal>FixedPointCharge</literal>.</simpara>
<formalpara xml:id="program:FixedPointCharge" xreflabel="FixedPointCharge">
<title>Corrected version of <literal>PointCharge</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class FixedPointCharge {
  private double charge;  // C
  private double x;       // m
  private double y;       // m
  private double z;       // m
  public static final double K = 8.9875517873681764e9; //N m^2 C^-2

  public FixedPointCharge( double charge, double x, double y, double z ) {
    this.charge = charge;
    this.x = x;
    this.y = y;
    this.z = z;
  }

  public double getCharge() { return charge; }

  public double distance( FixedPointCharge p ) {
    return distance( p.x, p.y, p.z );
  }

  private double distance( double x, double y, double z ) {
    double deltaX = this.x - x;
    double deltaY = this.y - y;
    double deltaZ = this.z - z;
    return Math.sqrt( deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ );
  }

  public double scalarForce( PointCharge p ) {
    double r = distance( p );
    return K*charge*p.charge/(r*r);
  }

  public double fieldMagnitude( double x, double y, double z ) {
    double r = distance( x, y, z );
    return K*charge/(r*r);
  }
}</programlisting>
</para>
</formalpara>
<simpara>And, for easy readability, here is the full JUnit test class
<literal>TestPointCharge</literal>. Note that you will have to change the name
<literal>PointCharge</literal> to <literal>FixedPointCharge</literal> if you want to test the corrected
class.</simpara>
<formalpara xml:id="program:TestPointCharge" xreflabel="TestPointCharge">
<title>Class for testing <literal>PointCharge</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import org.junit.*;
import static org.junit.Assert.*;

public class TestPointCharge {
  private PointCharge charge1;
  private PointCharge charge2;
  private PointCharge charge3;
  private PointCharge charge4;

  @Before
  public void setUp() {
    charge1 = new PointCharge( 1, 0, 0, 0 );
    charge2 = new PointCharge( 2, 1, 0, 0 );
    charge3 = new PointCharge( -1, 0, 1, 0 );
    charge4 = new PointCharge( 0, 0, 0, 1 );
  }

  @Test
  public void distance() {
    assertEquals( 1.0, charge1.distance(charge2), 0.001 );
    assertEquals( 1.0, charge1.distance(charge3), 0.001 );
    assertEquals( 1.0, charge1.distance(charge4), 0.001 );
    assertEquals( Math.sqrt(2.0), charge2.distance(charge3), 0.001 );
  }

  @Test
  public void scalarForce() {
    assertEquals( 2*PointCharge.K, charge1.scalarForce(charge2), 0.001 );
    assertEquals( -PointCharge.K, charge1.scalarForce(charge3), 0.001 );
    assertEquals( 0.0, charge1.scalarForce(charge4), 0.001 );
    assertEquals( (double)-PointCharge.K, (double)charge2.scalarForce(charge3), 0.001 );
  }

  @Test
  public void fieldMagnitude() {
    assertEquals( 2*PointCharge.K, charge2.fieldMagnitude(0, 0, 0), 0.001 );
    assertEquals( PointCharge.K, charge2.fieldMagnitude(0, 1, 0), 0.001 );
    assertEquals( PointCharge.K, charge2.fieldMagnitude(0, 0, 1), 0.001 );
  }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_exercises_15">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>What is the purpose of the <literal>assert</literal> keyword in Java? What steps must
be taken for it to be active?</simpara>
</listitem>
<listitem>
<simpara>What is the value of <literal>j</literal> after the following statements are
executed?</simpara>
<programlisting language="java" linenumbering="unnumbered">int j = 1;
int i;
for( i = 0; i &lt; 10; i++ );
    j += i;</programlisting>
<simpara>Assuming the programmer made an error, what category of programming
error does it fall under?</simpara>
</listitem>
<listitem>
<simpara>The following loop is intended to print out all possible <literal>byte</literal>
values. What is the conceptual error made in the following loop? How
many times will it execute?</simpara>
<programlisting language="java" linenumbering="unnumbered">for( byte value = 0; value &lt; 256; ++value )
    System.out.println("Byte: " + value);</programlisting>
</listitem>
<listitem>
<simpara>What are all the possible run-time errors that could occur in this
method that reverses a section of an array?</simpara>
<programlisting language="java" linenumbering="unnumbered">public void reverse( Object[] array, int start, int end ) {
    Object temp;
    end--;  //up to but not including end
    while( start &lt; end ) {
        temp = array[start];
        array[start] = array[end];
        array[end] = temp;
        start++;
        end--;
    }
}</programlisting>
<simpara>What checks could be added to catch these errors?</simpara>
</listitem>
<listitem>
<simpara>Consider the following definition of a stack that holds <literal>int</literal>
values.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class IntegerStack {
    private static Node {
        public int data;
        public Node next;
    }

    private Node head = null;

    public void push( int value ) {
        Node temp = new Node();
        temp.data = value;
        temp.next = head;
        head = temp;
    }

    public void pop() { head = head.next; }
    public int top() { return head.data; }
    public boolean empty() { return head == null; }
}</programlisting>
<simpara>What exceptions could be thrown when using this class? Where could they
be thrown?</simpara>
</listitem>
<listitem>
<simpara>This question sometimes comes up in job interviews. Imagine that you
have a simple singly linked list such as the one described in
ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>. What if there is a loop in
the list such that the last element in the list points to an earlier
element in the list? For this reason, a simple traversal of the list
will go on forever. How could you detect such a problem during program
execution?</simpara>
</listitem>
<listitem>
<simpara>What is the difference between black box testing and white box
testing? What kinds of bugs are more likely to be caught by black box
testing? By white box testing?</simpara>
</listitem>
<listitem>
<simpara>The Microsoft Zune is a portable media player in competition with
the Apple iPod. The first generation ZuneÂ 30 received negative publicity
because many of them froze on December 31, 2008 due to a leap year bug.
It is possible to find segments of the source code that caused this
problem on the Internet. Essentially, the clock code for the Zune
behaved correctly on any day of the year numbered 365 or lower.
Likewise, when the day was greater than 366, it would correctly move to
the next year and reset the day counter. When day was exactly 366,
however, the Zune became stuck in an infinite loop. What kind of testing
should Microsoft have done to prevent this bug?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Apply JUnit testing to the last major assignment you did in class.
What bugs did you uncover?</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>James Gosling&#8217;s original specification for Java contained
assertions, but they were not included until Java 1.4. One of the
concerns about an assertion mechanism is the additional time required to
process the assertions. Time a program of at least moderate length
before adding <literal>assert</literal> statements to its methods. If you use <literal>assert</literal>
statements to check method input and output thoroughly, you should see a
slight decrease in performance when assertions are enabled. When
disabled, you should see almost none. How great is the performance hit?</simpara>
</listitem>
<listitem>
<simpara>Take another look at your last programming assignment. Calculate the
number of branches based on <literal>if</literal> and <literal>switch</literal> statements and compute 2
raised to that power. Time your program executing once under normal
circumstances. Multiply that time by the number of different
possibilities you would need to exercise every possible combination of
branches in your program. How long would it take?</simpara>
</listitem>
<listitem>
<simpara>Take a concurrent program you have written that relies on explicit
synchronization mechanisms for correctness. Remove all synchronization
tools and run the code many times, testing for race conditions. Then,
instrument the code with ConTest and run it many more times. Do you see
increased variety in output with ConTest? Was it easier to find race
conditions?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Polymorphism">
<title>Polymorphism</title>
<blockquote>
<attribution>
Neutral Milk Hotel
</attribution>
<simpara>&#8230;&#8203;how strange it is to be anything at all.</simpara>
</blockquote>
<section xml:id="_problem_banking_account_with_a_vengeance">
<title>Problem: Banking account with a vengeance</title>
<simpara>In Chapter <xref linkend="chapter:Synchronization"/>, we introduced the
<literal>SynchronizedAccount</literal> class that guarantees that checking the balance,
making deposits, and making withdrawals will all be safe even in a
multi-threaded environment. Unfortunately, <literal>SynchronizedAccount</literal> gives
very few of the options a full bank account should have. The problem we
present to you now is to create an entire line of bank accounts which
all inherit from <literal>SynchronizedAccount</literal>. Because of inheritance, all
accounts will at least have <literal>getBalance()</literal>, <literal>deposit()</literal>, and
<literal>withdraw()</literal> methods.</simpara>
<simpara>You must create three new account classes. The constructor for each
class must take a <literal>String</literal> which gives the name of the person opening
the account and <literal>double</literal> which gives the starting balance of the
account. The first of these classes is <literal>CheckingAccount</literal>. The rules for
the checking account implemented by this class are simply that the
customer is charged $10 every month that the account is open. The second
class is <literal>DirectDepositAccount</literal>. This account is very similar to the
basic checking account except that an additional method
<literal>directDeposit()</literal> has been added. On its own, <literal>directDeposit()</literal> appears
to operate like <literal>deposit()</literal>; however, if a direct deposit has been made
in the last month, no service fee will be charged to the account.</simpara>
<simpara>The <literal>SavingsAccount</literal> class operates somewhat differently. In addition to
a name and a starting balance, the constructor for a <literal>SavingsAccount</literal>
takes a <literal>double</literal> which gives the annual interest rate the account earns.
Each month the balance is checked. If the balance of the account is
greater than $0, the account earns interest corresponding to
<inlineequation><alt><![CDATA[\frac{1}{12}]]></alt><mathphrase><![CDATA[\frac{1}{12}]]></mathphrase></inlineequation> of the annual rate. However, if the balance
is below $1000, a $25 service fee is charged each month, regardless of
how low the balance becomes.</simpara>
<simpara>In ChapterÂ <xref linkend="chapter:Inheritance"/> you were exposed to concepts in
inheritance. We are now returning to these concepts and exploring them
further. In the first place, concurrency is on the table now, and you
must be careful to keep your derived classes thread-safe. In the second,
we will discuss the full breadth of inheritance. The tools we discuss
are intended to allow you to solve this extended bank account problem
and indeed many other problems with as little code as possible.</simpara>
</section>
<section xml:id="_concepts_polymorphism">
<title>Concepts: Polymorphism</title>
<simpara>Perhaps the most important use for inheritance is code reuse. When you
can successfully reuse existing code, you are not just saving the time
of writing new code: You are also leveraging the quality and correctness
of the existing code. For example, when you create your own class which
extends <literal>Thread</literal>, you are confident that all the thread mechanisms work
properly.</simpara>
<simpara>You can reuse code by taking a class that does something you like, say
the <literal>Racecar</literal> class, and enhance it in some way, perhaps so that it
becomes the <literal>TurboRacecar</literal> class. If you use the <literal>TurboRacecar</literal> class on
its own, your code reuse is through simple inheritance. If you use
<literal>TurboRacecar</literal> objects with a <literal>RaceTrack</literal> class, which was written to
take <literal>Racecar</literal> objects as input, you have entered the realm of
<emphasis>polymorphism</emphasis>. Polymorphism means that the same method can be used on
different types of objects without being rewritten. In Java,
polymorphism works by allowing the programmer to use a derived class in
any place where a base class could have been used.</simpara>
<section xml:id="_the_is_a_relationship">
<title>The is-a relationship</title>
<simpara>Consider the two following class definitions:</simpara>
<programlisting xml:id="program:Racecar" xreflabel="Racecar" language="java" linenumbering="numbered">public class Racecar {
	public double getTopSpeed() { return 200.0; }
	public int getHorsepower() { return 700; }
	public double speed = 0;
}</programlisting>
<programlisting xml:id="program:TurboRacecar" xreflabel="TurboRacecar" language="java" linenumbering="numbered">public class TurboRacecar extends Racecar {
	public int getHorsepower() { return 1100; }
}</programlisting>
<simpara>Now, imagine that a <literal>RaceTrack</literal> has an <literal>addCar(Racecar car)</literal> method
which adds a <literal>Racecar</literal> to the list of cars on the track. When the cars
begin racing, the <literal>RaceTrack</literal> object will query the cars to see how much
horsepower they have. A <literal>Racecar</literal> object will return 700 when
<literal>getHorsepower()</literal> is called, but a <literal>TurboRacecar</literal> will return 1100.</simpara>
<simpara>Even through the <literal>TurboRacecar</literal> does not have an explicit
<literal>getTopSpeed()</literal> method, it inherits one from <literal>Racecar</literal>. Like all derived
classes in Java, <literal>TurboRacecar</literal> has all the methods and fields that
<literal>Racecar</literal> does. This relationship is called an <emphasis>is-a</emphasis> relationship
because every <literal>TurboRacecar</literal> is a <literal>Racecar</literal> in the sense that you can
use a <literal>TurboRacecar</literal> whenever a <literal>Racecar</literal> is required.</simpara>
</section>
<section xml:id="_dynamic_binding">
<title>Dynamic binding</title>
<simpara>There is a little bit of magic that makes polymorphism work. When you
compile your code, the <literal>RaceTrack</literal> doesn&#8217;t know which <literal>getHorsePower()</literal>
method will eventually get called. Only at run time does it query the
object in question and, if it is a <literal>TurboRacecar</literal>, use the overridden
method that returns 1100. This feature of Java is called <emphasis>dynamic
binding</emphasis>. Not every object oriented programming language supports
dynamic binding. C++ actually allows the programmer to specify whether
or not a method is dynamically bound.</simpara>
<simpara>Only methods are dynamically bound in Java. Fields are <emphasis>statically
bound</emphasis>. Consider the following re-definitions of <literal>Racecar</literal> and
<literal>TurboRacecar</literal>.</simpara>
<programlisting xml:id="program:StaticRacecar" xreflabel="StaticRacecar" language="java" linenumbering="numbered">public class StaticRacecar {
	public static final double TOP_SPEED = 200.0;
	public static final int HORSEPOWER = 700;
	public double speed = 0;
}</programlisting>
<programlisting xml:id="program:StaticTurboRacecar" xreflabel="StaticTurboRacecar" language="java" linenumbering="numbered">public class StaticTurboRacecar extends StaticRacecar {
	public static final int HORSEPOWER = 1100;
}</programlisting>
<simpara>Assume that <literal>RaceTrack</literal> contains a method which prints out the
horsepower of a <literal>StaticRacecar</literal> like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">public void printHorsepower( StaticRacecar car ) {
    System.out.print( car.HORSEPOWER );
}</programlisting>
<simpara>Even if you pass an object of type <literal>StaticTurboRacecar</literal>, the value 700
will be printed out every time. In Java, all fields, whether normal,
<literal>static</literal>, or <literal>final</literal> are statically bound.</simpara>
</section>
<section xml:id="_general_vs_specific">
<title>General vs. specific</title>
<simpara>Another way to look at inheritance is as a statement of a specialization
and generalization. A <literal>TurboRacecar</literal> is a specific kind of <literal>Racecar</literal>
while a <literal>Racecar</literal> is a general category that <literal>TurboRacecar</literal> belongs to.</simpara>
<simpara>The rules of Java say that you can always use a more specific version of
a class than you need but never a more general one. You can use a
<literal>TurboRacecar</literal> any time you need a <literal>Racecar</literal> but not the reverse. A
square will do the job of a rectangle, but a rectangle will not always
be suitable when a square is needed.</simpara>
<simpara>Consider the following two classes:</simpara>
<programlisting xml:id="program:Vehicle" xreflabel="Vehicle" language="java" linenumbering="numbered">public class Vehicle {
	public void travel( String destination ) {
		System.out.println("Traveling to " + destination + "!");
	}
}</programlisting>
<programlisting xml:id="program:RocketShip" xreflabel="RocketShip" language="java" linenumbering="numbered">public class RocketShip extends Vehicle {
	public void blastOff() {
		System.out.println("FOOOOM!");
	}
}</programlisting>
<simpara>Here is a method that requires a <literal>RocketShip</literal> but only uses its
<literal>travel()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void takeVacation( RocketShip ship, String destination ) {
    ship.travel( destination );
}</programlisting>
<simpara>It seems as though we should be able to pass any <literal>Vehicle</literal> to the
<literal>takeVacation()</literal> method because the only method in <literal>ship</literal> used by
<literal>takeVacation()</literal> is the <literal>travel()</literal> method. However, the programmer
specified that the parameter should be a <literal>RocketShip</literal>, and Java plays it
safe. Just because it looks like there won&#8217;t be a problem, Java isn&#8217;t
going to take any chances on passing an overly general <literal>Vehicle</literal> when a
<literal>RocketShip</literal> is required. If Java took chances, a problem could arise if
the <literal>takeVacation()</literal> method was overridden by a method that did call
<literal>ship.blastOff()</literal>.</simpara>
<simpara>In summary, you can pass a <literal>RocketShip</literal> to a method which takes a
<literal>Vehicle</literal> or store a <literal>RocketShip</literal> in an array of <literal>Vehicles</literal>, but not the
reverse. Java usually gives a compile time error if you try to put
something too general into a location that is too specific. There are,
however, some situations which are so tricky that Java doesn&#8217;t catch the
error until runtime. Arrays, specifically, can cause problems. Examine
the following code snippet:</simpara>
<programlisting language="java" linenumbering="unnumbered">Vehicle[] transportation = new RocketShip[100];
transportation[0] = new Vehicle();</programlisting>
<simpara>On the first line, we are using a <literal>Vehicle</literal> array reference to store an
array of 100 <literal>RocketShip`s. But, in the second line, we try to store a
`Vehicle</literal> into an array that is really a <literal>RocketShip</literal> array, even though
it looks to the compiler like a <literal>Vehicle</literal> array. Doing so will compile
but throw an <literal>ArrayStoreException</literal> at runtime.</simpara>
</section>
</section>
<section xml:id="_syntax_inheritance_tools_in_java">
<title>Syntax: Inheritance tools in Java</title>
<simpara>So far, we have described polymorphism in Java with a conceptual focus.
In our previous examples, the only language tool needed to use
polymorphism was the <literal>extends</literal> keyword which you are well familiar with
by now. There are a number of other tools designed to help you structure
class hierarchies and enforce design decisions.</simpara>
<section xml:id="_abstract_classes_and_methods">
<title>Abstract classes and methods</title>
<simpara>One such tool is abstract classes. An abstract class is one which can
never be instantiated. In order to use an abstract class, it is
necessary to derive a class from it. To create an abstract class, you
just need to add the <literal>abstract</literal> keyword to its definition, as in the
following example.</simpara>
<programlisting xml:id="program:Useless" xreflabel="Useless" language="java" linenumbering="numbered">public abstract class Useless {
	protected int variable;

	public Useless( int input ) {
		variable = input;
	}

	public void print() {
		System.out.println( variable );
	}
}</programlisting>
<simpara>This class is useless for a number of reasons. For one thing, there&#8217;s no
way to find out the value of <literal>variable</literal> except by printing it out.
Furthermore, there&#8217;s no way to change the value of <literal>variable</literal> after the
object has been created. Finally, since an abstract class cannot be
instantiated, the following code snippet will not compile.</simpara>
<programlisting language="java" linenumbering="unnumbered">Useless thing = new Useless( 14 );</programlisting>
<simpara>Instead, we must create a new class that extends <literal>Useless</literal>.</simpara>
<programlisting xml:id="program:Useful" xreflabel="Useful" language="java" linenumbering="numbered">public class Useful extends Useless {
	public int getVariable() { return variable; }

	public void setVariable( int value ) {
		variable = value;
	}
}</programlisting>
<simpara>Then, we can instantiate an object of type <literal>Useful</literal> and use it for
something.</simpara>
<programlisting language="java" linenumbering="unnumbered">Useless item = new Useful( 14 );
item.print();</programlisting>
<simpara>Note that, in accordance with the rules of Java, we can store a more
specific object of type <literal>Useful</literal> into more general reference of type
<literal>Useless</literal>. Even though Java knows that the object it points to will
never actually be a <literal>Useless</literal> object, it is perfectly legal to have a
<literal>Useless</literal> reference. You can use abstract classes in this way to provide
a base class with some fundamental fields and methods that all other
classes in a particular hierarchy need. By using the keyword <literal>abstract</literal>,
you are marking the class as template for other classes instead of a
class that will be used directly.</simpara>
<simpara>Methods can be abstract as well. If you have an abstract class, you can
create a method header which describes a method that all non-abstract
children classes must implement, as show below.</simpara>
<programlisting xml:id="program:Sequence" xreflabel="Sequence" language="java" linenumbering="numbered">public abstract class Sequence {
	protected int number;
	protected final int CONSTANT;

	public Sequence( int number, int constant ) {
		this.number = number;
		CONSTANT = constant;
	}

	public abstract int getNextValue();
}</programlisting>
<simpara>This abstract class is supposed to be a template for classes which can
produce some sequence of numbers. Note that there is no body for the
<literal>getNextValue()</literal> method. It simply ends with a semicolon. Every
non-abstract derived class must implement a <literal>getNextValue()</literal> method to
produce the next number in the sequence. For example, we could implement
an arithmetic or a geometric sequence as follows.</simpara>
<programlisting xml:id="program:ArithmeticSequence" xreflabel="ArithmeticSequence" language="java" linenumbering="numbered">public class ArithmeticSequence extends Sequence {
	public abstract int getNextValue() {
		number += CONSTANT;
		return number;
	}
}</programlisting>
<programlisting xml:id="program:GeometricSequence" xreflabel="GeometricSequence" language="java" linenumbering="numbered">public class GeometricSequence extends Sequence {
	public abstract int getNextValue() {
		number *= CONSTANT;
		return number;
	}
}</programlisting>
<simpara>The <literal>Sequence</literal> class does not specify <emphasis role="strong">how</emphasis> the sequence of numbers
should be generated, but any derived class must implement the
<literal>getNextValue()</literal> method in order to compile. By using an abstract class,
we don&#8217;t have to create a base class which generates a meaningless
sequence of numbers just for the sake of establishing the
<literal>getNextValue()</literal> method.</simpara>
<simpara>Here&#8217;s a more involved example of an abstract class that gives a first
step toward solving the bank account with a vengeance problem posed at
the beginning of the chapter.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.Calendar;</programlisting>
<simpara>The first step is to import the <literal>Calendar</literal> class for some date stuff we
are going to use later.</simpara>
<programlisting language="java" linenumbering="numbered">public abstract class BankAccount extends SynchronizedAccount {
	private String name;
	private Calendar lastAccess;
	private int monthsPassed = 0;</programlisting>
<simpara>We extend <literal>SynchronizedAccount</literal> and declare the new class to be
abstract. In this example, we do not use any abstract methods, but,
since each bank account has unique characteristics, we don&#8217;t want people
to be able to create a generic <literal>BankAccount</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">	public BankAccount( String name, double balance )
		throws InterruptedException {
		this.name = name;
		changeBalance( balance );
		lastAccess = Calendar.getInstance();
	}

	public String getName() { return name; }

	protected Calendar getLastAccess() { return lastAccess; }

	protected int getMonthsPassed() { return monthsPassed; }</programlisting>
<simpara>The constructor and the accessors should be what you expect to see. Note
that calling the static method <literal>Calendar.getInstance()</literal> is the correct
way to get a <literal>Calendar</literal> object with the current date and time.</simpara>
<programlisting language="java" linenumbering="numbered">	public final double getBalance() throws InterruptedException {
		update();
		return super.getBalance();
	}

	public final void deposit( double amount )
		throws InterruptedException {
		update();
		super.deposit( amount );
	}

	public final boolean withdraw( double amount )
		throws InterruptedException {
		update();
		return super.withdraw(amount);
	}</programlisting>
<simpara>Then come the balance checking and changing methods. Each simply calls
the parent methods after calling an <literal>update()</literal> method we discuss below.</simpara>
<programlisting language="java" linenumbering="numbered">	protected synchronized void update() throws InterruptedException {
		Calendar current = Calendar.getInstance();
		int months = 12*(current.get(Calendar.YEAR) -
		getLastAccess().get(Calendar.YEAR)) +
		(current.get(Calendar.MONTH) -
		getLastAccess().get(Calendar.MONTH));
		if( months &gt; 0 ) {
				lastAccess = current;
				monthsPassed = months;
		}
	}
}</programlisting>
<simpara>Other than adding <literal>String</literal> for a name associated with the account, the
<literal>update()</literal> method is the other major addition made in <literal>BankAccount</literal>.
Each time <literal>update()</literal> is called, the number of months since the last
access is stored in the field <literal>monthsPast</literal> and the timestamp of the last
access is stored in <literal>lastAccess</literal>. We didn&#8217;t need these time features
before, but issues like earning interest or paying monthly service
charges will make them necessary. This method is synchronized so that
the two fields associated with the last access are updated atomically.</simpara>
</section>
<section xml:id="_final_classes_and_methods">
<title>Final classes and methods</title>
<simpara>If you look at the previous example carefully, you will notice that the
methods <literal>getBalance()</literal>, <literal>deposit()</literal>, and <literal>withdraw()</literal> were each declared
with the keyword <literal>final</literal>. You have seen this keyword used to declare
constants before. When applied to methods, <literal>final</literal> is philosophically
similar (and almost the opposite of <literal>abstract</literal>). A method which is
declared <literal>final</literal> cannot be overridden by child classes. If you are
designing a class hierarchy and you want to lock a method into doing a
specific thing and never changing, this is the way to do it.</simpara>
<simpara>Like <literal>abstract</literal>, the keyword <literal>final</literal> can be applied to a class as well.
If you want to prevent a class from being extended further, apply the
<literal>final</literal> keyword to its definition. You may not find yourself using this
feature of Java very often. It is primarily useful in situations where a
large body of code has been designed to make use of a specific class.
The designers of that specific class want to keep it exactly the way it
is and prevent anything unexpected from happening.</simpara>
<simpara>The most common example of a <literal>final</literal> class is the <literal>String</literal> class.
Consider the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SuperString extends String {}</programlisting>
<simpara>This code will give a compiler error. <literal>String</literal> is perfect the way it is
(or so the Java designers have decided). There is no reason to restrict
your code arbitrarily, but use of the <literal>final</literal> keyword for classes,
methods, and especially to specify constants allows the compiler to do
some performance optimizations that would otherwise be impossible.</simpara>
</section>
<section xml:id="_casting">
<title>Casting</title>
<simpara>If we shift the focus back to polymorphism, we have to admit that we
have avoided one of the messier issues. It&#8217;s true that polymorphism
gives us lots of power. For example, we can make a <literal>Vehicle</literal> array and
store subclasses of <literal>Vehicle</literal> inside, like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">Vehicle[] vehicles = new Vehicle[5];
vehicles[0] = new Skateboard();
vehicles[1] = new RocketShip();
vehicles[2] = new SteamBoat();
vehicles[3] = new Car();
vehicles[4] = new Skateboard;</programlisting>
<simpara>This process could be infinitely more complex. We could be reading data
out of a file and dynamically creating different kinds of <literal>Vehicle</literal>
objects. But, the final product of an array of <literal>Vehicle</literal> objects is the
important thing. Now, we can run through the array with a loop and have
the code magically work for each kind of <literal>Vehicle</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">for( int i = 0; i &lt; vehicles.length; i++ )
    vehicles[i].travel( "Prague" );</programlisting>
<simpara>Each <literal>Vehicle</literal> will travel to Prague as it should. The only trouble is
that we have hidden some information. We know that <literal>vehicles[1]</literal> is a
<literal>RocketShip</literal>, but we can&#8217;t treat it like one.</simpara>
<programlisting language="java" linenumbering="unnumbered">vehicles[1].blastOff();</programlisting>
<simpara>This code will not compile.</simpara>
<programlisting language="java" linenumbering="unnumbered">RocketShip ship = vehicles[1];</programlisting>
<simpara>This code will not compile either. In both cases, we must use an
explicit cast to tell the compiler that the object really <emphasis role="strong">is</emphasis> a
<literal>RocketShip</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">RocketShip ship = (RocketShip)vehicles[1];
((RocketShip)vehicles[1]).blastOff();</programlisting>
<simpara>Both lines of code will work. The compiler is always conservative. It
never makes guesses about the type of something. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">Vehicle ship = new RocketShip();
ship.blastOff();</programlisting>
<simpara>Even though <literal>ship</literal> <emphasis role="strong">must</emphasis> be a <literal>RocketShip</literal>, Java does not assume that.
The compiler uses the reference type <literal>Vehicle</literal> to do the check and will
refuse to compile. Casting allows us to use our human intellect to
overcome the shortsightedness of the compiler. Human intellect is
unfortunately flawed. What happens if you cast improperly?</simpara>
<programlisting language="java" linenumbering="unnumbered">Vehicle vehicle = new Skateboard();
RocketShip ship = (RocketShip)vehicle;
ship.blastOff();</programlisting>
<simpara>In this example, we are trying to cast a <literal>Skateboard</literal> into a
<literal>RocketShip</literal>. At compile time, no errors will be found. Because we use
explicit casting, the compiler assumes that we, powerful human beings
that we are, know what we are doing. The error will happen at runtime
while executing the second line. Java will try to cast <literal>vehicle</literal> into a
<literal>RocketShip</literal>, fail, and throw a <literal>ClassCastException</literal>.</simpara>
<simpara>Java provides some additional tools to make casting easier. One of these
is the <literal>instanceof</literal> keyword which can be used to test if an object is an
instance of a particular class (or one of its derived classes). For
example, we can make an object execute a special command if we know that
the object is capable of it.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void visitDenver( Vehicle vehicle ) {
    if( vehicle instanceof RocketShip )
        ((RocketShip)vehicle).blastOff();
    vehicle.travel( "Denver" );
}</programlisting>
<simpara>Even inside the <literal>if</literal> statement where it must be the case that <literal>vehicle</literal>
is a <literal>RocketShip</literal>, we still must perform an explicit cast. Sometimes
<literal>instanceof</literal> is not precise enough. If you must be sure that the object
in question is a specific class and not just one of its subclasses, you
can use the <literal>getClass()</literal> method on any object and compare it to the
static class object. Using this tool, we can rewrite the former example
to be more specific.</simpara>
<programlisting language="java" linenumbering="unnumbered">public void visitDenver( Vehicle vehicle ) {
    if( vehicle.getClass() ==  RocketShip.class )
        ((RocketShip)vehicle).blastOff();
    vehicle.travel( "Denver" );
}</programlisting>
<simpara>This version of the code will only call <literal>blastOff()</literal> for objects of
class <literal>RocketShip</literal> and not for objects of a subclass like
<literal>FusionPoweredRocketShip</literal>.</simpara>
</section>
<section xml:id="subsection:Inheritance_and_exceptions">
<title>Inheritance and exceptions</title>
<simpara>Beyond `ClassCastException`s, there are a few other issues that come up
when combining exceptions with inheritance. As you already know, an
exception handler for a parent class will work for a child class. As
such, when using multiple exception handlers, it is necessary to order
them from most specific to most general in terms of class hierarchy.</simpara>
<simpara>However, there is another subtle rule that is necessary to keep
polymorphism functioning smoothly. Let&#8217;s consider a <literal>Fruit</literal> class with
an <literal>eat()</literal> method that throws an <literal>UnripeFruitException</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Fruit {
    public void eat() throws UnripeFruitException {
        ...
    }
}</programlisting>
<simpara>Almost any fruit can be unripe, and it is unpleasant to try to eat an
unripe fruit. But, there are other things that can go wrong when eating
fruit. Consider the <literal>Plum</literal> class derived from <literal>Fruit</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Plum extends Fruit {
    public void eat() throws
        UnripeFruitException, ChokingOnPitException {
        ...
    }
}</programlisting>
<simpara>In the <literal>Plum</literal> class, the <literal>eat()</literal> method has been overridden to tackle
the special ways that eating a plum is different from eating fruit in
general. When eating a plum, you can make a mistake and try to swallow
the pit, throwing, it seems, a <literal>ChokingOnPitException</literal>. This scenario
seems natural, but it is not allowed in Java.</simpara>
<simpara>The principle behind polymorphism is that a more specialized version of
something can be used in place of a more general version. Indeed, if you
use a <literal>Plum</literal> in place of a <literal>Fruit</literal>, calling the <literal>eat()</literal> method is no
problem. The problem happens if a <literal>ChokingOnPitException</literal> is thrown.
Now, code which was designed for <literal>Fruit</literal> objects knows nothing about a
<literal>ChokingOnPitException</literal>, so there is no way for such code to catch the
exception and deal with the situation.</simpara>
<simpara>There is nothing wrong with throwing exceptions on overridden methods.
The rule is that the overriding method must throw a subset (not a proper
subset, so it could be all of the original exceptions) of the exceptions
that the overridden method throws. This rule is actually a concept
called Hoare&#8217;s rule of consequence that pops up several places in
programming languages. Essentially, if you start with something that
works, tighten the requirements on the input (use a <literal>Plum</literal> instead of
any <literal>Fruit</literal>), loosen the requirements on the output (throw fewer
exceptions than were originally thrown), it will still work.</simpara>
<example>
<title>More human than human</title>
<simpara>Now we have a few additional examples in a somewhat larger class
hierarchy.</simpara>
<figure role="text-center">
<title>Animal class hierarchy.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/17-polymorphism/images/animals.svg" width="75%"/>
</imageobject>
<textobject><phrase>animals</phrase></textobject>
</mediaobject>
</figure>
<programlisting xml:id="program:Animal" xreflabel="Animal" language="java" linenumbering="numbered">public abstract class Animal {
	private boolean alive = true;
	private boolean happy = true;
	private final boolean warmblooded;

	public Animal( boolean warmblooded ) {
		this.warmblooded = warmblooded;
	}

	public boolean isHappy() { return happy; }

	public void setHappy( boolean value ) { happy = value; }

	public boolean isAlive() { return alive; }

	public void die() { alive = false; }
}</programlisting>
<simpara>We begin with the abstract <literal>Animal</literal> class. This class gives a base
definition for animals which includes whether the animal is alive,
whether the animal is happy, and whether it is warmblooded (declared
<literal>final</literal> because an animal can&#8217;t switch between warmblooded and
coldblooded).</simpara>
<programlisting xml:id="program:Mammal" xreflabel="Mammal" language="java" linenumbering="numbered">public abstract class Mammal extends Animal {
	public static final boolean MALE = false;
	public static final boolean FEMALE = true;
	private final boolean gender;

	public Mammal( boolean gender ) {
		super( true );
		this.gender = gender;
	}

	public getGender() { return gender; }

	public abstract String makeSound();
}</programlisting>
<simpara>We then extend <literal>Animal</literal> into <literal>Mammal</literal>. All mammals are warmblooded,
which is reflected in the constructor call to the base class. In
addition, it is assumed that all mammals make some sound. Mammals also
have well-defined genders, declared <literal>final</literal> because it cannot change
once it has been set. Like <literal>Animal</literal>, <literal>Mammal</literal> is an abstract class, and
any non-abstract subclass of <literal>Mammal</literal> must implement <literal>makeSound()</literal>.</simpara>
<programlisting xml:id="program:Platypus" xreflabel="Platypus" language="java" linenumbering="numbered">public class Platypus extends Mammal {
	public Platypus( boolean gender ) {
		super( gender );
	}

	public String makeSound() {
		return "Quack!"
	}

	public Egg layEgg() {
		if( getGender() == FEMALE )
			return new Egg();
		else
			return null;
	}

	public void poison( Animal victim ) {
		if( getGender() == MALE )
			victim.setHappy( false );
	}
}</programlisting>
<simpara>The <literal>Platypus</literal> class extends <literal>Mammal</literal> and adds the unusual things that a
platypus can do: laying eggs (if female) and poisoning other animals (if
male).</simpara>
<programlisting language="java" linenumbering="numbered">public class Human extends Mammal {
	public Human( boolean gender, boolean happy ) {
		super( gender );
		setHappy( happy );
	}

	public String makeSound() {
		return "Hello, world."
	}
}</programlisting>
<simpara>The <literal>Human</literal> class also extends <literal>Mammal</literal>. Depending on the problem being
solved, this class might warrant a great deal more specialization. Right
now the main addition is taking happiness as an argument to the
constructor. Unfortunately, the default human state is not necessarily
happiness.</simpara>
<programlisting xml:id="program:DavidBowie" xreflabel="DavidBowie" language="java" linenumbering="numbered">public final class DavidBowie extends Human {
	public DavidBowie() {
		super( MALE, true );
	}

	public String makeSound() {
		return "I always had a repulsive need to be " +
		"something more than human."
	}
}</programlisting>
<simpara>Finally, the <literal>DavidBowie</literal> class extends <literal>Human</literal> and is declared a final
class because it really is impossible to add anything to David Bowie.</simpara>
</example>
<simpara>You will notice that our examples have stretched fairly long in this
chapter. It is difficult to give strong motivation for some aspects of
inheritance and polymorphism without a large class hierarchy. These
tools are designed to help organize large bodies of code and should
become more useful as the size of the problem you are working on grows.
One of the best examples of the success of inheritance is the Java API
itself. The standard Java library is very large and depends on
inheritance a great deal.</simpara>
</section>
</section>
<section xml:id="_solution_banking_account_with_a_vengeance">
<title>Solution: Banking account with a vengeance</title>
<simpara>Now we return to the specific problem given at the beginning of the
chapter and give its solution. We have already given you the
<literal>BankAccount</literal> abstract class which provides a lot of structure.</simpara>
<figure role="text-center">
<title>Bank account class hierarchy.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/17-polymorphism/images/accounts.svg" width="75%"/>
</imageobject>
<textobject><phrase>accounts</phrase></textobject>
</mediaobject>
</figure>
<formalpara xml:id="program:CheckingAccount" xreflabel="CheckingAccount">
<title>Subclass of <literal>BankAccount</literal> that models a normal checking account.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class CheckingAccount extends BankAccount {
	public static final double FEE = 10;

	public CheckingAccount( String name, double balance )
		throws InterruptedException {
		super( name, balance );
	}

	protected synchronized void update()
		throws InterruptedException {
		super.update();
		changeBalance( -getFee()*getMonthsPassed() );
	}

	protected double getFee() {	return FEE;	}
}</programlisting>
</para>
</formalpara>
<simpara>The most basic account is the <literal>CheckingAccount</literal>. As you recall from the
<literal>BankingAccount</literal> class, the <literal>getBalance()</literal>, <literal>deposit()</literal>, and
<literal>withdraw()</literal> methods are all declared <literal>final</literal>. At first it seems as if
there is no way to change these methods to add the $10 service charge.
However, each of those methods calls the <literal>update()</literal> method first to take
care of any bookkeeping. By overriding the <literal>update()</literal> method, we can
easily add the service charge. The new <literal>update()</literal> method calls the
parent <literal>update()</literal> to calculate the passage of time, then it changes the
balance based on the number of months that have passed.</simpara>
<simpara>The system we have adopted may seem unusual at first. Any time the
balance is checked, deposited to, or withdrawn from, we call <literal>update()</literal>.
By updating the account to reflect any months which may have passed
before continuing on, we do not have to write code which periodically
updates each bank account. Each bank account is only updated if needed.</simpara>
<simpara>We were careful to mark <literal>update()</literal> as <literal>synchronized</literal>. Although the
chance of an error happening is small, we make the update of the
internal <literal>Calendar</literal> and the application of any fee atomic, just to be
safe.</simpara>
<simpara>Note that we do not use the constant <literal>FEE</literal> directly in <literal>update()</literal>.
Instead, we call the <literal>getFee()</literal> method. The reason for this decision is
due to the next class.</simpara>
<formalpara xml:id="program:DirectDepositAccount" xreflabel="DirectDepositAccount">
<title>Subclass of <literal>CheckingAccount</literal> that models the behavior of accounts with direct deposits.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Calendar;
public class DirectDepositAccount extends CheckingAccount {
	protected Calendar lastDirectDeposit;

	public DirectDepositAccount( String name, double balance )
		throws InterruptedException {
		super( name, balance );
		lastDirectDeposit = Calendar.getInstance();
	}

	public double getFee() {
		Calendar current = Calendar.getInstance();
		int months = 12*(current.get(Calendar.YEAR) -
		lastDirectDeposit.get(Calendar.YEAR)) +
		(current.get(Calendar.MONTH) -
		lastDirectDeposit.get(Calendar.MONTH));
		if( months &lt;= 1 )
			return 0;
		else
			return super.getFee();
	}

	public void directDeposit( double amount )
		throws InterruptedException {
		deposit( amount );
		lastDirectDeposit = Calendar.getInstance();
	}
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>DirectDepositAccount</literal> class extends the <literal>CheckingAccount</literal> class.
Note that the <literal>update()</literal> method hasn&#8217;t been overridden. We have added
another <literal>Calendar</literal> object to keep track of the last time a direct
deposit was made. Then, we do override the <literal>getFee()</literal> method. If there
has been a recent direct deposit, the fee is nothing, otherwise, it
returns the fee from the <literal>CheckingAccount</literal>. Because of dynamic binding,
the <literal>update()</literal> method defined in <literal>CheckingAccount</literal> will call this
overridden <literal>getFee()</literal> method for <literal>DirectDepositAccount</literal> objects.</simpara>
<formalpara xml:id="program:SavingsAccount" xreflabel="SavingsAccount">
<title>Subclass of <literal>BankAccount</literal> that models the behavior of a savings account.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class SavingsAccount extends BankAccount {
	public static final double MINIMUM = 1000;
	public static final double FEE = 25;
	protected final double RATE;

	public SavingsAccount( String name, double balance, double rate )
		throws InterruptedException {
		super( name, balance );
		RATE = rate;
	}

	protected double getFee() { return FEE;	}

	protected double getMinimum() {	return MINIMUM;	}

	protected synchronized void update()
		throws InterruptedException {
		super.update();
		int months = getMonthsPassed();
		for( int i = 0; i &lt; months; i++ ) {
			if( getBalance() &gt; 0 )
				changeBalance( getBalance() * (1 + RATE/12) );
			if( getBalance() &lt; getMinimum() )
				changeBalance( -getFee() );
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>There should be few surprises in the last class, <literal>SavingsAccount</literal>. The
biggest difference is that, in the <literal>update()</literal> method, we use a loop to
update the balance because the account could be gaining interest and
also incurring fees. The interaction of the two operations may give a
different result than applying each in a block for the backlog of
months.</simpara>
<simpara>This set of classes may not resemble the way a real, commercial-grade
banking application works. Nevertheless, with inheritance and
polymorphism we were able to create bank accounts which do some
complicated tasks with a relatively small amount of code. At the same
time, we preserved thread safety so that these accounts can be used in
concurrent environments.</simpara>
</section>
<section xml:id="_concurrency_atomic_libraries">
<title>Concurrency: Atomic libraries</title>
<simpara>This chapter has discussed using polymorphism to reuse code. To solve
the Bank Account with a Vengeance problem from the beginning of the
chapter, we explored the process of extending several bank account
classes to add additional features while working hard to maintain thread
safety.</simpara>
<simpara>Code can be reused by extending classes with child classes or by using
instances of existing classes as fields. There is no single solution
that is best for every case. As in the bank account examples, it can be
difficult to know when to apply the <literal>synchronized</literal> keyword to methods.</simpara>
<simpara>To lessen the load on the programmer, the Java API provides a library of
atomic primitives in the<?asciidoc-br?>
<literal>java.util.concurrent.atomic</literal> package. These are classes with certain
operations that are guaranteed to execute atomically. For example, the
<literal>AtomicInteger</literal> class encapsulates the functionality of an <literal>int</literal>
variable with atomic accesses. One of its methods is
<literal>incrementAndGet()</literal>, which will atomically increment its internal value
by 1 and return the result. Recall from
ProgramÂ <xref linkend="program:RaceCondition"/> that even an operation as simple as
<literal>++</literal> is not atomic. If many different threads try to increment a single
variable, some of those increments can get lost, causing the final value
to be less than it should be.</simpara>
<example>
<title>AtomicInteger</title>
<simpara>We can use the <literal>AtomicInteger</literal> class to rewrite
ProgramÂ <xref linkend="program:RaceCondition"/> so that no race condition occurs.</simpara>
<formalpara xml:id="program:NoRaceCondition" xreflabel="NoRaceCondition">
<title>Program to demonstrate the use of <literal>AtomicInteger</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.concurrent.atomic.*;

public class NoRaceCondition extends Thread {
	private static AtomicInteger counter = new AtomicInteger();
	public static final int THREADS = 4;
	public static final int COUNT = 1000000;

	public static void main( String[] args ) {
		NoRaceCondition[] threads = new NoRaceCondition[THREADS];
		for( int i = 0; i &lt; THREADS; i++ ) {
			threads[i] = new NoRaceCondition();
			threads[i].start();
		}
		try {
			for( int i = 0; i &lt; THREADS; i++ )
				threads[i].join();
		}
		catch( InterruptedException e ) {
			e.printStackTrace();
		}
		System.out.println("Counter:\t" + counter.get() );
	}

	public void run() {
		for( int i = 0; i &lt; COUNT / THREADS; i++ )
			counter.incrementAndGet();
	}
}</programlisting>
</para>
</formalpara>
<simpara>This program is identical to ProgramÂ <xref linkend="program:RaceCondition"/>, except
that the type of <literal>counter</literal> has been changed from <literal>int</literal> to
<literal>AtomicInteger</literal> (and an appropriate <literal>import</literal> has been added).
Consequently, the <literal>++</literal> operation was changed to an <literal>incrementAndGet()</literal>
method call, and a <literal>get()</literal> method call was needed to get the final
value. If you run this program, the final answer should always be
1000000, no matter what.</simpara>
</example>
<simpara>The <literal>java.util.concurrent.atomic</literal> package includes <literal>AtomicBoolean</literal> and
<literal>AtomicLong</literal> as well as <literal>AtomicInteger</literal>. Likewise, the
<literal>AtomicIntegerArray</literal> and <literal>AtomicLongArray</literal> classes are included to
perform atomic array accesses. For general purposes, the
<literal>AtomicReference&lt;V&gt;</literal> class provides an atomic way to store a reference
to any object. (The <literal>&lt;V&gt;</literal> is a generic type parameter, which will be
discussed in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>.)</simpara>
<simpara>Although you could use the <literal>synchronized</literal> keyword to create each one of
these classes yourself, the result would not be as efficient. The atomic
classes use a special <emphasis>lock-free</emphasis> mechanism. Unlike using the
<literal>synchronized</literal> keyword which forces a thread to acquire a lock on a
specific object, lock-free mechanisms are built on a <emphasis>compare-and-swap</emphasis>
(CAS) hardware instruction. Thus, incrementing and the handful of other
ways to update an atomic variable execute in one step because of special
instructions on the CPU. Since there is no waiting to acquire a lock or
fighting over which thread has the lock, the operation is very fast.
Many high performance concurrent applications depends on CAS
implementations.</simpara>
</section>
<section xml:id="_exercises_16">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Consider the following two classes:</simpara>
<programlisting xml:id="program:Sale" xreflabel="Sale" language="java" linenumbering="numbered">public class Sale {
	public double discount = 0.25;

	public double getDiscount() {
		return discount;
	}

	public void setDiscount( double value ) {
		discount = value;
	}
}</programlisting>
<programlisting xml:id="program:Blowout" xreflabel="Blowout" language="java" linenumbering="numbered">public class Blowout extends Sale {
	public double discount = 0.5;

	public double getDiscount() {
		return discount;
	}

	public void setDiscount( double value ) {
		discount = value;
	}
}</programlisting>
<simpara>Given the following snippet of code, what is the output?</simpara>
<programlisting language="java" linenumbering="unnumbered">Sale sale = new Blowout();
System.out.println( sale.discount );
System.out.println( sale.getDiscount );
Blowout blowout = (Blowout)sale;
System.out.println( blowout.discount );
sale.setDiscount( 0.75 );
System.out.println( sale.discount );</programlisting>
</listitem>
<listitem>
<simpara>What are the differences and similarities between abstract classes
and interfaces?</simpara>
</listitem>
<listitem>
<simpara>Assume that the <literal>Corn</literal>, <literal>Carrot</literal>, and <literal>Potato</literal> classes are all
derived from <literal>Vegetable</literal>. Both <literal>Carrot</literal> and <literal>Potato</literal> classes have a
<literal>peel()</literal> method, but <literal>Corn</literal> does not. Examine the following code and
identify which line will cause an error and why.</simpara>
<programlisting language="java" linenumbering="unnumbered">Vegetable[] vegetables = new Vegetable[30];
for( int i = 0; i &lt; vegetables.length; i += 3 ) {
    vegetables[i] = new Corn();
    vegetables[i + 1] = new Carrot();
    vegetables[i + 2] = new Potato();
}
int index = vegetables.length - 1;
Potato potato;
while( index &gt;= 0 ) {
    potato = (Potato)vegetable[index];
    potato.peel();
}</programlisting>
</listitem>
<listitem>
<simpara>How many different meanings of the keyword <literal>final</literal> are there in
Java, and what does each mean?</simpara>
</listitem>
<listitem>
<simpara>Assume that <literal>Quicksand</literal> is a subclass of <literal>Danger</literal>.</simpara>
<simpara>What is the output of the following code?</simpara>
<programlisting language="java" linenumbering="unnumbered">Quicksand quicksand = new Quicksand();
if( quicksand instanceof Danger ) {
    System.out.printf( "Run for your lives!" );
if( quicksand.getClass() == Danger.class )
    System.out.printf( "Run even faster!" );
if( quicksand instanceof Quicksand ) {
    System.out.printf( "The more you struggle," +
    " the faster you'll sink!" );
if( quicksand.getClass() == Quicksand.class )
    System.out.printf( "You'll need to find a vine to escape!" );</programlisting>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Implement a program to assess income tax on normal employees,
students, and international students using a class hierarchy. Normal
employees pay a 6.2% social security tax and a 1.45% Medicare tax every
year, but neither kind of student pays these taxes. All three groups pay
normal income tax according to the following table.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top">Marginal Tax Rate</entry>
<entry align="center" valign="top">Income Bracket</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>10%</simpara></entry>
<entry align="center" valign="top"><simpara>$0 - $7,825</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>15%</simpara></entry>
<entry align="center" valign="top"><simpara>$7,826 -$31,850</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>25%</simpara></entry>
<entry align="center" valign="top"><simpara>$31,851 -$77,100</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>28%</simpara></entry>
<entry align="center" valign="top"><simpara>$77,101- $160,850</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>33%</simpara></entry>
<entry align="center" valign="top"><simpara>$160,851- $349,700</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>35%</simpara></entry>
<entry align="center" valign="top"><simpara>$349,701+</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Tax is assessed at a given rate for every dollar in the range. For
example, if someone makes $10,000, she pays 10% tax on the first $7,825
of her income and 15% on the remaining $2,175. The exception is
international students whose country has a treaty with the U.S. so that
they do not have to pay tax on the first $50,000 of income.</simpara>
</listitem>
<listitem>
<simpara>Refer to the sort given in SectionÂ <xref linkend="solution:Sort_it_out"/> as the
solution to the Sort It Out problem. Add another <literal>boolean</literal> to the
parameters of the sort which specifies whether the sort is ascending or
descending. Make the needed changes throughout the code to add this
functionality.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:parallel_bubble_sort"/> Again refer to the sort from
SectionÂ <xref linkend="solution:Sort_it_out"/>. The goal now is to parallelize the
sort. Change the sort to work with <literal>int</literal> values then write some code
which will generate an array of random <literal>int</literal> values. Design your code so
that you can spawn <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> threads. Partition the single array
into <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> arrays and map one partition to each thread. Use
your bubble sort implementation to sort each partition. Finally, merge
the arrays back together, in sorted order, into one final array. For
now, just use one thread (ideally the main thread) to do the merge.</simpara>
<simpara>The merge operation is a simple idea, but it is easy to make mistakes in
implementation. The idea is to have three indexes, one for each of the
two arrays you are merging and one for the result array. Always take the
smaller (or larger, if sorting in descending order) index value from the
two arrays and put it in the result. Then increment the index from the
array you took the data from as well as the index of the result array.
Make sure that you are careful not to go beyond the end of the arrays
which are being merged.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:use_atomics"/> Re-implement the original
<literal>SynchronizedAccount</literal> class from ExampleÂ <xref linkend="example:Bank_account"/> using
atomic classes. For simplicity, you can change the <literal>balance</literal> type from
<literal>double</literal> to <literal>AtomicInteger</literal> since there is no <literal>AtomicDouble</literal> class. How
much has this simplified the implementation? Is the <literal>readers</literal> field
still necessary? Why or why not?</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Once you have implemented the sort in parallel from
ExerciseÂ <xref linkend="exercise:parallel_bubble_sort"/>, time it against the
sequential version. Try 2, 4, and 8 different threads, particularly if
you have 8 cores. Be sure to create one random array and use the same
array for both the parallel and sequential versions. Try array sizes of
1000, 100000, and 1000000. Did the performance increase as much as you
expect?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:test_atomics"/> Take ProgramÂ <xref linkend="program:NoRaceCondition"/>
and increase <literal>COUNT</literal> to <literal>100000000</literal>. Run it several times and time how
long it takes to run to completion.</simpara>
<simpara>Then, take ProgramÂ <xref linkend="program:RaceCondition"/> and increase its <literal>COUNT</literal> to
<literal>100000000</literal> as well. Change the body of the <literal>for</literal> loop inside the
<literal>run()</literal> method so that <literal>count++;</literal> is inside of a <literal>synchronized</literal> block
that uses <literal>RaceCondition.class</literal> as the lock. (The choice of
<literal>RaceCondition.class</literal> is arbitrary, but it is an object that all the
threads can see.) In this way, the increment will occur atomically,
since only the thread that has acquired the <literal>RaceCondition.class</literal> lock
will be able to do the operation. Now, run this modified program several
times and time it.</simpara>
<simpara>How different are the running times? They may be similar, depending on
the implementation of locks and CAS on your OS and hardware platform.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Dynamic_Data_Structures">
<title>Dynamic Data Structures</title>
<blockquote>
<attribution>
Niklaus Wirth
</attribution>
<simpara>Algorithms + Data Structures = Programs</simpara>
</blockquote>
<section xml:id="_problem_infix_conversion">
<title>Problem: Infix conversion</title>
<simpara>If a math teacher writes the expression <inlineequation><alt><![CDATA[(1 + 7\times8 -
6\times(4 + 5) \div  3)]]></alt><mathphrase><![CDATA[(1 + 7\times8 -
6\times(4 + 5) \div  3)]]></mathphrase></inlineequation> on the blackboard and asks a group of 10 year
old children to solve it, different children may give different answers.
The difficulty is that the children may not understand the order of
operations. Modern graphing calculators and many computer programs can,
of course, evaluate such expressions correctly, but how do they do it?
You intuitively grasp order of operations (left to right, multiplication
and division take higher precedence than addition and subtraction), but
encoding that intuition into a computer program is more difficult.</simpara>
<simpara>One way a computer scientist might approach this problem is to turn the
mathematical expression from one that is difficult to evaluate to one
that is easy. The normal style of writing mathematical expressions is
called <emphasis>infix notation</emphasis>, because the operators are written in between
the operands they are used on. A much easier notation for automatic
evaluation is called <emphasis>postfix notation</emphasis>, because an operator is placed
after the operands it works on. The following tableÂ gives
a few examples of expressions written in both infix and postfix
notation.</simpara>
<informaltable role="center" frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Infix</entry>
<entry align="left" valign="top">Postfix</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>3 + 7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>3 7 +</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>4 * 2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>4 2 *</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>1 + 9 * 2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1 9 2 * +</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>(1 + 9) * 2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1 9 + 2 *</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Although infix notation is probably more familiar to you, postfix
notation has the benefit of exactly specifying the order of operations
without using any precedence rules and without needing parentheses to
clarify. To understand how to compute an expression in postfix notation,
we rely on the idea of a stack, which we first introduces in
ChapterÂ <xref linkend="chapter:Classes"/> and examine in much greater depth here.</simpara>
<simpara>Recall that a stack has three operations: <emphasis>push</emphasis>, <emphasis>pop</emphasis>, and <emphasis>top</emphasis>. It
works like a stack of physical objects. The push operation places an
object on the top, the pop operation removes an item from the top, and
the top operation tells you what is at the top of the stack.</simpara>
<simpara>Using a stack, the postfix evaluation rules are easy. Scan the
expression from left to right, if you see an operand (a number, in our
case), put it on the stack. If you see an operator, pop the last two
operands off the stack and use the operator on them. Then, push the
result back on the stack. When you run out of input, the value at the
top of the stack is your answer.</simpara>
<simpara>For example, with <literal>1Â 9Â 2Â *Â +</literal>, all three operands are pushed onto the
stack. Then, the <literal>*</literal> is read, and so <literal>2</literal> and <literal>9</literal> is popped off the stack
and multiplied. The result <literal>18</literal> is pushed back on the stack. Then, the
<literal>+</literal> is read, and <literal>18</literal> and <literal>1</literal> is popped off the stack and summed,
resulting in <literal>19</literal>, which is pushed back on the stack and is the final
answer.</simpara>
<simpara>Our problem, however, is not to evaluate an expression in postfix
notation but to convert an expression in infix notation to postfix
notation. Again, the concept of a stack is useful. To do the conversion,
we initialize a stack and scan through the input in infix notation. As
we scan through the input, we do one of four things depending on which
of the four possible inputs we see:</simpara>
<variablelist>
<varlistentry>
<term>Operand</term>
<listitem>
<simpara>Simply copy the operand to the postfix output.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator</term>
<listitem>
<simpara>If the stack is empty, push the operator onto the stack. If the stack
is not empty and the operator at the top of the stack has the same or
greater precedence than our new operator, put the top operator into
our postfix output and pop the stack. Continue this process as long as
the top operator has the same or greater precedence compared to our
new operator and the stack is not empty. Finally, push the new
operator onto the stack.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Left Parenthesis</term>
<listitem>
<simpara>Push the left parenthesis onto the stack.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Right Parenthesis</term>
<listitem>
<simpara>Pop everything off the stack and add it to the output until you find a
left parenthesis in the stack. Then pop the left parenthesis.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Precedence comes from order of operations: <literal>*</literal> and <literal>/</literal> have high
precedence and <literal>+</literal> and <literal>-</literal> have low precedence. When you encounter it on
the stack, treat <literal>(</literal> as if it has even lower precedence than <literal>+</literal> and
<literal>-</literal>. A right parenthesis should never appear on the stack.</simpara>
<simpara>Following this algorithm, we are able to write a program that converts
infix notation to postfix notation. We further restrict our problem to
the case when the only operands are positive integers in the range
<inlineequation><alt><![CDATA[[0, 9]]></alt><mathphrase><![CDATA[[0, 9]]></mathphrase></inlineequation>]. Since each is a single character, parsing the
input is much easier. The same ideas for postfix conversion holds no
matter how the input is formatted, but parsing arbitrarily formatted
numbers is a difficult problem in its own right. This restriction also
makes spaces unnecessary.</simpara>
<simpara>To solve the infix conversion problem, we need to create a stack data
structure whose elements are terms from an infix expression, where a
term is an operator, operand, or a parenthesis. We created a stack to
solve the nesting expression problem in SectionÂ <xref linkend="solution:Nested
expressions"/>, but we explore stacks in this chapter as one of many
different kinds of dynamic data structure.</simpara>
</section>
<section xml:id="_concepts_dynamic_data_structures">
<title>Concepts: Dynamic data structures</title>
<simpara>By now you have seen several ways to organize data in your programs. For
example, you have used arrays to store a sequence of values and class
definitions to store (and operate on) collections of related values.
These data structures have the property that they are <emphasis>static</emphasis> in size:
Once allocated, they do not grow as the program runs. If you allocate an
array to store 100 integers, you&#8217;ll get an error if you try to store 101
integers into it.</simpara>
<simpara>In this chapter, we examine <emphasis>dynamic</emphasis> data structures: As more data is
read or processed, these data structures grow and shrink in memory to
store what is needed. The stack used to solve the nesting expressions
problem from ChapterÂ <xref linkend="chapter:Classes"/> is not actually a dynamic data
structure since it is defined with a fixed maximum size. In this
chapter, we implement a true stack as well as many other kinds of
dynamic data structures.</simpara>
<section xml:id="_dynamic_arrays">
<title>Dynamic arrays</title>
<simpara>There are two broad classes of dynamic data structures we examine here.
The first kind are based on arrays that grow and shrink. Dynamic arrays
allow for fast access to individual elements in the data structure. One
drawback of dynamic arrays is that the array that stores that data has a
fixed amount of space. When too many elements are added, a new array has
to be reallocated and all the original elements copied over.</simpara>
<figure role="text-center">
<title>Insertion into full dynamic array requiring reallocation. Even if the array wasn&#8217;t full, all values after <literal>14</literal> would need to be moved back to insert <literal>17</literal> in order.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/18-dynamic-data-structures/images/dynamicinsertion.svg" width="80%"/>
</imageobject>
<textobject><phrase>dynamicinsertion</phrase></textobject>
</mediaobject>
</figure>
<simpara>Another drawback of dynamic arrays is that they are poorly suited for
insertion or deletion of elements in the middle of the array. When an
element is inserted, each element after it must be moved back one
position. Likewise, when an element is deleted, all of the elements
after it must be moved forward one position. Thus, insertions and
deletions at the end of a dynamic array are usually efficient, but
insertions and deletions in the middle are very time consuming.</simpara>
</section>
<section xml:id="subsection:Linked_lists">
<title>Linked lists</title>
<simpara>The second kind of dynamic data structure is based on objects that link
to (or reference) other objects. The simplest form of such a data type
is a <emphasis>linked list</emphasis>. A linked list is a data structure made up of a
sequence of objects. Each object contains some data value (such as a
<literal>String</literal>) and a <emphasis>link</emphasis> to the next object in the sequence.</simpara>
<figure>
<title>Visualization of a linked list.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/18-dynamic-data-structures/images/linkedlist.svg" width="100%"/>
</imageobject>
<textobject><phrase>linkedlist</phrase></textobject>
</mediaobject>
</figure>
<simpara>Linked lists are flexible because they have no preset size. Whenever a
new element is needed, it can be created and linked into the list.
Unfortunately, they can be slow if you need to access arbitrary elements
in the list. The only way to reach an element in the list is to walk
from element to element until you find what you&#8217;re looking for. If the
element is at the beginning (or the end) of the list, this process can
be quick. If the element is in the middle, there is no fast way to get
there.</simpara>
<simpara>Linked lists work well when inserting new elements at arbitrary
locations in the list. Unlike arrays, they are not implemented as a
contiguous block of memory. Linking a new element into the middle of the
list automatically creates the correct relationship among elements, and
there is no need to move all the elements after an insertion.</simpara>
<simpara>Among their downsides is the memory overhead of linked lists. Because a
new object must be allocated for each element in the list, which must
include a reference to the next element. Consequently, using a linked
list to solve a problem usually take more memory than an equivalent
dynamic array solution.</simpara>
<simpara>It turns out that either dynamic arrays or linked lists can be used to
create an efficient solution to the infix conversion problem defined at
the beginning of the chapter.</simpara>
</section>
<section xml:id="_abstract_data_types">
<title>Abstract data types</title>
<simpara>The fact that dynamic arrays and linked lists can be used to solve
similar problems points out that we may often be more interested in the
<emphasis role="strong">capabilities</emphasis> of a data structure rather than its implementation.</simpara>
<simpara>An <emphasis>abstract data type</emphasis> (ADT) is a set of operations that can be applied
to a set of data values with well-defined results that are independent
of any particular implementation. In other words, it is a list of things
that a data type can do (or have done to it).</simpara>
<simpara>A stack is a great example of an ADT. A stack needs to be able to push a
value, pop a value, and tell us what value is on top. The internal
workings of the stack are irrelevant (as long as they are efficient). It
is possible to use either a dynamic array or a linked list to implement
a stack ADT. A queue is another ADT we discuss in
SectionÂ <xref linkend="syntax:Abstract_data_types_(ADT)"/>, but there are many other
useful ADTs.</simpara>
</section>
</section>
<section xml:id="_syntax_dynamic_arrays_and_linked_lists">
<title>Syntax: Dynamic arrays and linked lists</title>
<section xml:id="_dynamic_arrays_2">
<title>Dynamic arrays</title>
<simpara>Suppose you are faced with the problem of reading a list of names from a
file, sorting them into alphabetical order, and printing them out. You
have already looked at simple sorting algorithms to handle the sorting
part, or you could use the Java <literal>Arrays.sort()</literal> method. In previous
problems when you needed to use an array for storing items, you knew in
advance how many (or a maximum of how many) items you would need to
store. In this new problem, the number of names in the input file is
unspecified, so you must allow an arbitrary number to be handled.</simpara>
<simpara>One approach is to make a guess at how many names are in the input file
and allocate an array of that size. If your guess is too small, and you
don&#8217;t check array accesses, you&#8217;ll cause an exception once you have
filled the array and try to store the next name into the index one past
the last. If your guess is too large, you could be wasting a significant
amount of storage space.</simpara>
<simpara>Our first solution to the problem of dealing with dynamic or unknown
amounts of data is to watch our array accesses and expand the array as
necessary during processing. (It is also possible to contract an array
once you determine that the array has more space than needed.)</simpara>
<section xml:id="_a_simple_solution">
<title>A simple solution</title>
<simpara>ProgramÂ <xref linkend="program:ReadIntoFixedArray"/> allocates an array of 10 strings
and reads a list of names from standard input until it reaches the end
of the file, storing each name in successive array locations. If the
number of names in the input is larger than the size of the array, it
generates an exception.</simpara>
<simpara>Since programs that generate uncaught exceptions are, in general, a bad
idea, our first change to this program should be either to catch the
exception or check the index before storing the name in the array. In
either case, we would then take some action that is more user friendly
than generating an exception, perhaps simply printing an explanatory
message before exiting.</simpara>
<formalpara xml:id="program:ReadIntoFixedArray" xreflabel="ReadIntoFixedArray">
<title>Program to read names into an array, sort, and print. If there are more than 10 lines in the input, an exception is generated.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;
import java.util.Scanner;

public class ReadIntoFixedArray {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		String[] names = new String[10];
		int n = 0;

		while( in.hasNextLine() )
			names[n++] = in.nextLine();

		Arrays.sort(names, 0, n);

		for( int i = 0; i &lt; n; i++ )
			System.out.println(names[i]);
	}
}</programlisting>
</para>
</formalpara>
<simpara>Our second change is to take a recovery action that allows the program
to proceed. What went wrong? We made a guess of the input size,
allocated an array of that size, but our guess was too small. We could
start over again (modify the code to initially allocate a larger array,
recompile, and re-run the program), but that option may not be available
to us if the program has been distributed to users around the world.
Instead, we fix the problem on the fly by allocating a larger array,
copying the old array into the new array, and continuing.</simpara>
<simpara>ProgramÂ <xref linkend="program:ReadAndGrowArray"/> begins like the previous program by
allocating a fixed array. However, it now catches the
<literal>ArrayOutOfBoundsException</literal> at lineÂ <xref linkend="exceptionRAGA"/> if it tries to
store too many names into the array. The <literal>catch</literal> clause allocates a new
array, twice the size of the original (current) array, copies the
existing array into it, and replaces the reference to the current array
with a reference to the new array.</simpara>
<formalpara xml:id="program:ReadAndGrowArray" xreflabel="ReadAndGrowArray">
<title>Read names into an array, enlarging the array as necessary.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;
import java.util.Scanner;

public class ReadAndGrowArray {
	public static void main(String[] args) {
		String[] names = new String[10];/*@\label{lineNames}@*/
		Scanner in = new Scanner(System.in);
		int n = 0;
		String name = null;

		while (in.hasNextLine()) {
			name = in.nextLine();
			try {
				names[n] = name;
			}
			catch( ArrayIndexOutOfBoundsException e ) {/*@\label{exceptionRAGA}@*/
				names = Arrays.copyOfRange(names, 0,/*@\label{lineCopy}@*/
							names.length*2);
				names[n] = name;
			}
			n++;
		}

		Arrays.sort(names, 0, n);

		for (int i = 0; i &lt; n; i++)
			System.out.println(names[i]);
	}
}</programlisting>
</para>
</formalpara>
<simpara>Note that it was necessary to refactor the code in
ProgramÂ <xref linkend="program:ReadIntoFixedArray"/> slightly: Add the <literal>name</literal> variable
to hold the temporary result of reading the input line, and move the
counter increment to outside the <literal>try</literal>-<literal>catch</literal> block.</simpara>
<simpara>Can this new, improved program still fail? Yes, but only for <emphasis role="strong">very
large</emphasis> input, in the case when the Java virtual machine runs out of
memory when doubling the size of the array.</simpara>
<simpara>A potentially more serious problem is the way we set <literal>names</literal> to point at
a new array.</simpara>
<programlisting language="java" linenumbering="unnumbered">    names = Arrays.copyOfRange(names, 0, names.length*2);</programlisting>
<simpara>This line works because we know the only variable that references the
array is <literal>names</literal>. If other variables referenced that array, they would
continue to reference the old, smaller, and now out-of-date version of
the <literal>names</literal> array. FigureÂ <xref linkend="figure:dynamicproblems"/> gives an example of
this problem.</simpara>
<figure>
<title>A poorly designed dynamic array implementation. (a) Both <literal>array1</literal> and <literal>array2</literal> begin pointing at the same array. (b) A new array has been allocated, and <literal>42</literal> has been added to it. <literal>array1</literal> has been updated to point at the new array, but <literal>array2</literal> still points at the original.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/18-dynamic-data-structures/images/dynamicproblems.svg" width="100%"/>
</imageobject>
<textobject><phrase>dynamicproblems</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_a_more_complete_solution">
<title>A more complete solution</title>
<simpara>The problem of updating variables that reference the dynamic array is a
serious issue in large programs. It may not be enough to allocate a
larger array and assign the new reference to only one variable. There
may be hundreds of variables (or objects) that reference the original
array.</simpara>
<simpara>A solution to this problem is to create a new class whose objects
contain the array as a private field. References to the array are then
mediated, as usual, via accessor methods, which always refers to the
same version of the array. ProgramÂ <xref linkend="program:DynamicArray"/> is a simple
implementation of a dynamic array class. This class maintains an
internal array of <literal>String</literal> objects, which it extends whenever a call to
<literal>set()</literal> tries to write a new element just past the end of the array.</simpara>
<formalpara xml:id="program:DynamicArray" xreflabel="DynamicArray">
<title>A class to manage a dynamic array. This array grows by doubling when more space is needed.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;

public class DynamicArray {
    private String[] strings = new String[10];

    public synchronized void set(int i, String string) {
        if (i == strings.length)
            strings = Arrays.copyOfRange(strings, 0,
                                         strings.length*2);
        strings[i] = string;
    }

    public String get(int i) {
        return strings[i];
    }

    public synchronized void sort(int first, int last) {
        Arrays.sort(strings, first, last);
    }
}</programlisting>
</para>
</formalpara>
<simpara>Note that the <literal>set()</literal> and <literal>sort()</literal> methods are both <literal>synchronized</literal> in
case this class is used by multiple threads simultaneously.
ExerciseÂ <xref linkend="exercise:dynamicArrayTestExercise"/> explores the need to
synchronize these methods in the presence of multiple threads.</simpara>
<simpara>ProgramÂ <xref linkend="program:UseDynamicArray"/> illustrates how to modify and extend
ProgramÂ <xref linkend="program:ReadIntoFixedArray"/> to use this new class. Since the
array grows automatically, there is no need for the original program to
check for out-of-bounds exceptions. Of course, the array expansion only
works if the reference occurs exactly at the index corresponding to one
beyond the end of the array. Other out-of-bound references generate an
exception.</simpara>
<formalpara xml:id="program:UseDynamicArray" xreflabel="UseDynamicArray">
<title>A program that uses the <literal>DynamicArray</literal> class to store input read from a file.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Scanner;

public class UseDynamicArray {
    public static void main(String[] args) {
        DynamicArray names = new DynamicArray();

        Scanner in = new Scanner(System.in);
        int n = 0;
        String name = null;
        while (in.hasNextLine()) {
            name = in.nextLine();
            names.set(n, name);
            n++;
        }

        names.sort(0, n);

        for (int i = 0; i &lt; n; i++)
            System.out.println(names.get(i));
    }
}</programlisting>
</para>
</formalpara>
<simpara>Since <literal>names</literal> is no longer an array, but rather an object of class
<literal>DynamicArray</literal>, we can no longer use braces (<literal>[]</literal>) to access elements,
but must use accessor methods <literal>set()</literal> and <literal>get()</literal>. Also, <literal>Arrays.sort()</literal>
cannot sort this object, so we need to provide a <literal>sort()</literal> method in the
class itself to sort the private array on demand.</simpara>
<simpara>This implementation, like most implementations of dynamic arrays, has
potentially serious performance penalties. If the initial array is too
small, compared to the final size, then it will have been doubled and
the elements copied multiple times, resulting in slower execution. After
a resize, the array is only half full, resulting in wasted space. Even
on average, the array will only be three-quarters full</simpara>
</section>
</section>
<section xml:id="linked-lists">
<title>Linked lists</title>
<simpara>As we&#8217;ve seen, while dynamic arrays can grow to accommodate a large
number of items, the performance penalties of repeated copying and the
space wasted by unoccupied array elements can negatively affect program
behavior. In this section, we introduce the <emphasis>linked list</emphasis>, an
alternative data structure that can efficiently grow to accommodate a
large number of objects. As we shall see, this efficient growth comes at
the expense of limitations on how the structure can be accessed.</simpara>
<simpara>Consider again the problem of reading an arbitrary number of names from
an input file and storing them. Since we don&#8217;t know in advance how many
names there are, it may not be efficient to pre-allocate or dynamically
grow an array to store them. Imagine, instead, that we could write each
name on a small index card, and then link the index cards together to
keep track of them, much like the cars of a railroad train are linked by
the coupling from one to the next.</simpara>
<section xml:id="_constructing_a_linked_list">
<title>Constructing a linked list</title>
<simpara>In Java, a linked list is usually implemented as a class that provides
methods to interact with a sequence of objects. The objects in the list
are implemented as a private static nested class. A private static
nested class behaves like a normal class but can only be created and
accessed by the class surrounding it. In this way, the internal
representation of the list is hidden and protected from outside
modification. The nested class has two fields, one containing the data
to be stored and the other containing a link or reference to the next
object, or <emphasis>node</emphasis>, in the list. Since they are only accessed by the
outer class, it is reasonable to make these fields public. If you need a
refresher on static nested classes, refer to SectionÂ <xref linkend="advanced:Nested
classes"/>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class LinkedList {
    private static class Node {
        public String value;
        public Node next;
    }

 //methods for interacting with the list
}</programlisting>
<simpara>Note that the type <literal>next</literal> is the same as the class it&#8217;s inside of! This
apparent circular reference works because the variable only <emphasis role="strong">references</emphasis>
an object, but the object is not actually contained within the variable.
In fact, the value of the link may be <literal>null</literal>, indicating that there are
no additional nodes in the list.</simpara>
<simpara>In the railroad metaphor, the node is a train car (with its freight as
the value), and the link to the next node is the coupling to the next
car.</simpara>
<simpara>The definition of <literal>LinkedList</literal> given above is a good start, but it needs
a <literal>head</literal> reference that keeps track of the first node in the list.
Initially, this value is <literal>null</literal>. We also need an <literal>add()</literal> method so that
we can add nodes to the list. Without checking through the entire list,
it is useful to know how many nodes are in it. We can create a <literal>size</literal>
field that we increment whenever we add a node, as well as an accessor
to read its value. Finally, we can create a <literal>fillArray()</literal> method that
fills an array with the values in the list.</simpara>
<formalpara xml:id="program:LinkedList" xreflabel="LinkedList">
<title>A basic implementation of a linked list class to hold <literal>String</literal> objects.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class LinkedList {
    private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;
    private int size = 0;

    public void add(String value) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = head;
    	head = temp;
    	size++;
    }

    public int size() {
    	return size;
    }

    public void fillArray(String[] array) {
    	Node temp = head;
    	int position = 0;
    	while( temp != null ) {
    		array[position++] = temp.value;
    		temp = temp.next;
    	}
    }
}</programlisting>
</para>
</formalpara>
<simpara>ProgramÂ <xref linkend="program:UseLinkedList"/> is a re-implementation of the
name-reading program using class <literal>LinkedList</literal>. Note that no array needs
to be pre-allocated. Instead, we capture all the lines of input into a
linked list called <literal>list</literal>.</simpara>
<formalpara xml:id="program:UseLinkedList" xreflabel="UseLinkedList">
<title>A program that uses the <literal>LinkedList</literal> class to store input read from a file.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;
import java.util.Scanner;

public class UseLinkedList {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		LinkedList list = new LinkedList();

		while (in.hasNextLine())
			list.add(in.nextLine());/*@\label{lineReadNew}@*/

		String[] names = new String[list.getSize()];
		list.fillArray(names);

		Arrays.sort(names);/*@\label{lineSort}@*/

		for (int i = 0; i &lt; names.length; i++)
			System.out.println(names[i]);
	}
}</programlisting>
</para>
</formalpara>
<simpara>Each time we read a new line from the file, the <literal>LinkedList</literal> class
internally creates a new <literal>Node</literal> with the input line as its <literal>value</literal>. It
also sets its <literal>next</literal> reference to the <emphasis role="strong">current</emphasis> <literal>head</literal> so that the rest
of the list (which could be empty if <literal>head</literal> is <literal>null</literal>) comes after the
new <literal>Node</literal>. We then update the <literal>head</literal> field to reference the new <literal>Node</literal>.
Thus, each new line read from the file is stored at the <emphasis role="strong">beginning</emphasis> of
the linked list. The last node in the list, which contains the first
<literal>String</literal> read in, has a <literal>next</literal> value of <literal>null</literal>. FigureÂ <xref linkend="figure:linked
list classes"/> shows a visualization of the contents of this
implementation of a linked list. An &#8220;X&#8221; is used in place of an arrow
that points to <literal>null</literal>.</simpara>
<figure>
<title>Visualization of linked list implementation with classes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/18-dynamic-data-structures/images/linkedlistclasses.svg" width="100%"/>
</imageobject>
<textobject><phrase>linkedlistclasses</phrase></textobject>
</mediaobject>
</figure>
<simpara>Since we also increment the <literal>size</literal> field inside of <literal>LinkedList</literal> on each
add, we know how many <literal>String</literal> objects it contains. Thus, the
<literal>toString()</literal> method knows how large of an array to allocate. It then
visits every node in the linked list, storing its <literal>value</literal> into the
array. In <literal>UseLinkedList</literal>, we sort the returned array as before and then
print it.</simpara>
</section>
<section xml:id="_appending_to_the_end_of_a_linked_list">
<title>Appending to the end of a linked list</title>
<simpara>The <literal>LinkedList</literal> class maintains a field named <literal>head</literal> that references
the first node in the linked list. As we saw, that element was actually
the <emphasis role="strong">last</emphasis> or <emphasis role="strong">most recent</emphasis> <literal>String</literal> read from input. This <literal>head</literal>
element was followed by the next most recent <literal>String</literal>, followed by the
next most recent <literal>String</literal>, and so on. The last node contained the first
<literal>String</literal> read from input and had a <literal>null</literal> <literal>next</literal> field.</simpara>
<simpara>If we want the linked list to be ordered in the natural way, with <literal>head</literal>
pointing to the first element read from the file and the last element on
the list (the one with <literal>next</literal> pointing to <literal>null</literal>) containing the
<literal>String</literal> most recently read, we can maintain a second field that
references the <emphasis>tail</emphasis> of the list.</simpara>
<simpara>ProgramÂ <xref linkend="program:LinkedListWithTail"/> adds a <emphasis>tail pointer</emphasis> called
<literal>tail</literal> to the <literal>LinkedList</literal> class. Note that we have changed the <literal>add()</literal>
method to the <literal>addFirst()</literal> method, and we have also added an <literal>addLast()</literal>
method to make it easy to append elements to the end of a linked list.
Note that the <literal>addFirst()</literal> method has been updated to change the <literal>tail</literal>
pointer, but only if the list is empty (<literal>head</literal> is <literal>null</literal>). After all,
adding to the front of a list only changes <literal>tail</literal> if the front is <emphasis role="strong">also</emphasis>
the back. In the <literal>addLast()</literal> method, adding a value to an empty list
also sets both the <literal>head</literal> and <literal>tail</literal> to point at a node containing that
value. Once the list has a node in it, subsequent calls to <literal>addLast()</literal>
creates a new <literal>Node</literal>, points the <literal>next</literal> field of the old <literal>tail</literal> at it,
and changes the <literal>tail</literal> field so that it also points at it.</simpara>
<formalpara xml:id="program:LinkedListWithTail" xreflabel="LinkedListWithTail">
<title>We can append to the end of a linked list by using an additional variable, <literal>tail</literal>, to reference the last element (tail) of the list.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class LinkedListWithTail {
    private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public void addFirst(String value) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = head;
    	head = temp;
    	if( tail == null )
    		tail = head;
    	size++;
    }

    public void addLast(String value) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = null;
    	if( tail == null )
    		head = tail = temp;
    	else
    		tail.next = temp;
    	size++;
    }

    public int getSize() {
    	return size;
    }

    public void fillArray(String[] array) {
    	Node temp = head;
    	int position = 0;
    	while( temp != null ) {
    		array[position++] = temp.value;
    		temp = temp.next;
    	}
    }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_inserting_into_a_linked_list">
<title>Inserting into a linked list</title>
<simpara>In the running example for this chapter, we are interested in printing a
sorted list of <literal>String</literal> objects read from input. Thus far we have
captured the lines into a linked list of elements, dumped these elements
into an array of the right size, and then sorted the array. An
alternative solution is to insert the elements into the linked list at
the right point in the first place.</simpara>
<simpara>ProgramÂ <xref linkend="program:SortedLinkedList"/> is a version of a linked list that
inserts elements into the linked list in sorted order. The only
significant difference between it and the previous implementations of a
linked list is its <literal>add()</literal> method. This method walks down the linked
list, starting at <literal>head</literal>, until it either walks off the end of the list
or finds an element before which the new <literal>String</literal> should go. There are
special cases that must be handled to make this process work correctly.</simpara>
<variablelist>
<varlistentry>
<term>Empty list</term>
<listitem>
<simpara>The first time an item is inserted into a linked list, the <literal>head</literal> and
<literal>tail</literal> fields must be set to reference this new node. The <literal>next</literal> field
of the new node is <literal>null</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Insert at beginning</term>
<listitem>
<simpara>If a node is inserted at the beginning of the list, the <literal>head</literal> must be
updated to point to this new node. The <literal>next</literal> field of the new node is
set to the old value of <literal>head</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Insert in middle</term>
<listitem>
<simpara>To insert a node in the middle of a linked list, it is typically
necessary to maintain two variables to reference the <literal>current</literal> and
<literal>previous</literal> nodes while walking down the list. Once the proper
insertion point is found (between the <literal>previous</literal> and <literal>current</literal> nodes),
the <literal>next</literal> field for the <literal>previous</literal> node is adjusted to reference the
new node, and <literal>next</literal> field for the new node is set to <literal>current</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Insert at end</term>
<listitem>
<simpara>If the insertion is taking place at the end of the list, <literal>current</literal> is
<literal>null</literal>, and the new node has a <literal>next</literal> field of <literal>null</literal>. However, the
<literal>tail</literal> field must be updated to reference the new node.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara xml:id="program:SortedLinkedList" xreflabel="SortedLinkedList">
<title>A linked list class in which calling the <literal>add()</literal> method inserts each value in sorted order.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class SortedLinkedList {
    private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;
    private Node tail = null;
    private int size = 0;

    public void add( String value ) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = null;

    	if( head == null )
    		//empty list
    		head = tail = temp;
    	else if( value.compareTo( head.value ) &lt; 0 ) {
    		//insert at beginning
    		temp.next = head;
    		head = temp;
    	}
    	else {
    		//insert at middle or end
    		Node previous = head;
    		Node current = head.next;

    		while( current != null &amp;&amp;
    			value.compareTo( current.value ) &gt;= 0 ) {
    			previous = current;
    			current = current.next;
    		}

    		previous.next = temp;
    		temp.next = current;

    		if( current == null ) //insert at end of list
    			tail = temp;
    	}
    	size++;
    }

    public int size() {
    	return size;
    }

    public void fillArray(String[] array) {
    	Node temp = head;
    	int position = 0;
    	while( temp != null ) {
    		array[position++] = temp.value;
    		temp = temp.next;
    	}
    }
}</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="_syntax_abstract_data_types_adt">
<title>Syntax: Abstract data types (ADT)</title>
<simpara>We&#8217;ve seen two examples so far of dynamic data structures: dynamic
arrays and linked lists. A great deal of complexity can go on inside
these data structures, but code that uses these data structures does not
need to be aware of the details of the internal implementation. Ideally,
user programs could use any data structure that provided the needed set
of operations.</simpara>
<simpara>Our dynamic array and linked list classes were simple examples of
abstract data types (ADT). We continue to design data structures that
hide the details of their implementation inside a class. The user of
each class is aware of the operations (public methods) that can be
performed on objects of the class, but not on the techniques used to
implement those operations. Defining an ADT without regard to an
implementation keeps users of the ADT from becoming dependent on details
of any particular implementation. It gives maximum freedom to the
programmer to choose (and change) the implementation as appropriate for
the overall system design.</simpara>
<simpara>We generalize a data structure by observing which operations are applied
to it. Then, we create an abstraction that formalizes these
observations. The idea is to cleanly separate the use and behavior of
the data structure from the way in which it is implemented.</simpara>
<simpara>Interfaces are the obvious tool for defining the behavior of a class in
Java without specifying its implementation. When defining an ADT in
Java, the set of operations becomes the set of methods given by the
interface. Then, any class that implements the ADT must implement the
interface that defines that ADT.</simpara>
<simpara>In subsequent sections we look at two fundamental abstract data types,
<emphasis>stacks</emphasis> and <emphasis>queues</emphasis>, and sample classes that implement them.</simpara>
<section xml:id="_stacks">
<title>Stacks</title>
<simpara>We have already used stacks to solve problems in
ChapterÂ <xref linkend="chapter:Classes"/>. Recall that a stack data structure behaves
like a stack of books on your desk. When you place a book on the stack
it covers the books that are already there. When you take a book off the
stack, you remove the book most recently placed there, exposing the one
beneath it.</simpara>
<simpara>You can find a simple implementation of a stack in the solution to the
infix conversion problem in SectionÂ <xref linkend="solution:Infix_conversion"/>, but
we now examine the stack more deeply as an archetypal ADT. A stack&#8217;s
restricted set of operations (pushing and popping) is adequate for many
tasks and can be implemented in a number of different ways, some more
efficient than others.</simpara>
<simpara>The acronym FILO (first in, last out) is sometimes used to describe a
stack. The last item that has been pushed onto the stack is the first
item to be popped off the stack. In the next section, we&#8217;ll study the
<emphasis>queue</emphasis>, which is a FIFO (first in, first out) data structure.</simpara>
</section>
<section xml:id="_abstract_data_type_operations_on_a_stack">
<title>Abstract Data Type: Operations on a stack</title>
<simpara>There are two essential operations on a stack abstract data type
(corresponding to placing a book on the pile and removing it): <literal>push()</literal>
and <literal>pop()</literal>. We also define two additional operations, <literal>top()</literal> and
<literal>isEmpty()</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>push(x)</literal>:</emphasis> Push value <literal>x</literal> onto the stack.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>pop()</literal>:</emphasis> Pop the value on the top of the stack, and return its
value.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>top()</literal>:</emphasis> Return the value on the top of the stack, but do not pop it
off.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>isEmpty()</literal>:</emphasis> Return <literal>true</literal> if the stack is empty, <literal>false</literal> otherwise.</simpara>
</listitem>
</itemizedlist>
<simpara>Because a stack is an abstract data type, we are not specifically
concerned with <emphasis role="strong">how</emphasis> these operations are implemented, merely that they
are. Thus, we can specify an interface called <literal>Stack</literal> that requires
these four methods.</simpara>
<formalpara xml:id="program:Stack" xreflabel="Stack">
<title>An interface specifying the stack ADT.</title>
<para>
<programlisting language="java" linenumbering="numbered">public interface Stack {
	void push(String value);
	String pop();
	String top();
	boolean isEmpty();
}</programlisting>
</para>
</formalpara>
<section xml:id="_linked_list_implementation">
<title>Linked list implementation</title>
<simpara>All the operations defined by the stack ADT (and interface) are
implemented as methods in the class <literal>LinkedListStack</literal>, shown in
ProgramÂ <xref linkend="program:LinkedListStack"/>.</simpara>
<formalpara xml:id="program:LinkedListStack" xreflabel="LinkedListStack">
<title>A class to implement a stack ADT using a linked list.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class LinkedListStack implements Stack {
	private static class Node {
        public String value;
        public Node next;
    }

	private Node head = null;

	public void push(String value) {
		Node temp = new Node();
		temp.value = value;
		temp.next = head;
		head = temp;
	}

	public String pop() {/*@\label{linePop}@*/
		String value = null;
		if (isEmpty())
			System.out.println("Can't pop empty stack!");
		else {
			value = head.value;
			head = head.next;
		}
		return value;
	}

	public String top() {/*@\label{lineTop}@*/
		String value = null;
		if (isEmpty())
			System.out.println("No top on an empty stack!");
		else
			value = head.value;
		return value;
	}

	public boolean isEmpty() {
		return head == null;
	}
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>head</literal> field is used to maintain a reference to the linked list that
defines the stack. It is initialized to <literal>null</literal>.</simpara>
<simpara>The method <literal>push()</literal> must create a new node for the linked list and push
it onto the front of the list. It does so by creating a new <literal>Node</literal>,
setting its <literal>value</literal> field to the incoming <literal>value</literal>, and pointing its
<literal>next</literal> pointer to the beginning of the list, stored by <literal>head</literal>. Since
<literal>temp</literal> is now the new top of the stack, <literal>head</literal> is made to point at it.</simpara>
<simpara>The <literal>pop()</literal> method needs to return the <literal>value</literal> of the <literal>head</literal> node and
remove that node from the linked list. It does this by replacing the
<literal>head</literal> node with the node pointed at by the <literal>next</literal> link in <literal>head</literal>. The
<literal>pop()</literal> method from the simpler stack used in the solution to the nested
expressions problem in SectionÂ <xref linkend="solution:Nested_expressions"/> merely
removed the top and did not return the value. Most real-world stack
implementations of <literal>pop()</literal> <emphasis role="strong">do</emphasis> return this value, giving programmers
more flexibility.</simpara>
<simpara>Note that both <literal>pop()</literal> and <literal>top()</literal> print an error message if the stack
is empty. Other more elaborate error handling is possible, for example,
by throwing an exception.</simpara>
</section>
<section xml:id="_dynamic_array_implementation">
<title>Dynamic array implementation</title>
<simpara>Like the dynamic array example of ProgramÂ <xref linkend="program:UseDynamicArray"/>,
ProgramÂ <xref linkend="program:DynamicArrayStack"/> implements a stack of <literal>String</literal>
values using a dynamic array data structure.</simpara>
<formalpara xml:id="program:DynamicArrayStack" xreflabel="DynamicArrayStack">
<title>Program illustrating a stack ADT partially implemented using a dynamic array.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;

public class DynamicArrayStack implements Stack {
	private String[] strings = new String[10];
	private int size = 0;

	public void push(String string) {
		if( size == strings.length )
			doubleArray();
		strings[size++] = string;
	}

	public String pop() {
		String value = null;
		if (size == 0)
			System.out.println("Can't pop empty stack!");
		else
			value = strings[--size];
		return value;
	}

	private void doubleArray() {
		strings = Arrays.copyOfRange(strings, 0, strings.length*2);
	}
}</programlisting>
</para>
</formalpara>
<simpara>This stack implementation using a dynamic array omits the <literal>top()</literal> and
<literal>isEmpty()</literal> methods (causing a compiler error in
ProgramÂ <xref linkend="program:DynamicArrayStack"/> until the <literal>Stack</literal> interface is
properly implemented). ExerciseÂ <xref linkend="exercise:implementDASMethods"/> has you
provide implementations of these methods.</simpara>
<example>
<title>Postfix computation</title>
<simpara>At the beginning of the chapter, we introduced the problem of converting
an expression from infix to postfix notation. In
SectionÂ <xref linkend="solution:Infix_conversion"/>, we give the solution to this
problem, but without a program that can evaluate a postfix expression,
the conversion tool is not very useful.</simpara>
<simpara>Here we give a simple postfix evaluator. Recall the algorithm: Scan the
input expression from left to right, if you see a number, put it on the
stack. If you see an operator, pop the last two operands off the stack
and use the operator on them. Then, push the result back on the stack.
When you run out of input, the value at the top of the stack is your
answer.</simpara>
<simpara>Like the infix to postfix converter, we restrict our input to positive
integers of a single digit. To make this program simpler, we introduce
two new classes that are also useful in our infix to postfix converter.
The first is <literal>Term</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Term {
    private int value;
    public Term( int value ) { this.value = value; }
    public int getValue() { return value; }
}</programlisting>
<simpara>This class allows us to hold an <literal>int</literal> value. Although its structure is
simple, we update the definition of <literal>Term</literal> later in the solution to the
infix to postfix conversion problem. By doing so, we can keep exactly
the same definition for <literal>TermStack</literal> given next.</simpara>
<formalpara xml:id="program:TermStack" xreflabel="TermStack">
<title>Class to manage a stack of <literal>Term</literal> objects.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class TermStack {
	private static class Node {
        public Term value;
        public Node next;
    }

	private Node head = null;

	public void push( Term value ) {
		Node temp = new Node();
		temp.value = value;
		temp.next = head;
		head = temp;
	}

	public Term pop() {
		Term value = null;
		if (isEmpty())
			System.out.println("Can't pop empty stack!");
		else {
			value = head.value;
			head = head.next;
		}
		return value;
	}

	public Term top() {
		Term value = null;
		if (isEmpty())
			System.out.println("No top on an empty stack!");
		else
			value = head.value;
		return value;
	}

	public boolean isEmpty() {
		return head == null;
	}
}</programlisting>
</para>
</formalpara>
<simpara>This class gives a linked list implementation of a stack. In fact, it is
virtually identical to ProgramÂ <xref linkend="program:LinkedListStack"/> with the
substitution of <literal>Term</literal> for <literal>String</literal>.</simpara>
<formalpara xml:id="program:PostfixCalculator" xreflabel="PostfixCalculator">
<title>Program to evaluate a postfix expression.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class PostfixCalculator {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		String expression = in.nextLine();
		TermStack stack = new TermStack();
		for( int i = 0; i &lt; expression.length(); i++ ) {
			char term = expression.charAt(i);
			if(  term &gt;= '0'&amp;&amp; term &lt;= '9' )
				stack.push( new Term( (int)(term - '0')) );
			else {
				int b = stack.pop().getValue();
				int a = stack.pop().getValue();
				switch( term ) {
					case '+': stack.push( new Term( a + b ) );
						break;
					case '-': stack.push( new Term( a - b ) );
						break;
					case '*': stack.push( new Term( a * b ) );
						break;
					case '/': stack.push( new Term( a / b ) );
						break;
				}
			}
		}
		System.out.println("The answer is: " +
				stack.top().getValue());
	}
}</programlisting>
</para>
</formalpara>
<simpara>With our utility classes in place, the code for the postfix evaluator is
short. Our <literal>main()</literal> method reads in the expression from the user and
creates a <literal>TermStack</literal> called <literal>stack</literal>. Then, it iterates through the
expression with a <literal>for</literal> loop. For each number we find, we supply it as
an argument to the constructor of a new <literal>Term</literal> object, which we push
onto <literal>stack</literal>.</simpara>
<simpara>For each operator, we pop two items off <literal>stack</literal> and apply the operator
to them. We create a new <literal>Term</literal> from the result and push this value onto
<literal>stack</literal>. Finally, after all input is exhausted, we print the value on
the top of <literal>stack</literal>. To test it properly, you have to supply expressions
in postfix form. Also, remember that these operations are all integer
operations without fractional parts. Be careful to avoid division by
zero!.</simpara>
</example>
</section>
</section>
<section xml:id="_queues">
<title>Queues</title>
<simpara>A <emphasis>queue</emphasis> data structure is similar to a stack data structure, except
that when getting an item from a queue, the item that has been in the
queue longest is the one retrieved. A queue data structure models an
ordinary queue or line of people. The first person into the queue or
line at a bank, for example, is the first one to receive service. Late
comers are served in the order in which they arrive.</simpara>
<simpara>A queue is sometimes called a FIFO (first in, first out) data structure
due to this property. To distinguish the operations on a queue from
those on a stack, we use the terms enqueue and dequeue instead of push
and pop.</simpara>
</section>
<section xml:id="_abstract_data_type_operations_on_a_queue">
<title>Abstract Data Type: Operations on a queue</title>
<simpara>Four typical operations on a queue data structure are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>enqueue(x)</literal>:</emphasis> Put value <literal>x</literal> onto the end of the queue.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>dequeue()</literal>:</emphasis> Remove and return the value at the front of the queue,
that is, the value that has been on the queue the longest.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>front()</literal>:</emphasis> Return (but do not remove) the value at the front of the
queue.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>isEmpty()</literal>:</emphasis> Return <literal>true</literal> if the queue is empty, <literal>false</literal> otherwise.</simpara>
</listitem>
</itemizedlist>
<simpara>As with stacks, we can specify an interface called <literal>Queue</literal> that requires
these four methods.</simpara>
<formalpara xml:id="program:Queue" xreflabel="Queue">
<title>An interface specifying the queue ADT.</title>
<para>
<programlisting language="java" linenumbering="numbered">public interface Queue {
	void enqueue(String value);
	String dequeue();
	String front();
	boolean isEmpty();
}</programlisting>
</para>
</formalpara>
<section xml:id="_linked_list_implementation_2">
<title>Linked list implementation</title>
<simpara>ProgramÂ <xref linkend="program:LinkedListQueue"/> shows an implementation of the queue
ADT operations using a linked list. Because we need to keep track of
nodes at both ends of the linked list, we maintain <literal>head</literal> and <literal>tail</literal>
variables to reference these nodes. The <literal>enqueue()</literal> and <literal>dequeue()</literal>
methods manipulate these variables to manage the queue as values are put
onto it and removed from it.</simpara>
<formalpara xml:id="program:LinkedListQueue" xreflabel="LinkedListQueue">
<title>Program illustrating a queue ADT implemented using a linked list.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class LinkedListQueue implements Queue {
	private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;
    private Node tail = null;

	public void enqueue(String value) {/*@\label{linePutQueue}@*/
		Node temp = new Node();
		temp.value = value;
		temp.next = null;

		if( isEmpty() )
			head = tail = temp; /*@\label{lineNewLLN}@*/
		else {
			tail.next = temp;
			tail = temp;
		}
	}

	public String dequeue() {
		String value = null;
		if( isEmpty() )
			System.out.println("Can't dequeue an empty queue!");
		else {
			value = head.value;
			head = head.next;
			if( head == null )
				tail = null;
		}
		return value;
	}

	public String front() {
		String value = null;
		if( isEmpty() )
			System.out.println("No front on an empty queue!");
		else
			value = head.value;
		return value;
	}

	public boolean isEmpty() {
		return head == null;
	}
}</programlisting>
</para>
</formalpara>
<simpara>Note that the implemention of the <literal>LinkedListQueue</literal> class is very
similar to the implementation of the <literal>LinkedListWithTail</literal> class. The
<literal>enqueue()</literal> method in the former is almost identical to the <literal>addLast()</literal>
method in the latter.</simpara>
</section>
</section>
</section>
<section xml:id="_advanced_generic_data_structures">
<title>Advanced: Generic data structures</title>
<simpara>Most of the dynamic data structures we have seen in this chapter store
values of type <literal>String</literal>. We explore dynamic arrays of <literal>String</literal> values,
linked lists of <literal>String</literal> objects, queues of <literal>String</literal> objects, and stacks
of <literal>String</literal> objects. In ExampleÂ <xref linkend="example:Postfix_computation"/>, we
create the stack class <literal>TermStack</literal> to hold <literal>Term</literal> objects, but
<literal>TermStack</literal> is identical to the existing <literal>LinkedListStack</literal> class with
the substitution of <literal>Term</literal> for <literal>String</literal>.</simpara>
<simpara>What if you wanted to store values of some other type in these data
structures? What if you wanted a stack of <literal>int</literal> values or a queue of
<literal>Thread</literal> objects? You might think that you need to create a distinct but
similar implementation of each ADT for each type, as we do in
ExampleÂ <xref linkend="example:Postfix_computation"/>.</simpara>
<simpara>One possible solution is to take advantage of the fact that a variable
of type <literal>Object</literal> can hold a reference to a value of any reference type
(since all classes are subtypes of <literal>Object</literal>). If we create data
structures using <literal>Object</literal> as the underlying type, we can store values of
any type in the data structure. For example,
ProgramÂ <xref linkend="program:ObjectStack"/> is an implementation of a stack ADT with
an underlying data type of <literal>Object</literal>.</simpara>
<formalpara xml:id="program:ObjectStack" xreflabel="ObjectStack">
<title>A class that implements a stack of <literal>Object</literal> references.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class ObjectStack {
	private static class Node {
        public Object value;
        public Node next;
    }

	private Node head = null;

	public void push(Object value) {
		Node temp = new Node();
		temp.value = value;
		temp.next = head;
		head = temp;
	}

	public Object pop() {
		Object value = null;
		if (isEmpty())
			System.out.println("Can't pop empty stack!");
		else {
			value = head.value;
			head = head.next;
		}
		return value;
	}

	public Object top() {
		Object value = null;
		if (isEmpty())
			System.out.println("Can't get top of empty stack!");
		else
			value = head.value;
		return value;
	}

	public boolean isEmpty() {
		return head == null;
	}
}</programlisting>
</para>
</formalpara>
<simpara>Note that a stack of <literal>Object</literal> references is an example of a
<emphasis>heterogeneous data structure</emphasis>. It is possible to put objects of
different types onto the same stack. While there are situations in which
this technique is useful, in most cases a <emphasis>homogeneous data structure</emphasis>
(where all values are of the same type) is all that is needed.
Homogeneous data structures allow type checking to occur at compile
time, thus helping to avoid run-time errors.</simpara>
<simpara>Using a stack of <literal>Object</literal> references is generally more cumbersome, since
you must cast values returned from <literal>pop()</literal> or <literal>top()</literal> to the appropriate
data type.</simpara>
<programlisting language="java" linenumbering="unnumbered">    ObjectStack stack = new ObjectStack();
    stack.push("hello");
    String s = (String)stack.pop();</programlisting>
<simpara>Without the cast to <literal>(String)</literal>, the compiler gives an error:
<literal>Type mismatch: cannot convert from Object to String</literal>.</simpara>
<simpara>Casting the returning value from a heterogeneous data structure
essentially forces type checking to move from compile-time to run-time.
Instead of having the Java compiler verify the type correctness of
operations, we force the Java virtual machine to do the check.</simpara>
<section xml:id="_generics_in_java">
<title>Generics in Java</title>
<simpara>Java provides a general facility to create classes that implement the
same basic ADT but with a different underlying data type. This mechanism
preserves the advantages of compile-time type checking and eliminates
the need for run-time casting. A <emphasis>generic class</emphasis> is a class that gives a
template for creating classes in which a placeholder for the underlying
data type can be filled in when a specific instance of that class is
created. In the case of ExampleÂ <xref linkend="example:Postfix_computation"/>, we need
a stack that can hold <literal>Term</literal> objects instead of <literal>String</literal> objects, and a
generic class allows us to create a stack of any reference type.</simpara>
<simpara>The generics facility in Java only supports underlying data types that
are reference types (such as <literal>String</literal> and user-defined types), not
primitive types (such as <literal>int</literal> or <literal>boolean</literal>). However, we can use
wrapper classes to hold primitives types. Thus, a generic stack of <literal>int</literal>
values needs to be implemented as a stack of <literal>Integer</literal> objects.
Fortunately, Java automatically converts between <literal>int</literal> and <literal>Integer</literal> in
most cases.</simpara>
<simpara>Defining a simple generic class in Java is done by appending a <emphasis>type
parameter</emphasis> within angle brackets (<literal>&lt;&gt;</literal>) to the end of the class name
being defined.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class GenericClass&lt;T&gt; {
    ...
    T transform (T item) {
        ...
    }
    ...
}</programlisting>
<simpara>This code defines a new generic class (think class template)
<literal>GenericClass</literal> with underlying type <literal>T</literal>. It includes a method
<literal>transform()</literal> that takes a value of type <literal>T</literal> and transforms it (in some
unspecified way) to another value of type <literal>T</literal>.</simpara>
<simpara>To use a generic class properly, you must create instances of it
specifying the underlying type. In actual fact, the compiler fills in
the appropriate type at compile time. The compiler must make sure that
all the operations are valid with the supplied type substituted for the
type parameter (<literal>T</literal> in this example).</simpara>
<simpara>For example, to create and use an instance of <literal>GenericClass</literal> with
underlying type <literal>String</literal>, you would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">GenericClass&lt;String&gt; genericString = new GenericClass&lt;String&gt;();
String s = generic.transform("hello");</programlisting>
<simpara>Because this use of the <literal>GenericClass</literal> class is defined for underlying
type <literal>String</literal>, no casting is necessary to assign the result of the
<literal>transform()</literal> method to the <literal>String</literal> variable <literal>s</literal>.</simpara>
<simpara>To create and use an instance of <literal>GenericClass</literal> with underlying type
<literal>Integer</literal>, you would type:</simpara>
<programlisting language="java" linenumbering="unnumbered">GenericClass&lt;Integer&gt; genericInteger = new GenericClass&lt;Integer&gt;();
int i = generic.transform(27);</programlisting>
<simpara>The same definition of <literal>GenericClass</literal> is used in both instances with
different underlying data types <emphasis role="strong">and</emphasis> the compiler is able to verify at
compile time that the uses are type safe.</simpara>
<simpara>If you omit the underlying type when declaring a generic variable or
creating an instance of a generic type, the compiler uses <literal>Object</literal> as
the underlying type. This use, called a <emphasis>raw type</emphasis>, is essentially like
not using generics at all. There is no compile-time type checking, and
references must be cast as needed.</simpara>
<programlisting language="java" linenumbering="unnumbered">GenericClass genericRaw = new GenericClass(); // raw type
int i = (Integer) genericRaw.transform(27); // cast needed</programlisting>
<simpara>The next two examples illustrate defining generic classes in Java.</simpara>
<example>
<title>Defining a generic linked list</title>
<simpara>ProgramÂ <xref linkend="program:GenericLinkedList"/> defines a generic version of the
<literal>LinkedList</literal> class shown earlier. Note that it is necessary to include
the type parameter <literal>T</literal> on the outer class as well as the nested class
<literal>Node</literal>.</simpara>
<formalpara xml:id="program:GenericLinkedList" xreflabel="GenericLinkedList">
<title>A class that implements a generic linked list.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class GenericLinkedList&lt;T&gt; {
    private static class Node&lt;T&gt; {
        public T value;
        public Node&lt;T&gt; next;
    }

    private Node&lt;T&gt; head = null;
    private int size = 0;

    public void add(T value) {
    	Node&lt;T&gt; temp = new Node&lt;T&gt;();
    	temp.value = value;
    	temp.next = head;
    	head = temp;
    	size++;
    }

    public int size() {
    	return size;
    }

    public void fillArray(T[] array) {
    	Node&lt;T&gt; temp = head;
    	int position = 0;
    	while( temp != null ) {
    		array[position++] = temp.value;
    		temp = temp.next;
    	}
    }
}</programlisting>
</para>
</formalpara>
<simpara>Using generics can be very easy, but there are some oddities. In
particular, there are problems instantiating arrays with generic types.
The <literal>fillArray()</literal> method works because it never creates the array, only
fills it.</simpara>
</example>
</section>
<section xml:id="_using_a_generic_class">
<title>Using a Generic Class</title>
<simpara>Creating an instance of a generic class is similar to creating an
instance of a regular class, except that (to avoid warnings) you must
specify the missing type (or types) used to parameterize the generic
class. For example, if you want to create an instance of the
<literal>GenericClass&lt;T&gt;</literal> class, you must specify the type <literal>T</literal>, for example
<literal>new GenericClass&lt;String&gt;()</literal>.</simpara>
<simpara>ProgramÂ <xref linkend="program:UseGenericLinkedList"/> uses the generic class
<literal>GenericLinkedList</literal> parameterized by <literal>String</literal> to re-implement
ProgramÂ <xref linkend="program:UseLinkedList"/>.</simpara>
<formalpara xml:id="program:UseGenericLinkedList" xreflabel="UseGenericLinkedList">
<title>Program that uses the generic class <literal>GenericLinkedList</literal> to create and use a linked list of Strings.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Arrays;
import java.util.Scanner;

public class UseGenericLinkedList {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        GenericLinkedList&lt;String&gt; list =
        	new GenericLinkedList&lt;String&gt;();

        while( in.hasNextLine() )
            list.add( in.nextLine() );

		String[] names = new String[list.getSize()];
		list.fillArray(names);

        Arrays.sort(names);

        for (int i = 0; i &lt; names.length; i++)
            System.out.println(names[i]);
    }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_using_java_libraries">
<title>Using Java Libraries</title>
<simpara>Many of the Java library classes use generics to make them more general
purpose. The <literal>java.util</literal> package includes many classes to implement
stacks, queues, dynamic arrays, sets, and other useful data structures.
These classes are parameterized so that they can be created with
different underlying types. We illustrate three examples here: <literal>Vector</literal>,
<literal>ArrayList</literal>, and <literal>HashMap</literal>. Note that there is also a <literal>LinkedList</literal>
class, which is a great deal more powerful than the <literal>LinkedList</literal> class
defined in this chapter. Any class that implements the <literal>Iterable</literal>
interface can be used in the for-each loops described in
SectionÂ <xref linkend="subsection:The_for-each_loop"/>. The <literal>ArrayDeque</literal>, <literal>ArrayList</literal>,
<literal>HashSet</literal>, <literal>TreeSet</literal>, and <literal>Vector</literal>, classes all implement <literal>Iterable</literal>. In
our examples, a <literal>Vector</literal> object and a <literal>Set</literal> (returned by the
<literal>entrySet()</literal> method of a <literal>HashMap</literal>) are used as targest of for-each
loops.</simpara>
<example>
<title>Vectors</title>
<simpara>A <literal>Vector</literal> (<literal>java.util.Vector</literal>) implements an array of objects that can
grow at run time. The array is automatically extended whenever an
attempt is made to store an item exactly one location beyond the last
element. Unlike a linked list, <literal>Vector</literal> elements can be efficiently
accessed in any order (by specifying the index, just like an ordinary
array). Elements can be inserted into the middle of the <literal>Vector</literal>,
causing following elements to be pushed back to later indexes. Arbitrary
elements can also be deleted from the <literal>Vector</literal> using the <literal>remove()</literal>
method.</simpara>
<simpara>ProgramÂ <xref linkend="program:VectorExample"/> illustrates a use of the <literal>Vector</literal>
class. The program creates an empty <literal>Vector</literal> and generates random
integers between 1 and 10, appending them to the end of the vector,
until their sum is at least 100. Then, it prints the integers and their
sum (including how many were generated).</simpara>
<formalpara xml:id="program:VectorExample" xreflabel="VectorExample">
<title>A simple program to illustrate the use of the Vector class.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Random;
import java.util.Vector;

public class VectorExample {
	public static void main(String[] args) {
		Random random = new Random();

		Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;();

		int sum = 0;
		while (sum &lt; 100) {
			int n = random.nextInt(10) + 1;
			vector.add(n);  // append n to end of vector
			sum += n;
		}

		for( int n : vector )
			System.out.format("%3d\n", n);
		System.out.println("---");
		System.out.format("%3d (%d values)\n", sum, vector.size());
	}
}</programlisting>
</para>
</formalpara>
<simpara>Output from a typical run of ProgramÂ <xref linkend="program:VectorExample"/> is shown
below:</simpara>
<programlisting language="java" linenumbering="unnumbered">  9
  9
  8
  7
  7
  4
  7
  6
  8
  7
  9
  4
  9
 10
---
104 (14 values)</programlisting>
</example>
<example>
<title>Maps</title>
<simpara>The <literal>HashMap</literal>(<literal>java.util.HashMap</literal>) is a very useful, general-purpose
data structure that maintains a dictionary of entries. A dictionary
associates unique keys with values. You can think of it as <emphasis>mapping</emphasis> a
<emphasis>key</emphasis> to a <emphasis>value</emphasis>. In the Java <literal>HashMap</literal> class, keys and values can be
arbitrary Java classes.</simpara>
<simpara>ProgramÂ <xref linkend="program:HashMapExample"/> reads a sequence of lines containing
names and ages (for simplicity, the name is one word and the age is a
simple integer). It stores these (name, age) pairs in a
<literal>HashMap&lt;String,Integer&gt;</literal> data structure. Once all the input is read
(<literal>in.hasNext()</literal> returns <literal>false</literal>), the program prints all the keys
(names), then all the values (ages), and finally it prints the names and
ages of each person in the input file.</simpara>
<formalpara xml:id="program:HashMapExample" xreflabel="HashMapExample">
<title>A program that illustrates using a <literal>HashMap</literal> dictionary to store a set of names and ages.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class HashMapExample {
	public static void main(String[] args) {
		HashMap&lt;String,Integer&gt; map =
			new HashMap&lt;String,Integer&gt;();

		Scanner in = new Scanner(System.in);
		while( in.hasNext() ) {
			String name = in.next();
			int age = in.nextInt();
			map.put(name, age);
		}

		System.out.format("Keys\n");
		for( String name : map.keySet() )
			System.out.println("\t" + name);

		System.out.println("Values");
		for( int age : map.values() )
			System.out.println("\t" + age);

		for( Map.Entry&lt;String, Integer&gt; entry : map.entrySet() ) {
			System.out.format(entry.getKey() + " -&gt; " +
							  entry.getValue());
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>Shown below is the output for a simple input file.</simpara>
<programlisting language="java" linenumbering="unnumbered">Keys
    kathy
    martha
    fred
    henway
    michael
    henry
    john
    margarette
    edward
    tim
    hamcost
Values
    60
    22
    15
    1
    21
    31
    23
    57
    12
    57
    2
kathy -&gt; 60
martha -&gt; 22
fred -&gt; 15
henway -&gt; 1
michael -&gt; 21
henry -&gt; 31
john -&gt; 23
margarette -&gt; 57
edward -&gt; 12
tim -&gt; 57
hamcost -&gt; 2</programlisting>
</example>
</section>
</section>
<section xml:id="_solution_infix_conversion">
<title>Solution: Infix conversion</title>
<simpara>Here we give our solution to the infix conversion problem from the
beginning of the chapter. As in ExampleÂ <xref linkend="example:Postfix_computation"/>,
we use a stack of <literal>Term</literal> objects to solve the problem. However, we
expand the <literal>Term</literal> class to hold both operands and operators. We only add
methods and fields to the earlier definition, taking nothing away. In
this way, we should be able to use the <literal>Term</literal> class for both infix to
postfix conversion and postfix calculation.</simpara>
<programlisting language="java" linenumbering="numbered">public class Term {
	private int value;
	private char operator;
	private boolean isOperator;</programlisting>
<simpara>Here we have augmented the earlier <literal>Term</literal> class by adding two more
fields, a <literal>char</literal> called <literal>operator</literal> to hold an operator and a <literal>boolean</literal>
called <literal>isOperator</literal> to keep track of whether or not our <literal>Term</literal> object
holds an operator or an operand.</simpara>
<programlisting language="java" linenumbering="numbered">	public Term( int value ) {
		this.value = value;
		isOperator = false;
	}

	public Term( char operator ) {
		this.operator = operator;
		isOperator = true;
	}</programlisting>
<simpara>We now have two constructors. The first one takes an <literal>int</literal> value and
stores it into <literal>value</literal>, setting <literal>isOperator</literal> to <literal>false</literal> to indicate that
the <literal>Term</literal> object must be an operand. The second constructor takes a
<literal>char</literal> value and stores it into <literal>operator</literal>, setting <literal>isOperator</literal> to
<literal>true</literal> to indicate that the <literal>Term</literal> object must be an operator (such as
<literal>+</literal>, <literal>-</literal>,<literal>*</literal>, or <literal>/</literal>).</simpara>
<programlisting language="java" linenumbering="numbered">	public int getValue() {	return value; }
	public char getOperator() { return operator; }
	public boolean isOperator() { return isOperator; }</programlisting>
<simpara>These three accessors give back the operand value, the operator
character, and whether or not the object is an operator, respectively.
This solution is not necessarily the most elegant from an OOP
perspective. The code that uses a <literal>Term</literal> object needs to chose the
<literal>getValue()</literal> method or the <literal>getOperator()</literal> method depending on whether
the <literal>Term</literal> is an operator or not. This design opens up the possibility
that some code will call the wrong accessor method and get a useless
default value.</simpara>
<programlisting language="java" linenumbering="numbered">	public boolean greaterOrEqual(Term term) {
		if( isOperator() )
			switch( operator ) {
				case '*':
				case '/': return true;
				case '+':
				case '-':
				return (term.operator != '*' &amp;&amp;
						term.operator != '/');
				default: return false;
			}
		else
			return false;
	}
}</programlisting>
<simpara>The most complicated addition to the <literal>Term</literal> class is the
<literal>greaterOrEqual()</literal> method, which takes in another <literal>Term</literal> object. This
method compares the operator of the <literal>Term</literal> object being called with the
one that is being passed in as a parameter. Because this method is in
the <literal>Term</literal> class, it can access the <literal>private</literal> variables of the <literal>term</literal>
parameter. This method returns <literal>true</literal> if the operator of the called
object has a greater or equal precedence compared to the operator of the
parameter object. The meat of the method is the <literal>switch</literal> statement that
establishes the high precedence of <literal>*</literal> and <literal>/</literal>, the medium precedence of
<literal>+</literal> and <literal>-</literal>, and the low precedence of anything else, namely the left
parenthesis <literal>(</literal>.</simpara>
<simpara>With this updated <literal>Term</literal> class, we can create <literal>Term</literal> objects that hold
either an operator or an operand and allow the precedence of operators
to be compared. We use exactly the same <literal>TermStack</literal> class from
ExampleÂ <xref linkend="example:Postfix_computation"/> for our stack. All that remains
is the client code that parses the input.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.*;

public class InfixToPostfix {
	public static void main(String[] args) {
		Scanner in = new Scanner( System.in );
		String expression = in.nextLine();
		TermStack stack = new TermStack(expression.length());
		String postfix = "";
		char term;</programlisting>
<simpara>The <literal>main()</literal> method of this class reads in the input expression and
creates a <literal>TermStack</literal> called <literal>stack</literal> with a maximum size of the length
of the expression. We also declare a <literal>String</literal> called <literal>postfix</literal> to hold
the output.</simpara>
<programlisting language="java" linenumbering="numbered">		for( int i = 0; i &lt; expression.length(); i++ ) {
			term = expression.charAt(i);
			if( term &gt;= '0' &amp;&amp; term &lt;= '9' )
				postfix += term;
			else if( term == '(' )
					stack.push( new Term( term ));
			else if( term == ')' ) {
				while( stack.top().getOperator() != '(' ) {
					postfix += stack.top().getOperator();
					stack.pop();
				}
				stack.pop(); //pop off the '('
			}
			else if( term == '*' || term == '/' ||
				 term == '+' || term == '-' ) {
				Term operator = new Term( term );
				while( stack.size() &gt; 0 &amp;&amp;
					stack.top().greaterOrEqual( operator ) ) {
					postfix += stack.top().getOperator();
					stack.pop();
				}
				stack.push( operator );
			}
		}</programlisting>
<simpara>This <literal>for</literal> loop runs through each <literal>char</literal> in the input expression and
applies the four rules given in the description of the infix conversion
problem. If a term is an operand, it is added to the output. If a term
is a left parenthesis, it is pushed onto the stack. If a term is a right
parenthesis, all the terms on the stack are popped off and added to the
output until a left parenthesis is reached. If a term is a normal
operator, the top of the stack is repeatedly popped and added to output
as long as it has a precedence greater than or equal to the new
operator. The complexity of doing this precedence comparison is now
tucked away inside of the <literal>Term</literal> class.</simpara>
<programlisting language="java" linenumbering="numbered">		while( stack.size() &gt; 0 ) {
			postfix += stack.top().getOperator();
			stack.pop();
		}
		System.out.println(postfix);
	}
}</programlisting>
<simpara>After the input has all been consumed, we pop all the elements off the
stack and add them to the output. Finally, we print the output. The
output to this program could be used as the input to the postfix
evaluator program from ExampleÂ <xref linkend="example:Postfix_computation"/>. A more
complex program that did both the conversion and the calculation might
want to store everything in <literal>Term</literal> objects instead of outputting a
<literal>String</literal> and then recreating <literal>Term</literal> objects.</simpara>
</section>
<section xml:id="_concurrency_linked_lists_and_thread_safety">
<title>Concurrency: Linked lists and thread safety</title>
<simpara>The implementations of stacks and queues in the previous sections are
<emphasis role="strong">not</emphasis> thread-safe. If multiple threads use a stack or queue object
simultaneously, the <literal>head</literal> or <literal>tail</literal> pointers can become inconsistent or
be updated incorrectly, potentially causing the stack or queue to lose
elements. As you have seen, multiple threads operating on the same data
can produce unexpected results.</simpara>
<simpara>ProgramÂ <xref linkend="program:UseLinkedListQueue"/> is a simple multi-threaded
program to test (and break!) the thread safety of the queue
implementation in ProgramÂ <xref linkend="program:LinkedListQueue"/>. This program
(<xref linkend="program:UseLinkedListQueue"/>) creates a queue and stores a reference
to it in a static (class) variable <literal>queue</literal>. It then creates and starts
10 threads. During the adding phase (indicated by <literal>adding</literal> being
<literal>true</literal>), each thread adds its thread ID number to the queue and prints
it to standard output. Then, the program joins the threads until each
has finished. The program then ends the adding phase (by setting the
boolean variable <literal>adding</literal> to <literal>false</literal>) and starts 10 more threads. These
threads each read one value from the queue and print it to standard
output.</simpara>
<formalpara xml:id="program:UseLinkedListQueue" xreflabel="UseLinkedListQueue">
<title>Program to test the queue implementation, including its thread safety.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class UseLinkedListQueue extends Thread {
	private static final int THREADS = 10;
	private static LinkedListQueue queue = new LinkedListQueue();/*@\label{lineQueueRef}@*/
	private static boolean adding = true;

	public static void main(String[] args) {
		Thread[] threads = new Thread[THREADS];
		for (int i = 0; i &lt; THREADS; i++) {
			threads[i] = new UseLinkedListQueue();
			threads[i].start();/*@\label{lineStart10a}@*/
		}

		for (int i = 0; i &lt; THREADS; i++)
			try { threads[i].join(); } /*@\label{lineJoin}@*/
			catch (InterruptedException e) {}

		adding = false;

		for (int i = 0; i &lt; THREADS; i++) {
			threads[i] = new UseLinkedListQueue();
			threads[i].start();/*@\label{lineStart10b}@*/
		}

		for (int i = 0; i &lt; THREADS; i++)
			try { threads[i].join(); }
			catch (InterruptedException e) {}

		while( !queue.isEmpty() )
			System.out.println("Left in queue: ID = " +
					queue.dequeue());
	}

	public void run() {
		if( adding ) {
			long ID = Thread.currentThread().getId();
			System.out.println("Thread ID added to queue: " +
					Thread.currentThread().getId());
			queue.enqueue(String.valueOf(ID));
		}
		else {
			String ID = queue.dequeue();
			System.out.println("Thread ID removed from queue: "
					+ ID);
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>Without appropriate synchronization, the program may not correctly link
all values into the queue nor remove them at the end. A typical
error-prone output run is shown here:</simpara>
<programlisting language="java" linenumbering="unnumbered">Thread ID added to queue: 9
Thread ID added to queue: 14
Thread ID added to queue: 13
Thread ID added to queue: 12
Thread ID added to queue: 11
Thread ID added to queue: 10
Thread ID added to queue: 18
Thread ID added to queue: 17
Thread ID added to queue: 16
Thread ID added to queue: 15
Thread ID removed from queue: 14
Thread ID removed from queue: 11
Thread ID removed from queue: 12
Thread ID removed from queue: 16
Thread ID removed from queue: 17
Thread ID removed from queue: 18
Thread ID removed from queue: 10
Can't dequeue an empty queue!
Can't dequeue an empty queue!
Thread ID removed from queue: 15
Thread ID removed from queue: null
Thread ID removed from queue: null</programlisting>
<simpara>How does this implementation fail? Consider the situation in which two
threads are attempting to put a value in the queue simultaneously (see
lineÂ <xref linkend="linePutQueue"/> in ProgramÂ <xref linkend="program:LinkedListQueue"/>). Suppose
the first thread tests the queue and finds it empty (<literal>isEmpty()</literal> returns
<literal>true</literal>) but is then interrupted. If a second thread gets control it will
also see that the queue is empty then sets the <literal>head</literal> and <literal>tail</literal>
variables to the new <literal>Node</literal> object <literal>temp</literal> at lineÂ <xref linkend="lineNewLLN"/> and
return. The first thread will eventually wake up, still thinking that
the queue is empty, and also set the <literal>head</literal> and <literal>tail</literal> variables to its
own new <literal>Node</literal> <literal>temp</literal>. But these assignments overwrite the assignments
just done by the previous thread! The initial node that was in the queue
is now lost.</simpara>
<simpara>This problem can be fixed by ensuring that once one thread starts
examining and modifying queue variables, no other thread can access the
same variables until the first one is finished. As shown in
ChapterÂ <xref linkend="chapter:Synchronization"/>, this mutual exclusion can be
achieved by using the <literal>synchronized</literal> keyword on methods that need to
have exclusive access to object variables. In this queue implementation,
we need to synchronize access by threads that are using either the
<literal>enqueue()</literal> or <literal>dequeue()</literal> methods, since both methods access and
manipulate variables in the object. Although it is not called in this
program, the <literal>front()</literal> method should also be synchronized so that a
<literal>null</literal> <literal>head</literal> is not accessed accidentally. The <literal>isEmpty()</literal> method does
not need to be synchronized since the only methods that call it that can
do any harm are already synchronized. Outside code that calls
<literal>isEmpty()</literal> might get the wrong value if another thread modifies the
contents of the queue, but there is no guarantee that other threads will
not modify the state of the queue at any point after the <literal>isEmpty()</literal>
method is called anyway.</simpara>
<formalpara xml:id="program:LinkedListQueueTS" xreflabel="LinkedListQueueTS">
<title>A synchronized version of the queue class that allows thread-safe use.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class LinkedListQueueTS implements Queue {
	private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;
    private Node tail = null;

	public synchronized void enqueue(String value) {
		Node temp = new Node();
		temp.value = value;
		temp.next = null;

		if( isEmpty() )
			head = tail = temp;
		else {
			tail.next = temp;
			tail = temp;
		}
	}

	public synchronized String dequeue() {
		String value = null;
		if( isEmpty() )
			System.out.println("Can't dequeue an empty queue!");
		else {
			value = head.value;
			head = head.next;
			if( head == null )
				tail = null;
		}
		return value;
	}

	public synchronized String front() {
		String value = null;
		if( isEmpty() )
			System.out.println("No front on an empty queue!");
		else
			value = head.value;
		return value;
	}

	public boolean isEmpty() {
		return head == null;
	}
}</programlisting>
</para>
</formalpara>
<simpara>With both <literal>enqueue()</literal> and <literal>dequeue()</literal> methods synchronized as in
ProgramÂ <xref linkend="program:LinkedListQueueTS"/>, a typical output generated by the
program is shown below.</simpara>
<programlisting language="java" linenumbering="unnumbered">Thread ID added to queue: 9
Thread ID added to queue: 14
Thread ID added to queue: 12
Thread ID added to queue: 13
Thread ID added to queue: 10
Thread ID added to queue: 11
Thread ID added to queue: 18
Thread ID added to queue: 17
Thread ID added to queue: 16
Thread ID added to queue: 15
Thread ID removed from queue: 9
Thread ID removed from queue: 18
Thread ID removed from queue: 13
Thread ID removed from queue: 17
Thread ID removed from queue: 15
Thread ID removed from queue: 16
Thread ID removed from queue: 14
Thread ID removed from queue: 12
Thread ID removed from queue: 10
Thread ID removed from queue: 11</programlisting>
</section>
<section xml:id="_concurrency_thread_safe_libraries">
<title>Concurrency: Thread-safe libraries</title>
<simpara>As we mentioned in SectionÂ <xref linkend="concurrency:Objects"/>, some libraries are
thread-safe and some are not. The Java Collections Framework (JCF) is a
very useful library, but it is also a library that requires thread
safety to be at the forefront of your mind.</simpara>
<simpara>The JCF defines the <literal>Collection</literal> interface and the <literal>Map</literal> interface. The
<literal>Collection</literal> interface, which any collection of objects should
implement, has subinterfaces <literal>Set</literal>, <literal>List</literal>, and <literal>Queue</literal> which define the
basic operations in Java that are needed to implement a set, list, or
queue of items. The <literal>Map</literal> interface gives the basic operations for a
dictionary, a collection of key-value pairs, one implementation of which
is the <literal>HashMap</literal> from ExampleÂ <xref linkend="example:Maps"/>.</simpara>
<simpara>As we mentioned in ChapterÂ <xref linkend="chapter:Interfaces"/>, an interface cannot
mark a method with the <literal>synchronized</literal> keyword. Consequently, the JCF can
make no guarantee about the thread safety of a container based on which
interface it implements. The programmer must read the documentation
carefully in order to know if a container is thread-safe and react
accordingly.</simpara>
<example>
<title>ArrayList</title>
<simpara>An <literal>ArrayList</literal> is like a <literal>Vector</literal>, with essentially the same interface
but lacks synchronization. That is, if two threads attempt to insert or
remove an element from the same <literal>ArrayList</literal> at the same time, the
<literal>ArrayList</literal> internal state may become corrupt or the results may be
incorrect.</simpara>
<simpara>ProgramÂ <xref linkend="program:ArrayListExample"/> is an example of synchronizing
updates to the <literal>ArrayList</literal> class with multiple threads. The program
creates an <literal>ArrayList</literal> and places a reference to it in the static class
variable <literal>list</literal>. It then creates and starts two threads. Each thread
repeats a loop 10 times, appending a <literal>String</literal> to the <literal>ArrayList</literal> on each
iteration. To increase the likelihood of concurrent update attempts, the
thread sleeps for a millisecond on each iteration. To prevent concurrent
updates from actually happening, each thread synchronizes on the common
(shared) class variable <literal>list</literal> at lineÂ <xref linkend="aleSync"/>.</simpara>
<formalpara xml:id="program:ArrayListExample" xreflabel="ArrayListExample">
<title>Example of thread-safe use of an <literal>ArrayList</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.ArrayList;

public class ArrayListExample extends Thread {
	private static ArrayList&lt;String&gt; list;

	public static void main(String[] args) {
		Thread t1 = new ArrayListExample();
		Thread t2 = new ArrayListExample();

		list = new ArrayList&lt;String&gt;();

		t1.start();
		t2.start();

		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) { e.printStackTrace(); }

		for (String s : list)
			System.out.println(s);
	}

	public void run() {
		for (int i = 0; i &lt; 10; i++) {
			synchronized (list) {/*@\label{aleSync}@*/
				list.add(this.getName() + ": " + i);
			}
			try { Thread.sleep(1);	}
			catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara><emphasis role="strong">Without</emphasis> the <literal>synchronized</literal> keyword, a typical run, shown below,
includes a <literal>null</literal> reference in the output, indicating that the internal
<literal>ArrayList</literal> data structure was not updated correctly.</simpara>
<programlisting language="java" linenumbering="unnumbered">Thread-1: 0
Thread-0: 0
Thread-1: 1
Thread-0: 1
Thread-1: 2
Thread-0: 2
Thread-0: 3
Thread-1: 3
Thread-1: 4
Thread-0: 4
null
Thread-0: 5
Thread-1: 6
Thread-0: 6
Thread-1: 7
Thread-0: 7
Thread-1: 8
Thread-0: 8
Thread-0: 9
Thread-1: 9</programlisting>
<simpara><emphasis role="strong">With</emphasis> the <literal>synchronized</literal> keyword, each run includes exactly the same
number of entries from each thread, although the threads do not always
alternate in strict lock-step.</simpara>
<programlisting language="java" linenumbering="unnumbered">Thread-0: 0
Thread-1: 0
Thread-0: 1
Thread-1: 1
Thread-1: 2
Thread-0: 2
Thread-1: 3
Thread-0: 3
Thread-1: 4
Thread-0: 4
Thread-0: 5
Thread-1: 5
Thread-1: 6
Thread-0: 6
Thread-1: 7
Thread-0: 7
Thread-1: 8
Thread-0: 8
Thread-1: 9
Thread-0: 9</programlisting>
</example>
</section>
<section xml:id="_exercises_17">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Explain the difference between static data structures and dynamic
data structures.</simpara>
</listitem>
<listitem>
<simpara>In which situations is it better to use a dynamic array? In which
situations is it better to use a linked list? Explain why in each case.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:exceptionGeneratedExercise"/> On which line in
ProgramÂ <xref linkend="program:ReadIntoFixedArray"/> is an exception generated?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:postIncrementExercise"/> In
ProgramÂ <xref linkend="program:ReadAndGrowArray"/>, is it possible to post-increment
<literal>n</literal> inside the <literal>try</literal> clause rather than at the bottom of the <literal>while</literal>
loop?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:proveThreeQuartersFull"/> Explain why the <literal>names</literal> array in
ProgramÂ <xref linkend="program:UseDynamicArray"/> is, on average, only three-quarters
full.</simpara>
</listitem>
<listitem>
<simpara>Based on the stack implementation in
ProgramÂ <xref linkend="program:LinkedListStack"/>, draw a picture of the linked list
structure after each of the following statements.</simpara>
<programlisting language="java" linenumbering="unnumbered">    LinkedListStack stack = new LinkedListStack();
    stack.push("hello");
    stack.push("goodbye");
    stack.pop();
    stack.push("there");
    stack.push("cruel");
    stack.pop();
    stack.push("world");</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:implementDASMethods"/> Implement the methods <literal>top()</literal> and
<literal>isEmpty()</literal> for the dynamic array implementation of the stack in
ProgramÂ <xref linkend="program:DynamicArrayStack"/>.</simpara>
</listitem>
<listitem>
<simpara>Based on queue implementation in
ProgramÂ <xref linkend="program:LinkedListQueue"/>, draw a picture of the linked list
structure after each of the following statements.</simpara>
<programlisting language="java" linenumbering="unnumbered">    LinkedListStack queue = new LinkedListStack();
    stack.enqueue("hello");
    stack.enqueue("there");
    stack.enqueue("world");
    stack.dequeue();
    stack.enqueue("cruel");
    stack.dequeue();
    stack.enqueue("goodbye");</programlisting>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Shrink_dynamic_array"/> Implement a version of
<literal>DynamicArray</literal> that shrinks the size of its internal storage array to
half its size when only one quarter of its capacity is being used. This
design can save significant amounts of space if a large number of items
are added to the dynamic array at once and then removed.</simpara>
</listitem>
<listitem>
<simpara>Consider ProgramÂ <xref linkend="program:LinkedListWithTail"/> which defines the
<literal>LinkedListWithTail</literal> class for storing a linked list of <literal>String</literal> values.
Add a <literal>public reverse()</literal> method to the class which reverses the order of
the nodes in the linked list. The key idea is make a new linked list
that holds the head of the list. Then, remove the head from the original
linked list. Put the next node <emphasis role="strong">in front</emphasis> of the head in the new linked
list and remove it from the old. Continue the process until there is
nothing left in the original list. Be sure to reset the <literal>head</literal> and
<literal>tail</literal> references correctly after the reversal.</simpara>
</listitem>
<listitem>
<simpara>In SectionÂ <xref linkend="subsection:Linked_lists"/>, we use two kinds of linked
lists to store data, but copy all of that data back into an array before
sorting it. We use third linked list class (<literal>SortedLinkedList</literal>) to
insert data and maintain a sorted order. However, it is possible to add
data in non-sorted order to a linked list and then sort it afterwards.
Add a <literal>sort()</literal> method to the <literal>LinkedListWithTail</literal> class that performs a
bubble sort on the nodes inside.</simpara>
<simpara>The algorithm for a bubble sort is described in SectionÂ <xref linkend="problem:Sort
it out"/>. The idea is to make repeated passes through a list, swapping
two adjacent items if they are out of order. You keep making passes over
the list until no adjacent items are out of order. For a this <literal>sort()</literal>
method, you will need to use the <literal>compareTo()</literal> method to compare the
<literal>String</literal> values in the linked list nodes. Also, it may be necessary to
have special cases that update the <literal>head</literal> and <literal>tail</literal> pointers if those
nodes are swapped with other nodes. Note that bubble sort is not the
fastest way to sort a linked list. We introduce a faster approach in
ChapterÂ <xref linkend="chapter:Recursion"/>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:dynamicArrayTestExercise"/> Create JUnit test cases to
verify that the <literal>synchronized</literal> keywords are needed on the <literal>set()</literal> and
<literal>sort()</literal> methods of the <literal>DynamicArray</literal> example
(ProgramÂ <xref linkend="program:DynamicArray"/>). To test the <literal>set()</literal> method, you can
create one thread that repeatedly sets, gets, and tests a changing value
at a fixed location (e.g., 0) and another thread that continuously
appends to the array (causing it to grow by copy and replace, thus
occasionally overwriting the value at the fixed location). To test the
<literal>sort()</literal> method, create two threads that sort the same large random
array at the same time. Check to see if the array is, in fact, actually
sorted after the threads have exited. For both tests, you may need to
repeat the operations a number of times to trigger the race condition.</simpara>
</listitem>
<listitem>
<simpara>To make an infix calculator that can handle floating point values or
even just integers with more than one digit, you need to make a pass
over the input, parsing the sequence of characters into terms. When an
expression is in infix notation, the order of terms is an operand
followed by an operator, repeated over and over, and finishing on an
operand. There are two exceptions: Whenever you are expecting an
operand, you might get a left parenthesis, but, after the parenthesis,
you continue to look for an operand. Whenever you are expecting an
operator, you might get a right parenthesis, but, after that
parenthesis, you continue to look for an operator.</simpara>
<simpara>Using this first pass over input to separate terms as well as the
<literal>parseDouble()</literal> method from ExampleÂ <xref linkend="example:Parsing_a_number"/> to
compute the equivalent <literal>double</literal> values of operands, rewrite the solution
from SectionÂ <xref linkend="solution:Infix_conversion"/> to convert your terms into
postfix ordering and then calculate the answer.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the solution to the infix conversion problem given in
SectionÂ <xref linkend="solution:Infix_conversion"/> so that it uses <literal>GenericStack</literal>
with a type parameter of <literal>Term</literal> instead of <literal>TermStack</literal>.</simpara>
</listitem>
<listitem>
<simpara>Interfaces can also be generic. Consider the following generic
version of <literal>Queue</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Queue&lt;T&gt; {
    void enqueue(T value);
    T dequeue();
    T front();
    boolean isEmpty();
}</programlisting>
<simpara>Re-implement <literal>LinkedListQueue</literal> so that it is generic with type parameter
<literal>T</literal> and implements interface <literal>Queue&lt;T&gt;</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Recursion">
<title>Recursion</title>
<blockquote>
<attribution>
Anonymous
</attribution>
<simpara>In order to understand recursion, you must first understand recursion.</simpara>
</blockquote>
<section xml:id="_problem_maze_of_doom">
<title>Problem: Maze of doom</title>
<simpara>The evil mastermind from ChapterÂ <xref linkend="chapter:Concurrent_Programming"/> has
returned with a new attempt at world domination. Since he now knows that
you can use concurrency to crack his security code, this time he has
hidden his deadly virus in a secret location protected by a complex maze
of walls and passageways. Fortunately, you&#8217;ve been able to get a copy of
the maze floor plan, but now you must write a program to find a path
through the maze so you can steal the deadly virus before the evil
mastermind releases it on the world.</simpara>
<figure role="text-center">
<title>Example of a maze to solve.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/maze.svg" width="50%"/>
</imageobject>
<textobject><phrase>maze</phrase></textobject>
</mediaobject>
</figure>
<simpara>Finding a path through a maze involves systematically exploring twists
and turns, keeping track of where you&#8217;ve been, backtracking out of dead
ends, and producing a resulting path once you make it through. You
already have the basic tools necessary to solve this problem. You can,
for example, represent the maze with a two-dimensional array of
characters, where a plus ( <literal>'+'</literal> ) represents a wall and a space ( <literal>' '</literal> )
represents a passageway. You could create a path through the maze by
replacing a contiguous (vertical and horizontal but not diagonal)
sequence of <literal>' '</literal> characters by <literal>'*'</literal> characters, that lead from the
starting square to the final square where the deadly virus is located.</simpara>
<simpara>The difficulty is dead ends or, worse, loops. How do you keep track of
which paths you&#8217;ve tried that didn&#8217;t work? While you could use
additional data structures to store this additional information,
<emphasis>recursion</emphasis> is a solution technique that makes solving problems like
this one surprisingly straightforward.</simpara>
</section>
<section xml:id="_concepts_recursive_problem_solving">
<title>Concepts: Recursive problem solving</title>
<simpara>The idea that we use to solve this maze problem is called recursion.
Imagine that you are in a maze and have the choice to go right, left, or
straight. No matter which of the three paths you take, you will probably
be confronted by more choices of going right, left, or straight. You
need to explore them all systematically. The process of systematically
exploring the right path is similar to the process of systematically
exploring the left path. The choice at this moment between left, right,
and straight is in fact part of the same systematic process that you
want to follow when you are in the left, right, or straight branches of
the maze.</simpara>
<simpara>Solutions that can be described in terms of themselves are recursive.
But what is recursion? How can describing something in terms of itself
be useful? Since recursion sounds circular, how can it be applied to
problem solving in Java? How does the computer keep track of these
self-references? The following subsections address precisely these
questions.</simpara>
<section xml:id="subsection:What_is_recursion">
<title>What is recursion?</title>
<simpara>In the context of computer science and mathematics, recursion means
describing some repetitive process in terms of itself. Many complex
things can be described elegantly using recursion.</simpara>
<simpara>Consider the question, &#8220;How old are you now?&#8221; If you were 27, you
could answer, &#8220;I am one year older than I was last year.&#8221; If then
asked, &#8220;Well, how old were you last year?&#8221; Again, you could answer,
&#8220;I was one year older than I was the year before.&#8221; Assuming that the
person who wanted to wanted to know your age was very patient, you could
repeat this answer over and over, explaining that each year you have
been one year older than the previous year. However, after asking you 27
times about your age on the previous year, you would run out of years of
life and be forced to answer, &#8220;Zero years old.&#8221;</simpara>
<simpara>This absurd dialog shows an important feature of useful recursive
definitions: They have at least one <emphasis>base case</emphasis> and at least one
<emphasis>recursive case</emphasis>. The base case is the part of the definition that is
not described in terms of itself. It is a concrete answer. Without the
base case, the process would never end, and the definition would be
meaningless. The recursive case is the part of the definition that is
defined in terms of itself. Without the recursive case, the definition
could only describe a finite set of things.</simpara>
<simpara>In the example above, the base case is the age of zero years old. You
have no age before that. The recursive case is any age greater than zero
years old. We can use mathematical notation to describe your age in a
given year. Here <inlineequation><alt><![CDATA[age(year)]]></alt><mathphrase><![CDATA[age(year)]]></mathphrase></inlineequation> is a function that gives the
age you were during year <inlineequation><alt><![CDATA[year]]></alt><mathphrase><![CDATA[year]]></mathphrase></inlineequation>.</simpara>
<simpara><inlineequation><alt><![CDATA[age(year) =
\begin{cases} 0 & \text{if you were born in $year$} & \text{(Base Case)}
\\
  1 + age(year-1) & \text{if you were born before $year$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[age(year) =
\begin{cases} 0 & \text{if you were born in $year$} & \text{(Base Case)}
\\
  1 + age(year-1) & \text{if you were born before $year$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>To be meaningful, recursive cases should be defined in terms of simpler
or smaller values. In English, it is equally correct to say that you are
now a year younger than you&#8217;ll be next year. Unfortunately, the age that
you&#8217;ll be next year is not any closer to a base case, making that
recursion useless.</simpara>
<figure>
<title>Recursive refinement generating a tree-like image.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/trees.svg" width="100%"/>
</imageobject>
<textobject><phrase>trees</phrase></textobject>
</mediaobject>
</figure>
<simpara>A recursive definition of your age suggests that recursion is all around
us. It takes some work to write it down in formal notation, but
self-similarity is a constant theme in art and nature. The branching of
a trunk of a tree is similar to the branching of its limbs, which is
similar to the branching of its branches, which in turn is similar to
the branching of its twigs. In fact, we borrow the idea of the branching
of a tree to define a recursive data structure in
SectionÂ <xref linkend="syntax:Recursive_data_structures"/>. FigureÂ <xref linkend="recursiveTrees"/>
starts with a simple Y-shaped branching. By successively replacing the
branches with the previous shape, a tree is generated recursively.
<emphasis>Fractals</emphasis> are images generated by similar recursive techniques.
Although many real trees exhibit recursive tendencies, they do not
follow rules consistently or rigidly.</simpara>
</section>
<section xml:id="_recursive_definitions">
<title>Recursive definitions</title>
<simpara>Although recursion has many fascinating applications, certain forms of
recursion are more useful for solving problems. As with many aspects of
programming, there is a strong connection to mathematical principles.</simpara>
<simpara>In mathematics, a <emphasis>recursive definition</emphasis> is one that is defined in terms
of itself. It is common to define functions and sequences (and also
sets) recursively. Functions (such as <inlineequation><alt><![CDATA[f(n)]]></alt><mathphrase><![CDATA[f(n)]]></mathphrase></inlineequation>) are usually
defined in relation to the same function with a smaller input (such as
<inlineequation><alt><![CDATA[f(n - 1)]]></alt><mathphrase><![CDATA[f(n - 1)]]></mathphrase></inlineequation>). Sequences (such as <inlineequation><alt><![CDATA[s_n]]></alt><mathphrase><![CDATA[s_n]]></mathphrase></inlineequation>) are
usually defined in relation to earlier elements in the sequence (such as
<inlineequation><alt><![CDATA[s_{n - 1}]]></alt><mathphrase><![CDATA[s_{n - 1}]]></mathphrase></inlineequation>).</simpara>
<example>
<title>Multiplication defined recursively</title>
<simpara>Even very common functions can be defined recursively. Consider the
multiplication <inlineequation><alt><![CDATA[x \times y]]></alt><mathphrase><![CDATA[x \times y]]></mathphrase></inlineequation>. This multiplication means
repeatedly adding the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation> a total of <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> times.
If <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> is a positive integer, we can describe this
multiplication with the following recursive definition. Note the base
case and recursive case.</simpara>
<simpara><inlineequation><alt><![CDATA[x \times y =
\begin{cases} x & \text{if  $y = 1$} & \text{(Base Case)}
\\
x + \left(x \times (y - 1)\right) & \text{if $y > 1$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[x \times y =
\begin{cases} x & \text{if  $y = 1$} & \text{(Base Case)}
\\
x + \left(x \times (y - 1)\right) & \text{if $y > 1$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>Multiplication seems like such a basic operation that there would be no
need to have such a definition. Yet mathematicians often use multiple
equivalent definitions to prove results. Furthermore, this elementary
definition provides intuition for creating more complex definitions.</simpara>
</example>
<example>
<title>Factorial defined recursively</title>
<simpara>Another mathematical function with a natural recursive definition is the
factorial function, often written <inlineequation><alt><![CDATA[n!]]></alt><mathphrase><![CDATA[n!]]></mathphrase></inlineequation>. The factorial
function is used heavily in probability and counting. The value of
<inlineequation><alt><![CDATA[n! = n
\cdot(n - 1)\cdot(n - 2) \ldots 3\cdot \cdot 2 \cdot 1]]></alt><mathphrase><![CDATA[n! = n
\cdot(n - 1)\cdot(n - 2) \ldots 3\cdot \cdot 2 \cdot 1]]></mathphrase></inlineequation>. Mathematicians
like recursive definitions because they are able to describe functions
and sequences precisely without using ellipses (<inlineequation><alt><![CDATA[\ldots]]></alt><mathphrase><![CDATA[\ldots]]></mathphrase></inlineequation>).</simpara>
<simpara><inlineequation><alt><![CDATA[n! =
\begin{cases} 1 & \text{if  $n = 0$} & \text{(Base Case)}
\\
n \cdot (n-1)! & \text{if $n>0$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[n! =
\begin{cases} 1 & \text{if  $n = 0$} & \text{(Base Case)}
\\
n \cdot (n-1)! & \text{if $n>0$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>Note that the base case gives <inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation> as the answer when
<inlineequation><alt><![CDATA[n = 0]]></alt><mathphrase><![CDATA[n = 0]]></mathphrase></inlineequation>. By convention <inlineequation><alt><![CDATA[0! = 1]]></alt><mathphrase><![CDATA[0! = 1]]></mathphrase></inlineequation>. Thus, this
definition correctly gives <inlineequation><alt><![CDATA[0! = 1]]></alt><mathphrase><![CDATA[0! = 1]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[1! = 1\cdot 0!
= 1]]></alt><mathphrase><![CDATA[1! = 1\cdot 0!
= 1]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[2! = 2\cdot 1! = 2]]></alt><mathphrase><![CDATA[2! = 2\cdot 1! = 2]]></mathphrase></inlineequation>,
<inlineequation><alt><![CDATA[3! = 3\cdot 2! = 6]]></alt><mathphrase><![CDATA[3! = 3\cdot 2! = 6]]></mathphrase></inlineequation>, and so on.</simpara>
</example>
<example>
<title>Fibonacci defined recursively</title>
<simpara>The Fibonacci sequence is an infinite sequence of integers starting with
1, 1, 2, 3, 5, 8, 13, 21, <inlineequation><alt><![CDATA[\ldots]]></alt><mathphrase><![CDATA[\ldots]]></mathphrase></inlineequation>. Each term after the two
initial 1s is the sum of the previous two terms in the sequence.
Fibonacci has many interesting properties and crops up in surprisingly
diverse areas of mathematics. It was originally used to model the growth
of rabbit populations.</simpara>
<simpara>The Fibonacci sequence also has a natural recursive mathematical
definition. Indeed, you may have noticed that we described each term as
the sum of the two previous terms. We can formally define the
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> Fibonacci number <inlineequation><alt><![CDATA[F_n]]></alt><mathphrase><![CDATA[F_n]]></mathphrase></inlineequation> as follows,
starting with <inlineequation><alt><![CDATA[n=0]]></alt><mathphrase><![CDATA[n=0]]></mathphrase></inlineequation>. <inlineequation><alt><![CDATA[F_n=
\begin{cases} 1 & \text{if  $n=0$ or  $n = 1$} & \text{(Base
Cases)}
\\
F_{n-1}+F_{n-2} & \text{if $n>1$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[F_n=
\begin{cases} 1 & \text{if  $n=0$ or  $n = 1$} & \text{(Base
Cases)}
\\
F_{n-1}+F_{n-2} & \text{if $n>1$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>Since the <inlineequation><alt><![CDATA[F_n]]></alt><mathphrase><![CDATA[F_n]]></mathphrase></inlineequation> depends on the two previous terms, it is
necessary to have two base cases. The Fibonacci sequence is a special
kind of Lucas sequence. Other Lucas sequences specify different values
for the two base cases (and sometimes coefficients to multiply the
previous terms by).</simpara>
</example>
</section>
<section xml:id="_iteration_vs_recursion">
<title>Iteration vs. recursion</title>
<simpara>These mathematical definitions are interesting, but what is their
relationship to Java code? So far, we have considered algorithms that
are iterative in nature: processing is performed as a sequence of
operations on elements of a sequential data structure. We sum the
elements of an array by iterating through them from first to last. We
multiply two matrices by using nested <literal>for</literal> loops to sequence through
the matrix contents in the proper order. Similarly, one method may make
a sequence of one or more calls to other methods. We&#8217;re confident that
such computations terminate because we start at the beginning and work
to the end of a finite structure. But what if the structure is not a
simple linear or multidimensional array? The path we&#8217;re trying to find
through the maze is of unknown length and may not take a &#8220;straight
line&#8221; through the array.</simpara>
<simpara>A method may call other methods to complete its operation. For example,
a method that sorts a list of <literal>String</literal> values calls another method to do
pairwise comparison of the values in the list. A method that calls
<emphasis role="strong">itself</emphasis>, either directly or indirectly, is called a <emphasis>recursive</emphasis> method.</simpara>
<simpara>A recursive method may seem like a circular argument that never ends. In
fact, a recursive method only calls itself under certain circumstances.
Other times, it does not. A recursive method has the same two parts that
a mathematical recursive definition has.</simpara>
<variablelist>
<varlistentry>
<term>Base case</term>
<listitem>
<simpara>The operation being computed is done without any recursive calls.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Recursive case</term>
<listitem>
<simpara>The operation is broken down into smaller pieces, one or more of which
results in a recursive call to the method itself.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Each time a method calls itself recursively, it does so on a smaller
problem. Eventually it reaches a base case, and the recursion
terminates.</simpara>
<simpara>A recursive method is useful when a problem can be broken down into
smaller subproblems where each subproblem has the same structure as the
original, complete problem. These subproblems can be solved by recursive
calls and the results of those calls assembled to create a larger
solution.</simpara>
<simpara>Recursive methods are often surprisingly small given their complexity.
Each recursive call only makes a single step forward in the process of
solving the problem. In fact, it can appear that the problem is never
solved. The code has something like a &#8220;leap of faith&#8221; inside of it.
Assuming that you can solve a smaller subproblem, how do you put the
solutions together to solve the full problem? This assumption is the
leap of faith, but it works out as long as the subproblems get broken
down into smaller and smaller pieces that eventually reach a base case.</simpara>
<simpara>From a theoretical standpoint, any problem that can be solved
iteratively can be solved recursively, and vice versa. Iteration and
recursion are equivalent in computational power. Sometimes it is more
efficient or more elegant to use one approach or the other, and some
languages are designed to work better with a given approach.</simpara>
</section>
<section xml:id="_call_stack">
<title>Call stack</title>
<simpara>Many programmers who are new to recursion feel uncomfortable about the
syntax. How can a method call itself? What does that even mean?</simpara>
<simpara>Recursion in Java is grounded in the idea of a call stack. We discuss
the stack abstract data type in ChapterÂ <xref linkend="chapter:Dynamic Data
Structures"/>. A similar structure is used to control the flow of control
of a program as it calls methods.</simpara>
<simpara>Recall that a stack is a first in, last out (FILO) data structure. Each
time a method is called, its local variables are put on the call stack.
As the method executes, a pointer to the current operation it is
executing is kept on the call stack as well. This collection of local
variables and execution details for a method call is called the <emphasis>stack
frame</emphasis> or <emphasis>activation record</emphasis>. When another method is called, it pushes
its own stack frame onto the call stack as well, and its caller
remembers what it was executing before the call. When a method returns,
it pops its stack frame (the variables and state associated with its
execution) off the call stack.</simpara>
<simpara>A recursive method is called in exactly the same way. It puts another
copy of its stack frame on the call stack. Each call of the method has
its own stack frame and operates independently. There is no way to
access the variables from one call to the next, other than by passing in
parameters or returning values.</simpara>
<simpara>FigureÂ <xref linkend="figure:recursive_calls"/> shows the stack frames being pushed
onto the call stack as the <literal>main()</literal> method calls the <literal>factorial()</literal>
method, starting with the argument <literal>4</literal>. The <literal>factorial()</literal> method
recursively calls itself with successively smaller values.</simpara>
<figure>
<title>Successive recursive method calls getting added to the call stack.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/recursivecalls.svg" width="100%"/>
</imageobject>
<textobject><phrase>recursivecalls</phrase></textobject>
</mediaobject>
</figure>
<simpara>FigureÂ <xref linkend="figure:recursive_returns"/> shows the stack frames popping off
the call stack as each call to <literal>factorial()</literal> returns. As the answers are
returned, they are incorporated into the answer that is generated and
returned to the next caller in the sequence until the final answer <literal>24</literal>
(<inlineequation><alt><![CDATA[4!]]></alt><mathphrase><![CDATA[4!]]></mathphrase></inlineequation>) is returned to <literal>main()</literal>.</simpara>
<figure>
<title>Recursive methods returning results to their callers.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/recursivereturns.svg" width="100%"/>
</imageobject>
<textobject><phrase>recursivereturns</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="_syntax_recursive_methods">
<title>Syntax: Recursive methods</title>
<simpara>Unlike many <emphasis role="strong">Syntax</emphasis> sections in other chapters, there is no new Java
syntax to introduce here. Any method that calls itself, directly or
indirectly, is a recursive method. Recursive methods are simply methods
like any others, called in the normal way.</simpara>
<simpara>The real difficulty in learning to program recursively lies in breaking
out of the way you are used to thinking about program control flow. All
that you have learned about solving problems with iteration in previous
chapters may make it harder for you to embrace recursion.</simpara>
<simpara>Iteration views the whole problem at once and tries to sequence all the
pieces of the solution in some organized way. Recursion is only
concerned with the current step in the solution. If the current step is
one in which the answer is clear, you&#8217;re in a base case. Otherwise, the
solution takes one step toward the answer and then makes the leap of
faith, allowing the recursion to take care of the rest. Programmers who
are new to recursion are often tempted to do too much in each recursive
call. Don&#8217;t rush it!</simpara>
<simpara>The use of recursion in languages like Java owes much to the development
of <emphasis>functional programming</emphasis>. In many functional languages (such as
Scheme), there are no loops, and <emphasis role="strong">only</emphasis> recursion is allowed. In a
number of these languages, there is no assignment either. Each variable
has one value for its entire lifetime, and that value comes as a
parameter from whatever method called the current method.</simpara>
<simpara>It may seem odd to you, but this approach is a good one to follow when
writing recursive methods. Try <emphasis role="strong">not</emphasis> to assign variables inside your
methods. See if the work done in each method can be passed on as an
argument to the next method rather than changing the state inside the
current method. In that way, each recursive method is a frozen snapshot
of some part of the process of solving the problem. Of course, this
guideline is only a suggestion. Many practical recursive methods need to
assign variables internally, but a surprisingly large number do not.</simpara>
<simpara>Because the data inside these methods is tied so closely to the input
parameters and the return values given back to the caller, these methods
are often made <literal>static</literal>. Ideally, recursive methods do not change the
state of fields or class variables. Again, sometimes changing external
state is necessary, but recursive methods are meant to take in only
their input parameters and give back only return values. Recursive code
that reads and writes variables inside of objects or classes can be
difficult to understand and debug, since it depends on outside data.</simpara>
<simpara>With this information as background, we focus on examples for the rest
of this section. Because recursion is a new way of thinking, approach
these examples with an open mind. Many students have the experience that
recursion makes no sense until they see the right example. Then, the way
it works suddenly &#8220;clicks.&#8221; Do not be discouraged if recursion seems
difficult at first.</simpara>
<simpara>In this section, we work through examples of factorial computation,
Fibonacci numbers, the classic Tower of Hanoi problem, exponentiation.
These problems are mathematical in nature because the mathematical
recursion is easy to model in code. The next section applies recursion
to processing data structures.</simpara>
<example>
<title>Factorial implemented recursively</title>
<simpara>In our first example of a recursive implementation, we return to the
factorial function. Recall the recursive definition that describes the
function.</simpara>
<simpara><inlineequation><alt><![CDATA[n! =
\begin{cases} 1 & \text{if $n = 0$} & \text{(Base Case)}
\\
n \cdot (n-1)! & \text{if $n>0$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[n! =
\begin{cases} 1 & \text{if $n = 0$} & \text{(Base Case)}
\\
n \cdot (n-1)! & \text{if $n>0$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>By translating this mathematical definition almost directly into Java,
we can generate a method that computes the factorial function.</simpara>
<programlisting language="java" linenumbering="unnumbered">    public static long factorial(int n) {
        if (n == 0)     //base case
            return 1;
        else            //recursive case
            return n * factorial(n-1);
    }</programlisting>
<simpara>Note the base case and recursive case are exactly the same as in the
recursive definition. The return type of the method is <literal>long</literal> because
factorial grows so quickly that only the first few values are small
enough to fit inside of an <literal>int</literal>.</simpara>
</example>
<example>
<title>Fibonacci implemented recursively</title>
<simpara>Let us return to the recursive definition of Fibonacci.</simpara>
<simpara><inlineequation><alt><![CDATA[F_n=
\begin{cases} 1 & \text{if  $n=0$ or $n = 1$} & \text{(Base
Cases)}
\\
F_{n-1}+F_{n-2} & \text{if  $n>1$} & \text{(Recursive Case)}
\end{cases}]]></alt><mathphrase><![CDATA[F_n=
\begin{cases} 1 & \text{if  $n=0$ or $n = 1$} & \text{(Base
Cases)}
\\
F_{n-1}+F_{n-2} & \text{if  $n>1$} & \text{(Recursive Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>Like factorial, this definition translates naturally into a recursive
method in Java.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int fibonacci(int n) {
    if( n == 0 || n == 1 )  //base cases
        return 1;
    else                    //recursive case
        return fibonacci(n-1) + fibonacci(n-2);
}</programlisting>
<simpara>One significant problem with this example is performance. In this case,
the double recursion performs a great deal of redundant computation.</simpara>
<simpara>One technique for eliminating redundant computation in recursion is
called <emphasis>memoization</emphasis>. Whenever the value for a subproblem is computed,
we note down the result (like a memo). When we go to compute a value, we
first check to see if we have already found it.</simpara>
<simpara>To perform memoization for Fibonacci, we can pass an array of <literal>int</literal>
values of length <literal>n + 1</literal>. The values in this array all begin with a
value of <literal>0</literal>. When computing the Fibonacci value for a particular <literal>n</literal>,
we first check to see if its value is in the array. If not, we perform
the recursion and store the result in the array.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int fibonacci( int n, int[] results ) {
    if( results[n] == 0 ) {
        if( n == 0 || n == 1 )
            results[n] = 1;
        else
            results[n] = fibonacci(n-1) + fibonacci(n-2);
    }
    return results[n];
}</programlisting>
<simpara>This change makes the computation of the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> Fibonacci
number much more efficient; however, even more efficient approaches are
described in the exercises.</simpara>
</example>
<example>
<title>Tower of Hanoi</title>
<simpara>The famous Tower of Hanoi puzzle is another example commonly used to
illustrate recursion. In this puzzle, there are three poles containing a
number of different sized disks. The puzzle begins with all disks
arranged in a tower on one pole in decreasing size, with the smallest
diameter disk on top and the largest on the bottom.
FigureÂ <xref linkend="figure:hanoi"/> shows an example of the puzzle. The goal is to
move all the disks from the initial pole to the final pole, with two
restrictions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>only one disk can be moved at a time</simpara>
</listitem>
<listitem>
<simpara>a larger disk can never be placed on top of a smaller disk</simpara>
</listitem>
</orderedlist>
<figure>
<title>Tower of Hanoi puzzle with 4 disks on the initial pole.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/hanoi.svg" width="100%"/>
</imageobject>
<textobject><phrase>hanoi</phrase></textobject>
</mediaobject>
</figure>
<simpara>The extra pole is used as a holder for intermediate moves. The idea
behind the recursive solution follows.</simpara>
<variablelist>
<varlistentry>
<term>Base Case</term>
<listitem>
<simpara>Moving one disk is easy. Just move it from the pole it&#8217;s on to the
destination pole.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Recursive Case</term>
<listitem>
<simpara>In order to move <inlineequation><alt><![CDATA[n > 1]]></alt><mathphrase><![CDATA[n > 1]]></mathphrase></inlineequation> disks from one pole to another,
we can move <inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation> disks to an intermediate pole, move
the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> disk to the destination pole, then move the
<inlineequation><alt><![CDATA[n - 1]]></alt><mathphrase><![CDATA[n - 1]]></mathphrase></inlineequation> disks from the intermediate pole to the
destination pole.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The Tower of Hanoi solution in Java translates this outline into code.</simpara>
<formalpara xml:id="program:TowerOfHanoi" xreflabel="TowerOfHanoi">
<title>A recursive solution to the Tower of Hanoi with four disks and poles named <literal>'A'</literal>, <literal>'B'</literal>, and <literal>'C'</literal>.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class TowerOfHanoi {
    public static void main(String[] args) {
        move(4, 'A', 'C', 'B');
    }

    public static void move(int n, char fromPole, char toPole,
    	char viaPole) {
        if (n == 1)
            System.out.format(
            	"Move disk from pole %c to pole %c.\n",
            	fromPole, toPole);
        else {
            move(n - 1, fromPole, viaPole, toPole);
            move(1, fromPole, toPole, viaPole);
            move(n - 1, viaPole, toPole, fromPole);
        }
    }
}</programlisting>
</para>
</formalpara>
<simpara>A legend tells of monks that are solving the Tower of Hanoi puzzle with
64 disks. The legend predicts that the world will end when they finish.
Run the implementation above with different numbers of disks to see how
long the sequence of moves is. Try small numbers of disks, since large
numbers of disks takes a very long time.</simpara>
</example>
<example>
<title>Exponentiation</title>
<simpara>Both Fibonacci and the Tower of Hanoi have natural recursive structures.
In the case of Fibonacci, one way to implement its natural recursive
definition results in very wasteful computation. In the case of the
Tower of Hanoi, the <emphasis role="strong">only</emphasis> way to solve the problem takes an
excruciatingly long amount of time.</simpara>
<simpara>However, we can apply recursion to many practical problems and get
efficient solutions. Consider the problem of exponentiation, which looks
trivial: Given a rational number <inlineequation><alt><![CDATA[a]]></alt><mathphrase><![CDATA[a]]></mathphrase></inlineequation> and a positive integer
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, find the value of <inlineequation><alt><![CDATA[a^n]]></alt><mathphrase><![CDATA[a^n]]></mathphrase></inlineequation>.</simpara>
<simpara>It&#8217;s tempting to call <literal>Math.pow(a, n)</literal> or to use a short <literal>for</literal> loop to
compute this value, but what if neither tool existed in Java? A simple
recursive formulation can describe exponentiation.</simpara>
<simpara><inlineequation><alt><![CDATA[a^n =
\begin{cases} a & \text{if $n=1$} & \text{(Base case)}
\\
a \cdot a^{n - 1} & \text{if $n>1$} & \text{(Recursive case)}
\end{cases}]]></alt><mathphrase><![CDATA[a^n =
\begin{cases} a & \text{if $n=1$} & \text{(Base case)}
\\
a \cdot a^{n - 1} & \text{if $n>1$} & \text{(Recursive case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>As with factorial and Fibonacci, directly converting the recursive
definition into Java syntax yields a method that computes the correct
value.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double power(double a, int n) {
    if( n == 1 )    //base case
        return a;
    else            //recursive case
        return a*power(a, n - 1);
}</programlisting>
<simpara>Admittedly, this method only works for positive integer values of
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. Ignoring that limitation, what can we say about its
efficiency? For any legal value of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, the method is called
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> times. If <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> has a small value, like 2 or
3, the process is quick. But if <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is 1,000,000 or so, the
method might take a while to finish. Another problem is that stack size
is limited. On most systems, the JVM crashes with a <literal>StackOverflowError</literal>
if a method tries to call itself recursively a 1,000,000 times.</simpara>
<simpara>If we limit <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> to a power of 2, we can do something clever
that makes the method much more efficient with many fewer recursive
calls. Consider this alternative recursion definition of exponentiation.</simpara>
<simpara><inlineequation><alt><![CDATA[a^n =
\begin{cases} a & \text{if  $n=1$} & \text{(Base Case)}
\\
\left(a^{\frac{n}{2}}\right)^2 & \text{if  $n>1$} & \text{(Base Case)}
\end{cases}]]></alt><mathphrase><![CDATA[a^n =
\begin{cases} a & \text{if  $n=1$} & \text{(Base Case)}
\\
\left(a^{\frac{n}{2}}\right)^2 & \text{if  $n>1$} & \text{(Base Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
<simpara>Recalling basic rules of exponents,
<inlineequation><alt><![CDATA[a^n = \left(a^{\frac{n}{2}}\right)^2]]></alt><mathphrase><![CDATA[a^n = \left(a^{\frac{n}{2}}\right)^2]]></mathphrase></inlineequation>, but what does that
buy us? If we structure our method correctly, we cut the size of
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> in half at each recursive step instead of only reducing
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> by 1.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static double power(double a, int n) {
    if( n == 1 )    //base case
        return a;
    else {          //recursive case
        double temp = power(a, n/2);
        return temp*temp;
    }
}</programlisting>
<simpara>Note that we only make the recursive call once and save it in <literal>temp</literal>. If
we made two recursive calls, we would no longer be more efficient than
the previous method. That version took <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> recursive calls.
How efficient is this version? The answer is the number of times you
have to cut <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> in half before you get 1. Let&#8217;s call that
value <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>. Recall that <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is a power of 2,
meaning that <inlineequation><alt><![CDATA[n = 2^k]]></alt><mathphrase><![CDATA[n = 2^k]]></mathphrase></inlineequation> for some integer
<inlineequation><alt><![CDATA[k \geq 0]]></alt><mathphrase><![CDATA[k \geq 0]]></mathphrase></inlineequation>.</simpara>
<simpara><inlineequation><alt><![CDATA[\begin{aligned}
\left(\frac{1}{2}\right)^x \cdot n &= 1\\
2^x\left(\frac{1}{2}\right)^x \cdot n &= 2^x\\
n &= 2^x\\
2^k &= 2^x\\
k &= x\\
\log_2 n &= x\\\end{aligned}]]></alt><mathphrase><![CDATA[\begin{aligned}
\left(\frac{1}{2}\right)^x \cdot n &= 1\\
2^x\left(\frac{1}{2}\right)^x \cdot n &= 2^x\\
n &= 2^x\\
2^k &= 2^x\\
k &= x\\
\log_2 n &= x\\\end{aligned}]]></mathphrase></inlineequation></simpara>
<simpara>In other words, the number of times you have to divide <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>
in half to get 1 is the logarithm base 2 of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, written
<inlineequation><alt><![CDATA[\log_2 n]]></alt><mathphrase><![CDATA[\log_2 n]]></mathphrase></inlineequation>. The logarithm function is the inverse of
exponentiation. It cuts any number down to size very quickly (just as
exponentiation blows up the value of a number very quickly). For
example, <inlineequation><alt><![CDATA[2^{20} = 1,048,576]]></alt><mathphrase><![CDATA[2^{20} = 1,048,576]]></mathphrase></inlineequation>. Thus,
<inlineequation><alt><![CDATA[\log_2 1,048,576 = 20]]></alt><mathphrase><![CDATA[\log_2 1,048,576 = 20]]></mathphrase></inlineequation>. The original version of <literal>power()</literal>
would have to make 1,048,576 calls to raise a number to that power. This
second version would only have to make 20 calls.</simpara>
<simpara>It is critical that <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is a power of 2 (1, 2, 4, 8, â¦),
otherwise the process of repeatedly cutting <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> in half
loses some data due to integer division. The problem is that, at some
point in the recursion, the value of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is odd unless you
start with a power of 2. There is a way to extend this clever approach
to all values of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>, even and odd, but we leave it as an
exercise.</simpara>
</example>
<simpara>Recursion offers elegant ways to compute mathematical functions like
those we have explored in this section. Recursion also offers powerful
ways to manipulate data structures. As we show in the next section,
recursive methods are especially well suited to use with recursive data
structures.</simpara>
</section>
<section xml:id="_syntax_recursive_data_structures">
<title>Syntax: Recursive data structures</title>
<simpara>Because recursion can be used to do anything that iteration can do, it
is clear that data structures can be processed recursively. For example,
the following recursive method reverses the contents of an array. It
keeps track of the position in the array it is swapping with the
<literal>position</literal> parameter. This method is initially called with a value of
<literal>0</literal> passed as an argument for <literal>position</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void reverse( int[] array, int position ) {
    if( position &lt; array.length/2 ) {
        int temp = array[position];
        array[position] = array[array.length - position - 1];
        array[array.length - position - 1] = temp;
        reverse( array, position + 1 );
    }
}</programlisting>
<simpara>Note that nothing is done in the base case for this recursive method.
The recursion swaps the first element of the array (at index <literal>0</literal>) with
the last (at index <literal>array.length - 1</literal>). Recursion continues until
<literal>position</literal> has reached half the length of <literal>array</literal>. If execution
continued past the halfway point, it would begin to swap elements that
had already been swapped.</simpara>
<simpara>Although it is possible to reverse an array recursively, there is
usually no advantage in doing so. We introduce bubble sort and selection
sort in previous chapters, but neither of these algorithms is very fast.
Many of the best sorting algorithms are recursive, as in the following
example of merge sort.</simpara>
<example>
<title>Merge sort</title>
<simpara>Merge sort is an efficient sorting algorithm that is usually implemented
recursively. The idea of the sort is to break a list of items in half
and recursively merge sort each half. Then, these two sorted halves are
merged back together into the final sorted list. The base case of the
recursion is when there&#8217;s only a single item in the list, since a list
with only one thing in it is, by definition, sorted.</simpara>
<simpara>Here is a method that recursively sorts an <literal>int</literal> array using the merge
sort algorithm.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void mergeSort( int[] array ) {
    if( array.length &gt; 1 ) {
        int[] a = new int[array.length / 2];
        int[] b = new int[array.length - a.length];
        for( int i = 0; i &lt; a.length; ++i )
            a[i] = array[i];
        for( int i = 0; i &lt; b.length; ++i )
            b[i] = array[a.length + i];
        mergeSort( a );
        mergeSort( b );
        merge( array, a, b );
    }
}</programlisting>
<simpara>The <literal>mergeSort()</literal> method is quite short and appears to do very little.
It starts by creating arrays <literal>a</literal> and <literal>b</literal> and copying roughly half of the
elements in <literal>array</literal> into each. We make <literal>a</literal> half the size of <literal>array</literal>, but
we can&#8217;t do the same thing for <literal>b</literal> because an odd length for <literal>array</literal>
would leave us without enough space in <literal>a</literal> and <literal>b</literal> to hold everything
from <literal>array</literal>. Instead, we let <literal>b</literal> hold however much is leftover after
the elements for <literal>a</literal> have been accounted for.</simpara>
<simpara>Then, arrays <literal>a</literal> and <literal>b</literal> are recursively sorted. Finally, these two
sorted arrays are merged back into <literal>array</literal> in sorted order using a
helper method called <literal>merge()</literal>. This method is non-recursive and does
much of the real work in the algorithm.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void merge( int[] array, int[] a, int[] b ) {
    int aIndex = 0;
    int bIndex = 0;
    for( int i = 0; i &lt; array.length; ++i ) {
        if( bIndex &gt;= b.length )
            array[i] = a[aIndex++];
        else if( aIndex &gt;= a.length )
            array[i] = b[bIndex++];
        else if( a[aIndex] &lt;= b[bIndex] )
            array[i] = a[aIndex++];
        else
            array[i] = b[bIndex++];
    }
}</programlisting>
<simpara>The <literal>merge()</literal> method loops through all the elements in <literal>array</literal>, filling
them in. We keep two indexes, <literal>aIndex</literal> and <literal>bIndex</literal>, that keep track of
our current positions in the <literal>a</literal> and <literal>b</literal> arrays, respectively. This
method assumes that <literal>a</literal> and <literal>b</literal> are sorted and that the sum of their
lengths is the length of <literal>array</literal>. We want to compare each element in <literal>a</literal>
and <literal>b</literal>, always taking the smaller and putting it into the next
available location in <literal>array</literal>. Since the next smallest item could be in
either <literal>a</literal> or <literal>b</literal>, we never know when we&#8217;ll run out of elements in
either array. That&#8217;s why the first two <literal>if</literal> statements in the <literal>merge()</literal>
method check to see if the <literal>bIndex</literal> or the <literal>aIndex</literal> is already past the
last element in its respective array. If so, the next element from the
other array is automatically used. By the time the third <literal>if</literal> statement
is reached, we are certain that both indexes are valid and can compare
the elements at those locations to see which is smaller.</simpara>
<simpara>Sorting lists using the merge sort algorithm seems more complicated than
using bubble sort or selection sort, but this additional complication
pays dividends. For large lists, merge sort performs much faster than
either of those sorts. In fact, it is comparable in speed to the best
general sorting algorithms that are possible.</simpara>
</example>
<simpara>Although recursive sorting algorithms are useful for arrays, recursion
really shines when manipulating <emphasis>recursive data structures</emphasis>. A recursive
data structure is one that is defined in terms of itself. For example,
class <literal>X</literal> is recursive if there is a field inside <literal>X</literal> with type <literal>X</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class X {
    private int a, b;
    private X x;
}</programlisting>
<simpara>The linked list examples from ChapterÂ <xref linkend="chapter:Dynamic Data
Structures"/> are recursive data structures, since a linked list node is
defined in terms of itself. You may not have thought of the linked list
<literal>Node</literal> class as being recursive since it simply has a reference to
another <literal>Node</literal> inside it. However, this self-reference is the essence of
a recursive data structure.</simpara>
<simpara>Data structures are often defined recursively. We typically need to
represent an unbounded collection of data, but we always write bounded
programs to describe the data. A recursive data structure allows us to
bridge the gap between a compile-time, fixed length definition and a
run-time, unbounded collection of objects.</simpara>
<simpara>Recursive data structures have a base case to end the recursion.
Typically, the end of the recursion is indicated by a link with a <literal>null</literal>
value. For example, in the last node of a linked list, the link field is
<literal>null</literal>. Unsurprisingly, recursive methods are frequently used to
manipulate recursive data structures.</simpara>
<example>
<title>Recursive linked list size</title>
<simpara>How would you get the size of a linked list? The implementation in
ProgramÂ <xref linkend="program:LinkedList"/> keeps track of its size as it grows, but
what if it didn&#8217;t? A standard way to count the elements in the list
would be to start with a reference to the head of the list and a counter
with value zero. As long as the reference is not <literal>null</literal>, add one to the
counter and set the reference to the next element on the list.
ProgramÂ <xref linkend="program:IterativeListSize"/> counts the elements in this way.</simpara>
<formalpara xml:id="program:IterativeListSize" xreflabel="IterativeListSize">
<title>Linked list implementation whose <literal>size()</literal> method counts its elements iteratively.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class IterativeListSize {
    private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;

    public void add(String value) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = head;
    	head = temp;
    }

    public int size() {
    	Node current = head;
    	int counter = 0;
    	while( current != null ) {
    		current = current.next;
    		counter++;
    	}
    	return counter;
    }
}</programlisting>
</para>
</formalpara>
<simpara>An alternative way to count the number of elements in a linked list is
to use the natural recursion of the linked list itself. We can say that
the length of a linked list is 0 if the list is empty (the current link
is <literal>null</literal>), otherwise, it is one more than the size of the rest of the
list.</simpara>
<simpara>ProgramÂ <xref linkend="program:RecursiveListSize"/> counts the elements in a linked
list using this recursive procedure. Note that there is a non-recursive
<literal>size()</literal> method that calls the recursive <literal>size()</literal> method. This
non-recursive method is called a <emphasis>proxy method</emphasis>. The recursive method
requires access to the internals of the data structure. The proxy method
calls the recursive method with the appropriate starting point (<literal>head</literal>),
while providing a public way to get the list&#8217;s size without exposing its
internals.</simpara>
<formalpara xml:id="program:RecursiveListSize" xreflabel="RecursiveListSize">
<title>Linked list implementation with a recursive <literal>size()</literal> method for counting its elements.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class RecursiveListSize {
    private static class Node {
        public String value;
        public Node next;
    }

    private Node head = null;

    public void add(String value) {
    	Node temp = new Node();
    	temp.value = value;
    	temp.next = head;
    	head = temp;
    }

    //proxy method
    public int size() {
    	return size( head );
    }

    private static int size(Node list) {
    	if( list == null ) //base case
    		return 0;
    	//recursive case
    	return 1 + size( list.next );
    }
}</programlisting>
</para>
</formalpara>
</example>
<section xml:id="_trees">
<title>Trees</title>
<simpara>A linked list models a linear, one-to-one relationship between its
elements. Each item in the list is linked to a maximum of one following
element. Another useful relationship to model is a hierarchical,
one-to-many relationship: parent to children, boss to employees,
directory to files, and so on. These relationships can be modeled using
a <emphasis>tree</emphasis> structure, which begins with a single <emphasis>root</emphasis>, and proceeds
through <emphasis>branches</emphasis>, to the <emphasis>leaves</emphasis>. Typically, the elements of a tree
are also called <emphasis>nodes</emphasis>, with three special cases:</simpara>
<variablelist>
<varlistentry>
<term>Root node</term>
<listitem>
<simpara>The root of the tree has no parents.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Leaf node</term>
<listitem>
<simpara>A leaf is at the edge of a tree and has no children.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Interior node</term>
<listitem>
<simpara>An interior node has a parent and at least one child; it is neither
the root nor a leaf.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>FigureÂ <xref linkend="figure:tree_visualization"/> shows a visualization of a tree. In
nature, a tree has its root at the bottom and branches upward. Since the
root is the starting point for a tree data structure, it is almost
always drawn at the top.</simpara>
<figure>
<title>Visualization of a tree. The root is shown in light red. The leaves are shown in blue. The interior nodes are show in light purple.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/treevisualization.svg" width="100%"/>
</imageobject>
<textobject><phrase>treevisualization</phrase></textobject>
</mediaobject>
</figure>
<simpara>Abstractly, a tree is either empty (the base case) or contains
references to 0 or more other trees (the recursive case). Trees are very
useful for storing and retrieving sortable data efficiently. Some
applications include dictionaries, catalogs, ordered lists, and any
other sorted set of objects. For these purposes, we can define an
abstract data type that includes operations such as <literal>add()</literal> and
<literal>find()</literal>.</simpara>
<simpara>A special case of a tree that is used frequently is a <emphasis>binary tree</emphasis>, in
which each node references at most two other trees.</simpara>
<example>
<title>Binary search tree</title>
<simpara>A <emphasis>binary search tree</emphasis> is a binary tree with the following three
properties.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The value in the left child of the root is smaller than the value in
the root.</simpara>
</listitem>
<listitem>
<simpara>The value in the right child of the root is larger than the value in
the root.</simpara>
</listitem>
<listitem>
<simpara>Both the left and the right subtrees are binary search trees.</simpara>
</listitem>
</orderedlist>
<simpara>This recursive definition describes a tree that makes items with a
natural ordering easy to find. If you are looking for an item, you first
look at the root of the tree. If the item you want is in the root,
you&#8217;ve found it! If the item you want is smaller than the root, go left.
If the item you want is larger than the root, go right. If you ever run
out of tree (hit a <literal>null</literal>), the item is not in the tree.</simpara>
<simpara>This example is a simple binary tree that can stores a list of strings
and print them out in alphabetical order. ProgramÂ <xref linkend="program:Tree"/> shows
the <literal>Tree</literal> class that defines the fields and two public methods, <literal>add()</literal>
and <literal>print()</literal> that operate on the tree. Each is a proxy method that
calls its private recursive version, which takes a reference to a <literal>Node</literal>
object. The <literal>Node</literal> static nested class contains three fields.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>value</literal>: the <literal>String</literal> value stored at the node</simpara>
</listitem>
<listitem>
<simpara><literal>left</literal>: a link to the left subtree</simpara>
</listitem>
<listitem>
<simpara><literal>right</literal>: a link to the right subtree</simpara>
</listitem>
</itemizedlist>
<formalpara xml:id="program:Tree" xreflabel="Tree">
<title>A class that implements a simple binary search tree ADT for creating a sorted list of strings.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class Tree {
	private static class Node {
		String value;
		Node left = null;
		Node right = null;
	}

	private Node root = null;

	//proxy add
	public void add(String value) {
		root = add( value, root );
	}

	private static Node add(String value, Node tree) {
		if( tree == null ) {	//base case
			tree = new Node();
			tree.value = value;
		}
		//left recursive case
		else if( value.compareTo(tree.value) &lt; 0 )
			tree.left = add( value, tree.left );
		//right recursive case
		else if( value.compareTo(tree.value) &gt; 0 )
			tree.right = add( value, tree.right );
		return tree;
	}

	//proxy print
	public void print() {
		print( root );
	}

	private static void print(Node tree) {
		if( tree != null ) {
			print( tree.left );
			System.out.println( tree.value );
			print( tree.right );
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>FigureÂ <xref linkend="figure:tree_classes"/> shows a visualization of the contents of
this implementation of a binary search tree. As with a linked list, an
&#8220;X&#8221; is used in place of arrows that point to <literal>null</literal>.</simpara>
<figure role="text-center">
<title>Visualization of a tree implementation with classes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="chapters/19-recursion/images/treeclasses.svg" width="75%"/>
</imageobject>
<textobject><phrase>treeclasses</phrase></textobject>
</mediaobject>
</figure>
<simpara>The recursive <literal>add()</literal> method first checks to see if the current subtree
is empty (<literal>null</literal>). If so, it creates a new <literal>Node</literal> and puts <literal>value</literal>
inside it. If the current subtree is not <literal>null</literal>, it checks to see if
<literal>value</literal> is smaller or larger than the <literal>value</literal> at the root of the subtee.
If it is smaller, it recurses down the left subtree. If it is larger, it
recurses down the right subtree. If <literal>value</literal> is already in the root node,
it does nothing.</simpara>
<simpara>Remember that all parameters are pass by value in Java. Thus, assigning
a new <literal>Node</literal> to <literal>tree</literal> does not by itself change anything at higher
levels of the tree. What does change the links in the parent of the
current subtree is returning the <literal>tree</literal> pointer. If the recursive call
to <literal>add()</literal> was made with a left or a right subtree, the <literal>left</literal> or
<literal>right</literal> link, respectively, of the parent <literal>Node</literal> is assigned the return
value. If the call was made with <literal>root</literal>, the parent of the entire tree,
the non-recursive <literal>add()</literal> method sets its value when the recursive
<literal>add()</literal> returns.</simpara>
<simpara>The recursive <literal>print()</literal> method starts by walking down the left subtree.
Those values are all alphabetically less than the value of the current
node. When it finishes, it prints the current node value. Finally, it
walks the right subtree to print the values that alphabetically follow
the value in the current node. This path through the nodes of the tree
is called an <emphasis>inorder traversal</emphasis>.</simpara>
<simpara>With the power of a binary search tree, it takes virtually no code at
all to store a list of <literal>String</literal> values and then print them out in sorted
order. ProgramÂ <xref linkend="program:ReadAndSortStrings"/> gives an example of this
process using a <literal>Tree</literal> object for storage.</simpara>
<formalpara xml:id="program:ReadAndSortStrings" xreflabel="ReadAndSortStrings">
<title>A program to read <literal>String</literal> values, store them in a binary search tree, and print the results in sorted order.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Scanner;

public class ReadAndSortStrings {
	public static void main(String[] args) {
		Tree tree = new Tree();
		Scanner in = new Scanner(System.in);

		while( in.hasNextLine() )
				tree.add( in.nextLine() );

		tree.print();
	}
}</programlisting>
</para>
</formalpara>
<simpara>Binary search trees (and other trees, including heaps, tries, B-trees,
and more) are fundamental data structures that have been studied
heavily. Designing them to have efficient implementations that balance
the size of their left and right subtrees is an important topic that is
beyond the scope of this book.</simpara>
</example>
</section>
<section xml:id="_generic_dynamic_data_structures_and_recursion">
<title>Generic dynamic data structures and recursion</title>
<simpara>Combining dynamic data structures and generics from the previous chapter
and recursion from this chapter gives us the full power of generic
dynamic data structures and recursive methods to process them.</simpara>
<example>
<title>Binary search tree to hold integers</title>
<simpara>Consider ProgramÂ <xref linkend="program:IntegerTree"/>, which implements a tree that
stores values of type <literal>Integer</literal>. Although it would be more efficient to
store <literal>int</literal> values, we use the <literal>Integer</literal> wrapper class to ease our
eventual transition into a parameterized generic type.</simpara>
<formalpara xml:id="program:IntegerTree" xreflabel="IntegerTree">
<title>A variant of ProgramÂ <xref linkend="program:Tree"/> that stores`Integer` values instead of <literal>String</literal> values.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class IntegerTree {
	private static class Node {
		Integer value;
		Node left = null;
		Node right = null;
	}

	private Node root = null;

	//proxy add
	public void add(Integer value) {
		root = add( value, root );
	}

	private static Node add(Integer value, Node tree) {
		if( tree == null ) {	//base case
			tree = new Node();
			tree.value = value;
		}
		//left recursive case
		else if( value.compareTo(tree.value) &lt; 0 )
			tree.left = add( value, tree.left );
		//right recursive case
		else if( value.compareTo(tree.value) &gt; 0 )
			tree.right = add( value, tree.right );
		return tree;
	}

	//proxy print
	public void print() {
		print( root );
	}

	private static void print(Node tree) {
		if( tree != null ) {
			print( tree.left );
			System.out.println( tree.value );
			print( tree.right );
		}
	}
}</programlisting>
</para>
</formalpara>
</example>
<simpara>It is a waste to create class <literal>IntegerTree</literal>, which is identical to
<literal>Tree</literal> except that the type <literal>String</literal> has been replaced by <literal>Integer</literal>. As
in ChapterÂ <xref linkend="chapter:Dynamic_Data_Structures"/>, we want our data
structures, recursive or otherwise, to hold any type. In this way, we
can reuse code.</simpara>
<example>
<title>Defining a generic binary search tree</title>
<simpara>ProgramÂ <xref linkend="program:GenericTree"/> defines a generic version of the <literal>Tree</literal>
class. This example is complicated by the fact that we need to be able
to compare the value we want to store with the value in each <literal>Node</literal>
object. We can&#8217;t make a tree with any arbitrary type. Objects of the
type <emphasis role="strong">must</emphasis> have the ability to be compared to each other and ordered.
Thus, we use a <emphasis>bounded type parameter</emphasis> specifying that the type <literal>T</literal>
stored in each <literal>Tree</literal> must implement the <literal>Comparable</literal> interface. This
requirement complicates the generic syntax significantly but guarantees
that any type that cannot be compared with itself is rejected at
compile-time.</simpara>
<formalpara xml:id="program:GenericTree" xreflabel="GenericTree">
<title>A class that implements a generic tree.</title>
<para>
<programlisting language="java" linenumbering="numbered">public class GenericTree&lt;T extends Comparable&lt;T&gt;&gt; {
	private static class Node&lt;T extends Comparable&lt;T&gt;&gt;{
		T value;
		Node left = null;
		Node right = null;
	}

	private Node&lt;T&gt; root = null;

	//proxy add
	public void add(T value) {
		root = add( value, root );
	}

	private Node&lt;T&gt; add(T value, Node&lt;T&gt; tree) {
		if( tree == null ) {	//base case
			tree = new Node&lt;T&gt;();
			tree.value = value;
		}
		//left recursive case
		else if( value.compareTo(tree.value) &lt; 0 )
			tree.left = add( value, tree.left );
		//right recursive case
		else if( value.compareTo(tree.value) &gt; 0 )
			tree.right = add( value, tree.right );
		return tree;
	}

	//proxy print
	public void print() {
		print( root );
	}

	private void print(Node&lt;T&gt; tree) {
		if( tree != null ) {
			print( tree.left );
			System.out.println( tree.value );
			print( tree.right );
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>First, note that the recursive methods are no longer <literal>static</literal>. The
generic syntax for keeping them <literal>static</literal> is unnecessarily complex. The
type specifier <literal>T extends Comparable&lt;T&gt;</literal> guarantees that type <literal>T</literal>
implements the interface <literal>Comparable&lt;T&gt;</literal>. The generic <literal>Comparable</literal>
interface defined in the Java API is as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Comparable&lt;T&gt; {
    int compareTo(T object);
}</programlisting>
<simpara>The syntax for generics in Java with type bounds is complex, and we only
scratch the surface here. The good news is that these subtleties are
more important for people designing data structures and libraries and
come up infrequently for programmers who are only using the libraries.</simpara>
</example>
<example>
<title>Using a generic class</title>
<simpara>ProgramÂ <xref linkend="program:ReadAndSortGenerics"/> uses the generic tree class to
create two kinds of trees, a tree of <literal>String</literal> objects and a tree of
<literal>Integer</literal> objects. Java library implementations of binary search trees
are available as the <literal>TreeSet</literal> and <literal>TreeMap</literal> classes.</simpara>
<formalpara xml:id="program:ReadAndSortGenerics" xreflabel="ReadAndSortGenerics">
<title>Program to create two trees with different underlying types.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.util.Random;
import java.util.Scanner;

public class ReadAndSortGenerics {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		GenericTree&lt;String&gt; stringTree = new GenericTree&lt;String&gt;();
		GenericTree&lt;Integer&gt; integerTree =
			new GenericTree&lt;Integer&gt;();

		while( in.hasNextLine() )
			stringTree.add(in.nextLine());
		stringTree.print();

		Random random = new Random();
		for (int i = 0; i &lt; 10; i++)
			integerTree.add(random.nextInt());
		integerTree.print();
	}
}</programlisting>
</para>
</formalpara>
</example>
</section>
</section>
<section xml:id="_solution_maze_of_doom">
<title>Solution: Maze of doom</title>
<simpara>Our algorithm for solving the maze follows the conventional
pencil-and-paper method: trial and error! We mark locations in the maze
with <literal>'*'</literal> as we explore them. If we come to a dead end, we unmark the
location (by replacing <literal>'*'</literal> with <literal>' '</literal>) and return to our previous
location to try a different direction.</simpara>
<simpara>Start at the beginning square of the maze, which must be a passageway.
Mark that location as part of the path by putting <literal>'*'</literal> in the cell.
Now, what can we do? There are, in general, four possible directions to
head: up, down, left, or right. If that direction doesn&#8217;t take you
outside the bounds of the array, then you find either a wall or a
passageway. If you have been walking through the maze, you may also find
a part of the current path (often the square you were on before the
current one).</simpara>
<simpara>Suppose from your current point in the maze you could send a scout ahead
in each of the four directions. If the direction did not take the scout
out of bounds, he would find either a wall, a part of the current path
(the path that led into that space), or an open passageway. If the scout
doesn&#8217;t find an open passageway, he reports back that that direction
doesn&#8217;t work.</simpara>
<simpara>On the other hand, if the scout finds an open passageway, what does he
do? Brace yourself! He does the exact same thing you just did: Sends out
scouts of his own in each of the four possible directions.</simpara>
<simpara>With careful, consistent coding, you and the scout follow the exact same
process. And the scout&#8217;s scouts. And so on. There is, in fact, only one
method and instead of calling a scout method to investigate each of the
squares in the four directions, you call yourself recursively.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.Scanner;

public class MazeSolver {
	private char[][] maze;
	private int rows, columns;

	public static void main( String[] args ) {
		MazeSolver solver = new MazeSolver();
		if( solver.solve(0, 0) )/*@\label{mazeRCall}@*/
			System.out.println("\nSolved!");
		else
			System.out.println("\nNot solvable!");
		solver.print();/*@\label{mazeRPrint}@*/
	}</programlisting>
<simpara>The <literal>MazeSolver</literal> class needs a two-dimensional array of <literal>char</literal> values to
store a representation of the maze. Likewise, it is convenient to store
the number of rows and columns in fields.</simpara>
<simpara>The <literal>main()</literal> method creates a new <literal>MazeSolver</literal> object and then calls its
<literal>solve()</literal> method with a starting location of <literal>(0, 0)</literal>. It prints an
appropriate message depending on whether or not the maze was solved.
Finally, it prints out the maze, which includes a path marked with <literal>'*'</literal>
symbols if the maze is solvable.</simpara>
<programlisting language="java" linenumbering="numbered">	public MazeSolver() {
		Scanner in = new Scanner(System.in);
		rows = in.nextInt();
		columns = in.nextInt();
		in.nextLine();
		maze = new char[rows][columns];
		for( int row = 0; row &lt; rows; row++ ) {
			String line = in.nextLine();
			System.out.println(line);
			for (int column = 0; column &lt; columns; column++) {
				maze[row][column] = line.charAt(column);
			}
		}
	}</programlisting>
<simpara>The constructor for <literal>MazeSolver</literal> creates a <literal>Scanner</literal>. It assumes that
the file describing the maze is redirected from standard input, although
it would be easy to modify the constructor to take a file name and read
from there instead. Next, it reads two integers and sets <literal>rows</literal> and
<literal>columns</literal> to those values. It allocates a two-dimensional array of
<literal>char</literal> values with <literal>rows</literal> rows and <literal>columns</literal> columns. Finally, it reads
through the file, storing each line of <literal>char</literal> values into this array. As
it reads, it prints out each line to the screen, showing the initial
(unsolved) maze.</simpara>
<programlisting language="java" linenumbering="numbered">	public void print() {
		for( int row = 0; row &lt; rows; row++ ) {
			for (int column = 0; column &lt; columns; column++)
				System.out.print(maze[row][column]);
			System.out.println();
		}
	}</programlisting>
<simpara>The <literal>print()</literal> method is a utility method that prints out the maze. It
iterates through each row, printing out the values for the columns in
that row.</simpara>
<programlisting language="java" linenumbering="numbered">	public boolean solve( int row, int column ) {/*@\label{mazeRBegin}@*/
		if( row &lt; 0 || column &lt; 0 || row &gt;= rows || column &gt;= columns)/*@\label{mazeROutside}@*/
			return false;
		else if( maze[row][column] == 'E' )/*@\label{mazeRDone}@*/
			return true;
		else if( maze[row][column] != ' ')/*@\label{mazeRBlocked}@*/
			return false;
		else {
			maze[row][column] = '*';
			if( solve(row - 1, column) || solve(row + 1, column) ||/*@\label{mazeRRecursive}@*/
				solve(row, column - 1) || solve(row, column + 1) )
				return true;
			else {
				maze[row][column] = ' ';/*@\label{mazeRBlank}@*/
				return false;
			}
		}
	}
}</programlisting>
<simpara>The heart of the solution is the recursive method <literal>solve()</literal>. The
<literal>solve()</literal> method takes two parameters, <literal>row</literal> and <literal>column</literal>, and tries to
find a solution to the maze starting at location <literal>maze[row][column]</literal>. It
assumes that the maze is filled with <literal>'+'</literal> for walls, <literal>' '</literal> for
passageways, and may include <literal>'*'</literal> characters at locations that are part
of the partially completed solution.</simpara>
<simpara>If <literal>solve()</literal> is able to find a solution from the current location, it
returns <literal>true</literal>, otherwise it returns <literal>false</literal>. There are three base cases
for the current location in the maze.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The current location is outside the maze. Return <literal>false</literal>.</simpara>
</listitem>
<listitem>
<simpara>The current location is the final location. We have a winner, return
<literal>true</literal>!</simpara>
</listitem>
<listitem>
<simpara>The current location is not a passage (either a wall or a location
in the current path that has already been marked). This call to <literal>solve</literal>
is not making progress toward the finish. Return <literal>false</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If none of the base cases applies, then the current location, which must
contain a <literal>' '</literal> character, <emphasis role="strong">might</emphasis> be on a successful path, so <literal>solve()</literal>
gives it a try. The method tentatively marks the current position with
<literal>'*'</literal>. Then, it recursively tries to find a path from the current
location to each of the four neighboring cells
(lineÂ <xref linkend="mazeRRecursive"/>). If any of those four neighbors returns
<literal>true</literal>, then <literal>solve()</literal> knows it has found a completed path and returns
<literal>true</literal> to its caller.</simpara>
<simpara>If none of the four neighbors was on a path to the destination, then the
current location is not on a path. The method unmarks the current
location (by storing a <literal>' '</literal>) and returns <literal>false</literal>. Presumably, its
caller figures out what to do next, perhaps calling a different one of
its neighbors or giving up and returning <literal>false</literal> to its caller.</simpara>
<simpara>The very first call to <literal>solve()</literal> from the <literal>main()</literal> method either returns
<literal>true</literal> if a complete path through the maze is found or <literal>false</literal> if no
path exists. Note that this solver has no guarantee of finding the
<emphasis role="strong">shortest</emphasis> path through the maze, but if there is at least one path to
the goal, it finds one.</simpara>
</section>
<section xml:id="_concurrency_futures">
<title>Concurrency: Futures</title>
<simpara>This section does not deal explicitly with recursion, but it does deal
with concurrency and methods in an interesting way. When we call a
method in Java, a stack frame for the method is put on the stack, and
the thread of execution begins executing code inside the method. When it
is done, it returns a value (or not), and execution resumes in the
caller. But what if calling the method began executing an independent
thread, and the caller continued on without waiting for the method to
return?</simpara>
<simpara>This second situation should seem familiar, since it is very much what
happens when the <literal>start()</literal> method is called on a <literal>Thread</literal> object: the
<literal>start()</literal> method returns immediately to its caller, but an independent
thread of execution has begun executing the code in the <literal>run()</literal> method
of the <literal>Thread</literal>.</simpara>
<simpara>What if we only care about the value that is computed by the new thread
of execution? We can think of spawning the thread as an asynchronous
method call, a value that is computed <emphasis role="strong">at some point</emphasis> rather than one we
have to wait for. The name for such an asynchronous method call is a
<emphasis>future</emphasis>. In some languages, particularly functional languages, all
concurrency is expressed as a future. In Java, only a little bit of code
is needed to create threads that can behave like futures. However, the
idea of futures is pervasive enough that Java API tools were created to
make the process of creating them easy.</simpara>
<simpara>We introduce three interfaces and a factory method call that can allow
you to use futures in Java. This section is not a complete introduction
to futures, but these tools are enough to get you started with them.</simpara>
<simpara>The first interface is the <literal>Future</literal> interface, which allows you to store
a reference to the asynchronous computation while it is computing (and
before you ask for its value). The second interface is the <literal>Callable</literal>
interface, which is similar to the <literal>Runnable</literal> interface in that it
allows you to specify a class whose objects can be started as
independent threads. Both the <literal>Future</literal> interface and the <literal>Callable</literal> are
generic interfaces that require to specify a type. Remember that futures
are supposed to give back an answer, and that&#8217;s the type that you supply
as a parameter. For example, when creating a future that returns an
<literal>int</literal> value, you would create a class that implemented the
<literal>Callable&lt;Integer&gt;</literal> interface, requiring it to contain a method with the
signature <literal>Integer call()</literal>. Likewise, you would store a reference to the
future you create in a <literal>Future&lt;Integer&gt;</literal> reference.</simpara>
<simpara>And how do you create such a future? Usually, many futures are running
at once to leverage the power of multiple cores. What if you want to
create 100 futures but only have 8 cores? The process of creating
threads is expensive, and it might not be worthwhile to create 100
threads when only 8 are able to run concurrently. To deal with this
problem, the Java API provides classes that implement the
<literal>ExecutorService</literal> interface, which can maintain a fixed-size <emphasis>pool</emphasis> of
threads. When a thread finishes computing one future, it is
automatically assigned another. To create an object that can manage
threads this way, call the static factory method <literal>newFixedThreadPool()</literal>
on the <literal>Executors</literal> class with the size of the thread pool you want
create. For example, we can create an <literal>ExecutorService</literal> with a pool of 8
threads as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">ExecutorService executor = Executors.newFixedThreadPool(8);</programlisting>
<simpara>Once you have an <literal>ExecutorService</literal>, you can give it a <literal>Callable</literal> object
of a particular type (such as <literal>Callable&lt;Integer&gt;</literal>) as a parameter to its
<literal>submit()</literal> method, and it returns a <literal>Future</literal> object of a matching type
(such as <literal>Future&lt;Integer&gt;</literal>). Then, the future is running (or at least
scheduled to run). At any later point you can call the <literal>get()</literal> method on
the <literal>Future</literal> object, which returns the value of its computation. Like
calling <literal>join()</literal>, calling <literal>get()</literal> is a blocking call that may have to
wait for the future to finish executing.</simpara>
<simpara>All of this messy syntax becomes clearer in the following example, which
uses futures to compute the sum of the square roots of the first
100,000,000 integers concurrently.</simpara>
<example>
<title>Futures to sum square roots</title>
<simpara>To use futures to sum the square roots of integers, we first need a
worker class that implements <literal>Callable</literal>. Since the result of the sum of
square roots is a <literal>double</literal>, it must implement <literal>Callable&lt;Double&gt;</literal>. Recall
that primitive types such as <literal>double</literal> cannot be used as generic type
parameters, requiring us to use wrapper classes in those cases.</simpara>
<programlisting xml:id="program:RootSummer" xreflabel="RootSummer" language="java" linenumbering="numbered">import java.util.concurrent.*;

public class RootSummer implements Callable&lt;Double&gt; {
	private int min;
	private int max;

	public RootSummer( int min, int max ) {
		this.min = min;
		this.max = max;
	}

	public Double call() {
		double sum = 0.0;
		for( int i = min; i &lt; max; ++i )
			sum += Math.sqrt(i);
		return sum;
	}
}</programlisting>
<simpara><literal>RootSummer</literal> is a simple worker class that takes a <literal>min</literal> and a <literal>max</literal>
value in its constructor. Its <literal>call()</literal> method sums the square roots of
all the <literal>int</literal> values greater than or equal to <literal>min</literal> and less than <literal>max</literal>.
It imports <literal>java.util.concurrent.*</literal> to have access to the <literal>Callable</literal>
interface.</simpara>
<simpara>Of course, we need another class to create the <literal>ExecutorService</literal>, start
the futures running, and collect the results.</simpara>
<programlisting language="java" linenumbering="numbered">import java.util.concurrent.*;
import java.util.ArrayList;

public class RootFutures {
	private static final int THREADS = 10;
	private static final int N = 100000000;
	private static final int FUTURES = 1000;

	public static void main( String[] args ) {
		ArrayList&lt;Future&lt;Double&gt;&gt; futures =
			new ArrayList&lt;Future&lt;Double&gt;&gt;(FUTURES);
		ExecutorService executor =
			Executors.newFixedThreadPool(THREADS);
		int work = N / FUTURES;</programlisting>
<simpara>The first part of <literal>RootFutures</literal> is setup. The imports give us the
concurrency tools we need and a list to store our futures in. We have
three constants. <literal>THREADS</literal> specifies the number of threads to create.
<literal>N</literal> gives the number we are going up to. <literal>FUTURES</literal> is the total number
of futures we create, considerably larger than the number of threads
they share.</simpara>
<simpara>Inside the <literal>main()</literal> method, we create an <literal>ArrayList</literal> to hold the
futures. Since we know the number of futures ahead of time, an array
would be ideal. Unfortunately, quirks in the way Java handles generics
makes it illegal to create an array with a generic type. Instead, we
create an <literal>ArrayList</literal> with the size we&#8217;ll need pre-allocated. Next, we
create an <literal>ExecutorService</literal> with a thread pool of size <literal>THREADS</literal>.
Finally, we find the amount of work done by each future by dividing <literal>N</literal>
by <literal>FUTURES</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.println("Creating futures...");
		for( int i = 0; i &lt; FUTURES; i++ ) {
			Callable&lt;Double&gt; summer =
				new RootSummer( 1 + i*work, 1 + (i + 1)*work );
			Future&lt;Double&gt; future = executor.submit( summer );
			futures.add( future );
		}</programlisting>
<simpara>In this section of code, we create each future and start it running.
First, we instantiate a <literal>RootSummer</literal> object with the appropriate bounds
for the work it&#8217;s going to compute. Then, we supply that object to the
<literal>submit()</literal> method on the <literal>ExecutorService</literal>, which returns a <literal>Future</literal>
object. We could have saved a line of code by storing this return value
directly into the list <literal>futures</literal>.</simpara>
<programlisting language="java" linenumbering="numbered">		System.out.println("Getting results from futures...");
		double sum = 0;
		for( Future&lt;Double&gt; future : futures ) {
			try {
				sum += future.get();
			}
			catch( InterruptedException e ) {
				e.printStackTrace();
			}
			catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
		executor.shutdown();
		System.out.println("The sum of square roots is: " + sum);
	}
}</programlisting>
<simpara>All that remains is to collect the values from each future. We iterate
through the list of futures with a for-each loop and add the return
value each future&#8217;s <literal>get()</literal> method to our running total <literal>sum</literal>. Because
<literal>get()</literal> is a blocking call, we have to catch an <literal>InterruptedException</literal>
in case we are interrupted while waiting for the future to respond.
However, we also have to catch an <literal>ExecutionException</literal> in case an
exception occurred during the execution of the future. This exception
handling mechanism is one of the big advantages of using futures:
Exceptions thrown by the future are propagated back to the thread that
gets the answer from the future. Normal threads simply die if they have
unhandled exceptions.</simpara>
<simpara>After all the values have been read and summed, we shut the
<literal>ExecutorService</literal> down. If we had wanted, we could have submitted
additional <literal>Callable</literal> objects to it to run more futures. Finally, we
print out the result.</simpara>
</example>
</section>
<section xml:id="_exercises_18">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="exercise:recursive_addition"/> ExampleÂ <xref linkend="example:Multiplication_defined_recursively"/> gave a mathematical recursive definition for
<inlineequation><alt><![CDATA[x \times y]]></alt><mathphrase><![CDATA[x \times y]]></mathphrase></inlineequation>. Give a similar recursive definition for
<inlineequation><alt><![CDATA[x + y]]></alt><mathphrase><![CDATA[x + y]]></mathphrase></inlineequation>. The structure is similar to the recursion to
determine your current age given in SectionÂ <xref linkend="subsection:What_is_recursion"/>.</simpara>
</listitem>
<listitem>
<simpara>In principle, every problem that can be solved with an iterative
solution can be solved with a recursive one (and vice versa). However,
the limited size of the call stack can present problems for recursive
solutions with very deep recursion. Why? Conversely, are there any
recursive solutions that are impossible to turn into iterative ones?</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:inefficient_Fibonacci"/> Consider the first (non-memoized)
recursive version of the Fibonacci method given in
ExampleÂ <xref linkend="example:Fibonacci_implemented_recursively"/>. How many times is
<literal>fibonacci()</literal> called with argument <inlineequation><alt><![CDATA[1]]></alt><mathphrase><![CDATA[1]]></mathphrase></inlineequation> to compute
<literal>fibonacci(n)</literal>? Instrument your program and count the number of calls
for <inlineequation><alt><![CDATA[n = 2, 3, 4 \ldots 20]]></alt><mathphrase><![CDATA[n = 2, 3, 4 \ldots 20]]></mathphrase></inlineequation>.</simpara>
</listitem>
<listitem>
<simpara>In the recursive <literal>solve()</literal> method in the <literal>MazeSolver</literal> program given
in SectionÂ <xref linkend="solution:Maze_of_doom"/>, the current location in the maze
array is is set to a blank character (<literal>' '</literal>) after no solution had been
found. What value was in that location? How would the program behave if
the value was not changed?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:recursive_palindromes"/> ExerciseÂ <xref linkend="exercise:palindromes"/>
from ChapterÂ <xref linkend="chapter:Methods"/> challenges you to write a method to
determine whether a <literal>String</literal> contains a palindrome. Recall that a
palindrome (if punctuation and spaces are ignored) can be described as a
<literal>String</literal> in which the first and last characters are equal, and all the
characters in between form a palindrome. Write a recursive method to
test if a <literal>String</literal> is a palindrome, using the following signature.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static boolean isPalindrome( String text, int start,
    int end )</programlisting>
<simpara>In this method, the <literal>start</literal> parameter is the index of the first
character you are examining, and the <literal>end</literal> parameter is the index
immediately after the last character you are examining. Thus, it would
initially be called with a <literal>String</literal>, <literal>0</literal>, and the length of the
<literal>String</literal>, as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">boolean result =
    isPalindrome( "A man, a plan, a canal: Panama", 0, 30 );</programlisting>
</listitem>
<listitem>
<simpara><xref linkend="exercise:Fibonacci_without_array"/> The efficient implementation of
Fibonacci from ExampleÂ <xref linkend="example:Fibonacci_implemented_recursively"/>
eliminates redundant computation through memoization, storing values in
an array as they are found. It is possible to carry along the
computations of the previous two Fibonacci numbers <emphasis role="strong">without</emphasis> the
overhead of storing an array. Consider the following method signature.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static int fibonacci(int previous, int current, int n)</programlisting>
<simpara>The next recursive call to the <literal>fibonacci()</literal> method passes in <literal>n - 1</literal>
and suitably altered versions of <literal>previous</literal> and <literal>current</literal>. When <literal>n</literal>
reaches <literal>0</literal>, the <literal>current</literal> parameter holds the value of the Fibonacci
number you were originally looking for.</simpara>
<simpara>The method would be called as follows for any value of <literal>n</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">int result = fibonacci( 0, 1, n );</programlisting>
<simpara>Complete the implementation of this recursive method.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:efficient_exponentiation"/> Write an implementation of
fast exponentiation that works for even and odd <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation>. This
implementation is exactly the same as the one given at the end of
ExampleÂ <xref linkend="example:Exponentiation"/> except when <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> is odd.
Use the following recursive definition of exponentiation to guide your
implementation.</simpara>
<simpara><inlineequation><alt><![CDATA[a^n =
\begin{cases} a & \text{if  $n=1$} & \text{(Base Case)}
\\
\left(a^{\frac{n}{2}}\right)^2 & \text{if  $n>1$ and even} & \text{(Base Case)}
\\
a\cdot \left(a^{\frac{n - 1}{2}}\right)^2 & \text{if  $n>1$ and odd} & \text{(Base Case)}
\end{cases}]]></alt><mathphrase><![CDATA[a^n =
\begin{cases} a & \text{if  $n=1$} & \text{(Base Case)}
\\
\left(a^{\frac{n}{2}}\right)^2 & \text{if  $n>1$ and even} & \text{(Base Case)}
\\
a\cdot \left(a^{\frac{n - 1}{2}}\right)^2 & \text{if  $n>1$ and odd} & \text{(Base Case)}
\end{cases}]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:efficient_Fibonacci"/> ExampleÂ <xref linkend="example:Fibonacci_implemented_recursively"/> shows two implementations that can be used to
find the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> Fibonacci number. With a little bit of
math, it is possible to show that there is a closed-form equation that
gives the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> Fibonacci number <inlineequation><alt><![CDATA[F_n]]></alt><mathphrase><![CDATA[F_n]]></mathphrase></inlineequation> where
<inlineequation><alt><![CDATA[F_0 = F_1 = 1]]></alt><mathphrase><![CDATA[F_0 = F_1 = 1]]></mathphrase></inlineequation>.</simpara>
<simpara><inlineequation><alt><![CDATA[F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^{n+1}  -  \left(\frac{1 -
\sqrt{5}}{2}\right)^{n+1}}{\sqrt{5}}]]></alt><mathphrase><![CDATA[F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^{n+1}  -  \left(\frac{1 -
\sqrt{5}}{2}\right)^{n+1}}{\sqrt{5}}]]></mathphrase></inlineequation></simpara>
<simpara>Although this math is a bit ugly, you can plug numbers into this
equation and discover the value of <inlineequation><alt><![CDATA[F_n]]></alt><mathphrase><![CDATA[F_n]]></mathphrase></inlineequation> quickly, provided
that you have an efficient way to raise values to the
<inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> power. Use the recursive algorithm for fast
exponentation from ExerciseÂ <xref linkend="exercise:efficient_exponentiation"/> to
make an implementation that finds the <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation><superscript>th</superscript> Fibonacci
number <emphasis role="strong">very</emphasis> quickly.</simpara>
<simpara>Note that this approach uses real numbers (including
<inlineequation><alt><![CDATA[\sqrt{5}]]></alt><mathphrase><![CDATA[\sqrt{5}]]></mathphrase></inlineequation>) that need to be represented as <literal>double</literal> values.
There are exact methods that use fast exponentiation of integer matrices
to do this computation without doing any floating-point arithmetic, but
we do not go into those details here.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:print_linked_list"/> ExampleÂ <xref linkend="example:Recursive_linked_list_size"/> shows a way to calculate the size of a linked list
recursively. Add a recursive method called <literal>print()</literal> to the
<literal>RecursiveListSize</literal> class that prints out the values in the linked list
recursively, on each line.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:reverse_print_linked_list"/> Expand the previous exercise
to add another method called <literal>reversePrint()</literal> that prints out the values
in the linked list the <emphasis role="strong">opposite</emphasis> order that they appear. It should take
only a slight modification of the <literal>print()</literal> method you have already
written.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:tree_find"/> Create a recursive <literal>find()</literal> method (and a
non-recursive proxy method to call it) for the <literal>Tree</literal> class given in
ProgramÂ <xref linkend="program:Tree"/>. Its operation is similar to the <literal>add()</literal>
method. If the subtree it is examining is empty (<literal>null</literal>), it should
return <literal>false</literal>. If the value it is looking for is at the root of the
current subtree, it should return <literal>true</literal>. These are the two base cases.
If the value it is looking for comes earlier in the alphabet than the
value at the root of the current subtree, it should look in the left
subtree. If the value it is looking for comes later in the alphabet than
the value at the root of the current subtree, it should look in the
right subtree. These are the two recursive cases.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:tree_height"/> The height of a binary tree is defined as
the longest path from the root to any leaf node. Thus, the height of a
tree with only a root node in it is 0. By convention, the height of an
empty tree is -1.</simpara>
<simpara>Create a recursive <literal>getHeight()</literal> method (and a non-recursive proxy
method to call it) for the <literal>Tree</literal> class given in
ProgramÂ <xref linkend="program:Tree"/>. The base case is an empty tree (a <literal>null</literal>
pointer), which has a height of -1. For the recursive case of a
non-empty tree, its height is one more than the height of the larger of
its two subtrees.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:setInterfaceExercise"/> Create an <literal>interface</literal> that
describes a tree ADT. Modify the programs in ExampleÂ <xref linkend="example:Binary_search_tree"/> to use this <literal>interface</literal>.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Write an iterative version of the factorial function and compare its
speed to the recursive version given in the text. Use the
<literal>System.currentTimeMillis()</literal> or<?asciidoc-br?>
<literal>System.nanoTime()</literal> methods before and after <literal>for</literal> loops that call the
factorial methods 1,000,000 times each for random values.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:sort_timing"/> Write a program that generates four arrays
of random <literal>int</literal> values with lengths 1,000, 10,000, 100,000, and
1,000,000. Make two additional copies of each array. Then, sort each of
three copies of the array with the selection sort algorithm given in
ExampleÂ <xref linkend="example:Selection_sort"/>, the bubble sort algorithm given in
SectionÂ <xref linkend="section:Problem:_Sort_it_out"/>, and the merge sort algorithm given in
ExampleÂ <xref linkend="example:Merge_sort"/>, respectively. Use the
<literal>System.currentTimeMillis()</literal> or <literal>System.nanoTime()</literal> methods to time each
of the sorts. Note that both selection sort and bubble sort may take
quite a while to sort an array of 1,000,000 elements.</simpara>
<simpara>Run the program several times and find average values for each algorithm
on each array size. Plot those times on a graph. The times needed to run
selection sort and bubble sort should increase quadratically, but the
time to run merge sort should increase linearithmically. In other words,
an array length of <inlineequation><alt><![CDATA[n]]></alt><mathphrase><![CDATA[n]]></mathphrase></inlineequation> should take time proportional to
<inlineequation><alt><![CDATA[n^2]]></alt><mathphrase><![CDATA[n^2]]></mathphrase></inlineequation> (multiplied by some constant) for selection sort and
bubble sort, but it should take time proportional to
<inlineequation><alt><![CDATA[n \log n]]></alt><mathphrase><![CDATA[n \log n]]></mathphrase></inlineequation> (multiplied by some constant) for merge sort. For
large arrays, the difference in time is significant.</simpara>
</listitem>
<listitem>
<simpara>Investigate the performance of using recursion to compute Fibonacci
numbers. Implement the naive recursive solution, the memoization method,
and an iterative solution similar to the memoization method. Use the
<literal>System.currentTimeMillis()</literal> or <literal>System.nanoTime()</literal> methods to time the
computations for large values of <literal>n</literal>. (<emphasis role="strong">Warning:</emphasis> It may take a very
long time to compute the <literal>n</literal><superscript>th</superscript> Fibonacci number with the naive
recursive solution.)</simpara>
</listitem>
<listitem>
<simpara>ExerciseÂ <xref linkend="exercise:binary_search"/> from ChapterÂ <xref linkend="chapter:Arrays"/>
explains how binary search can be used to search for a value in a sorted
array of values. The idea is to play a &#8220;high-low&#8221; game, first looking
at the middle value. If the value is the one you&#8217;re looking for, you&#8217;re
done. If it is too high, look in the lower half of the array. If it is
too low, look in the upper half of the array. Implement binary search
both iteratively and recursively. Populate an array with 100,000 <literal>int</literal>
values between 1 and 10,000,000 and sort it. Then, search for 1,000,000
random values generated betwee 1 and 10,000,000 using iterative binary
search and then recursive binary search. Use the
<literal>System.currentTimeMillis()</literal> or <literal>System.nanoTime()</literal> methods to time each
process. Was the iterative or recursive approach faster? By how much?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:File_IO">
<title>File I/O</title>
<blockquote>
<attribution>
The Dark Crystal
</attribution>
<simpara><emphasis role="strong">Kira:</emphasis> What are those funny marks?<?asciidoc-br?>
<emphasis role="strong">Jen:</emphasis> This is all writing.<?asciidoc-br?>
<emphasis role="strong">Kira:</emphasis> What&#8217;s writing?<?asciidoc-br?>
<emphasis role="strong">Jen:</emphasis> Words that stay, my master said.</simpara>
</blockquote>
<section xml:id="_problem_a_picture_is_worth_1_000_bytes">
<title>Problem: A picture is worth 1,000 bytes</title>
<simpara>If you are familiar with bitmap (bmp) files, you know that they can get
very large. People often use a technique called data compression to
reduce the size of large files for storage. There are many different
kinds of compression and many which are tailored to work well on images.
Your task is to write a program that will do a particular kind of
compression called run length encoding (RLE), which we will test on
bitmaps. The idea behind RLE is simple: Imagine a file as a stream of
bytes. As you look through the stream, replace repeating sequences of a
single byte with a count telling how many times it repeats followed by
the byte that repeats. Consider the following sequence.</simpara>
<simpara><literal>215 7 7 7 7 7 7 7 7 7 123 94 94 94 71</literal></simpara>
<simpara>Its RLE compressed version could be as follows.</simpara>
<simpara><literal>1 215 9 7 1 123 3 94 1 71</literal></simpara>
<simpara>Since there is no simple way to keep track of which numbers are counts
and which ones are actual bytes of data, we have to keep a count for
every byte, even unrepeated ones. In this example, we went down from 15
numbers to 10 numbers, a savings of a third. In the worst case, a file
that has no repetition at all would actually double in size after being
&#8220;compressed&#8221; with this kind of RLE. Nevertheless, RLE compression is
used in practice and performs very well in some situations.</simpara>
<simpara>Your job is to write a Java program that takes two arguments from the
command line. The first is either <literal>-c</literal> for compress or <literal>-d</literal> for
decompress. The second argument is the name of the file to be compressed
or decompressed. When compressing, append the suffix <literal>.compress</literal> to the
end of the file name. When decompressing, remove that suffix.</simpara>
<simpara>Executing <literal>java BitmapCompression -c test.bmp</literal> from the command line
should generate an RLE compressed file called <literal>test.bmp.compress</literal>.</simpara>
<simpara>Likewise, executing <literal>java BitmapCompression -d test.bmp.compress</literal> should
create an uncompressed file called <literal>test.bmp</literal>. Be sure to make a backup
of the original file (in this case <literal>test.bmp</literal>) because decompressing
will overwrite a file of the same name.</simpara>
<simpara>To perform the compression, go byte by byte through the file. For each
repeating sequence of a byte (which can be as short as a single byte
long), write the length of the sequence as a byte and then the byte
itself into the compressed file. If a repeating sequence is more than
127 bytes, you must break the sequence into more than one piece since
the largest value the <literal>byte</literal> data type can hold in Java is 127. (The
<literal>byte</literal> type in Java is always signed, giving a range of -128 to 127.)
Decompression simply reads the count then the byte value and writes the
appropriate number of copies of the byte value into the decompressed
file.</simpara>
</section>
<section xml:id="_concepts_file_i_o">
<title>Concepts: File I/O</title>
<simpara>Before you can begin to tackle the problem of compressing, or even
reading from and writing to, files, some background on files might be
useful. By now, you have had many experiences with files: editing Java
source files, compiling those files, and running them on a virtual
machine, at the very least. You have probably done some word processing,
looked at photos, listened to music, and watched videos, all on a
computer. Each of these activities centers on one or more files. In
order to reach these files, you probably had to look through some
directories, which are a special kind of file as well. But, what is a
file?</simpara>
<section xml:id="_non_volatile_storage">
<title>Non-volatile storage</title>
<simpara>A computer program is like a living thing, always moving and restless.
The variables in a program are stored in RAM, which is volatile storage.
The data in volatile memory will only persist as long as there is
electricity powering it. But programs do not run constantly, and neither
do most computers. We need a place to store data between runs of a
particular program. Likewise, we need a place to store data when our
computer isn&#8217;t turned on. Both scenarios share a common solution:
secondary storage such as hard drives, flash drives, and optical media
like CD-ROMs and DVD-ROMs.</simpara>
<simpara>Files are not always stored in non-volatile memory. It is possible to
load entire files into RAM and keep them there for long periods of time.
Likewise, all input and output on Unix and Linux systems are viewed as
file operations. Nevertheless, the characteristics of non-volatile
memory are often associated with file I/O: slow access times and the
possibility of errors in the event of hardware problems.</simpara>
</section>
<section xml:id="_stream_model">
<title>Stream model</title>
<simpara>While discussing RLE encoding, we described a file as a stream of bytes,
and that is a good definition for a file, especially in Java. Since Java
is platform independent, and different operating systems and hardware
will deal with the nitty gritty details of storing files in different
ways, we want to think about files as abstractly as possible. The idea
of a stream of bytes should make a connection with all the other input
and output you have done so far. For the most part, file I/O will be
similar and, in fact, can use some of the same classes.</simpara>
<simpara>Although reading and writing from the files will be very much like
reading from the keyboard and writing to the screen, there are a few
additional complications. For one thing, you must open a file before you
can read and write. Sometimes opening the file will fail: You could try
to open a file for reading which does not exist or try to open a file
for writing which you do not have permissions for. When reading data,
you might try to read past the end of the file or try to read an <literal>int</literal>
when the next item is a <literal>String</literal>. Unlike reading from the keyboard, you
cannot ask the user to try again if there is a mistake in input. To deal
with all these possible errors, exception handling will accompany many
different file I/O operations in Java.</simpara>
</section>
<section xml:id="_text_files_and_binary_files">
<title>Text files and binary files</title>
<simpara>When talking about files, many people divide files into two categories:
<emphasis>text files</emphasis> and <emphasis>binary files</emphasis>. A text file can be read by humans. That
is, when you open a text file with a simple file reader, it will not be
filled by gibberish and nonsense characters. A Java source file is an
excellent example of a text file.</simpara>
<simpara>In contrast, a binary file is a file meant only to be read by a
computer. Instead of printing out characters meant to be read by a
human, the raw bytes of memory for specific pieces of data are written
to binary files. To clarify, if we wanted to write the number 2127480645
in a text file, the file would contain the following.</simpara>
<simpara><literal>2127480645</literal></simpara>
<simpara>However, if we wanted to write the same number in a binary file, the
file would contain the following.</simpara>
<simpara><literal>~ÃÃE</literal></simpara>
<simpara>If you recall, an <literal>int</literal> in Java uses four bytes of storage. There is a
system of encoding called the ASCII table which maps each of the 256
(0â255) numerical bytes to a character. The four characters given above
are the ASCII representation of the four bytes of the number 2127480645.</simpara>
<simpara>In some sense, the idea of a text file is artificial. All files are
binary in the sense that they are readable by a computer. You will take
different steps and create different objects depending on whether you
want to do file I/O in the text or binary paradigms, but the overall
process will be similar in either case.</simpara>
</section>
</section>
<section xml:id="_syntax_file_operations_in_java">
<title>Syntax: File operations in Java</title>
<section xml:id="_the_literal_file_literal_class">
<title>The <literal>File</literal> class</title>
<simpara>The most basic object for interacting with a file in Java are objects of
the <literal>File</literal> class. A <literal>File</literal> object allows you to interact with a file at
the operating system level. You can create new files, test to see if a
file is a directory, find out the size of a file, and so on. A number of
file I/O classes require a <literal>File</literal> object as a parameter. To use the
<literal>File</literal> class, import <literal>java.io.File</literal> or <literal>java.io.*</literal>.</simpara>
<simpara>To create a <literal>File</literal> object, you can call the <literal>File</literal> constructor with a
<literal>String</literal> specifying the name of the file.</simpara>
<programlisting language="java" linenumbering="unnumbered">File file = new File("file.txt");</programlisting>
<simpara>Doing so will create a virtual file object associated with the name
<literal>file.txt</literal> (which may not exist yet) in the working directory of the
Java program. In this case, the extension <literal>.txt</literal> doesn&#8217;t have any real
meaning. On many systems, the extension (like <literal>.doc</literal> or <literal>.html</literal>) is used
by the operating system to guess which application should open the file.
To Java, however, the extension is just part of the file name. A file
name passed to the constructor of a <literal>File</literal> object can have any number of
periods in it.</simpara>
<simpara>Creating a file is all well and good, but file systems are useful in
part because of their hierarchical structure. If we want to create a
file in a particular location, we specify the <emphasis>path</emphasis> in the <literal>String</literal>
before the name of the file.</simpara>
<programlisting language="java" linenumbering="unnumbered">File file = new File("/homes/owilde/programs/file.txt");</programlisting>
<simpara>In this case, the prefix <literal>"/homes/owilde/programs/"</literal> is the path and
<literal>"file.txt"</literal> is still the file name. Each slash (<literal>'/'</literal>) separates a
parent directory from the files or directories inside of it. This path
specifies that we start at the root, go into the <literal>homes</literal> directory, then
the <literal>owilde</literal> directory, and then the <literal>programs</literal> directory. Note that we
can also use a single period (<literal>.</literal>) in a path to refer to the current
working directory and two periods (<literal>..</literal>) to refer to a parent directory.</simpara>
<simpara>This is one of those sticky places where Java is trying to be platform
independent, but the platforms each have different needs. The example we
gave above is for a Unix or Linux system. In Windows, the way to specify
the path is slightly different. Creating a similar <literal>File</literal> object on
Windows system might be done as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">File file = new File("C:\\My Documents\\programs\\file.txt");</programlisting>
<simpara>Then, the path specifies that we start in the <literal>C</literal> drive, go into the
<literal>My Documents</literal> directory and then the <literal>programs</literal> directory. Windows
systems use a backslash (<literal>\</literal>) to separate a parent directory from its
children. But, in Java, a backslash is not allowed to be by itself in a
string literal, and so each backslash must be escaped with another
backslash. To simplify things somewhat, Java allows Windows paths to be
separated with regular slashes as well, so we will use this style for
the rest of the book.</simpara>
<simpara>If we return to objects of class <literal>File</literal>, there are a number of things we
can do directly. A <literal>File</literal> object has methods that can test if a file
with the associated name and path exists, if it is readable, if it is
writable, and many other things. Because there are so many classes
associated with file I/O and each class has so many methods, now is a
good time to remind you of the usefulness of the Java API. If you visit
<link xl:href="http://docs.oracle.com/javase/">http://docs.oracle.com/javase/</link>, you can choose the edition of Java you
are using and get detailed documentation for all of the standard
library, including file I/O classes.</simpara>
</section>
<section xml:id="_reading_and_writing_text_files">
<title>Reading and writing text files</title>
<simpara>Once you have a <literal>File</literal> object, its true usefulness comes from combining
it with other classes. You are already familiar with the <literal>Scanner</literal>
class, and once you have a <literal>File</literal> object, reading from a text file is
the same as reading from the keyboard.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = null;
try {
    in = new Scanner( file );
    while( in.hasNextInt() )
        process( in.nextInt() );
}
catch( FileNotFoundException e ) {
    System.out.println("File " + file.getName() + " not found!");
}
finally { if( in != null ) in.close(); }</programlisting>
<simpara>Assuming that <literal>file</literal> is linked to a file which the program has read
access to, this block of code will extract <literal>int</literal> values from the file
and pass them to the <literal>process()</literal> method. If the file does not exist or
is not readable to the program, a <literal>FileNotFoundException</literal> will be thrown
and an error message printed. Creating a <literal>Scanner</literal> from a <literal>File</literal> object
instead of <literal>System.in</literal> can throw a checked exception, and so the <literal>try</literal>
and <literal>catch</literal> are needed before the program will compile. Note that you
will need to import <literal>java.util.Scanner</literal> or <literal>java.util.*</literal> just like any
other time you use the <literal>Scanner</literal> class.</simpara>
<simpara>And that&#8217;s all there is to it. After opening the file, using the
<literal>Scanner</literal> class will be almost the same as before. One difference is
that you should close the <literal>Scanner</literal> object (and by extension the file)
when you are done reading from it, as we do in the example. Closing
files is key to writing robust code. You&#8217;ll notice that we put
<literal>in.close()</literal> in a <literal>finally</literal> block. Using <literal>finally</literal> is a good habit for
file I/O. File operations could fail for any number of reasons, but you
will still need to close the file afterwards. We put in the <literal>null</literal> check
in case the file didn&#8217;t exist and the reference <literal>in</literal> never pointed to a
valid object. (We also begin by setting <literal>in</literal> to <literal>null</literal>. Otherwise, Java
complains that it might not have been initialized.)</simpara>
<simpara>Writing information to a file is similar to using <literal>System.out</literal>. First,
you need to create a <literal>PrintWriter</literal> object. Unlike <literal>Scanner</literal>, you cannot
create a <literal>PrintWriter</literal> object directly from a <literal>File</literal> object. Instead,
you have to create a <literal>FileOutputStream</literal> object first. If we want to
write a list of random numbers to the file we were reading from earlier,
we could do it as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">PrintWriter out = null;
try {
    out = new PrintWriter( new FileOutputStream( file ) );
    Random random = new Random();
    for( int i = 0; i &lt; 100; i++ )
        out.println( random.nextInt() );
}
catch( FileNotFoundException e ) {
    System.out.println("File " + file.getName() + " not found!");
}
finally { if( out != null ) out.close(); }</programlisting>
<simpara>Again, once you have a <literal>PrintWriter</literal> object, the methods for outputting
data will be just like using <literal>System.out</literal>. In this case, we already had
an <literal>File</literal> object lying around. To save time, the <literal>FileOutputStream</literal>
constructor can take a path name instead of a <literal>File</literal> object. So, it
would be equivalent to create the <literal>PrintWriter</literal> from above by supplying
a path like so.</simpara>
<programlisting language="java" linenumbering="unnumbered">PrintWriter out = new PrintWriter(
new FileOutputStream( "/homes/owilde/programs/file.txt" ) );</programlisting>
<simpara>Be sure to import <literal>java.io.*</literal> in order to have access to the
<literal>FileOutputStream</literal> and <literal>PrintWriter</literal> classes.</simpara>
</section>
<section xml:id="_reading_and_writing_binary_files">
<title>Reading and writing binary files</title>
<simpara>We covered text files first because the input and output is similar to
console I/O. When reading and writing text files, it&#8217;s easy to verify
that what you wanted to write was written and what you read was what was
in the file. Binary files, however, are more powerful. Data, as in the
example with the integer 2127480645, can often be stored more compactly.
Even better, Java provides facilities for easily dumping (and later
retrieving) primitive data types, objects, and even complex data
structures to binary files.</simpara>
<simpara>The first object you&#8217;ll need to read input from a binary file is a
<literal>FileInputStream</literal> object. As before, all you need is a <literal>File</literal> object to
create one.</simpara>
<programlisting language="java" linenumbering="unnumbered">File file = new File( "file.bin" );
FileInputStream in = new FileInputStream( file );</programlisting>
<simpara>As it happens, <literal>FileInputStream</literal> also allows you to call its constructor
with a <literal>String</literal> specifying the file path and name.</simpara>
<programlisting language="java" linenumbering="unnumbered">FileInputStream in = new FileInputStream( "file.bin" );</programlisting>
<simpara>The bad news is that you can&#8217;t do much with a <literal>FileInputStream</literal> object.
Its methods allow you to read single bytes, either one at a time, or a
group of them into an array. The basic <literal>read()</literal> method returns the next
byte in the file, or a -1 if the end of the file has been reached.
Working at the low level of bytes, we can still write useful code like
the following method which prints the size of a file.</simpara>
<programlisting language="java" linenumbering="unnumbered">public static void printFileSize( String fileName ) {
    FileInputStream in = null;
    try {
        in = new FileInputStream( fileName );
        int count = 0;
        while( in.read() != -1 )
            count++;
        System.out.println("File size: " + count + " bytes" );
    }
    catch( Exception e ) {
        System.out.println("File access failed.");
    }
    finally { try{ in.close(); } catch(Exception e){} }
}</programlisting>
<simpara>Note the extra <literal>try</literal>-<literal>catch</literal> block inside of the <literal>finally</literal>. Like the
other binary file I/O objects we will discuss in this chapter,
<literal>FileInputStream</literal> can throw a <literal>IOException</literal> when closing. Usually, you
will not need to deal with this exception, but you still must catch it.
By catching any <literal>Exception</literal>, we can save a little bit of code by
eliminating the <literal>null</literal> check. If <literal>in</literal> is <literal>null</literal> in this example, a
<literal>NullPointerException</literal> will be thrown and immediately caught, causing no
damage.</simpara>
<simpara>To output a number of bytes, you can create a <literal>FileOutputStream</literal> object.
Its <literal>write()</literal> methods are the mirror images of the <literal>read()</literal> methods in
<literal>FileInputStream</literal>. For output, what we really want is an object which
will chop up primitive data types and objects into their component bytes
and send those bytes to a <literal>FileOutputStream</literal>. Then, for input, we would
want an object which could read a sequence of bytes from a
<literal>FileInputStream</literal> and reassemble them into whatever kind of data they
are supposed to be.</simpara>
<simpara>These objects exist, and they belong to the <literal>ObjectInputStream</literal> and
<literal>ObjectOutputStream</literal> classes, respectively. To create an
<literal>ObjectInputStream</literal>, you supply a <literal>FileInputStream</literal> to its constructor.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectInputStream in =
    new ObjectInputStream( new FileInputStream( "baseball.bin" ) );</programlisting>
<simpara>Now, let&#8217;s assume that <literal>baseball.bin</literal> contains baseball statistics. The
first thing in the file is an <literal>int</literal> indicating the number of records it
contains. Then, for each record, it will list home runs, RBI, and
batting average, as an <literal>int</literal>, an <literal>int</literal>, and a <literal>float</literal>, respectively.
Assuming that we&#8217;ve opened the file correctly above, we can read these
statistics into three arrays with the following code.</simpara>
<programlisting language="java" linenumbering="unnumbered">int records = in.readInt();
int[] homeRuns = new int[records];
int[] RBI = new int[records];
float[] battingAverage = new float[records];
for( int i = 0; i &lt; records; i++ ) {
    homeRuns[i] = in.readInt();
    RBI[i] = in.readInt();
    battingAverage[i] = in.readFloat();
}</programlisting>
<simpara>Of course, all of the code should be enclosed in a <literal>try</literal> block with
appropriate exception handling and <literal>in.close()</literal> in a <literal>finally</literal> block at
the end. If an <literal>ObjectInputStream</literal> object tries to read past the end of
a file, an <literal>EOFException</literal> exception will be thrown. Using an
<literal>ObjectInputStream</literal> object to read from a file also assumes that the
file was created with an <literal>ObjectOutputStream</literal> object. If you substitute
<literal>write</literal> for <literal>read</literal>, <literal>ObjectOutputStream</literal> methods are almost the same as
<literal>ObjectInputStream</literal> methods. Below is a companion piece of code which
assumes that <literal>homeRuns</literal>, <literal>RBI</literal>, and <literal>battingAverage</literal> are filled with
data and writes them to a file.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectOutputStream out = null;
try {
    out = new ObjectOutputStream(
        new FileOutputStream("baseball.bin") );
    out.writeInt( homeRuns.length );
    for( int i = 0; i &lt; homeRuns.length; i++ ) {
        out.writeInt( homeRuns[i] );
        out.writeInt( RBI[i] );
        out.writeFloat( battingAverage[i] );
    }
}
catch( Exception e ) {
    System.out.println( "File writing failed." );
}
finally { try{ out.close(); } catch( Exception e ){} }</programlisting>
<simpara>Using <literal>ObjectInputStream</literal> and <literal>ObjectOutputStream</literal> in this way is not
too difficult, but it seems cumbersome. The objects provide methods
which elegantly allow you to read and write a whole object at a time. To
do so, we need to define a new class.</simpara>
<formalpara xml:id="program:BaseballPlayer" xreflabel="BaseballPlayer">
<title>Serializable BaseballPlayer class.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.io.Serializable;

public class BaseballPlayer implements Serializable {
	private int homeRuns;
	private int RBI;
	private float battingAverage;

	public BaseballPlayer( int homeRuns, int RBI, float battingAverage ) {
		this.homeRuns = homeRuns;
		this.RBI = RBI;
		this.battingAverage = battingAverage;
	}

	public int getHomeRuns() { return homeRuns; }
	public int getRBI() { return RBI; }
	public float getBattingAverage() { return battingAverage; }
}</programlisting>
</para>
</formalpara>
<simpara>The new class <literal>BaseballPlayer</literal> encapsulates the three pieces of
information we want. Note that it also implements the interface
<literal>Serializable</literal>, but it doesn&#8217;t seem to implement any special methods to
conform to the interface. We&#8217;ll discuss this more after we show how
using this new class can simplify the file I/O. The input will change to
the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectInputStream in = null;
try {
    in = new ObjectInputStream(
        new FileInputStream( "baseball.bin" ));
    int records = in.readInt();
    BaseballPlayer[] players = new BaseballPlayer[records];
    for( int i = 0; i &lt; players.length; i++ )
        players[i] = (BaseballPlayer)in.readObject();
}
catch( Exception e ) {
    System.out.println( "File reading failed." );
}
finally { try{ in.close(); } catch(Exception e){} }</programlisting>
<simpara>The output will become what follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectOutputStream out = null;
try {
    out = new ObjectOutputStream(
        new FileOutputStream( "baseball.bin" ));
    out.writeInt( players.length );
    for( int i = 0; i &lt; players.length; i++ )
        out.writeObject( players[i] );
}
catch( Exception e ) {
    System.out.println( "File writing failed." );
}
finally { try{ out.close(); } catch(Exception e){} }</programlisting>
<simpara>This process of outputting an entire object at a time is called
<emphasis>serialization</emphasis>. The <literal>BaseballPlayer</literal> class is very simple, but even
complex objects can be serialized, and Java takes care of almost
everything for you. The only magic needed is for the class which is
going to be serialized to implement <literal>Serializable</literal>. There are no methods
in <literal>Serializable</literal>. It is just a tag for a class which can be packed up
and stored. The catch is that, if there are any references to other
objects inside of the object being serialized, they must also be
serializable. Otherwise, a <literal>NotSerializableException</literal> will be thrown
when the JVM tries to serialize. Most things are serializable, including
the vast majority of the Java API.</simpara>
<simpara>However, objects which have some kind of special system dependent state,
like a <literal>Thread</literal> or a<?asciidoc-br?>
<literal>FileInputStream</literal> object cannot be serialized. If you need to serialize
a class with references to objects like these, add the <literal>transient</literal>
keyword to the declaration of each unserializable reference. That said,
these should be few and far between. For <literal>BaseballPlayer</literal>, adding
<literal>implements Serializable</literal> was all that was needed, and we can still get
more mileage out of it. Consider that an array can be treated liked an
<literal>Object</literal> and is also serializable. We can further simplify the input as
below.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectInputStream in = null;
try {
    in = new ObjectInputStream(
        new FileInputStream( "baseball.bin" ));
    BaseballPlayer[] players = (BaseballPlayer[])in.readObject();
}
catch( Exception e ) {
    System.out.println( "File reading failed." );
}
finally { try{ in.close(); } catch(Exception e){} }</programlisting>
<simpara>And the corresponding output code can be simplified as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectOutputStream out = null;
try {
    out = new ObjectOutputStream(
        new FileOutputStream( "baseball.bin" ));
    out.writeObject( players );
}
catch( Exception e ) {
    System.out.println( "File writing failed." );
}
finally { try{ out.close(); } catch(Exception e){} }</programlisting>
<simpara>It is worth noting that <literal>DataInputStream</literal> and <literal>DataOutputStream</literal> objects
can be used in place of <literal>ObjectInputStream</literal> and <literal>ObjectOutputStream</literal>
objects if you only need to read and write primitive data.</simpara>
</section>
</section>
<section xml:id="_examples_file_examples">
<title>Examples: File examples</title>
<example>
<title>Directory listing</title>
<simpara>Let&#8217;s return to the <literal>File</literal> class and look at another example of how to
use it. It is often useful to know the contents of a directory. At the
Windows command prompt, this is usually done using the <literal>dir</literal> command; in
Linux and Unix, the <literal>ls</literal> command is generally used. In a few lines of
code, we can write a directory listing tool which lists all the files in
a directory, the dates each was last modified, and whether or not a file
is a directory.</simpara>
<formalpara xml:id="program:Directory" xreflabel="Directory">
<title>Directory listing tool.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.io.*;
import java.text.*;
import java.util.*;

public class Directory {
	public static void main(String[] args) {
		File directory = new File(".");
		File[] files = directory.listFiles();
		for( File file : files ) {
			System.out.print( DateFormat.getDateInstance().format(
				new Date( file.lastModified()) ) + "\t");
			if( file.isDirectory() )
				System.out.print( "directory" );
			else
				System.out.print( "\t" );
			System.out.println( "\t" +  file.getName() );
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>As you can see, the code first creates a <literal>File</literal> object using <literal>"."</literal> to
specify the current working directory. The <literal>listFiles()</literal> method returns
an array of <literal>File</literal> objects which we then iterate over. We call
<literal>lastModified()</literal> on each file to get its date, <literal>isDirectory()</literal> to see if
it is a directory, and finally print the name given by <literal>getName()</literal>.</simpara>
</example>
<example>
<title>Radiuses stored in a file</title>
<simpara>Now, let&#8217;s look at a data processing application of files. Let&#8217;s assume
that there is a file called <literal>radiuses.txt</literal> which holds the radiuses of a
number of circles formatted as text, one on each line of the file. It&#8217;s
our job to read each radius, compute the area of the circle, and write
those areas to a file called <literal>areas.txt</literal>, using the formula
<inlineequation><alt><![CDATA[A = \pi r^2]]></alt><mathphrase><![CDATA[A = \pi r^2]]></mathphrase></inlineequation>.</simpara>
<formalpara xml:id="program:AreaFromRadiusText" xreflabel="AreaFromRadiusText">
<title>Program to read a list of radiuses from a text file and output their areas to another file.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.io.*;
import java.util.*;

public class AreaFromRadiusText {
	public static void main(String[] args) {
		File inFile = new File( "radiuses.txt" );
		File outFile = new File( "areas.txt" );
		Scanner in = null;
		PrintWriter out = null;
		double radius;
		try {
			in = new Scanner( inFile );
			out = new PrintWriter( outFile );
			while( in.hasNextDouble() ) {
				radius = in.nextDouble();
				out.println( Math.PI*radius*radius );
			}
		}
		catch( Exception e ) {
			System.out.println( e.getMessage() );
		}
		finally {
			if( in != null ) in.close();
			if( out != null ) out.close();
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>The previous class did all of its input and output with text files. We
will also implement this program to read from a binary file called
<literal>radiuses.bin</literal> and write to a binary file called <literal>areas.bin</literal>.</simpara>
<formalpara xml:id="program:AreaFromRadiusBinary" xreflabel="AreaFromRadiusBinary">
<title>Program to read a list of radiuses from a binary file and output their areas to another file.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.io.*;

public class AreaFromRadiusBinary {
	public static void main(String[] args) {
		File inFile = new File( "radiuses.bin" );
		File outFile = new File( "areas.bin" );
		ObjectInputStream in = null;
		ObjectOutputStream out = null;
		double radius;
		try {
			in = new ObjectInputStream(
				new FileInputStream( inFile ));
			out = new ObjectOutputStream(
				new FileOutputStream( outFile ));
			while( true ) {
				radius = in.readDouble();
				out.writeDouble(  Math.PI*radius*radius );
			}
		}
		catch( EOFException e ) {}
		catch(Exception e) {
			System.out.println( e.getMessage() );
		}
		finally {
			try { in.close(); } catch( Exception e ){}
			try { out.close(); } catch( Exception e ){}
		}
	}
}</programlisting>
</para>
</formalpara>
<simpara>There should be few surprises in this piece of code as only a few
changes have been made so that <literal>ObjectInputStream</literal> and
<literal>ObjectOutputStream</literal> objects could be used. You may notice that the
input <literal>while</literal> loop is an infinite loop. The easiest way to see if there
is any more data in a binary file is to keep reading until an
<literal>EOFException</literal> is thrown. As you can see, we do nothing to handle this
exception, because, in this case, it is just a signal to stop reading.</simpara>
</example>
</section>
<section xml:id="_solution_a_picture_is_worth_1_000_bytes">
<title>Solution: A picture is worth 1,000 bytes</title>
<simpara>Now we will give the solution to the problem posed at the beginning of
the chapter. First, let&#8217;s look at the class definition and <literal>main()</literal>
method.</simpara>
<programlisting language="java" linenumbering="numbered">import java.io.*;

public class BitmapCompression {
	public static void main(String[] args) {
		ObjectInputStream in = null;
		try {
			in = new ObjectInputStream(new FileInputStream(args[1]));
			if( args[0].equals("-c"))
				compress( in, args[1] );
			else if( args[0].equals("-d"))
				decompress( in, args[1] );
		}
		catch( Exception e ) {
			System.out.println("Bad input: " + e.getMessage() );
		}
		finally { try{ in.close(); } catch( Exception e ){} }
	}</programlisting>
<simpara>Here we open an <literal>ObjectInputStream</literal> based on the file named passed as
the second command line parameter. Then, we either compress or
decompress the file depending on which switch is passed as the first
command line parameter. The <literal>catch</literal> block will deal with the
<literal>FileNotFoundException</literal> or the <literal>IOException</literal> which could be thrown by
opening the file, as well as <literal>ArrayIndexOutOfBoundsException</literal> which
could be caused if there are not enough command line arguments. In
either case, the vague message <literal>"Bad input: "</literal> will be output with the
message from the exception. Commercial-grade code should give a more
specific error.</simpara>
<simpara>After the rest of the method, note the usual <literal>finally</literal> block where the
file is closed, including the inner <literal>try</literal>-<literal>catch</literal> blocks needed to
safely close binary files.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void compress( ObjectInputStream in,
		String file ) {
		int temp, current, count = 1;
		ObjectOutputStream out = null;
		try {
			out = new ObjectOutputStream(
				new FileOutputStream( file + ".compress" ) );
			current = in.read();
			while( (temp = in.read()) != -1 ) {
				if( temp == current &amp;&amp; count &lt; 127 )
					count++;
				else {
					out.writeByte( count );
					out.writeByte( current );
					count = 1;
					current = temp;
				}
			out.write( count );
			out.write( current );
			}
		}
		catch( Exception e ) {
			System.out.println("Compression failed: "
				+ e.getMessage() );
		}
		finally { try { out.close(); }catch(Exception e){} }
	}</programlisting>
<simpara>In the <literal>compress()</literal> method we first open a new <literal>ObjectOutputStream</literal> for
a file named the same as the input file with <literal>.compress</literal> tacked on the
end. Then, we read in bytes of data from the input file. As long as we
keep seeing the same byte, we increment a counter. When we run into a
new byte (or when we reach the limit of 127 of the same consecutive
byte), we write the count and the byte we&#8217;ve been reading and move on.
When <literal>in.read()</literal> returns <literal>-1</literal>, we know that we&#8217;ve reached the end of the
file and output the last count and last byte value. The method finishes
with the usual <literal>catch</literal> and <literal>finally</literal> blocks needed to catch errors and
safely close the output file.</simpara>
<programlisting language="java" linenumbering="numbered">	public static void decompress( ObjectInputStream in,
		String file ) {
		int count, temp;
		ObjectOutputStream out = null;
		try {
			out = new ObjectOutputStream(
				new FileOutputStream( file.substring( 0,
					file.lastIndexOf(".compress")) ));
			while( (count = in.read()) != -1 ) {
				temp = in.readByte();
				for( int i = 0; i &lt; count; i++ )
					out.writeByte( temp );
			}
		}
		catch( Exception e ) {
			System.out.println("Decompression failed: "
				+ e.getMessage() );
		}
		finally { try{ out.close(); } catch(Exception e){} }
	}
}</programlisting>
<simpara>The <literal>decompress()</literal> method is even simpler than <literal>compress()</literal>. It begins
by opening a new <literal>ObjectOutputStream</literal> for a file named the same as the
input file with a <literal>.compress</literal> extension stripped off. Then, it reads a
count, reads a byte value, and writes the byte value as many times as
the count specifies.</simpara>
</section>
<section xml:id="_concurrency_file_i_o">
<title>Concurrency: File I/O</title>
<simpara>By now, you have seen threads behave in unpredictable ways because of
the way they are reading and writing to shared variables. Well, isn&#8217;t a
file a shared resource as well? What happens when two threads try to
access a file at the same time? If both threads are reading from the
file, everything should work fine. If the threads are both writing or
doing a combination of reading and writing, there can be problems.</simpara>
<simpara>As we mentioned in SectionÂ <xref linkend="syntax:File_operations_in_Java"/>, file
operations are OS dependent. Although Java tries to give a uniform
interface, different system calls are happening at a low level.
Consequently, the results may be different as well.</simpara>
<simpara>Consider the following program that spawns two threads that both print a
series of numbers to a file called <literal>concurrent.out</literal>. The first thread
prints the even numbers between 0 and 9,999 while the second thread
prints the odd ones.</simpara>
<formalpara xml:id="program:ConcurrentFileAccess" xreflabel="ConcurrentFileAccess">
<title>Program that spawns threads that print odd and even numbers to a file concurrently.</title>
<para>
<programlisting language="java" linenumbering="numbered">import java.io.*;

public class ConcurrentFileAccess implements Runnable {
	private boolean even;

	public static void main(String args[]) {
		Thread writer1 =
			new Thread( new ConcurrentFileAccess(true) );
		Thread writer2 =
			new Thread( new ConcurrentFileAccess(false) );
		writer1.start();
		writer2.start();
	}

	public ConcurrentFileAccess( boolean even ) {
		this.even = even;
	}

	public void run() {
		PrintWriter out = null;
		int start = 0;
		if( !even )
			start = 1;
		try {
			out = new PrintWriter (
					new FileOutputStream ( "concurrent.out", true ) ); /*@\label{open concurrent file}@*/
			for( int i = start; i &lt; 10000; i += 2 ) {
				out.println ( i ); /*@\label{output data concurrently}@*/
				out.flush();
			}

		}
		catch ( FileNotFoundException e ) {
			System.out.println("concurrent.out not found!");
		}
		finally { if( out != null ) out.close (); }
	}
}</programlisting>
</para>
</formalpara>
<simpara>The code in this program should have no surprises. The <literal>main()</literal> method
creates two <literal>Thread</literal> objects based on <literal>ConcurrentFileAccess</literal> objects,
each with a different value for its <literal>even</literal> field. Then, the <literal>main()</literal>
method starts the threads running. In each thread&#8217;s <literal>run()</literal> method, it
opens the file and starts printing out even or odd numbers, depending on
which thread it is. Afterwards, each thread closes the file and ends.</simpara>
<simpara>What do you expect the file <literal>concurrent.out</literal> to look like after the
program has completed? Run it several times, on Windows, Linux, and Mac
computers, if you can. Most likely, the file will contain either all the
even numbers from 0 to 9,998 or all the odd numbers from 1 to 9,999. If
you run the program enough times, you should be able to see both
possibilities.</simpara>
<simpara>Why are half the numbers getting lost? When you open a file for writing,
by default it erases everything that was already in the file. So, an
entire sequence of numbers is getting saved and then lost. We can change
this behavior by changing the line below.</simpara>
<programlisting language="java" linenumbering="unnumbered">out = new PrintWriter ( new FileOutputStream("concurrent.out") );</programlisting>
<simpara>We replace it with the following.</simpara>
<programlisting language="java" linenumbering="unnumbered">out = new PrintWriter ( new FileOutputStream("concurrent.out", true) );</programlisting>
<simpara>This second <literal>boolean</literal> parameter to the <literal>FileOutputStream</literal> constructor
specifies that output will <emphasis>append</emphasis> to the file instead of overwriting
it.</simpara>
<simpara>After this change, what does the file look like when we run the program?
Since we are going to append to any preexisting file, make sure that you
delete <literal>concurrent.out</literal> before running the program again. The file may
look different on different systems. The file probably contains long
runs of numbers from each thread. In fact, it is quite possible to have
the complete output from one thread followed by the complete output from
the other.</simpara>
<simpara>For performance reasons, file operations are usually done in batches.
Instead of writing each number to the file as the thread produces it,
output is usually stored in a buffer which is written as a whole. If we
call <literal>out.flush()</literal> after lineÂ <xref linkend="output_data_concurrently"/>, we can flush
the buffer to the file after each number is generated. Doing so will not
be as efficient, but it may give us some insight into how concurrent
writes on files work.</simpara>
<simpara>Using flushes, the output from the two threads should be thoroughly
intermixed. On a Windows machine, if you copy the data from the file and
sort it, you will probably see some numbers missing. This lost output is
similar to situations where updates to variables were lost because they
were overwritten by another thread. On the other hand, most Linux
systems have better concurrent file writing and will not lose any
numbers. (Even on Linux, it is possible for a number to be printed in
the middle of another number, but no digits should be lost.)</simpara>
<simpara>Under ideal circumstances, no two threads or processes should be writing
to the same file. However, this situation is sometimes unavoidable, as
with a database program that must support concurrent writes for the sake
of speed. If you need to enforce file locking, you can prevent threads
within your own program from accessing a file concurrently by using
normal Java synchronization tools. If you expect other programs to
interact with the same files that your program will use, Java provides a
<literal>FileLock</literal> class which allows the user to lock up portions of a file. As
with everything file-related, <literal>FileLock</literal> is dependent on the underlying
OS and may behave differently on different systems.</simpara>
</section>
<section xml:id="_exercises_19">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>What is the difference between volatile and non-volatile memory?
Which is often associated with files and why?</simpara>
</listitem>
<listitem>
<simpara>What is the difference between text and binary files? What are the
pros and cons of using each?</simpara>
</listitem>
<listitem>
<simpara>Define compression ratio to be the size of the uncompressed data in
bytes divided by the size of the compressed data in bytes. What is the
theoretical maximum compression ratio you can get out of the RLE
encoding we used? What is the theoretical lowest compression ratio you
can get out of the RLE encoding we used?</simpara>
</listitem>
<listitem>
<simpara>What is serialization in Java? What do you have to do to serialize
an object?</simpara>
</listitem>
<listitem>
<simpara>What kinds of objects cannot be serialized?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Implement the RLE bitmap compression program using only
<literal>FileInputStream</literal> and <literal>FileOutputStream</literal> for file input and output.</simpara>
</listitem>
<listitem>
<simpara>Re-implement the maze solving program from SectionÂ <xref linkend="solution:Maze
of doom"/> to ask the user for a file instead of reading from standard
input.</simpara>
</listitem>
<listitem>
<simpara>An HTML file contains many tags such as <literal>&lt;p&gt;</literal>, which marks the
beginning of a paragraph, and <literal>&lt;/p&gt;</literal>, which marks the end of a
paragraph. A lesser known feature of HTML is that ampersand (<literal>&amp;</literal>) can
mark special HTML entities used to produce symbols on a web page. For
example, <literal>&amp;pi;</literal> is the entity for the Greek letter <inlineequation><alt><![CDATA[\pi]]></alt><mathphrase><![CDATA[\pi]]></mathphrase></inlineequation>.
Because of these features of the language, raw text that is going to be
marked up in HTML should not contain less than signs (<literal>&lt;</literal>), greater than
signs (<literal>&gt;</literal>), or ampersands (<literal>&amp;</literal>).</simpara>
<simpara>Write a program that reads in an input text file specified by the user
and writes to an output text file also specified by the user. The output
file should be exactly the same as the input file except that every
occurrence of a less than sign should be replaced by <literal>&lt;</literal>, every
occurrence of a greater than sign should be replaced by <literal>&gt;</literal>, and
every occurrence of an ampersand should be replaced by <literal>&amp;</literal>.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:word_list"/> Write a program that prompts the user for an
input text file. Open the file and read each word from the file, where a
word is defined as any <literal>String</literal> made up only of upper and lower case
letters. You can use the <literal>next()</literal> method in the <literal>Scanner</literal> class to break
up text by whitespace, but your code will still need to examine the
input character by character, ending a word when any punctuation or
other characters are reached. Store each word (with a count of the
number of times you find it) in a binary search tree such as those
described in ExampleÂ <xref linkend="example:Binary_search_tree"/>. Then, traverse the
tree, printing all the words found (and the number of times found) to
the screen in alphabetical order.</simpara>
</listitem>
<listitem>
<simpara>Expand the program from ExerciseÂ <xref linkend="exercise:word_list"/> so that it
also prompts for a second file containing a dictionary in the form of a
word list with one word on each line. Store the words from the
dictionary in another binary search tree. Then, for each word in the
larger document that you cannot find in the dictionary tree, add it to a
third binary search tree. Finally, print out the contents of this third
binary search tree to the screen, and you will have implemented a
rudimentary spell checker. You can test the quality of your
implementation by using a novel from Project Gutenberg
(<link xl:href="http://www.gutenberg.org/">http://www.gutenberg.org/</link>) and a dictionary file from an open source
spell checker or from a Scrabble word list.</simpara>
</listitem>
<listitem>
<simpara>Files can become corrupted when they are transferred over a network.
It is common to make a <emphasis>checksum</emphasis>, a short code generated using the
entire contents of a file. The checksum can be generated before and
after file transmission. If both of the checksums match, there&#8217;s a good
chance that there were no transmission errors. Of course, there can be
problems sending checksums, but checksums are much smaller and therefore
less likely to be corrupted. Modern checksums are often generated using
cryptographic hash functions, which are more complex than we want to
deal with here. An older checksum algorithm works in the following way.
Although we use mathematical notation, the operations specified below
are integer modulus and integer division.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add up the values of all the bytes, storing this sum in a <literal>long</literal>
variable</simpara>
</listitem>
<listitem>
<simpara>Set <inlineequation><alt><![CDATA[sum = sum\mod 2^{32}]]></alt><mathphrase><![CDATA[sum = sum\mod 2^{32}]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara>Let <inlineequation><alt><![CDATA[r = (sum\mod 2^{16}) + (sum \div 2^{16})]]></alt><mathphrase><![CDATA[r = (sum\mod 2^{16}) + (sum \div 2^{16})]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara>Let <inlineequation><alt><![CDATA[s = (r\mod 2^{16}) + (r \div 2^{16})]]></alt><mathphrase><![CDATA[s = (r\mod 2^{16}) + (r \div 2^{16})]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara>The final checksum is <inlineequation><alt><![CDATA[s]]></alt><mathphrase><![CDATA[s]]></mathphrase></inlineequation></simpara>
<simpara>Remember that finding powers of 2 is easy with bitwise shifts. Write a
program that opens a file for binary reading using <literal>FileInputStream</literal> and
outputs the checksum described. On Linux systems, you can check the
operation of your program with the <literal>sum</literal> utility, using the <literal>-s</literal> option.
The following is an example of the command used on a file called
<literal>wombat.dat</literal>. The first number in the output below it, <literal>6892</literal>, is the
checksum.</simpara>
<programlisting language="java" linenumbering="unnumbered">sum -s wombat.dat
6892 213 wombat.dat</programlisting>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Write the RLE bitmap compression program in parallel so that a file
is evenly divided into as many pieces as you have threads, compressed,
and then each compressed portion is output in the correct order. Compare
the speed for 2, 4, and 8 threads to the sequential implementation. Are
any of the threaded versions faster? Why or why not? Run some
experiments to see how long it takes to read 1,000,000 bytes from a file
compared to the time it takes to compress 1,000,000 bytes which are
already stored in an array.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="chapter:Network_Communication">
<title>Network Communication</title>
<blockquote>
<attribution>
Neal Stephenson
</attribution>
<simpara>Arguing with anonymous strangers on the Internet is a sucker&#8217;s game because they almost always
turn out to be&#8212;&#8203;or to be indistinguishable from&#8212;&#8203;self-righteous sixteen-year-olds possessing
infinite amounts of free time.</simpara>
</blockquote>
<section xml:id="_problem_web_server">
<title>Problem: Web server</title>
<simpara>It is no accident that the previous chapter about file I/O is followed
by this one about networking. At first glance, the two probably seem
unrelated. As it happens, both files and networks are used for input and
output, and the designers of Java were careful to create an API with a
similar interface for both.</simpara>
<simpara>In the next two sections, we discuss how this API works, but first we
introduce the problem: You need to create a web server application. The
term <emphasis>server</emphasis> is used to describe a computer on a network which other
computers, called <emphasis>clients</emphasis>, connect to in order to access some services
or resources. When you surf the Internet, your computer is a client
connecting to web servers all over the world. Writing a web server might
seem like a daunting task. The web browser you run on your client
computer (e.g. Chrome, Firefox, Internet Explorer, or Safari) is, in modern
times, a very complicated program, capable of playing sounds and movies,
browsing in multiple tabs, automatically encrypting and decrypting
secure information, and, at the very least, correctly displaying web
pages of every description.</simpara>
<simpara>In contrast, a web server application is much simpler. At its heart, a
web server application gets requests for files and sends those files
over the network. More advanced servers can execute code and dynamically
generate pages, and many web servers are multi-threaded to support heavy
traffic. The web server you are writing needs only to focus on getting
requests for files and sending those files back to the requester.</simpara>
<section xml:id="_http_requests">
<title>HTTP requests</title>
<simpara>To receive requests, a web server uses something called <emphasis>hypertext
transfer protocol (HTTP)</emphasis>, which is just a way of specifying the format
of the requests. The only request we are interested in is the <literal>GET</literal>
request. All <literal>GET</literal> requests have the following format.<?asciidoc-br?>
<literal>GET</literal> <emphasis role="strong">path</emphasis> <literal>HTTP/</literal><emphasis role="strong">version</emphasis><?asciidoc-br?>
where <emphasis role="strong">path</emphasis> is the path of the file being requested and <emphasis role="strong">version</emphasis> is
the HTTP version number. A typical request might be as follows.<?asciidoc-br?>
<literal>GET /images/banner.jpg HTTP/1.1</literal><?asciidoc-br?>
You should also note that all HTTP commands end with <emphasis role="strong">two</emphasis> newline
characters (<literal>'\\n'</literal>). The extra blank line makes it easier to separate
the commands from other data being sent.</simpara>
</section>
<section xml:id="_http_responses">
<title>HTTP responses</title>
<simpara>After your web server receives a <literal>GET</literal> message, it looks for the file
specified by the <emphasis role="strong">path</emphasis>. If the server finds the file, it sends the
following message.<?asciidoc-br?>
<literal>HTTP/1.1 200 OK</literal><?asciidoc-br?>
Again, note that this message is followed with two newline characters.
After this message is sent, the server sends the requested file, byte by
byte across the network. If the file cannot be found by the web server,
it sends an error message as follows.<?asciidoc-br?>
<literal>HTTP/1.1 404 Not Found</literal><?asciidoc-br?>
Of course, two newlines will be sent after this as well. After the error
message, servers will also typically send some default web page with an
explanation in HTML.</simpara>
<simpara>Now, we return to the more fundamental problem of how to communicate
over a network.</simpara>
</section>
</section>
<section xml:id="_concepts_tcp_ip_communication">
<title>Concepts: TCP/IP communication</title>
<simpara>We begin where nearly every discussion of computer networking begins,
with the Open Systems Interconnection Basic Reference Model (or OSI
model). As we mentioned before, the designers of Java wanted to make a
networking API which was very similar to the file system API. This
single API must be used for JVM&#8217;s running on Windows or on MacÂ OS or on
Linux or any other operating system. Even with the same operating
system, different computers have different hardware. Some computers have
wired connections to a router or gateway. Others are connected
wirelessly. And somehow, you have to figure out the address of the
computer you want to send messages to and deal with its network,
hardware, and software.</simpara>
<simpara>There are so many steps in the process that it seems hopelessly
complicated. To combat this problem, the OSI seven layer model was
developed. Each layer defines a specification for one aspect of the
communication path between two computers. As long as a particular layer
interacts smoothly with the one above it and below it, that layer could
take the form of many different hardware or software choices. Listing
them in order from the highest level (closest to the user) to the lowest
level (closest to the hardware), the layers are as follows.</simpara>
<itemizedlist>
<listitem>
<simpara>Layer 7: Application Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 6: Presentation Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 5: Session Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 4: Transport Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 3: Network Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 2: Data Link Layer</simpara>
</listitem>
<listitem>
<simpara>Layer 1: Physical Layer</simpara>
</listitem>
</itemizedlist>
<simpara>The application layer is where your code is. The Java networking API
calls that your code uses to send and receive data comprise the
application layer for your purposes. The only thing above this layer is
the user. Protocols like HTTP and FTP are the province of this layer.
All the other communication problems have been solved, and the key issue
is what to do with the data that is communicated.</simpara>
<simpara>The presentation layer changes one kind of message encoding to another.
This layer is not one people usually spend a lot of time worrying about,
but some kinds of encryption and compression can happen here.</simpara>
<simpara>The session layer allows for the creation of sessions when communicating
between computers. Sessions requiring authentication and permissions can
be dealt with here, but,in practice, this layer is not often used. One
notable exception is the Secure Sockets Layer (SSL), the technology most
commonly used to protect passwords and credit card numbers when you make
online purchases.</simpara>
<simpara>The transport layer is concerned with the making the lower level
communication of data more transparent to higher layers. This layer
typically breaks larger messages into smaller packets of data which can
be sent across the network. This layer can also provide reliability by
checking to see if these packets make it to their destinations and
resending them otherwise. The two most important protocols for this
layer are Transmission Control Protocol (TCP) and User Datagram Protocol
(UDP). TCP is more commonly used and provides communication that is
reliable and ensures that packets are delivered in order. TCP is used
for file transfers, e-mail, web browsing, and any number of other web
applications. UDP does not have guarantees about reliability or
ordering; however, UDP is faster. For this reason, UDP is used for
streaming media and online games.</simpara>
<simpara>The network layer is responsible for packet transmission from source to
destination. It is concerned with addressing schemes and routing. The
most well-known example of a network layer protocol is the Internet
Protocol (IP) used to make the Internet work.</simpara>
<simpara>If the network layer worries about sending of packets from source to
destination, the data link layer is responsible for the actual
transmission of packets between each link in the chain. Here hardware
becomes more important because there are so many different kinds of
networks. Examples of data link layers include Ethernet, token ring
networks, IEEE 802.11 wireless networks, and many more.</simpara>
<simpara>Finally, the lowest level is the physical layer. This layer defines the
actual physical specifications for sending raw information from one
place to another, over a wire or wirelessly. This layer is typically the
least interesting to programmers but is a key area for electrical
engineers.</simpara>
</section>
<section xml:id="_syntax_networking_in_java">
<title>Syntax: Networking in Java</title>
<simpara>The seven layer model might seem overwhelming, but there are only a few
key pieces that we&#8217;ll need on a regular basis. In fact, the system of
layers is designed to help people focus on the one or two layers
specified to their needs and ignore the rest.</simpara>
<section xml:id="_addresses">
<title>Addresses</title>
<simpara>The first topic we touch on is the network layer. What we need from this
layer are addresses. A network address is much like a street address. It
gives the location on the network of a computer so that messages can be
sent there.</simpara>
<simpara>For most systems you use, such an address is be an <emphasis>IP address</emphasis>. There
are two current versions of IP addresses, IPv4 and IPv6. IPv6 is the way
of the future and provides a huge number of possible addresses. Not all
systems support IPv6, and the general public is not very aware of it.
Although it will one day be the standard, we use the more common IPv4
addresses here. An IPv4 address is typically written as four decimal
numbers separated by dots. Each of these four numbers is in the range 0
- 255. For example, <literal>64.233.187.99</literal> and <literal>192.168.1.1</literal> are IPv4
addresses.</simpara>
</section>
<section xml:id="_sockets">
<title>Sockets</title>
<simpara>The second topic we focus on is the transport layer. Here, you need to
make a choice between TCP or UDP for communication. In this book, we
only cover TCP communication because it is reliable and much more
commonly used than UDP. If you need to use UDP communication, the basics
are not too different from TCP, and there are many excellent resources
online.</simpara>
<simpara>To create a TCP connection, you typically need a server program and a
client program. The difference between the two is not necessarily big.
In fact, both the client and the server could be running on the same
computer. What distinguishes the server is that it sets up a <emphasis>port</emphasis> and
listens to it, waiting for a connection. Once the client makes a
connection, the two programs can send and receive data on an equal
footing.</simpara>
<simpara>We just mentioned the term port. As you know, an address is the location
of a computer in a network, but a single computer may be performing many
different kinds of network communications. For example, your computer
could be running a web browser, an instant message application, an
online game, and a number of other things. So that none of these
programs become confused and get each others' messages, each program
uses a separate port for communication. To the outside world, your
computer usually only has a single address but thousands of available
ports. Many of these ports are set aside for specific purposes. For
example, port 20 is for FTP, port 23 is for Telnet, and port 80 is for
HTTP (webpages).</simpara>
<simpara>When you write a server program, you will usually create a
<literal>ServerSocket</literal> object which is linked to a particular port. For example,
if you wanted to write a web server, you might create a <literal>ServerSocket</literal>
as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">ServerSocket serverSocket = new ServerSocket( 80 );</programlisting>
<simpara>Once the <literal>ServerSocket</literal> object has been created, the server will
typically listen to the socket and try to accept incoming connections.
When a connection is accepted, a new <literal>Socket</literal> object is created for that
connection. The purpose of the <literal>ServerSocket</literal> is just to set up this
<literal>Socket</literal>. The <literal>ServerSocket</literal> doesn&#8217;t do any real communication on its
own. This system may seem indirect, but it allows for greater
flexibility. For example, a server could have a thread just listening
for connections. When a connection is made, it could spawn a new thread
to do the communication. Commercial web servers often function in this
way. The code for a server to listen for a connection is:</simpara>
<programlisting language="java" linenumbering="unnumbered">Socket socket = serverSocket.accept();</programlisting>
<simpara>The <literal>accept()</literal> method is a blocking method; thus, the server will wait
for a connection before doing anything else.</simpara>
<simpara>Now, if you want to write the client which connects to such a server,
you can create the <literal>Socket</literal> object directly.</simpara>
<programlisting language="java" linenumbering="unnumbered">Socket socket = new Socket( "64.233.187.99", 80 );</programlisting>
<simpara>The first parameter is a <literal>String</literal> specifying the address of the server,
either as an IP address as shown or as domain like <literal>"google.com"</literal>. The
second parameter is, of course, the port you want to connect on.</simpara>
</section>
<section xml:id="subsection:receiving_and_sending_data">
<title>Receiving and sending data</title>
<simpara>From here on out, we no longer have to worry about the differences
between the client and server. Both programs have a <literal>Socket</literal> object that
can be used for communication.</simpara>
<simpara>In order to get input from a <literal>Socket</literal>, you first call its
<literal>getInputStream()</literal> method. You can use the <literal>InputStream</literal> returned to
create an object used for normal file input like in the first half of
the chapter. The considerations are similar. If you only need to receive
plain, human readable from the <literal>Socket</literal>, you can create a <literal>Scanner</literal>
object as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">Scanner in = new Scanner( socket.getInputStream() );</programlisting>
<simpara>Over the network, it will be much more common to send files and other
binary data. For that purpose you can create an <literal>ObjectInputStream</literal> or
<literal>DataInput\-Stream</literal> from the <literal>Socket</literal> in much the same way.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectInputStream in = new ObjectInputStream( socket.getInputStream() );</programlisting>
<simpara>It should be unsurprising that output is just as easy as input. Text
output can be accomplished by creating a <literal>PrintWriter</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">PrintWriter out = new PrintWriter( socket.getOutputStream() );</programlisting>
<simpara>Likewise, binary output can be accomplished by creating an
<literal>ObjectOutputStream</literal> or a <literal>DataOutputStream</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">ObjectOutputStream out = new ObjectOutputStream(
    socket.getOutputStream() );</programlisting>
<simpara>Once you have these input and output objects, you use them in the same
way you would for file processing. There are a few minor differences to
keep in mind. In the first place, when reading data, you may not know
when more is coming. There is no explicit end of file. Also, it is
sometimes necessary to call a <literal>flush()</literal> method after doing a write.
Unlike writing to a disk, a socket may wait for a sizable chunk of data
to be accumulated before it gets sent across the network. Without a
<literal>flush()</literal>, the data you write may not be sent immediately.</simpara>
<example>
<title>Simple client and server</title>
<simpara>Here&#8217;s an example of a piece of server code which listens on port 4321
waits for a connection, then reads 100 <literal>int</literal> values in binary form from
the socket, and prints their sum.</simpara>
<programlisting language="java" linenumbering="unnumbered">try{
    ServerSocket serverSocket = new ServerSocket( 4321 );
    Socket socket = serverSocket.accept();
    ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
    int sum = 0;
    for( int i = 0; i &lt; 100; i++ )
        sum += in.readInt();
    in.close();
    System.out.println("Sum: " + sum);
}
catch( IOException e )
{}</programlisting>
<simpara>Now, here&#8217;s a companion piece of client code which connects to port 4321
and sends 100 <literal>int</literal> values in binary form, specifically, the first 100
perfect squares.</simpara>
<programlisting language="java" linenumbering="unnumbered">try{
    Socket socket = new Socket( "127.0.0.1", 4321 );
    ObjectOutputStream out = new ObjectOutputStream(
        socket.getOutputStream());
    for( int i = 1; i &lt;= 100; i++ )
        out.writeInt(i*i);
    out.close();
}
catch( IOException e )
{}</programlisting>
<simpara>Note that this client code connects to the IP address <literal>127.0.0.1</literal>. This
is a special loopback IP address. When you connect to this IP address,
it connects to the machine you are currently working on. In this way,
you can test your networking code without needing two separate
computers. To test this client and server code together, you you will
need to run two virtual machines. The simplest way to do this is open
two command line prompts and run the client from one and the server from
the other. Be sure that you start the server first so that the client
has something to connect to.</simpara>
</example>
<example>
<title>Chat client and server</title>
<simpara>Now we look at a more complicated example of network communication which
should be familiar: a chat program. If you want to apply the GUI design
from ChapterÂ <xref linkend="chapter:Constructing_Graphical_User_Interfaces"/>, you can
make a windowed version of this chat program which looks more like chat
programs you are used to. For now, our chat program is be text only. .</simpara>
<simpara>The functionality of the program is simple. Once connected to a single
other chat program, the user will enter his or her name, then enter
lines of text each followed by a newline. The program will insert the
user&#8217;s name at the beginning of each line of text and then send it
across the network to the other chat program, which will display it. We
encapsulate both client and server functionality in a class called
<literal>Chat</literal>.</simpara>
<simpara>The first step is the appropriate import statements and the <literal>main()</literal>
method, which creates a client or a server <literal>Chat</literal> object, depending on
command line parameters.</simpara>
<programlisting language="java" linenumbering="numbered">import java.io.*;
import java.net.*;
import java.util.*;
public class Chat {
	private Socket socket;

	public static void main(String[] args) {
		if( args[0].equals("-s") )
			new Chat( Integer.parseInt( args[1] ) );
		else if( args[0].equals("-c") )
			new Chat( args[1], Integer.parseInt( args[2] )  );
		else
			System.out.println("Invalid command line flag.");
	}</programlisting>
<simpara>The code given here calls the server version of the <literal>Chat</literal> constructor
if the argument <literal>"-s"</literal> is given and the client version of the <literal>Chat</literal>
constructor if the argument <literal>"-c"</literal> is given. For the server, only a port
is required, but the client also needs an IP address to connect to.</simpara>
<simpara>The server <literal>Chat</literal> constructor takes the port and listens for a
connection on it. After a connection, it calls the <literal>runChat()</literal> method to
perform the actual business of sending and receiving chats.</simpara>
<programlisting language="java" linenumbering="numbered">	// Server
	public Chat( int port ) {
		try {
			ServerSocket serverSocket = new ServerSocket( port );
			socket = serverSocket.accept();
			runChat();
		}
		catch( Exception e ) {}
	}</programlisting>
<simpara>The client constructor is similar but connects directly to the specified
IP address on the specified port.</simpara>
<programlisting language="java" linenumbering="numbered">	// Client
	public Chat( String address, int port )	{
		try {
			socket = new Socket( address, port );
			runChat();
		}
		catch( Exception e )
		{}
	}</programlisting>
<simpara>Once the client and server are connected, they both run the <literal>runChat()</literal>
method, which creates a new <literal>Sender</literal> and a new <literal>Receiver</literal> to do the
sending and receiving. Note that both <literal>start()</literal> and <literal>join()</literal> are called
on the <literal>Sender</literal> and <literal>Receiver</literal> objects. These calls are needed because
both classes are subclasses of <literal>Thread</literal>. Sending messages is an
independent task concerned with reading input from the keyboard and then
sending it across the network. Receiving messages is also an independent
task, but it is concerned with reading input from the network and
printing it on the screen. Since both tasks are independent, it is
reasonable to allocate a separate thread to each.</simpara>
<programlisting language="java" linenumbering="numbered">	public void runChat() throws InterruptedException {
		Sender sender = new Sender();
		Receiver receiver = new Receiver();
		sender.start();
		receiver.start();
		sender.join();
		receiver.join();
	}</programlisting>
<simpara>Below is the private inner class <literal>Sender</literal>. In this case it is convenient
but not necessary to make <literal>Sender</literal> an inner class, especially since it
is so short. The only piece of data <literal>Sender</literal> shares with <literal>Chat</literal> is the
all important <literal>socket</literal> variable. The <literal>Sender</literal> begins by creating a
<literal>PrintWriter</literal> object from the <literal>socket&#8217;s output stream. After reading a
name from the user, it waits for a line from the user. Each time a line
is ready, it is printed and flushed, with the user name inserted at the
beginning, through the `PrintWriter</literal> connected to the <literal>Socket&#8217;s output
stream. When the user types `quit</literal>, the <literal>Socket</literal> will be closed.</simpara>
<programlisting language="java" linenumbering="numbered">	private class Sender extends Thread {
		public void run() {
			try {
				PrintWriter netOut = new PrintWriter(
					socket.getOutputStream() );
				Scanner in = new Scanner( System.in );
				System.out.print("Enter your name: ");
				String name = in.nextLine();
				String buffer = "";
				while( !socket.isClosed() ) {
					if( in.hasNextLine() ) {
						buffer = in.nextLine();
						if( buffer.equals("quit") )
							socket.close();
						else {
							netOut.println( name + ": "
								+ buffer );
							netOut.flush();
						}
					}
				}
			}
			catch( IOException e ) {}
		}
	}</programlisting>
<simpara>45-69, not available.*</simpara>
<simpara>Below is the private inner class <literal>Receiver</literal>, the counterpart of
<literal>Sender</literal>, as well as the last thing defined in the <literal>Chat</literal> class. The
<literal>Receiver</literal> class is even simpler than the <literal>Sender</literal> class. After creating
a <literal>Scanner</literal> object connected to the input stream of the <literal>Socket</literal>, it
waits for a line of text to arrive from the connection. Each time a line
arrives, it prints it to the screen. Here again, you can see that this
problem is solved with threads much more easily than without them. Both
the <literal>in.hasNextLine()</literal> method called by <literal>Sender</literal> and the
<literal>netIn.hasNextLine()</literal> method called by <literal>Receiver</literal> are blocking
functions. Because each might wait for input before continuing, they
cannot easily be combined in one thread of execution.</simpara>
<programlisting language="java" linenumbering="numbered">	private class Receiver extends Thread {
		public void run() {
			try{
				Scanner netIn = new Scanner(
					socket.getInputStream()) ;
				while( !socket.isClosed() )
					if( netIn.hasNextLine() )
						System.out.println( netIn.nextLine() );
			}
			catch( IOException e ) {}
		}
	}
}</programlisting>
<simpara>Although the fundamentals are present in this example, a real chat
client should provide a buddy list, the opportunity to talk to more than
one other user at a time, real error-handling code in the
<literal>catch</literal>-blocks, and many other features. Some of these features are
easier to provide in a GUI.</simpara>
</example>
<simpara>In the next section, we give a solution for the Web Server problem.
Since only the server side is provided, some of the networking is
simpler, and there are no threads. However, the communication is done in
both binary and text mode.</simpara>
</section>
</section>
<section xml:id="_solution_web_server">
<title>Solution: Web server</title>
<simpara>Here is our solution to the Web Server problem. As usual, our solution
doesn&#8217;t provide all the error checking or features that a real web
server would, but it is entirely functional. When you compile and run
the code, it will start a web server on port 8080 (an alternative port
for HTTP) in the directory you run it from. Feel free to change those
settings in the <literal>main()</literal> method. When the server is running, you should
be able to open any web browser and go to <literal><link xl:href="http://127.0.0.1">http://127.0.0.1</link></literal>. If you put
some sample HTML files in the directory you run the server from, you
should be able to browse them.</simpara>
<simpara>As for our code, we start with the imports and constructor below. Note
that the server has fields for the port communication will take place
on, the root directory for the web page, and a <literal>ServerSocket</literal>. The
<literal>main()</literal> method does nothing but call the constructor using the current
directory as an argument and then start the server.</simpara>
<programlisting language="java" linenumbering="numbered">import java.io.*;
import java.net.*;
import java.util.*;
public class WebServer {
	private int port;
	private String webRoot;
	private ServerSocket serverSocket = null;

	public WebServer( int port, String webRoot ) {
		this.port = port;
		this.webRoot = webRoot;
	}

	public static void main(String[] args) {
		File currentDirectory = new File(".");
		try{
			WebServer server = new WebServer(8080,
				currentDirectory.getCanonicalPath() );
			server.start();
		}
		catch( IOException e )
		{}
	}</programlisting>
<simpara>Below is the <literal>start()</literal> method. This method contains the central loop of
the web server that waits for connections and loops forever. Once a
connection has been made, the server creates input and output objects
from the socket connection. Then, it tries to serve requests coming from
the socket input. Our web server ignores any request other than a <literal>GET</literal>
request and closes the connection after the first <literal>GET</literal>. When a <literal>GET</literal>
request is made, the server removes the <literal>"HTTP"</literal> at the beginning and
passes off the remaining path to the <literal>serve()</literal> method. Everything else
in the <literal>start()</literal> method is made up of the necessary exception handling
machinery.</simpara>
<simpara>Note that the <literal>out</literal> object is of type <literal>ObjectOutputStream</literal>, allowing us
to send binary data over the socket. However, the <literal>in</literal> variable is of
type <literal>Scanner</literal>, because HTTP requests are generally only text.</simpara>
<programlisting language="java" linenumbering="numbered">	public void start() {
		Socket socket = null;
		Scanner in = null;
		ObjectOutputStream out = null;
		String line;
		try {
			serverSocket = new ServerSocket( port );
			while( true ) {
				socket = serverSocket.accept();
				try {
					in = new Scanner( socket.getInputStream()) ;
					out = new ObjectOutputStream(
						socket.getOutputStream() );
					while ( in.hasNextLine() ) {
						line = in.nextLine();
						if( line.startsWith("GET") ) {
							String path = line.substring(4,
								line.lastIndexOf("HTTP")).trim();
							System.out.println(
								"Received request for: " + path);
							serve( out, getPath( path ) );
							socket.close();
							break;
						}
					}
				}
				catch( IOException e ) {
					System.out.println("Error: " + e.getMessage());
				}
				finally {
					if( in != null ) in.close();
					if( out != null ) out.close();
				}
			}
		}
		catch( IOException e ) {
			System.out.println("Error: " + e.getMessage());
		}
	}</programlisting>
<simpara>Next is a short utility method which provides some amount of platform
independence. The <literal>getPath()</literal> method take in a <literal>String</literal> representation
of a path requested by a web browser and format it. This path should
always be given in the Unix or Linux style with slashes (<literal>/</literal>) separating
each directory. To function smoothly with other operating systems,
<literal>getPath()</literal> uses the class variable <literal>File.separatorChar</literal> which gives the
<literal>char</literal> used to separate directories on whichever platform the JVM is
currently running. In addition, <literal>getPath()</literal> adds <literal>"index.html"</literal> to the
end of the path if the path ends with a directory rather than a file
name. Real web servers try a list of many different files such as
<literal>index.html</literal>, <literal>index.htm</literal>, <literal>index.php</literal>, and so on, until a file is found
or the list runs out.</simpara>
<programlisting language="java" linenumbering="numbered">	public String getPath(String path) {
		if ('/' != File.separatorChar)
			path = path.replace('/', File.separatorChar);
		if (path.endsWith("" + File.separatorChar ) )
			return webRoot + path + "index.html";
		else
			return webRoot + path;
	}</programlisting>
<simpara>The last method in the <literal>WebServer</literal> class takes in a path and sends the
corresponding file over the nextwork. The <literal>serve()</literal> method first tries
to find the specified file. If it fails, it sends an <literal>HTTP 404</literal> message
with a short explanatory piece of HTML. Anyone who surfs the Internet
should be familiar with 404 messages. On the other hand, if this method
finds the file, it sends the <literal>HTTP 200</literal> method indicating success and
then creates a new <literal>ObjectInputStream</literal> object to read the file in binary
format. In this case, it is necessary to read the file in binary. In
general, HTML files are simple text files which are human readable, but
the image files that web servers must often send such as GIF and JPEG
files are binary files which are filled with unprintable characters.
Because we need to send binary data, we were also careful to open an
<literal>ObjectOutputStream</literal> on the socket earlier.</simpara>
<simpara>Once the file is open, the <literal>serve()</literal> method simply reads it in, byte by
byte, and sends each byte out over the socket. After the file has been
sent, the method closes it and returns.</simpara>
<programlisting language="java" linenumbering="numbered">	public void serve( ObjectOutputStream out, String path )
		throws IOException {
		System.out.println("Trying to serve " + path);
		File file = new File(path);
		if( !file.exists() ) {
			out.writeBytes("HTTP/1.1 404 Not Found\n\n");
			out.writeBytes("&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found" +
				"&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found" +
				"&lt;/h1&gt;The requested URL " + path +
				" was not found on this server.&lt;/body&gt;&lt;/html&gt;");
			System.out.println("File not found.");
		}
		else {
			out.writeBytes("HTTP/1.1 200 OK\n\n");
			ObjectInputStream in = null;
			try {
				in = new ObjectInputStream(
					new FileInputStream( file ));
				int data;
				while ( (data = in.readByte()) != -1 )
					out.writeByte( (byte)data );
				System.out.println("Request succeeded.");
			}
			catch (IOException e) {
				System.out.println("Error sending file: " +
					e.getMessage());
			}
			finally { if( in != null ) in.close(); }
		}
	}
}</programlisting>
<simpara>Because a web server is a real world application, we have to give the
usual caveat that this implementation is quite bare-bones. There are
other HTTP requests and many features, including error handling, that a
web server should do better. Feel free to extend the functionality.</simpara>
<simpara>Also, you might notice that there is no way to stop the web server. It
has an infinite loop which is only broken if there is an <literal>IOException</literal>
thrown. From a Windows, Linux, or Mac command prompt, you can usually
stop a running program by typing <literal>Ctrl-C</literal>.</simpara>
</section>
<section xml:id="_concurrency_networking">
<title>Concurrency: Networking</title>
<simpara>Throughout this book, we have used concurrency primarily for the purpose
of speedup. For that kind of performance improvement, concurrency is
essentially icing on the cake. Unless you are performing massively
parallel computations such as code breaking or scientific computing,
concurrency will probably make your application run just a little faster
or a little smoother.</simpara>
<simpara>With network programming, the situation is different. Many networked
programs, including chat clients, web servers, and peer-to-peer file
sharing software, will simultaneously be connected to tens if not
hundreds of other computers at the same time. While there are
single-threaded strategies to handle these scenarios, it is natural to
handle them in a multi-threaded way.</simpara>
<simpara>A web server at Google, for example, may service thousands of requests
per second. If each request had to wait for the previous one to come to
completion, the server would become hopelessly bogged down. By using a
single thread to listen to requests and then spawn worker threads as
needed, the server can run more smoothly.</simpara>
<simpara>Even in ExampleÂ <xref linkend="example:Chat_client_and_server"/>, it was convenient to
create two different threads, <literal>Sender</literal> and <literal>Receiver</literal>. We did not create
them for speedup but simply because they were doing two different jobs.
Since the <literal>Sender</literal> waits for the user to type a line and the <literal>Receiver</literal>
waits for a line of text to arrive over the network, it would be
difficult to write a single thread that could handle both jobs. Both
threads call the <literal>hasNextLine()</literal> method, which can block execution. A
single thread waiting to see if the user had entered more text could not
respond to text arriving over the network until the user hit enter.</simpara>
<simpara>We only touch briefly on networking in this book. As the Internet
evolves, standards and APIs evolve as well. Some libraries can create
and manage threads transparently, without the user worrying about the
details. In other cases, your program must explicitly use multiple
threads to solve the networking problem effectively.</simpara>
</section>
<section xml:id="_exercises_20">
<title>Exercises</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Why are there so many similarities between the network I/O and the
file I/O APIs in Java?</simpara>
</listitem>
<listitem>
<simpara>Explain the difference between client and server computers in
network communication. Is it possible for a single computer to be both a
client and a server?</simpara>
</listitem>
<listitem>
<simpara>Why is writing a web browser so much more complicated than writing a
web server?</simpara>
</listitem>
<listitem>
<simpara>Name and briefly describe the seven layers of the OSI model.</simpara>
</listitem>
<listitem>
<simpara>Modern computers often have many programs running that are all in
communication over a network. Since a computer often has only one IP
address that the outside world can send to, how are messages that arrive
at the computer connected to the right program?</simpara>
</listitem>
<listitem>
<simpara>What are the most popular choices of protocols at the transport
layer of the OSI model? What are the advantages and disadvantages of
each?</simpara>
</listitem>
<listitem>
<simpara>How many possible IP addresses are there in IPv4? IPv6 addresses are
often written as eight groups of four hexadecimal digits, totaling 32
hexadecimal digits. How many possible IP addresses are there in IPv6?</simpara>
<simpara><emphasis role="strong">Programming Practice</emphasis></simpara>
</listitem>
<listitem>
<simpara>Recall the client and server from SectionÂ <xref linkend="subsection:receiving_and_sending_data"/> that, respectively, send 100 <literal>int</literal> values and sum them.
Rewrite these fragments to send and receive the <literal>int</literal> values in text
rather than binary format.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:chat_GUI"/> Add a GUI based on <literal>JFrame</literal> for the chat
program given in ExampleÂ <xref linkend="example:Chat_client_and_server"/>. Use a
(non-editable) <literal>JTextArea</literal> to display the log of messages, including
user name. Provide a <literal>JTextField</literal> for entering messages, a <literal>JButton</literal> for
sending messages, and another <literal>JButton</literal> for closing the network
connections and ending the program.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:multi-threaded_web_server"/> Study the web server
implementation from Section <xref linkend="solution:Web_server"/>. Implement a similar
web server which is multi-threaded. Instead of serving each request with
the same thread that is listening for connections, spawn a new thread to
handle the request each time a connection is made.</simpara>
</listitem>
<listitem>
<simpara><xref linkend="exercise:thread_pool_web_server"/> One of the weaknesses of the web
server from the previous exercise is that a new thread has to be created
for each connection. An alternative approach is to create a pool of
threads to handle requests. Then, when a new request arrives, an idle
thread is selected from the pool. Extend the solution to the previous
exercise to use a fixed pool of 10 worker threads.</simpara>
<simpara><emphasis role="strong">Experiments</emphasis></simpara>
</listitem>
<listitem>
<simpara>Consider the multi-threaded implementation of a web server from
ExerciseÂ <xref linkend="exercise:multi-threaded_web_server"/>. Can you design an
experiment to measure the average amount of time a client waits to
receive the requested file? How does this time change from the single
threaded to the multi-threaded version? If the file size is larger, is
the increase in the waiting time the same in both the single and
multi-threaded versions?</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
</book>